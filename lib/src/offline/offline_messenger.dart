// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

part of mapbox_maps_flutter;

/// Describes glyphs rasterization modes.
enum GlyphsRasterizationMode {
  /// No glyphs are rasterized locally. All glyphs are loaded from the server.
  NO_GLYPHS_RASTERIZED_LOCALLY,

  /// Ideographs are rasterized locally, and they are not loaded from the server.
  IDEOGRAPHS_RASTERIZED_LOCALLY,

  /// All glyphs are rasterized locally. No glyphs are loaded from the server.
  ALL_GLYPHS_RASTERIZED_LOCALLY,
}

/// Describes the glyphs rasterization option values.
class GlyphsRasterizationOptions {
  GlyphsRasterizationOptions({
    required this.rasterizationMode,
    this.fontFamily,
  });

  /// Glyphs rasterization mode for client-side text rendering.
  GlyphsRasterizationMode rasterizationMode;

  /// Font family to use as font fallback for client-side text renderings.
  ///
  /// Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
  /// or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
  /// font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
  /// default font are varied in platforms:
  /// - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
  ///   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
  /// - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
  ///
  /// Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
  ///
  String? fontFamily;

  Object encode() {
    return <Object?>[
      rasterizationMode.index,
      fontFamily,
    ];
  }

  static GlyphsRasterizationOptions decode(Object result) {
    result as List<Object?>;
    return GlyphsRasterizationOptions(
      rasterizationMode: GlyphsRasterizationMode.values[result[0]! as int],
      fontFamily: result[1] as String?,
    );
  }
}

/// Describes the style package load option values.
class StylePackLoadOptions {
  StylePackLoadOptions({
    this.glyphsRasterizationMode,
    this.metadata,
    required this.acceptExpired,
  });

  /// Specifies glyphs rasterization mode.
  ///
  /// If provided, updates the style package's glyphs rasterization mode,
  /// which defines which glyphs will be loaded from the server.
  ///
  /// By default, ideographs are rasterized locally and other glyphs are loaded
  /// from network (i.e. `IdeographsRasterizedLocally` value is used).
  GlyphsRasterizationMode? glyphsRasterizationMode;

  /// A custom Mapbox value associated with this style package for storing metadata.
  ///
  /// If provided, the custom value value will be stored alongside the style package. Previous values will
  /// be replaced with the new value.
  ///
  /// Developers can use this field to store custom metadata associated with a style package.
  String? metadata;

  /// Accepts expired data when loading style resources.
  ///
  /// This flag should be set to true to accept expired responses. When a style resource is already loaded but expired,
  /// no attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
  /// for a style is up-to-date.
  bool acceptExpired;

  Object encode() {
    return <Object?>[
      glyphsRasterizationMode?.index,
      metadata,
      acceptExpired,
    ];
  }

  static StylePackLoadOptions decode(Object result) {
    result as List<Object?>;
    return StylePackLoadOptions(
      glyphsRasterizationMode: result[0] != null
          ? GlyphsRasterizationMode.values[result[0]! as int]
          : null,
      metadata: result[1] as String?,
      acceptExpired: result[2]! as bool,
    );
  }
}

/// The `style pack` represents a stored style package.
class StylePack {
  StylePack({
    required this.styleURI,
    required this.glyphsRasterizationMode,
    required this.requiredResourceCount,
    required this.completedResourceCount,
    required this.completedResourceSize,
    this.expires,
  });

  /// The style associated with the style package.
  String styleURI;

  /// The glyphs rasterization mode of the style package.
  ///
  /// It defines which glyphs will be loaded from the server.
  GlyphsRasterizationMode glyphsRasterizationMode;

  /// The number of resources that are known to be required for this style package.
  int requiredResourceCount;

  /// The number of resources that have been fully downloaded and are ready for
  /// offline access.
  int completedResourceCount;

  /// The cumulative size, in bytes, of all resources that have
  /// been fully downloaded.
  int completedResourceSize;

  /// The earliest point in time when any of the style package resources gets expired.
  ///
  /// Unitialized for incomplete style packages or for complete style packages with all immutable resources.
  int? expires;

  Object encode() {
    return <Object?>[
      styleURI,
      glyphsRasterizationMode.index,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    ];
  }

  static StylePack decode(Object result) {
    result as List<Object?>;
    return StylePack(
      styleURI: result[0]! as String,
      glyphsRasterizationMode:
          GlyphsRasterizationMode.values[result[1]! as int],
      requiredResourceCount: result[2]! as int,
      completedResourceCount: result[3]! as int,
      completedResourceSize: result[4]! as int,
      expires: result[5] as int?,
    );
  }
}

/// A `style pack load` progress includes information about
/// the number of resources that have completed downloading
/// and the total number of resources that are required.
class StylePackLoadProgress {
  StylePackLoadProgress({
    required this.completedResourceCount,
    required this.completedResourceSize,
    required this.erroredResourceCount,
    required this.requiredResourceCount,
    required this.loadedResourceCount,
    required this.loadedResourceSize,
  });

  /// The number of resources that are ready for offline access.
  int completedResourceCount;

  /// The cumulative size, in bytes, of all resources that are ready for offline access.
  int completedResourceSize;

  /// The number of resources that have failed to download due to an error.
  int erroredResourceCount;

  /// The number of resources that are known to be required for this style package.
  int requiredResourceCount;

  /// The number of resources that have been fully downloaded from the network.
  int loadedResourceCount;

  /// The cumulative size, in bytes, of all resources that have been fully downloaded
  /// from the network.
  int loadedResourceSize;

  Object encode() {
    return <Object?>[
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    ];
  }

  static StylePackLoadProgress decode(Object result) {
    result as List<Object?>;
    return StylePackLoadProgress(
      completedResourceCount: result[0]! as int,
      completedResourceSize: result[1]! as int,
      erroredResourceCount: result[2]! as int,
      requiredResourceCount: result[3]! as int,
      loadedResourceCount: result[4]! as int,
      loadedResourceSize: result[5]! as int,
    );
  }
}

class _HolderCodec extends StandardMessageCodec {
  const _HolderCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is GlyphsRasterizationOptions) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadProgress) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return GlyphsRasterizationOptions.decode(readValue(buffer)!);
      case 129:
        return StylePackLoadProgress.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class Holder {
  /// Constructor for [Holder].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Holder({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _HolderCodec();

  final String __pigeon_messageChannelSuffix;

  Future<GlyphsRasterizationOptions> options() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Holder.options$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as GlyphsRasterizationOptions?)!;
    }
  }

  Future<StylePackLoadProgress> progress() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Holder.progress$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePackLoadProgress?)!;
    }
  }
}

class __OfflineManagerCodec extends StandardMessageCodec {
  const __OfflineManagerCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StylePack) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadOptions) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return StylePack.decode(readValue(buffer)!);
      case 129:
        return StylePackLoadOptions.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class _OfflineManager {
  /// Constructor for [_OfflineManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _OfflineManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      __OfflineManagerCodec();

  final String __pigeon_messageChannelSuffix;

  Future<StylePack> loadStylePack(
      String styleURI, StylePackLoadOptions loadOptions) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.loadStylePack$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[styleURI, loadOptions]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePack?)!;
    }
  }

  Future<StylePack> removeStylePack(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.removeStylePack$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePack?)!;
    }
  }

  Future<void> addStylePackLoadProgressListener(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.addStylePackLoadProgressListener$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<StylePack> stylePack(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePack$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePack?)!;
    }
  }

  Future<String?> stylePackMetadata(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePackMetadata$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return (__pigeon_replyList[0] as String?);
    }
  }
}

class _OfflineMapInstanceManager {
  /// Constructor for [_OfflineMapInstanceManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _OfflineMapInstanceManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      StandardMessageCodec();

  final String __pigeon_messageChannelSuffix;

  Future<void> setupOfflineManager(String channelSuffix) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.setupOfflineManager$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[channelSuffix]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> tearDownOfflineManager(String channelSuffix) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.tearDownOfflineManager$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[channelSuffix]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}
