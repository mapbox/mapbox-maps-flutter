// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

part of mapbox_maps_flutter;

/// Describes glyphs rasterization modes.
enum GlyphsRasterizationMode {
  /// No glyphs are rasterized locally. All glyphs are loaded from the server.
  NO_GLYPHS_RASTERIZED_LOCALLY,

  /// Ideographs are rasterized locally, and they are not loaded from the server.
  IDEOGRAPHS_RASTERIZED_LOCALLY,

  /// All glyphs are rasterized locally. No glyphs are loaded from the server.
  ALL_GLYPHS_RASTERIZED_LOCALLY,
}

/// Classify network types based on cost.
enum NetworkRestriction {
  /// Allow access to all network types.
  NONE,

  /// Forbid network access to expensive networks, such as cellular.
  DISALLOW_EXPENSIVE,

  /// Forbid access to all network types.
  DISALLOW_ALL,
}

/// Describes the glyphs rasterization option values.
class GlyphsRasterizationOptions {
  GlyphsRasterizationOptions({
    required this.rasterizationMode,
    this.fontFamily,
  });

  /// Glyphs rasterization mode for client-side text rendering.
  GlyphsRasterizationMode rasterizationMode;

  /// Font family to use as font fallback for client-side text renderings.
  ///
  /// Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
  /// or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
  /// font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
  /// default font are varied in platforms:
  /// - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
  ///   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
  /// - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
  ///
  /// Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
  ///
  String? fontFamily;

  Object encode() {
    return <Object?>[
      rasterizationMode.index,
      fontFamily,
    ];
  }

  static GlyphsRasterizationOptions decode(Object result) {
    result as List<Object?>;
    return GlyphsRasterizationOptions(
      rasterizationMode: GlyphsRasterizationMode.values[result[0]! as int],
      fontFamily: result[1] as String?,
    );
  }
}

/// Describes the style package load option values.
class StylePackLoadOptions {
  StylePackLoadOptions({
    this.glyphsRasterizationMode,
    this.metadata,
    required this.acceptExpired,
  });

  /// Specifies glyphs rasterization mode.
  ///
  /// If provided, updates the style package's glyphs rasterization mode,
  /// which defines which glyphs will be loaded from the server.
  ///
  /// By default, ideographs are rasterized locally and other glyphs are loaded
  /// from network (i.e. `IdeographsRasterizedLocally` value is used).
  GlyphsRasterizationMode? glyphsRasterizationMode;

  /// A custom Mapbox value associated with this style package for storing metadata.
  ///
  /// If provided, the custom value value will be stored alongside the style package. Previous values will
  /// be replaced with the new value.
  ///
  /// Developers can use this field to store custom metadata associated with a style package.
  Map<String?, Object?>? metadata;

  /// Accepts expired data when loading style resources.
  ///
  /// This flag should be set to true to accept expired responses. When a style resource is already loaded but expired,
  /// no attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
  /// for a style is up-to-date.
  bool acceptExpired;

  Object encode() {
    return <Object?>[
      glyphsRasterizationMode?.index,
      metadata,
      acceptExpired,
    ];
  }

  static StylePackLoadOptions decode(Object result) {
    result as List<Object?>;
    return StylePackLoadOptions(
      glyphsRasterizationMode: result[0] != null
          ? GlyphsRasterizationMode.values[result[0]! as int]
          : null,
      metadata: (result[1] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
      acceptExpired: result[2]! as bool,
    );
  }
}

/// The `style pack` represents a stored style package.
class StylePack {
  StylePack({
    required this.styleURI,
    required this.glyphsRasterizationMode,
    required this.requiredResourceCount,
    required this.completedResourceCount,
    required this.completedResourceSize,
    this.expires,
  });

  /// The style associated with the style package.
  String styleURI;

  /// The glyphs rasterization mode of the style package.
  ///
  /// It defines which glyphs will be loaded from the server.
  GlyphsRasterizationMode glyphsRasterizationMode;

  /// The number of resources that are known to be required for this style package.
  int requiredResourceCount;

  /// The number of resources that have been fully downloaded and are ready for
  /// offline access.
  int completedResourceCount;

  /// The cumulative size, in bytes, of all resources that have
  /// been fully downloaded.
  int completedResourceSize;

  /// The earliest point in time when any of the style package resources gets expired.
  ///
  /// Unitialized for incomplete style packages or for complete style packages with all immutable resources.
  int? expires;

  Object encode() {
    return <Object?>[
      styleURI,
      glyphsRasterizationMode.index,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    ];
  }

  static StylePack decode(Object result) {
    result as List<Object?>;
    return StylePack(
      styleURI: result[0]! as String,
      glyphsRasterizationMode:
          GlyphsRasterizationMode.values[result[1]! as int],
      requiredResourceCount: result[2]! as int,
      completedResourceCount: result[3]! as int,
      completedResourceSize: result[4]! as int,
      expires: result[5] as int?,
    );
  }
}

/// A `style pack load` progress includes information about
/// the number of resources that have completed downloading
/// and the total number of resources that are required.
class StylePackLoadProgress {
  StylePackLoadProgress({
    required this.completedResourceCount,
    required this.completedResourceSize,
    required this.erroredResourceCount,
    required this.requiredResourceCount,
    required this.loadedResourceCount,
    required this.loadedResourceSize,
  });

  /// The number of resources that are ready for offline access.
  int completedResourceCount;

  /// The cumulative size, in bytes, of all resources that are ready for offline access.
  int completedResourceSize;

  /// The number of resources that have failed to download due to an error.
  int erroredResourceCount;

  /// The number of resources that are known to be required for this style package.
  int requiredResourceCount;

  /// The number of resources that have been fully downloaded from the network.
  int loadedResourceCount;

  /// The cumulative size, in bytes, of all resources that have been fully downloaded
  /// from the network.
  int loadedResourceSize;

  Object encode() {
    return <Object?>[
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    ];
  }

  static StylePackLoadProgress decode(Object result) {
    result as List<Object?>;
    return StylePackLoadProgress(
      completedResourceCount: result[0]! as int,
      completedResourceSize: result[1]! as int,
      erroredResourceCount: result[2]! as int,
      requiredResourceCount: result[3]! as int,
      loadedResourceCount: result[4]! as int,
      loadedResourceSize: result[5]! as int,
    );
  }
}

/// Describes the tileset descriptor option values.
class TilesetDescriptorOptions {
  TilesetDescriptorOptions({
    required this.styleURI,
    required this.minZoom,
    required this.maxZoom,
    this.pixelRatio,
    this.tilesets,
    this.stylePackOptions,
    this.extraOptions,
  });

  /// The style associated with the tileset descriptor.
  String styleURI;

  /// Minimum zoom level for the tile package.
  /// Note: the implementation loads and stores the loaded tiles
  /// in batches, each batch has a pre-defined zoom range and it contains
  /// all child tiles within the range. The zoom leveling scheme for the tile
  /// batches can be defined in Tile JSON, otherwise the default scheme is used:
  /// - Global coverage: 0 - 5
  /// - Regional information: 6 - 10
  /// - Local information: 11 - 14
  /// - Streets detail: 15 - 16
  /// Internally, the implementation maps the given tile pack zoom range
  /// and geometry to a set of pre-defined batches to load, therefore
  /// it is highly recommended to choose the `minZoom` and `maxZoom` values
  /// in accordance with the tile batches zoom ranges (see the list above).
  int minZoom;

  /// Maximum zoom level for the tile package.
  /// maxZoom value cannot exceed the maximum allowed tile batch zoom value.
  int maxZoom;

  /// Pixel ratio to be accounted for when downloading raster tiles.
  /// The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
  double? pixelRatio;

  /// The tilesets associated with the tileset descriptor.
  /// Contains an array, each element of which must be either a URI to a TileJSON
  /// resource or a JSON string representing the inline tileset.
  /// This property can be used to resolve extra tilesets that are not part of the original style
  /// represented by `styleURL`, it can be used also with the empty `styleURL`.
  /// The provided URIs must have "mapbox://" scheme, e.g. "mapbox://mapbox.mapbox-streets-v8".
  List<String?>? tilesets;

  /// Style package load options, associated with the tileset descriptor.
  /// If provided, `offline manager` will create a style package while resolving the corresponding
  /// tileset descriptor and load all the resources as defined in the provided style package options,
  /// i.e. resolving of corresponding the tileset descriptor will be equivalent to calling the `loadStylePack`
  /// method of `offline manager`.
  /// If not provided, resolving of the corresponding tileset descriptor will not cause creating of a new style
  /// package but the loaded resources will be stored in the disk cache.
  ///
  /// Style package creation requires nonempty `styleURL`, which will be the created style package identifier.
  StylePackLoadOptions? stylePackOptions;

  /// Extra tileset descriptor options.
  Map<String?, Object?>? extraOptions;

  Object encode() {
    return <Object?>[
      styleURI,
      minZoom,
      maxZoom,
      pixelRatio,
      tilesets,
      stylePackOptions?.encode(),
      extraOptions,
    ];
  }

  static TilesetDescriptorOptions decode(Object result) {
    result as List<Object?>;
    return TilesetDescriptorOptions(
      styleURI: result[0]! as String,
      minZoom: result[1]! as int,
      maxZoom: result[2]! as int,
      pixelRatio: result[3] as double?,
      tilesets: (result[4] as List<Object?>?)?.cast<String?>(),
      stylePackOptions: result[5] != null
          ? StylePackLoadOptions.decode(result[5]! as List<Object?>)
          : null,
      extraOptions:
          (result[6] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
    );
  }
}

/// Describes the tile region load option values.
class TileRegionLoadOptions {
  TileRegionLoadOptions({
    this.geometry,
    this.descriptorsOptions,
    this.metadata,
    required this.acceptExpired,
    required this.networkRestriction,
    this.startLocation,
    this.averageBytesPerSecond,
    this.extraOptions,
  });

  /// The tile region's associated geometry.
  ///
  /// If provided, updates the tile region's associated geometry i.e. geometry,
  /// which is used in the tile cover algorithm to find out a set of tiles to be loaded
  /// for the tile region.
  ///
  /// Providing an empty geometry list is equivalent to removeTileRegion() call.
  Map<String?, Object?>? geometry;

  /// The tile region's tileset descriptors.
  ///
  /// If provided, updates the tile region's tileset descriptors that define
  /// the tilesets and zoom ranges of the tiles for the tile region.
  ///
  /// Providing an empty tileset descriptors list is equivalent to removeTileRegion() call.
  List<TilesetDescriptorOptions?>? descriptorsOptions;

  /// A custom Mapbox Value associated with this tile region for storing metadata.
  ///
  /// If provided, the custom value value will be stored alongside the tile region. Previous values will
  /// be replaced with the new value.
  ///
  /// Developers can use this field to store custom metadata associated with a tile region. This value
  /// can be retrieved with getTileRegionMetadata().
  Map<String?, Object?>? metadata;

  /// Accepts expired data when loading tiles.
  ///
  /// This flag should be set to true to accept expired responses. When a tile is already loaded but expired, no
  /// attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
  /// for a tile is up-to-date. Set to true to continue loading a group without updating expired data for tiles that
  /// are already downloaded.
  bool acceptExpired;

  /// Controls which networks may be used to load the tile.
  ///
  /// By default, all networks are allowed. However, in some situations, it's useful to limit the kind of networks
  /// that are allowed, e.g. to ensure that data is only transferred over a connection that doesn't incur cost to
  /// the user, like a WiFi connection, and prohibit data transfer over expensive connections like cellular.
  NetworkRestriction networkRestriction;

  /// Starts loading the tile region at the given location and then proceeds to tiles that are further away
  /// from it.
  ///
  /// Note that this functionality is not currently implemented.
  Point? startLocation;

  /// Limits the download speed of the tile region.
  ///
  /// Note that this is not a strict bandwidth limit, but only limits the average download speed. tile regions may
  /// be temporarily downloaded with higher speed, then pause downloading until the rolling average has dropped below
  /// this value.
  ///
  /// If unspecified, the download speed will not be restricted.
  ///
  /// Note that this functionality is not currently implemented.
  int? averageBytesPerSecond;

  /// Extra tile region load options.
  ///
  /// If provided, contains an object value with extra tile region load options.
  ///
  /// There are currently no extra options.
  Map<String?, Object?>? extraOptions;

  Object encode() {
    return <Object?>[
      geometry,
      descriptorsOptions,
      metadata,
      acceptExpired,
      networkRestriction.index,
      startLocation?.encode(),
      averageBytesPerSecond,
      extraOptions,
    ];
  }

  static TileRegionLoadOptions decode(Object result) {
    result as List<Object?>;
    return TileRegionLoadOptions(
      geometry: (result[0] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
      descriptorsOptions:
          (result[1] as List<Object?>?)?.cast<TilesetDescriptorOptions?>(),
      metadata: (result[2] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
      acceptExpired: result[3]! as bool,
      networkRestriction: NetworkRestriction.values[result[4]! as int],
      startLocation:
          result[5] != null ? Point.decode(result[5]! as List<Object?>) : null,
      averageBytesPerSecond: result[6] as int?,
      extraOptions:
          (result[7] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
    );
  }
}

/// TileRegion represents an identifiable geographic tile region with metadata
class TileRegion {
  TileRegion({
    required this.id,
    required this.requiredResourceCount,
    required this.completedResourceCount,
    required this.completedResourceSize,
    this.expires,
  });

  /// The id of the tile region
  String id;

  /// The number of resources that are known to be required for this tile region.
  int requiredResourceCount;

  /// The number of resources that have been fully downloaded and are ready for
  /// offline access.
  ///
  /// The tile region is complete if `completedResourceCount` is equal to `requiredResourceCount`.
  int completedResourceCount;

  /// The cumulative size, in bytes, of all resources (inclusive of tiles) that have
  /// been fully downloaded.
  int completedResourceSize;

  /// The earliest point in time when any of the region resources gets expired.
  ///
  /// Unitialized for incomplete tile regions or for complete tile regions with all immutable resources.
  int? expires;

  Object encode() {
    return <Object?>[
      id,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    ];
  }

  static TileRegion decode(Object result) {
    result as List<Object?>;
    return TileRegion(
      id: result[0]! as String,
      requiredResourceCount: result[1]! as int,
      completedResourceCount: result[2]! as int,
      completedResourceSize: result[3]! as int,
      expires: result[4] as int?,
    );
  }
}

/// The result of tile region estimation.
class TileRegionEstimateResult {
  TileRegionEstimateResult({
    required this.errorMargin,
    required this.transferSize,
    required this.storageSize,
    this.extraOptions,
  });

  /// Error margin of the estimate, given a fixed confidence level of 99.9%, represented by
  /// a value between 0 and 1. There is a 99.9% probability that the real value is contained
  /// in the interval [ (1 - errorMargin) * estimated value, (1 + errorMargin) * estimated value].
  ///
  /// Note: the assumptions used to calculate the error margin may not hold true for sparce
  /// datasets.
  double errorMargin;

  /// Estimated number of bytes that would have to be transferred from the network in order
  /// to download the estimated tile region.
  int transferSize;

  /// Estimated number of bytes required to store the tile region on disk after the download
  /// is complete.
  int storageSize;

  /// Reserved for future use.
  Map<String?, Object?>? extraOptions;

  Object encode() {
    return <Object?>[
      errorMargin,
      transferSize,
      storageSize,
      extraOptions,
    ];
  }

  static TileRegionEstimateResult decode(Object result) {
    result as List<Object?>;
    return TileRegionEstimateResult(
      errorMargin: result[0]! as double,
      transferSize: result[1]! as int,
      storageSize: result[2]! as int,
      extraOptions:
          (result[3] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
    );
  }
}

/// Holds options for the tile region estimation operation.
class TileRegionEstimateOptions {
  TileRegionEstimateOptions({
    required this.errorMargin,
    required this.preciseEstimationTimeout,
    required this.timeout,
    this.extraOptions,
  });

  /// Accepted error margin.
  double errorMargin;

  /// If after this timeout the estimate is within the error margin, the operation
  /// will be completed without attempting to reduce the error margin to 0.
  /// A value of 0 means no timeout. If unspecified, defaults to 5 seconds.
  double preciseEstimationTimeout;

  /// Timeout after which the operation will be interrupted, regardless of the
  /// current error margin.
  /// A value of 0 means no timeout. If unspecified, defaults to 0.
  double timeout;

  /// Reserved for future use.
  Map<String?, Object?>? extraOptions;

  Object encode() {
    return <Object?>[
      errorMargin,
      preciseEstimationTimeout,
      timeout,
      extraOptions,
    ];
  }

  static TileRegionEstimateOptions decode(Object result) {
    result as List<Object?>;
    return TileRegionEstimateOptions(
      errorMargin: result[0]! as double,
      preciseEstimationTimeout: result[1]! as double,
      timeout: result[2]! as double,
      extraOptions:
          (result[3] as Map<Object?, Object?>?)?.cast<String?, Object?>(),
    );
  }
}

/// A tile region's load progress includes counts
/// of the number of resources that have completed downloading
/// and the total number of resources that are required.
class TileRegionLoadProgress {
  TileRegionLoadProgress({
    required this.completedResourceCount,
    required this.completedResourceSize,
    required this.erroredResourceCount,
    required this.requiredResourceCount,
    required this.loadedResourceCount,
    required this.loadedResourceSize,
  });

  /// The number of resources that are ready for offline access.
  int completedResourceCount;

  /// The cumulative size, in bytes, of all resources (inclusive of tiles) that
  /// are ready for offline access.
  int completedResourceSize;

  /// The number of resources that have failed to download due to an error.
  int erroredResourceCount;

  /// The number of resources that are known to be required for this tile region.
  int requiredResourceCount;

  /// The number of resources that are ready for offline use and that (at least partially)
  /// have been downloaded from the network.
  int loadedResourceCount;

  /// The cumulative size, in bytes, of all resources (inclusive of tiles) that have
  /// been downloaded from the network.
  int loadedResourceSize;

  Object encode() {
    return <Object?>[
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    ];
  }

  static TileRegionLoadProgress decode(Object result) {
    result as List<Object?>;
    return TileRegionLoadProgress(
      completedResourceCount: result[0]! as int,
      completedResourceSize: result[1]! as int,
      erroredResourceCount: result[2]! as int,
      requiredResourceCount: result[3]! as int,
      loadedResourceCount: result[4]! as int,
      loadedResourceSize: result[5]! as int,
    );
  }
}

/// A tile region's estimate progress includes counts of the number of resources that have
/// been estimated and the total number of resources as well as a partial result with the
/// current estimate, calculated using the data available at the moment.
class TileRegionEstimateProgress {
  TileRegionEstimateProgress({
    required this.requiredResourceCount,
    required this.completedResourceCount,
    required this.erroredResourceCount,
  });

  /// The number of resources that are known to be required for this tile region.
  int requiredResourceCount;

  /// The number of resources that are ready for offline access.
  int completedResourceCount;

  /// The number of resources that have failed to download due to an error.
  int erroredResourceCount;

  Object encode() {
    return <Object?>[
      requiredResourceCount,
      completedResourceCount,
      erroredResourceCount,
    ];
  }

  static TileRegionEstimateProgress decode(Object result) {
    result as List<Object?>;
    return TileRegionEstimateProgress(
      requiredResourceCount: result[0]! as int,
      completedResourceCount: result[1]! as int,
      erroredResourceCount: result[2]! as int,
    );
  }
}

class __HolderCodec extends StandardMessageCodec {
  const __HolderCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is GlyphsRasterizationOptions) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadProgress) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateProgress) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionLoadProgress) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return GlyphsRasterizationOptions.decode(readValue(buffer)!);
      case 129:
        return StylePackLoadProgress.decode(readValue(buffer)!);
      case 130:
        return TileRegionEstimateProgress.decode(readValue(buffer)!);
      case 131:
        return TileRegionLoadProgress.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class _Holder {
  /// Constructor for [_Holder].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _Holder({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = __HolderCodec();

  final String __pigeon_messageChannelSuffix;

  Future<GlyphsRasterizationOptions> options() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._Holder.options$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as GlyphsRasterizationOptions?)!;
    }
  }

  Future<StylePackLoadProgress> stylePackLoadProgress() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._Holder.stylePackLoadProgress$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePackLoadProgress?)!;
    }
  }

  Future<TileRegionLoadProgress> tileRegionLoadProgress() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._Holder.tileRegionLoadProgress$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as TileRegionLoadProgress?)!;
    }
  }

  Future<TileRegionEstimateProgress> tileRegionEstimateProgress() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._Holder.tileRegionEstimateProgress$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as TileRegionEstimateProgress?)!;
    }
  }
}

class __OfflineManagerCodec extends StandardMessageCodec {
  const __OfflineManagerCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is GlyphsRasterizationOptions) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is Point) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is StylePack) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadOptions) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadProgress) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is TileRegion) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateOptions) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateProgress) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateResult) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionLoadOptions) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionLoadProgress) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is TilesetDescriptorOptions) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return GlyphsRasterizationOptions.decode(readValue(buffer)!);
      case 129:
        return Point.decode(readValue(buffer)!);
      case 130:
        return StylePack.decode(readValue(buffer)!);
      case 131:
        return StylePackLoadOptions.decode(readValue(buffer)!);
      case 132:
        return StylePackLoadProgress.decode(readValue(buffer)!);
      case 133:
        return TileRegion.decode(readValue(buffer)!);
      case 134:
        return TileRegionEstimateOptions.decode(readValue(buffer)!);
      case 135:
        return TileRegionEstimateProgress.decode(readValue(buffer)!);
      case 136:
        return TileRegionEstimateResult.decode(readValue(buffer)!);
      case 137:
        return TileRegionLoadOptions.decode(readValue(buffer)!);
      case 138:
        return TileRegionLoadProgress.decode(readValue(buffer)!);
      case 139:
        return TilesetDescriptorOptions.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class _OfflineManager {
  /// Constructor for [_OfflineManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _OfflineManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      __OfflineManagerCodec();

  final String __pigeon_messageChannelSuffix;

  Future<StylePack> loadStylePack(
      String styleURI, StylePackLoadOptions loadOptions) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.loadStylePack$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[styleURI, loadOptions]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePack?)!;
    }
  }

  Future<StylePack> removeStylePack(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.removeStylePack$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePack?)!;
    }
  }

  Future<void> addStylePackLoadProgressListener(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.addStylePackLoadProgressListener$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<StylePack> stylePack(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePack$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as StylePack?)!;
    }
  }

  Future<Map<String?, Object?>> stylePackMetadata(String styleURI) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePackMetadata$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, Object?>();
    }
  }

  Future<List<StylePack?>> allStylePacks() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.allStylePacks$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<StylePack?>();
    }
  }
}

class __TileStoreCodec extends StandardMessageCodec {
  const __TileStoreCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is GlyphsRasterizationOptions) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is Point) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is StylePack) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadOptions) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is StylePackLoadProgress) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is TileRegion) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateOptions) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateProgress) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionEstimateResult) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionLoadOptions) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is TileRegionLoadProgress) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is TilesetDescriptorOptions) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:
        return GlyphsRasterizationOptions.decode(readValue(buffer)!);
      case 129:
        return Point.decode(readValue(buffer)!);
      case 130:
        return StylePack.decode(readValue(buffer)!);
      case 131:
        return StylePackLoadOptions.decode(readValue(buffer)!);
      case 132:
        return StylePackLoadProgress.decode(readValue(buffer)!);
      case 133:
        return TileRegion.decode(readValue(buffer)!);
      case 134:
        return TileRegionEstimateOptions.decode(readValue(buffer)!);
      case 135:
        return TileRegionEstimateProgress.decode(readValue(buffer)!);
      case 136:
        return TileRegionEstimateResult.decode(readValue(buffer)!);
      case 137:
        return TileRegionLoadOptions.decode(readValue(buffer)!);
      case 138:
        return TileRegionLoadProgress.decode(readValue(buffer)!);
      case 139:
        return TilesetDescriptorOptions.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class _TileStore {
  /// Constructor for [_TileStore].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _TileStore(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = __TileStoreCodec();

  final String __pigeon_messageChannelSuffix;

  Future<TileRegion> loadTileRegion(
      String id, TileRegionLoadOptions loadOptions) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.loadTileRegion$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[id, loadOptions]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as TileRegion?)!;
    }
  }

  Future<void> addTileRegionLoadProgressListener(String id) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.addTileRegionLoadProgressListener$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[id]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<TileRegionEstimateResult> estimateTileRegion(
      String id,
      TileRegionLoadOptions loadOptions,
      TileRegionEstimateOptions? estimateOptions) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.estimateTileRegion$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[id, loadOptions, estimateOptions]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as TileRegionEstimateResult?)!;
    }
  }

  Future<void> addTileRegionEstimateProgressListener(String id) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.addTileRegionEstimateProgressListener$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[id]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<Map<String?, Object?>> tileRegionMetadata(String id) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.tileRegionMetadata$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[id]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as Map<Object?, Object?>?)!
          .cast<String?, Object?>();
    }
  }

  Future<bool> tileRegionContainsDescriptor(
      String id, List<TilesetDescriptorOptions?> options) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.tileRegionContainsDescriptor$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[id, options]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }

  Future<List<TileRegion?>> allTileRegions() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.allTileRegions$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<TileRegion?>();
    }
  }

  Future<TileRegion> tileRegion(String id) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.tileRegion$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[id]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as TileRegion?)!;
    }
  }

  Future<TileRegion> removeRegion(String id) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStore.removeRegion$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[id]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as TileRegion?)!;
    }
  }
}

class _OfflineMapInstanceManager {
  /// Constructor for [_OfflineMapInstanceManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _OfflineMapInstanceManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      StandardMessageCodec();

  final String __pigeon_messageChannelSuffix;

  Future<void> setupOfflineManager(String channelSuffix) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.setupOfflineManager$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[channelSuffix]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> tearDownOfflineManager(String channelSuffix) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.tearDownOfflineManager$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[channelSuffix]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _TileStoreInstanceManager {
  /// Constructor for [_TileStoreInstanceManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _TileStoreInstanceManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      StandardMessageCodec();

  final String __pigeon_messageChannelSuffix;

  Future<void> setupTileStore(String channelSuffix, String? filePath) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStoreInstanceManager.setupTileStore$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList = await __pigeon_channel
        .send(<Object?>[channelSuffix, filePath]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> tearDownTileStore(String channelSuffix) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._TileStoreInstanceManager.tearDownTileStore$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[channelSuffix]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Instance that allows connecting or disconnecting the Mapbox stack to the network.
class _OfflineSwitch {
  /// Constructor for [_OfflineSwitch].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _OfflineSwitch(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : __pigeon_binaryMessenger = binaryMessenger,
        __pigeon_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      StandardMessageCodec();

  final String __pigeon_messageChannelSuffix;

  /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
  /// with HttpRequestErrorType#ConnectionError.
  ///
  /// @param connected Set false to disconnect the Mapbox stack
  Future<void> setMapboxStackConnected(bool connected) async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineSwitch.setMapboxStackConnected$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[connected]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
  ///
  /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
  Future<bool> isMapboxStackConnected() async {
    final String __pigeon_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._OfflineSwitch.isMapboxStackConnected$__pigeon_messageChannelSuffix';
    final BasicMessageChannel<Object?> __pigeon_channel =
        BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as bool?)!;
    }
  }
}
