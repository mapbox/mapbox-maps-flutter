// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

part of mapbox_maps_flutter;

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse(
    {Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

/// Describes glyphs rasterization modes.
enum GlyphsRasterizationMode {
  /// No glyphs are rasterized locally. All glyphs are loaded from the server.
  NO_GLYPHS_RASTERIZED_LOCALLY,

  /// Ideographs are rasterized locally, and they are not loaded from the server.
  IDEOGRAPHS_RASTERIZED_LOCALLY,

  /// All glyphs are rasterized locally. No glyphs are loaded from the server.
  ALL_GLYPHS_RASTERIZED_LOCALLY,
}

/// Describes the map context mode.
/// We can make some optimizations if we know that the drawing context is not shared with other code.
enum ContextMode {
  /// Unique context mode: in OpenGL, the GL context is not shared, thus we can retain knowledge about the GL state
  /// from a previous render pass. It also enables clearing the screen using glClear for the bottommost background
  /// layer when no pattern is applied to that layer.
  UNIQUE,

  /// Shared context mode: in OpenGL, the GL context is shared with other renderers, thus we cannot rely on the GL
  /// state set from a previous render pass.
  SHARED,
}

/// Describes whether to constrain the map in both axes or only vertically e.g. while panning.
enum ConstrainMode {
  /// No constrains.
  NONE,

  /// Constrain to height only
  HEIGHT_ONLY,

  /// Constrain both width and height axes.
  WIDTH_AND_HEIGHT,
}

/// Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards.
enum ViewportMode {
  /// Default viewport
  DEFAULT,

  /// Viewport flipped on the y-axis.
  FLIPPED_Y,
}

/// Describes the map orientation.
enum NorthOrientation {
  /// Default, map oriented upwards
  UPWARDS,

  /// Map oriented rightwards
  RIGHTWARDS,

  /// Map oriented downwards
  DOWNWARDS,

  /// Map oriented leftwards
  LEFTWARDS,
}

enum _MapWidgetDebugOptions {
  tileBorders,
  parseStatus,
  timestamps,
  collision,
  overdraw,
  stencilClip,
  depthBuffer,
  modelBounds,
  terrainWireframe,
  layers2DWireframe,
  layers3DWireframe,
  light,
  camera,
  padding,
}

/// Options for enabling debugging features in a map.
enum MapDebugOptionsData {
  /// Edges of tile boundaries are shown as thick, red lines to help diagnose
  /// tile clipping issues.
  TILE_BORDERS,

  /// Each tile shows its tile coordinate (x/y/z) in the upper-left corner.
  PARSE_STATUS,

  /// Each tile shows a timestamp indicating when it was loaded.
  TIMESTAMPS,

  /// Edges of glyphs and symbols are shown as faint, green lines to help
  /// diagnose collision and label placement issues.
  COLLISION,

  /// Each drawing operation is replaced by a translucent fill. Overlapping
  /// drawing operations appear more prominent to help diagnose overdrawing.
  OVERDRAW,

  /// The stencil buffer is shown instead of the color buffer.
  STENCIL_CLIP,

  /// The depth buffer is shown instead of the color buffer.
  DEPTH_BUFFER,

  /// Visualize residency of tiles in the render cache. Tile boundaries of cached tiles
  /// are rendered with green, tiles waiting for an update with yellow and tiles not in the cache
  /// with red.
  RENDER_CACHE,

  /// Show 3D model bounding boxes.
  MODEL_BOUNDS,

  /// Show a wireframe for terrain.
  TERRAIN_WIREFRAME,
}

/// Enum describing how to place view annotation relatively to geometry.
enum ViewAnnotationAnchor {
  /// The top of the view annotation is placed closest to the geometry.
  TOP,

  /// The left side of the view annotation is placed closest to the geometry.
  LEFT,

  /// The bottom of the view annotation is placed closest to the geometry.
  BOTTOM,

  /// The right side of the view annotation is placed closest to the geometry.
  RIGHT,

  /// The top-left corner of the view annotation is placed closest to the geometry.
  TOP_LEFT,

  /// The bottom-right corner of the view annotation is placed closest to the geometry.
  BOTTOM_RIGHT,

  /// The top-right corner of the view annotation is placed closest to the geometry.
  TOP_RIGHT,

  /// The bottom-left corner of the view annotation is placed closest to the geometry.
  BOTTOM_LEFT,

  /// The center of the view annotation is placed closest to the geometry.
  CENTER,
}

/// The type of interaction, either tap/click or longTap/longClick
enum InteractionType {
  /// A short tap or click
  TAP,

  /// A long tap or long click
  LONG_TAP,
}

/// Type information of the variant's content
enum Type {
  SCREEN_BOX,
  SCREEN_COORDINATE,
  LIST,
}

/// Controls the behavior of fill extrusion base over terrain
enum FillExtrusionBaseAlignment {
  /// The fill extrusion base follows terrain slope.
  TERRAIN,

  /// The fill extrusion base is flat over terrain.
  FLAT,
}

/// Controls the behavior of fill extrusion height over terrain
enum FillExtrusionHeightAlignment {
  /// The fill extrusion base follows terrain slope.
  TERRAIN,

  /// The fill extrusion base is flat over terrain.
  FLAT,
}

/// Orientation of background layer.
enum BackgroundPitchAlignment {
  /// The background is aligned to the plane of the map.
  MAP,

  /// The background is aligned to the plane of the viewport, covering the whole screen.
  VIEWPORT,
}

/// Describes the reason for a style package download request failure.
enum StylePackErrorType {
  /// The operation was canceled.
  CANCELED,

  /// The style package does not exist.
  DOES_NOT_EXIST,

  /// There is no available space to store the resources.
  DISK_FULL,

  /// Other reason.
  OTHER,
}

/// Describes the reason for an offline request response error.
enum ResponseErrorReason {
  /// No error occurred during the resource request.
  SUCCESS,

  /// The resource is not found.
  NOT_FOUND,

  /// The server error.
  SERVER,

  /// The connection error.
  CONNECTION,

  /// The error happened because of a rate limit.
  RATE_LIMIT,

  /// The resource cannot be loaded because the device is in offline mode.
  IN_OFFLINE_MODE,

  /// Other reason.
  OTHER,
}

/// Describes the download state of a region.
enum OfflineRegionDownloadState {
  /// Indicates downloading is inactive.
  INACTIVE,

  /// Indicates downloading is active.
  ACTIVE,
}

/// Describes tile store usage modes.
enum TileStoreUsageMode {
  /// Tile store usage is disabled.
  ///
  /// The implementation skips checking tile store when requesting a tile.
  DISABLED,

  /// Tile store enabled for accessing loaded tile packs.
  ///
  /// The implementation first checks tile store when requesting a tile.
  /// If a tile pack is already loaded, the tile will be extracted and returned. Otherwise, the implementation
  /// falls back to requesting the individual tile and storing it in the disk cache.
  READ_ONLY,

  /// Tile store enabled for accessing local tile packs and for loading new tile packs from server.
  ///
  /// All tile requests are converted to tile pack requests, i.e.
  /// the tile pack that includes the request tile will be loaded, and the tile extracted
  /// from it. In this mode, no individual tile requests will be made.
  ///
  /// This mode can be useful if the map trajectory is predefined and the user cannot pan
  /// freely (e.g. navigation use cases), so that there is a good chance tile packs are already loaded
  /// in the vicinity of the user.
  ///
  /// If users can pan freely, this mode is not recommended. Otherwise, panning
  /// will download tile packs instead of using individual tiles. Note that this means that we could first
  /// download an individual tile, and then a tile pack that also includes this tile. The individual tile in
  /// the disk cache wonâ€™t be used as long as the up-to-date tile pack exists in the cache.
  READ_AND_UPDATE,
}

/// Describes the kind of a style property value.
enum StylePropertyValueKind {
  /// The property value is not defined.
  UNDEFINED,

  /// The property value is a constant.
  CONSTANT,

  /// The property value is a style [expression](https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions).
  EXPRESSION,

  /// Property value is a style [transition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#transition).
  TRANSITION,
}

enum StyleProjectionName {
  mercator,
  globe,
}

/// Whether extruded geometries are lit relative to the map or viewport.
enum Anchor {
  /// The position of the light source is aligned to the rotation of the map.
  MAP,

  /// The position of the light source is aligned to the rotation of the viewport.
  VIEWPORT,
}

/// HTTP defines a set of request methods to indicate the desired action to be performed for a given resource.
enum HttpMethod {
  /// The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
  GET,

  /// The HEAD method asks for a response identical to that of a GET request, but without the response body.
  HEAD,

  /// The POST method sends data (stored in the request body) to a server to create or update a given resource.
  POST,
}

/// Enum which describes possible error types which could happen during HTTP request/download calls.
enum HttpRequestErrorType {
  /// Establishing connection related error.
  CONNECTION_ERROR,

  /// SSL related error.
  SSLERROR,

  /// Request was cancelled by the user.
  REQUEST_CANCELLED,

  /// Timeout error.
  REQUEST_TIMED_OUT,

  /// Range request failed.
  RANGE_ERROR,

  /// Other than above error.
  OTHER_ERROR,
}

/// Enum which represents different error cases which could happen during download session.
enum DownloadErrorCode {
  /// General filesystem related error code. For cases like: write error, no such file or directory, not enough space and etc.
  FILE_SYSTEM_ERROR,

  /// General network related error. Should be probably representation of HttpRequestError.
  NETWORK_ERROR,
}

/// Enum representing state of download session.
enum DownloadState {
  /// Download session initiated but not started yet.
  PENDING,

  /// Download session is in progress.
  DOWNLOADING,

  /// Download session failed.
  FAILED,

  /// Download session successfully finished.
  FINISHED,
}

/// Describes the reason for a tile region download request failure.
enum TileRegionErrorType {
  /// The operation was canceled.
  CANCELED,

  /// tile region does not exist.
  DOES_NOT_EXIST,

  /// Tileset descriptors resolving failed.
  TILESET_DESCRIPTOR,

  /// There is no available space to store the resources
  DISK_FULL,

  /// Other reason.
  OTHER,

  /// The region contains more tiles than allowed.
  TILE_COUNT_EXCEEDED,
}

enum _MapEvent {
  mapLoaded,
  mapLoadingError,
  styleLoaded,
  styleDataLoaded,
  cameraChanged,
  mapIdle,
  sourceAdded,
  sourceRemoved,
  sourceDataLoaded,
  styleImageMissing,
  styleImageRemoveUnused,
  renderFrameStarted,
  renderFrameFinished,
  resourceRequest,
}

/// Describes the glyphs rasterization option values.
class GlyphsRasterizationOptions {
  GlyphsRasterizationOptions({
    required this.rasterizationMode,
    this.fontFamily,
  });

  /// Glyphs rasterization mode for client-side text rendering.
  GlyphsRasterizationMode rasterizationMode;

  /// Font family to use as font fallback for client-side text renderings.
  ///
  /// Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
  /// or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
  /// font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
  /// default font are varied in platforms:
  /// - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
  ///   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
  /// - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
  ///
  /// Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
  ///
  String? fontFamily;

  Object encode() {
    return <Object?>[
      rasterizationMode,
      fontFamily,
    ];
  }

  static GlyphsRasterizationOptions decode(Object result) {
    result as List<Object?>;
    return GlyphsRasterizationOptions(
      rasterizationMode: result[0]! as GlyphsRasterizationMode,
      fontFamily: result[1] as String?,
    );
  }
}

/// Various options needed for tile cover.
class TileCoverOptions {
  TileCoverOptions({
    this.tileSize,
    this.minZoom,
    this.maxZoom,
    this.roundZoom,
  });

  /// Tile size of the source. Defaults to 512.
  int? tileSize;

  /// Min zoom defined in the source between range [0, 22].
  /// if not provided or is out of range, defaults to 0.
  int? minZoom;

  /// Max zoom defined in the source between range [0, 22].
  /// Should be greater than or equal to minZoom.
  /// If not provided or is out of range, defaults to 22.
  int? maxZoom;

  /// Whether to round zoom values when calculating tilecover.
  /// Set this to true for raster and raster-dem sources.
  /// If not specified, defaults to false.
  bool? roundZoom;

  Object encode() {
    return <Object?>[
      tileSize,
      minZoom,
      maxZoom,
      roundZoom,
    ];
  }

  static TileCoverOptions decode(Object result) {
    result as List<Object?>;
    return TileCoverOptions(
      tileSize: result[0] as int?,
      minZoom: result[1] as int?,
      maxZoom: result[2] as int?,
      roundZoom: result[3] as bool?,
    );
  }
}

/// The distance on each side between rectangles, when one is contained into other.
///
/// All fields' values are in `logical pixel` units.
class MbxEdgeInsets {
  MbxEdgeInsets({
    required this.top,
    required this.left,
    required this.bottom,
    required this.right,
  });

  /// Padding from the top.
  double top;

  /// Padding from the left.
  double left;

  /// Padding from the bottom.
  double bottom;

  /// Padding from the right.
  double right;

  Object encode() {
    return <Object?>[
      top,
      left,
      bottom,
      right,
    ];
  }

  static MbxEdgeInsets decode(Object result) {
    result as List<Object?>;
    return MbxEdgeInsets(
      top: result[0]! as double,
      left: result[1]! as double,
      bottom: result[2]! as double,
      right: result[3]! as double,
    );
  }
}

/// Various options for describing the viewpoint of a camera. All fields are
/// optional.
///
/// Anchor and center points are mutually exclusive, with preference for the
/// center point when both are set.
class CameraOptions {
  CameraOptions({
    this.center,
    this.padding,
    this.anchor,
    this.zoom,
    this.bearing,
    this.pitch,
  });

  /// Coordinate at the center of the camera.
  Point? center;

  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  MbxEdgeInsets? padding;

  /// Point of reference for `zoom` and `angle`, assuming an origin at the
  /// top-left corner of the view.
  ScreenCoordinate? anchor;

  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  double? zoom;

  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  double? bearing;

  /// Pitch toward the horizon measured in degrees.
  double? pitch;

  Object encode() {
    return <Object?>[
      center,
      padding,
      anchor,
      zoom,
      bearing,
      pitch,
    ];
  }

  static CameraOptions decode(Object result) {
    result as List<Object?>;
    return CameraOptions(
      center: result[0] as Point?,
      padding: result[1] as MbxEdgeInsets?,
      anchor: result[2] as ScreenCoordinate?,
      zoom: result[3] as double?,
      bearing: result[4] as double?,
      pitch: result[5] as double?,
    );
  }
}

/// Describes the viewpoint of a camera.
class CameraState {
  CameraState({
    required this.center,
    required this.padding,
    required this.zoom,
    required this.bearing,
    required this.pitch,
  });

  /// Coordinate at the center of the camera.
  Point center;

  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  MbxEdgeInsets padding;

  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  double zoom;

  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  double bearing;

  /// Pitch toward the horizon measured in degrees.
  double pitch;

  Object encode() {
    return <Object?>[
      center,
      padding,
      zoom,
      bearing,
      pitch,
    ];
  }

  static CameraState decode(Object result) {
    result as List<Object?>;
    return CameraState(
      center: result[0]! as Point,
      padding: result[1]! as MbxEdgeInsets,
      zoom: result[2]! as double,
      bearing: result[3]! as double,
      pitch: result[4]! as double,
    );
  }
}

/// Holds options to be used for setting `camera bounds`.
class CameraBoundsOptions {
  CameraBoundsOptions({
    this.bounds,
    this.maxZoom,
    this.minZoom,
    this.maxPitch,
    this.minPitch,
  });

  /// The latitude and longitude bounds to which the camera center are constrained.
  CoordinateBounds? bounds;

  /// The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area.
  double? maxZoom;

  /// The minimum zoom level, in Mapbox zoom levels 0-25.5.
  double? minZoom;

  /// The maximum allowed pitch value in degrees.
  double? maxPitch;

  /// The minimum allowed pitch value in degrees.
  double? minPitch;

  Object encode() {
    return <Object?>[
      bounds,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    ];
  }

  static CameraBoundsOptions decode(Object result) {
    result as List<Object?>;
    return CameraBoundsOptions(
      bounds: result[0] as CoordinateBounds?,
      maxZoom: result[1] as double?,
      minZoom: result[2] as double?,
      maxPitch: result[3] as double?,
      minPitch: result[4] as double?,
    );
  }
}

/// Holds information about `camera bounds`.
class CameraBounds {
  CameraBounds({
    required this.bounds,
    required this.maxZoom,
    required this.minZoom,
    required this.maxPitch,
    required this.minPitch,
  });

  /// The latitude and longitude bounds to which the camera center are constrained.
  CoordinateBounds bounds;

  /// The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area.
  double maxZoom;

  /// The minimum zoom level, in Mapbox zoom levels 0-25.5.
  double minZoom;

  /// The maximum allowed pitch value in degrees.
  double maxPitch;

  /// The minimum allowed pitch value in degrees.
  double minPitch;

  Object encode() {
    return <Object?>[
      bounds,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    ];
  }

  static CameraBounds decode(Object result) {
    result as List<Object?>;
    return CameraBounds(
      bounds: result[0]! as CoordinateBounds,
      maxZoom: result[1]! as double,
      minZoom: result[2]! as double,
      maxPitch: result[3]! as double,
      minPitch: result[4]! as double,
    );
  }
}

class MapAnimationOptions {
  MapAnimationOptions({
    this.duration,
    this.startDelay,
  });

  /// The duration of the animation in milliseconds.
  /// If not set explicitly default duration will be taken 300ms
  int? duration;

  /// The amount of time, in milliseconds, to delay starting the animation after animation start.
  /// If not set explicitly default startDelay will be taken 0ms. This only works for Android.
  int? startDelay;

  Object encode() {
    return <Object?>[
      duration,
      startDelay,
    ];
  }

  static MapAnimationOptions decode(Object result) {
    result as List<Object?>;
    return MapAnimationOptions(
      duration: result[0] as int?,
      startDelay: result[1] as int?,
    );
  }
}

/// A rectangular area as measured on a two-dimensional map projection.
class CoordinateBounds {
  CoordinateBounds({
    required this.southwest,
    required this.northeast,
    required this.infiniteBounds,
  });

  /// Coordinate at the southwest corner.
  /// Note: setting this field with invalid values (infinite, NaN) will crash the application.
  Point southwest;

  /// Coordinate at the northeast corner.
  /// Note: setting this field with invalid values (infinite, NaN) will crash the application.
  Point northeast;

  /// If set to `true`, an infinite (unconstrained) bounds covering the world coordinates would be used.
  /// Coordinates provided in `southwest` and `northeast` fields would be omitted and have no effect.
  bool infiniteBounds;

  Object encode() {
    return <Object?>[
      southwest,
      northeast,
      infiniteBounds,
    ];
  }

  static CoordinateBounds decode(Object result) {
    result as List<Object?>;
    return CoordinateBounds(
      southwest: result[0]! as Point,
      northeast: result[1]! as Point,
      infiniteBounds: result[2]! as bool,
    );
  }
}

/// Options for enabling debugging features in a map.
@Deprecated("Use 'MapWidgetDebugOptions' instead")
class MapDebugOptions {
  MapDebugOptions({
    required this.data,
  });

  MapDebugOptionsData data;

  Object encode() {
    return <Object?>[
      data,
    ];
  }

  static MapDebugOptions decode(Object result) {
    result as List<Object?>;
    return MapDebugOptions(
      data: result[0]! as MapDebugOptionsData,
    );
  }
}

/// Map memory budget in megabytes.
class TileCacheBudgetInMegabytes {
  TileCacheBudgetInMegabytes({
    required this.size,
  });

  int size;

  Object encode() {
    return <Object?>[
      size,
    ];
  }

  static TileCacheBudgetInMegabytes decode(Object result) {
    result as List<Object?>;
    return TileCacheBudgetInMegabytes(
      size: result[0]! as int,
    );
  }
}

/// Map memory budget in tiles.
class TileCacheBudgetInTiles {
  TileCacheBudgetInTiles({
    required this.size,
  });

  int size;

  Object encode() {
    return <Object?>[
      size,
    ];
  }

  static TileCacheBudgetInTiles decode(Object result) {
    result as List<Object?>;
    return TileCacheBudgetInTiles(
      size: result[0]! as int,
    );
  }
}

/// Describes the map option values.
class MapOptions {
  MapOptions({
    this.contextMode,
    this.constrainMode,
    this.viewportMode,
    this.orientation,
    this.crossSourceCollisions,
    this.size,
    required this.pixelRatio,
    this.glyphsRasterizationOptions,
  });

  /// The map context mode. This can be used to optimizations
  /// if we know that the drawing context is not shared with other code.
  ContextMode? contextMode;

  /// The map constrain mode. This can be used to limit the map
  /// to wrap around the globe horizontally. By default, it is set to
  /// `HeightOnly`.
  ConstrainMode? constrainMode;

  /// The viewport mode. This can be used to flip the vertical
  /// orientation of the map as some devices may use inverted orientation.
  ViewportMode? viewportMode;

  /// The orientation of the Map. By default, it is set to
  /// `Upwards`.
  NorthOrientation? orientation;

  /// Specify whether to enable cross-source symbol collision detection
  /// or not. By default, it is set to `true`.
  bool? crossSourceCollisions;

  /// The size to resize the map object and renderer backend.
  /// The size is given in `logical pixel` units. macOS and iOS platforms use
  /// device-independent pixel units, while other platforms, such as Android,
  /// use screen pixel units.
  Size? size;

  /// The custom pixel ratio. By default, it is set to 1.0
  double pixelRatio;

  /// Glyphs rasterization options to use for client-side text rendering.
  GlyphsRasterizationOptions? glyphsRasterizationOptions;

  Object encode() {
    return <Object?>[
      contextMode,
      constrainMode,
      viewportMode,
      orientation,
      crossSourceCollisions,
      size,
      pixelRatio,
      glyphsRasterizationOptions,
    ];
  }

  static MapOptions decode(Object result) {
    result as List<Object?>;
    return MapOptions(
      contextMode: result[0] as ContextMode?,
      constrainMode: result[1] as ConstrainMode?,
      viewportMode: result[2] as ViewportMode?,
      orientation: result[3] as NorthOrientation?,
      crossSourceCollisions: result[4] as bool?,
      size: result[5] as Size?,
      pixelRatio: result[6]! as double,
      glyphsRasterizationOptions: result[7] as GlyphsRasterizationOptions?,
    );
  }
}

/// Describes the coordinate on the screen, measured from top to bottom and from left to right.
/// Note: the `map` uses screen coordinate units measured in `logical pixels`.
class ScreenCoordinate {
  ScreenCoordinate({
    required this.x,
    required this.y,
  });

  /// A value representing the x position of this coordinate.
  double x;

  /// A value representing the y position of this coordinate.
  double y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static ScreenCoordinate decode(Object result) {
    result as List<Object?>;
    return ScreenCoordinate(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }
}

/// Describes the coordinate box on the screen, measured in `logical pixels`
/// from top to bottom and from left to right.
class ScreenBox {
  ScreenBox({
    required this.min,
    required this.max,
  });

  /// The screen coordinate close to the top left corner of the screen.
  ScreenCoordinate min;

  /// The screen coordinate close to the bottom right corner of the screen.
  ScreenCoordinate max;

  Object encode() {
    return <Object?>[
      min,
      max,
    ];
  }

  static ScreenBox decode(Object result) {
    result as List<Object?>;
    return ScreenBox(
      min: result[0]! as ScreenCoordinate,
      max: result[1]! as ScreenCoordinate,
    );
  }
}

/// A coordinate bounds and zoom.
class CoordinateBoundsZoom {
  CoordinateBoundsZoom({
    required this.bounds,
    required this.zoom,
  });

  /// The latitude and longitude bounds.
  CoordinateBounds bounds;

  /// Zoom.
  double zoom;

  Object encode() {
    return <Object?>[
      bounds,
      zoom,
    ];
  }

  static CoordinateBoundsZoom decode(Object result) {
    result as List<Object?>;
    return CoordinateBoundsZoom(
      bounds: result[0]! as CoordinateBounds,
      zoom: result[1]! as double,
    );
  }
}

/// Size type.
class Size {
  Size({
    required this.width,
    required this.height,
  });

  /// Width of the size.
  double width;

  /// Height of the size.
  double height;

  Object encode() {
    return <Object?>[
      width,
      height,
    ];
  }

  static Size decode(Object result) {
    result as List<Object?>;
    return Size(
      width: result[0]! as double,
      height: result[1]! as double,
    );
  }
}

/// Options for querying rendered features.
class RenderedQueryOptions {
  RenderedQueryOptions({
    this.layerIds,
    this.filter,
  });

  /// Layer IDs to include in the query.
  List<String?>? layerIds;

  /// Filters the returned features with an expression
  String? filter;

  Object encode() {
    return <Object?>[
      layerIds,
      filter,
    ];
  }

  static RenderedQueryOptions decode(Object result) {
    result as List<Object?>;
    return RenderedQueryOptions(
      layerIds: (result[0] as List<Object?>?)?.cast<String?>(),
      filter: result[1] as String?,
    );
  }
}

/// Options for querying source features.
class SourceQueryOptions {
  SourceQueryOptions({
    this.sourceLayerIds,
    required this.filter,
  });

  /// Source layer IDs to include in the query.
  List<String?>? sourceLayerIds;

  /// Filters the returned features with an expression
  String filter;

  Object encode() {
    return <Object?>[
      sourceLayerIds,
      filter,
    ];
  }

  static SourceQueryOptions decode(Object result) {
    result as List<Object?>;
    return SourceQueryOptions(
      sourceLayerIds: (result[0] as List<Object?>?)?.cast<String?>(),
      filter: result[1]! as String,
    );
  }
}

/// A value or a collection of a feature extension.
class FeatureExtensionValue {
  FeatureExtensionValue({
    this.value,
    this.featureCollection,
  });

  /// An optional value of a feature extension
  String? value;

  /// An optional array of features from a feature extension.
  List<Map<String?, Object?>?>? featureCollection;

  Object encode() {
    return <Object?>[
      value,
      featureCollection,
    ];
  }

  static FeatureExtensionValue decode(Object result) {
    result as List<Object?>;
    return FeatureExtensionValue(
      value: result[0] as String?,
      featureCollection: (result[1] as List<Object?>?)?.map((e) {
        return Map<Object?, Object?>.from(e as Map<dynamic, dynamic>)
            .cast<String?, Object?>();
      }).toList(),
    );
  }
}

/// Specifies position of a layer that is added via addStyleLayer method.
class LayerPosition {
  LayerPosition({
    this.above,
    this.below,
    this.at,
  });

  /// Layer should be positioned above specified layer id.
  String? above;

  /// Layer should be positioned below specified layer id.
  String? below;

  /// Layer should be positioned at specified index in a layers stack.
  int? at;

  Object encode() {
    return <Object?>[
      above,
      below,
      at,
    ];
  }

  static LayerPosition decode(Object result) {
    result as List<Object?>;
    return LayerPosition(
      above: result[0] as String?,
      below: result[1] as String?,
      at: result[2] as int?,
    );
  }
}

/// Represents query result that is returned in QueryRenderedFeaturesCallback.
/// @see `queryRenderedFeatures`
class QueriedRenderedFeature {
  QueriedRenderedFeature({
    required this.queriedFeature,
    required this.layers,
    this.queryTargets,
  });

  /// Feature returned by the query.
  QueriedFeature queriedFeature;

  /// An array of layer Ids for the queried feature.
  /// If the feature has been rendered in multiple layers, multiple Ids will be provided.
  /// If the feature is only rendered in one layer, a single Id will be provided.
  List<String?> layers;

  /// An array of feature query targets that correspond to this queried feature.
  ///
  /// - Note: Returned query targets will omit the original `filter` data.
  List<FeaturesetQueryTarget>? queryTargets;

  Object encode() {
    return <Object?>[
      queriedFeature,
      layers,
      queryTargets,
    ];
  }

  static QueriedRenderedFeature decode(Object result) {
    result as List<Object?>;
    return QueriedRenderedFeature(
      queriedFeature: result[0]! as QueriedFeature,
      layers: (result[1] as List<Object?>?)!.cast<String?>(),
      queryTargets:
          (result[2] as List<Object?>?)?.cast<FeaturesetQueryTarget>(),
    );
  }
}

/// Represents query result that is returned in QuerySourceFeaturesCallback.
/// @see `querySourceFeatures`
class QueriedSourceFeature {
  QueriedSourceFeature({
    required this.queriedFeature,
  });

  /// Feature returned by the query.
  QueriedFeature queriedFeature;

  Object encode() {
    return <Object?>[
      queriedFeature,
    ];
  }

  static QueriedSourceFeature decode(Object result) {
    result as List<Object?>;
    return QueriedSourceFeature(
      queriedFeature: result[0]! as QueriedFeature,
    );
  }
}

/// Represents query result that is returned in QueryFeaturesCallback.
/// @see `queryRenderedFeatures` or `querySourceFeatures`
class QueriedFeature {
  QueriedFeature({
    required this.feature,
    required this.source,
    this.sourceLayer,
    required this.state,
  });

  /// Feature returned by the query.
  Map<String?, Object?> feature;

  /// Source id for a queried feature.
  String source;

  /// Source layer id for a queried feature. May be null if source does not support layers, e.g., 'geojson' source,
  /// or when data provided by the source is not layered.
  String? sourceLayer;

  /// Feature state for a queried feature. Type of the value is an Object.
  /// @see `setFeatureState` and `getFeatureState`
  String state;

  Object encode() {
    return <Object?>[
      feature,
      source,
      sourceLayer,
      state,
    ];
  }

  static QueriedFeature decode(Object result) {
    result as List<Object?>;
    return QueriedFeature(
      feature: (result[0] as Map<Object?, Object?>?)!.cast<String?, Object?>(),
      source: result[1]! as String,
      sourceLayer: result[2] as String?,
      state: result[3]! as String,
    );
  }
}

/// Identifies a feature in a featureset.
///
/// Knowing the feature identifier allows to set the feature states to a particular feature, see ``MapboxMap/setFeatureState(featureset:featureId:state:callback:)``.
///
/// In a featureset a feature can come from different underlying sources. In that case their IDs are not guaranteed to be unique in the featureset.
/// The ``FeaturesetFeatureId/namespace`` is used to disambiguate from which source the feature is coming.
///
/// - Warning: There is no guarantee of identifier persistency. This depends on the underlying source of the features and may vary from style to style.
/// If you want to store the identifiers persistently, please make sure that the style or source provides this guarantee.
class FeaturesetFeatureId {
  FeaturesetFeatureId({
    required this.id,
    this.namespace,
  });

  /// A feature id coming from the feature itself.exp
  String id;

  /// A namespace of the feature
  String? namespace;

  Object encode() {
    return <Object?>[
      id,
      namespace,
    ];
  }

  static FeaturesetFeatureId decode(Object result) {
    result as List<Object?>;
    return FeaturesetFeatureId(
      id: result[0]! as String,
      namespace: result[1] as String?,
    );
  }
}

/// Wraps a FeatureState map
class FeatureState {
  FeatureState({
    required this.map,
  });

  Map<String, Object?> map;

  Object encode() {
    return <Object?>[
      map,
    ];
  }

  static FeatureState decode(Object result) {
    result as List<Object?>;
    return FeatureState(
      map: (result[0] as Map<Object?, Object?>?)!.cast<String, Object?>(),
    );
  }
}

/// An interaction that can be added to the map.
///
/// To create an interaction use ``TapInteraction`` and ``LongClickInteraction`` implementations.
///
/// See also: ``MapboxMap/addInteraction``.
class Interaction {
  Interaction({
    required this.featuresetDescriptor,
    required this.interactionType,
    required this.stopPropagation,
    this.filter,
    this.radius,
  });

  /// The featureset descriptor that specifies the featureset to be included in the interaction.
  FeaturesetDescriptor featuresetDescriptor;

  /// The type of interaction, either tap or longTap
  InteractionType interactionType;

  /// Whether to stop the propagation of the interaction to the map. Defaults to true.
  bool stopPropagation;

  /// An optional filter of features that should trigger the interaction.
  String? filter;

  /// Radius of a tappable area
  double? radius;

  Object encode() {
    return <Object?>[
      featuresetDescriptor,
      interactionType,
      stopPropagation,
      filter,
      radius,
    ];
  }

  static Interaction decode(Object result) {
    result as List<Object?>;
    return Interaction(
      featuresetDescriptor: result[0]! as FeaturesetDescriptor,
      interactionType: result[1]! as InteractionType,
      stopPropagation: result[2]! as bool,
      filter: result[3] as String?,
      radius: result[4] as double?,
    );
  }
}

/// A featureset descriptor.
///
/// The descriptor instance acts as a universal target for interactions or querying rendered features (see  'TapInteraction', 'LongTapInteraction')
class FeaturesetDescriptor {
  FeaturesetDescriptor({
    this.featuresetId,
    this.importId,
    this.layerId,
  });

  /// An optional unique identifier for the featureset within the style.
  /// This id is used to reference a specific featureset.
  ///
  /// * Note: If `featuresetId` is provided and valid, it takes precedence over `layerId`,
  /// * meaning `layerId` will not be considered even if it has a valid value.
  String? featuresetId;

  /// An optional import id that is required if the featureset is defined within an imported style.
  /// If the featureset belongs to the current style, this field should be set to a null string.
  ///
  /// Note: `importId` is only applicable when used in conjunction with `featuresetId`
  /// and has no effect when used with `layerId`.
  String? importId;

  /// An optional unique identifier for the layer within the current style.
  ///
  /// Note: If `featuresetId` is valid, `layerId` will be ignored even if it has a valid value.
  /// Additionally, `importId` does not apply when using `layerId`.
  String? layerId;

  Object encode() {
    return <Object?>[
      featuresetId,
      importId,
      layerId,
    ];
  }

  static FeaturesetDescriptor decode(Object result) {
    result as List<Object?>;
    return FeaturesetDescriptor(
      featuresetId: result[0] as String?,
      importId: result[1] as String?,
      layerId: result[2] as String?,
    );
  }
}

/// A basic feature of a featureset.
///
/// If you use Standard Style, you can use typed alternatives like `StandardPoiFeature`, `StandardPlaceLabelsFeature`, `StandardBuildingsFeature`.
///
/// The featureset feature is different to the `Turf.Feature`. The latter represents any GeoJSON feature, while the former is a high level representation of features.
class FeaturesetFeature {
  FeaturesetFeature({
    this.id,
    required this.featureset,
    required this.geometry,
    required this.properties,
    required this.state,
  });

  /// An identifier of the feature.
  ///
  /// The identifier can be `nil` if the underlying source doesn't have identifiers for features.
  /// In this case it's impossible to set a feature state for an individual feature.
  FeaturesetFeatureId? id;

  /// A featureset descriptor denoting the featureset this feature belongs to.
  FeaturesetDescriptor featureset;

  /// A feature geometry.
  Map<String?, Object?> geometry;

  /// Feature JSON properties.
  Map<String, Object?> properties;

  /// A feature state.
  ///
  /// This is a **snapshot** of the state that the feature had when it was interacted with.
  /// To update and read the original state, use ``MapboxMap/setFeatureState()`` and ``MapboxMap/getFeatureState()``.
  Map<String, Object?> state;

  Object encode() {
    return <Object?>[
      id,
      featureset,
      geometry,
      properties,
      state,
    ];
  }

  static FeaturesetFeature decode(Object result) {
    result as List<Object?>;
    return FeaturesetFeature(
      id: result[0] as FeaturesetFeatureId?,
      featureset: result[1]! as FeaturesetDescriptor,
      geometry: (result[2] as Map<Object?, Object?>?)!.cast<String?, Object?>(),
      properties:
          (result[3] as Map<Object?, Object?>?)!.cast<String, Object?>(),
      state: (result[4] as Map<Object?, Object?>?)!.cast<String, Object?>(),
    );
  }
}

/// Defines the parameters for querying features from a Featureset with an optional filter and id.
class FeaturesetQueryTarget {
  FeaturesetQueryTarget({
    required this.featureset,
    this.filter,
    this.id,
  });

  /// A `FeaturesetDescriptor` that specifies the featureset to be included in the query.
  FeaturesetDescriptor featureset;

  /// An optional filter expression used to refine the query results based on conditions related to the specified featureset.
  String? filter;

  /// An optional unique identifier associated with the target.
  int? id;

  Object encode() {
    return <Object?>[
      featureset,
      filter,
      id,
    ];
  }

  static FeaturesetQueryTarget decode(Object result) {
    result as List<Object?>;
    return FeaturesetQueryTarget(
      featureset: result[0]! as FeaturesetDescriptor,
      filter: result[1] as String?,
      id: result[2] as int?,
    );
  }
}

/// Geometry for querying rendered features.
class _RenderedQueryGeometry {
  _RenderedQueryGeometry({
    required this.value,
    required this.type,
  });

  /// ScreenCoordinate/List<ScreenCoordinate>/ScreenBox in Json mode.
  String value;

  Type type;

  Object encode() {
    return <Object?>[
      value,
      type,
    ];
  }

  static _RenderedQueryGeometry decode(Object result) {
    result as List<Object?>;
    return _RenderedQueryGeometry(
      value: result[0]! as String,
      type: result[1]! as Type,
    );
  }
}

/// ProjectedMeters is a coordinate in a specific
/// [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection.
///
/// This specific Spherical Mercator projection assumes the Earth is a sphere with a radius
/// of 6,378,137 meters. Coordinates are determined as distances, in meters, on the surface
/// of that sphere.
class ProjectedMeters {
  ProjectedMeters({
    required this.northing,
    required this.easting,
  });

  /// Projected meters in north direction.
  double northing;

  /// Projected meters in east direction.
  double easting;

  Object encode() {
    return <Object?>[
      northing,
      easting,
    ];
  }

  static ProjectedMeters decode(Object result) {
    result as List<Object?>;
    return ProjectedMeters(
      northing: result[0]! as double,
      easting: result[1]! as double,
    );
  }
}

/// Describes a point on the map in Mercator projection.
class MercatorCoordinate {
  MercatorCoordinate({
    required this.x,
    required this.y,
  });

  /// A value representing the x position of this coordinate.
  double x;

  /// A value representing the y position of this coordinate.
  double y;

  Object encode() {
    return <Object?>[
      x,
      y,
    ];
  }

  static MercatorCoordinate decode(Object result) {
    result as List<Object?>;
    return MercatorCoordinate(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }
}

/// The information about style object (source or layer).
class StyleObjectInfo {
  StyleObjectInfo({
    required this.id,
    required this.type,
  });

  /// The object's identifier.
  String id;

  /// The object's type.
  String type;

  Object encode() {
    return <Object?>[
      id,
      type,
    ];
  }

  static StyleObjectInfo decode(Object result) {
    result as List<Object?>;
    return StyleObjectInfo(
      id: result[0]! as String,
      type: result[1]! as String,
    );
  }
}

class StyleProjection {
  StyleProjection({
    required this.name,
  });

  StyleProjectionName name;

  Object encode() {
    return <Object?>[
      name,
    ];
  }

  static StyleProjection decode(Object result) {
    result as List<Object?>;
    return StyleProjection(
      name: result[0]! as StyleProjectionName,
    );
  }
}

/// A global directional light source which is only applied on 3D layers and hillshade layers. Using this type disables other light sources.
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
class FlatLight {
  FlatLight({
    required this.id,
    this.anchor,
    this.color,
    this.colorTransition,
    this.intensity,
    this.intensityTransition,
    this.position,
    this.positionTransition,
  });

  /// Unique light name
  String id;

  /// Whether extruded geometries are lit relative to the map or viewport.
  Anchor? anchor;

  /// Color tint for lighting extruded geometries.
  int? color;

  /// Transition property for `color`
  TransitionOptions? colorTransition;

  /// Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.
  double? intensity;

  /// Transition property for `intensity`
  TransitionOptions? intensityTransition;

  /// Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0 degree (0 degree when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0 degree when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0 degree, directly above, to 180 degree, directly below).
  List<double?>? position;

  /// Transition property for `position`
  TransitionOptions? positionTransition;

  Object encode() {
    return <Object?>[
      id,
      anchor,
      color,
      colorTransition,
      intensity,
      intensityTransition,
      position,
      positionTransition,
    ];
  }

  static FlatLight decode(Object result) {
    result as List<Object?>;
    return FlatLight(
      id: result[0]! as String,
      anchor: result[1] as Anchor?,
      color: result[2] as int?,
      colorTransition: result[3] as TransitionOptions?,
      intensity: result[4] as double?,
      intensityTransition: result[5] as TransitionOptions?,
      position: (result[6] as List<Object?>?)?.cast<double?>(),
      positionTransition: result[7] as TransitionOptions?,
    );
  }
}

/// A light that has a direction and is located at infinite, so its rays are parallel. Simulates the sun light and it can cast shadows
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
class DirectionalLight {
  DirectionalLight({
    required this.id,
    this.castShadows,
    this.color,
    this.colorTransition,
    this.direction,
    this.directionTransition,
    this.intensity,
    this.intensityTransition,
    this.shadowIntensity,
    this.shadowIntensityTransition,
  });

  /// Unique light name
  String id;

  /// Enable/Disable shadow casting for this light
  bool? castShadows;

  /// Color of the directional light.
  int? color;

  /// Transition property for `color`
  TransitionOptions? colorTransition;

  /// Direction of the light source specified as [a azimuthal angle, p polar angle] where a indicates the azimuthal angle of the light relative to north (in degrees and proceeding clockwise), and p indicates polar angle of the light (from 0 degree, directly above, to 180 degree, directly below).
  List<double?>? direction;

  /// Transition property for `direction`
  TransitionOptions? directionTransition;

  /// A multiplier for the color of the directional light.
  double? intensity;

  /// Transition property for `intensity`
  TransitionOptions? intensityTransition;

  /// Determines the shadow strength, affecting the shadow receiver surfaces final color. Values near 0.0 reduce the shadow contribution to the final color. Values near to 1.0 make occluded surfaces receive almost no directional light. Designed to be used mostly for transitioning between values 0 and 1.
  double? shadowIntensity;

  /// Transition property for `shadowIntensity`
  TransitionOptions? shadowIntensityTransition;

  Object encode() {
    return <Object?>[
      id,
      castShadows,
      color,
      colorTransition,
      direction,
      directionTransition,
      intensity,
      intensityTransition,
      shadowIntensity,
      shadowIntensityTransition,
    ];
  }

  static DirectionalLight decode(Object result) {
    result as List<Object?>;
    return DirectionalLight(
      id: result[0]! as String,
      castShadows: result[1] as bool?,
      color: result[2] as int?,
      colorTransition: result[3] as TransitionOptions?,
      direction: (result[4] as List<Object?>?)?.cast<double?>(),
      directionTransition: result[5] as TransitionOptions?,
      intensity: result[6] as double?,
      intensityTransition: result[7] as TransitionOptions?,
      shadowIntensity: result[8] as double?,
      shadowIntensityTransition: result[9] as TransitionOptions?,
    );
  }
}

/// An indirect light affecting all objects in the map adding a constant amount of light on them. It has no explicit direction and cannot cast shadows.
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
class AmbientLight {
  AmbientLight({
    required this.id,
    this.color,
    this.colorTransition,
    this.intensity,
    this.intensityTransition,
  });

  /// Unique light name
  String id;

  /// Color of the ambient light.
  int? color;

  /// Transition property for `color`
  TransitionOptions? colorTransition;

  /// A multiplier for the color of the ambient light.
  double? intensity;

  /// Transition property for `intensity`
  TransitionOptions? intensityTransition;

  Object encode() {
    return <Object?>[
      id,
      color,
      colorTransition,
      intensity,
      intensityTransition,
    ];
  }

  static AmbientLight decode(Object result) {
    result as List<Object?>;
    return AmbientLight(
      id: result[0]! as String,
      color: result[1] as int?,
      colorTransition: result[2] as TransitionOptions?,
      intensity: result[3] as double?,
      intensityTransition: result[4] as TransitionOptions?,
    );
  }
}

/// Image type.
class MbxImage {
  MbxImage({
    required this.width,
    required this.height,
    required this.data,
  });

  /// The width of the image, in screen pixels.
  int width;

  /// The height of the image, in screen pixels.
  int height;

  /// 32-bit premultiplied RGBA image data.
  ///
  /// An uncompressed image data encoded in 32-bit RGBA format with premultiplied
  /// alpha channel. This field should contain exactly `4 * width * height` bytes. It
  /// should consist of a sequence of scanlines.
  Uint8List data;

  Object encode() {
    return <Object?>[
      width,
      height,
      data,
    ];
  }

  static MbxImage decode(Object result) {
    result as List<Object?>;
    return MbxImage(
      width: result[0]! as int,
      height: result[1]! as int,
      data: result[2]! as Uint8List,
    );
  }
}

/// Describes the image stretch areas.
class ImageStretches {
  ImageStretches({
    required this.first,
    required this.second,
  });

  /// The first stretchable part in screen pixel units.
  double first;

  /// The second stretchable part in screen pixel units.
  double second;

  Object encode() {
    return <Object?>[
      first,
      second,
    ];
  }

  static ImageStretches decode(Object result) {
    result as List<Object?>;
    return ImageStretches(
      first: result[0]! as double,
      second: result[1]! as double,
    );
  }
}

/// Describes the image content, e.g. where text can be fit into an image.
///
/// When sizing icons with `icon-text-fit`, the icon size will be adjusted so that the this content box fits exactly around the text.
class ImageContent {
  ImageContent({
    required this.left,
    required this.top,
    required this.right,
    required this.bottom,
  });

  /// Distance to the left, in screen pixels.
  double left;

  /// Distance to the top, in screen pixels.
  double top;

  /// Distance to the right, in screen pixels.
  double right;

  /// Distance to the bottom, in screen pixels.
  double bottom;

  Object encode() {
    return <Object?>[
      left,
      top,
      right,
      bottom,
    ];
  }

  static ImageContent decode(Object result) {
    result as List<Object?>;
    return ImageContent(
      left: result[0]! as double,
      top: result[1]! as double,
      right: result[2]! as double,
      bottom: result[3]! as double,
    );
  }
}

/// The `transition options` controls timing for the interpolation between a transitionable style
/// property's previous value and new value. These can be used to define the style default property
/// transition behavior. Also, any transitionable style property may also have its own `-transition`
/// property that defines specific transition timing for that specific layer property, overriding
/// the global transition values.
class TransitionOptions {
  TransitionOptions({
    this.duration,
    this.delay,
    this.enablePlacementTransitions,
  });

  /// Time allotted for transitions to complete. Units in milliseconds. Defaults to `300.0`.
  int? duration;

  /// Length of time before a transition begins. Units in milliseconds. Defaults to `0.0`.
  int? delay;

  /// Whether the fade in/out symbol placement transition is enabled. Defaults to `true`.
  bool? enablePlacementTransitions;

  Object encode() {
    return <Object?>[
      duration,
      delay,
      enablePlacementTransitions,
    ];
  }

  static TransitionOptions decode(Object result) {
    result as List<Object?>;
    return TransitionOptions(
      duration: result[0] as int?,
      delay: result[1] as int?,
      enablePlacementTransitions: result[2] as bool?,
    );
  }
}

/// Represents a tile coordinate.
class CanonicalTileID {
  CanonicalTileID({
    required this.z,
    required this.x,
    required this.y,
  });

  /// The z value of the coordinate (zoom-level).
  int z;

  /// The x value of the coordinate.
  int x;

  /// The y value of the coordinate.
  int y;

  Object encode() {
    return <Object?>[
      z,
      x,
      y,
    ];
  }

  static CanonicalTileID decode(Object result) {
    result as List<Object?>;
    return CanonicalTileID(
      z: result[0]! as int,
      x: result[1]! as int,
      y: result[2]! as int,
    );
  }
}

/// Holds a style property value with meta data.
class StylePropertyValue {
  StylePropertyValue({
    this.value,
    required this.kind,
  });

  /// The property value.
  Object? value;

  /// The kind of the property value.
  StylePropertyValueKind kind;

  Object encode() {
    return <Object?>[
      value,
      kind,
    ];
  }

  static StylePropertyValue decode(Object result) {
    result as List<Object?>;
    return StylePropertyValue(
      value: result[0],
      kind: result[1]! as StylePropertyValueKind,
    );
  }
}

class MapInterfaces_PigeonCodec extends StandardMessageCodec {
  const MapInterfaces_PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is GlyphsRasterizationMode) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is ContextMode) {
      buffer.putUint8(130);
      writeValue(buffer, value.index);
    } else if (value is ConstrainMode) {
      buffer.putUint8(131);
      writeValue(buffer, value.index);
    } else if (value is ViewportMode) {
      buffer.putUint8(132);
      writeValue(buffer, value.index);
    } else if (value is NorthOrientation) {
      buffer.putUint8(133);
      writeValue(buffer, value.index);
    } else if (value is _MapWidgetDebugOptions) {
      buffer.putUint8(134);
      writeValue(buffer, value.index);
    } else if (value is MapDebugOptionsData) {
      buffer.putUint8(135);
      writeValue(buffer, value.index);
    } else if (value is ViewAnnotationAnchor) {
      buffer.putUint8(136);
      writeValue(buffer, value.index);
    } else if (value is InteractionType) {
      buffer.putUint8(137);
      writeValue(buffer, value.index);
    } else if (value is GestureState) {
      buffer.putUint8(138);
      writeValue(buffer, value.index);
    } else if (value is Type) {
      buffer.putUint8(139);
      writeValue(buffer, value.index);
    } else if (value is FillExtrusionBaseAlignment) {
      buffer.putUint8(140);
      writeValue(buffer, value.index);
    } else if (value is FillExtrusionHeightAlignment) {
      buffer.putUint8(141);
      writeValue(buffer, value.index);
    } else if (value is BackgroundPitchAlignment) {
      buffer.putUint8(142);
      writeValue(buffer, value.index);
    } else if (value is StylePackErrorType) {
      buffer.putUint8(143);
      writeValue(buffer, value.index);
    } else if (value is ResponseErrorReason) {
      buffer.putUint8(144);
      writeValue(buffer, value.index);
    } else if (value is OfflineRegionDownloadState) {
      buffer.putUint8(145);
      writeValue(buffer, value.index);
    } else if (value is TileStoreUsageMode) {
      buffer.putUint8(146);
      writeValue(buffer, value.index);
    } else if (value is StylePropertyValueKind) {
      buffer.putUint8(147);
      writeValue(buffer, value.index);
    } else if (value is StyleProjectionName) {
      buffer.putUint8(148);
      writeValue(buffer, value.index);
    } else if (value is Anchor) {
      buffer.putUint8(149);
      writeValue(buffer, value.index);
    } else if (value is HttpMethod) {
      buffer.putUint8(150);
      writeValue(buffer, value.index);
    } else if (value is HttpRequestErrorType) {
      buffer.putUint8(151);
      writeValue(buffer, value.index);
    } else if (value is DownloadErrorCode) {
      buffer.putUint8(152);
      writeValue(buffer, value.index);
    } else if (value is DownloadState) {
      buffer.putUint8(153);
      writeValue(buffer, value.index);
    } else if (value is TileRegionErrorType) {
      buffer.putUint8(154);
      writeValue(buffer, value.index);
    } else if (value is _MapEvent) {
      buffer.putUint8(155);
      writeValue(buffer, value.index);
    } else if (value is Point) {
      buffer.putUint8(156);
      writeValue(buffer, value.encode());
    } else if (value is Feature) {
      buffer.putUint8(157);
      writeValue(buffer, value.encode());
    } else if (value is GlyphsRasterizationOptions) {
      buffer.putUint8(158);
      writeValue(buffer, value.encode());
    } else if (value is TileCoverOptions) {
      buffer.putUint8(159);
      writeValue(buffer, value.encode());
    } else if (value is MbxEdgeInsets) {
      buffer.putUint8(160);
      writeValue(buffer, value.encode());
    } else if (value is CameraOptions) {
      buffer.putUint8(161);
      writeValue(buffer, value.encode());
    } else if (value is CameraState) {
      buffer.putUint8(162);
      writeValue(buffer, value.encode());
    } else if (value is CameraBoundsOptions) {
      buffer.putUint8(163);
      writeValue(buffer, value.encode());
    } else if (value is CameraBounds) {
      buffer.putUint8(164);
      writeValue(buffer, value.encode());
    } else if (value is MapAnimationOptions) {
      buffer.putUint8(165);
      writeValue(buffer, value.encode());
    } else if (value is CoordinateBounds) {
      buffer.putUint8(166);
      writeValue(buffer, value.encode());
    } else if (value is MapDebugOptions) {
      buffer.putUint8(167);
      writeValue(buffer, value.encode());
    } else if (value is TileCacheBudgetInMegabytes) {
      buffer.putUint8(168);
      writeValue(buffer, value.encode());
    } else if (value is TileCacheBudgetInTiles) {
      buffer.putUint8(169);
      writeValue(buffer, value.encode());
    } else if (value is MapOptions) {
      buffer.putUint8(170);
      writeValue(buffer, value.encode());
    } else if (value is ScreenCoordinate) {
      buffer.putUint8(171);
      writeValue(buffer, value.encode());
    } else if (value is ScreenBox) {
      buffer.putUint8(172);
      writeValue(buffer, value.encode());
    } else if (value is CoordinateBoundsZoom) {
      buffer.putUint8(173);
      writeValue(buffer, value.encode());
    } else if (value is Size) {
      buffer.putUint8(174);
      writeValue(buffer, value.encode());
    } else if (value is RenderedQueryOptions) {
      buffer.putUint8(175);
      writeValue(buffer, value.encode());
    } else if (value is SourceQueryOptions) {
      buffer.putUint8(176);
      writeValue(buffer, value.encode());
    } else if (value is FeatureExtensionValue) {
      buffer.putUint8(177);
      writeValue(buffer, value.encode());
    } else if (value is LayerPosition) {
      buffer.putUint8(178);
      writeValue(buffer, value.encode());
    } else if (value is QueriedRenderedFeature) {
      buffer.putUint8(179);
      writeValue(buffer, value.encode());
    } else if (value is QueriedSourceFeature) {
      buffer.putUint8(180);
      writeValue(buffer, value.encode());
    } else if (value is QueriedFeature) {
      buffer.putUint8(181);
      writeValue(buffer, value.encode());
    } else if (value is FeaturesetFeatureId) {
      buffer.putUint8(182);
      writeValue(buffer, value.encode());
    } else if (value is FeatureState) {
      buffer.putUint8(183);
      writeValue(buffer, value.encode());
    } else if (value is Interaction) {
      buffer.putUint8(184);
      writeValue(buffer, value.encode());
    } else if (value is FeaturesetDescriptor) {
      buffer.putUint8(185);
      writeValue(buffer, value.encode());
    } else if (value is FeaturesetFeature) {
      buffer.putUint8(186);
      writeValue(buffer, value.encode());
    } else if (value is FeaturesetQueryTarget) {
      buffer.putUint8(187);
      writeValue(buffer, value.encode());
    } else if (value is MapContentGestureContext) {
      buffer.putUint8(188);
      writeValue(buffer, value.encode());
    } else if (value is _RenderedQueryGeometry) {
      buffer.putUint8(189);
      writeValue(buffer, value.encode());
    } else if (value is ProjectedMeters) {
      buffer.putUint8(190);
      writeValue(buffer, value.encode());
    } else if (value is MercatorCoordinate) {
      buffer.putUint8(191);
      writeValue(buffer, value.encode());
    } else if (value is StyleObjectInfo) {
      buffer.putUint8(192);
      writeValue(buffer, value.encode());
    } else if (value is StyleProjection) {
      buffer.putUint8(193);
      writeValue(buffer, value.encode());
    } else if (value is FlatLight) {
      buffer.putUint8(194);
      writeValue(buffer, value.encode());
    } else if (value is DirectionalLight) {
      buffer.putUint8(195);
      writeValue(buffer, value.encode());
    } else if (value is AmbientLight) {
      buffer.putUint8(196);
      writeValue(buffer, value.encode());
    } else if (value is MbxImage) {
      buffer.putUint8(197);
      writeValue(buffer, value.encode());
    } else if (value is ImageStretches) {
      buffer.putUint8(198);
      writeValue(buffer, value.encode());
    } else if (value is ImageContent) {
      buffer.putUint8(199);
      writeValue(buffer, value.encode());
    } else if (value is TransitionOptions) {
      buffer.putUint8(200);
      writeValue(buffer, value.encode());
    } else if (value is CanonicalTileID) {
      buffer.putUint8(201);
      writeValue(buffer, value.encode());
    } else if (value is StylePropertyValue) {
      buffer.putUint8(202);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : GlyphsRasterizationMode.values[value];
      case 130:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ContextMode.values[value];
      case 131:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ConstrainMode.values[value];
      case 132:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ViewportMode.values[value];
      case 133:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : NorthOrientation.values[value];
      case 134:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : _MapWidgetDebugOptions.values[value];
      case 135:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : MapDebugOptionsData.values[value];
      case 136:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ViewAnnotationAnchor.values[value];
      case 137:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : InteractionType.values[value];
      case 138:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : GestureState.values[value];
      case 139:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : Type.values[value];
      case 140:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : FillExtrusionBaseAlignment.values[value];
      case 141:
        final int? value = readValue(buffer) as int?;
        return value == null
            ? null
            : FillExtrusionHeightAlignment.values[value];
      case 142:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : BackgroundPitchAlignment.values[value];
      case 143:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StylePackErrorType.values[value];
      case 144:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : ResponseErrorReason.values[value];
      case 145:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : OfflineRegionDownloadState.values[value];
      case 146:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : TileStoreUsageMode.values[value];
      case 147:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StylePropertyValueKind.values[value];
      case 148:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : StyleProjectionName.values[value];
      case 149:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : Anchor.values[value];
      case 150:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : HttpMethod.values[value];
      case 151:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : HttpRequestErrorType.values[value];
      case 152:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : DownloadErrorCode.values[value];
      case 153:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : DownloadState.values[value];
      case 154:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : TileRegionErrorType.values[value];
      case 155:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : _MapEvent.values[value];
      case 156:
        return Point.decode(readValue(buffer)!);
      case 157:
        return Feature.decode(readValue(buffer)!);
      case 158:
        return GlyphsRasterizationOptions.decode(readValue(buffer)!);
      case 159:
        return TileCoverOptions.decode(readValue(buffer)!);
      case 160:
        return MbxEdgeInsets.decode(readValue(buffer)!);
      case 161:
        return CameraOptions.decode(readValue(buffer)!);
      case 162:
        return CameraState.decode(readValue(buffer)!);
      case 163:
        return CameraBoundsOptions.decode(readValue(buffer)!);
      case 164:
        return CameraBounds.decode(readValue(buffer)!);
      case 165:
        return MapAnimationOptions.decode(readValue(buffer)!);
      case 166:
        return CoordinateBounds.decode(readValue(buffer)!);
      case 167:
        return MapDebugOptions.decode(readValue(buffer)!);
      case 168:
        return TileCacheBudgetInMegabytes.decode(readValue(buffer)!);
      case 169:
        return TileCacheBudgetInTiles.decode(readValue(buffer)!);
      case 170:
        return MapOptions.decode(readValue(buffer)!);
      case 171:
        return ScreenCoordinate.decode(readValue(buffer)!);
      case 172:
        return ScreenBox.decode(readValue(buffer)!);
      case 173:
        return CoordinateBoundsZoom.decode(readValue(buffer)!);
      case 174:
        return Size.decode(readValue(buffer)!);
      case 175:
        return RenderedQueryOptions.decode(readValue(buffer)!);
      case 176:
        return SourceQueryOptions.decode(readValue(buffer)!);
      case 177:
        return FeatureExtensionValue.decode(readValue(buffer)!);
      case 178:
        return LayerPosition.decode(readValue(buffer)!);
      case 179:
        return QueriedRenderedFeature.decode(readValue(buffer)!);
      case 180:
        return QueriedSourceFeature.decode(readValue(buffer)!);
      case 181:
        return QueriedFeature.decode(readValue(buffer)!);
      case 182:
        return FeaturesetFeatureId.decode(readValue(buffer)!);
      case 183:
        return FeatureState.decode(readValue(buffer)!);
      case 184:
        return Interaction.decode(readValue(buffer)!);
      case 185:
        return FeaturesetDescriptor.decode(readValue(buffer)!);
      case 186:
        return FeaturesetFeature.decode(readValue(buffer)!);
      case 187:
        return FeaturesetQueryTarget.decode(readValue(buffer)!);
      case 188:
        return MapContentGestureContext.decode(readValue(buffer)!);
      case 189:
        return _RenderedQueryGeometry.decode(readValue(buffer)!);
      case 190:
        return ProjectedMeters.decode(readValue(buffer)!);
      case 191:
        return MercatorCoordinate.decode(readValue(buffer)!);
      case 192:
        return StyleObjectInfo.decode(readValue(buffer)!);
      case 193:
        return StyleProjection.decode(readValue(buffer)!);
      case 194:
        return FlatLight.decode(readValue(buffer)!);
      case 195:
        return DirectionalLight.decode(readValue(buffer)!);
      case 196:
        return AmbientLight.decode(readValue(buffer)!);
      case 197:
        return MbxImage.decode(readValue(buffer)!);
      case 198:
        return ImageStretches.decode(readValue(buffer)!);
      case 199:
        return ImageContent.decode(readValue(buffer)!);
      case 200:
        return TransitionOptions.decode(readValue(buffer)!);
      case 201:
        return CanonicalTileID.decode(readValue(buffer)!);
      case 202:
        return StylePropertyValue.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Interface for managing animation.
class _AnimationManager {
  /// Constructor for [_AnimationManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _AnimationManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<void> easeTo(CameraOptions cameraOptions,
      MapAnimationOptions? mapAnimationOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[cameraOptions, mapAnimationOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> flyTo(CameraOptions cameraOptions,
      MapAnimationOptions? mapAnimationOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[cameraOptions, mapAnimationOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> pitchBy(
      double pitch, MapAnimationOptions? mapAnimationOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[pitch, mapAnimationOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> scaleBy(double amount, ScreenCoordinate? screenCoordinate,
      MapAnimationOptions? mapAnimationOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[amount, screenCoordinate, mapAnimationOptions])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> moveBy(ScreenCoordinate screenCoordinate,
      MapAnimationOptions? mapAnimationOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[screenCoordinate, mapAnimationOptions])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> rotateBy(ScreenCoordinate first, ScreenCoordinate second,
      MapAnimationOptions? mapAnimationOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[first, second, mapAnimationOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> cancelCameraAnimation() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Interface for managing camera.
class _CameraManager {
  /// Constructor for [_CameraManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _CameraManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Convenience method that returns a `camera options` object for the given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
  /// If any of the fields in camera options is not provided then the current value from the map for that field will be used.
  /// @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
  /// This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  Future<CameraOptions> cameraForCoordinatesPadding(
      List<Point> coordinates,
      CameraOptions camera,
      MbxEdgeInsets? coordinatesPadding,
      double? maxZoom,
      ScreenCoordinate? offset) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesPadding$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel.send(
            <Object?>[coordinates, camera, coordinatesPadding, maxZoom, offset])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraOptions?)!;
    }
  }

  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param bounds The `coordinate bounds` of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  Future<CameraOptions> cameraForCoordinateBounds(
      CoordinateBounds bounds,
      MbxEdgeInsets? padding,
      double? bearing,
      double? pitch,
      double? maxZoom,
      ScreenCoordinate? offset) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[bounds, padding, bearing, pitch, maxZoom, offset])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraOptions?)!;
    }
  }

  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  Future<CameraOptions> cameraForCoordinates(List<Point> coordinates,
      MbxEdgeInsets? padding, double? bearing, double? pitch) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[coordinates, padding, bearing, pitch])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraOptions?)!;
    }
  }

  /// Convenience method that adjusts the provided `camera options` object for given parameters.
  ///
  /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
  /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
  /// Returns the provided `camera` options object unchanged upon an error.
  /// Note that this method may fail if the principal point of the projection is not inside the `box` or
  /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
  /// @param box The `screen box` into which `coordinates` should fit.
  ///
  /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
  Future<CameraOptions> cameraForCoordinatesCameraOptions(
      List<Point> coordinates, CameraOptions camera, ScreenBox box) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[coordinates, camera, box]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraOptions?)!;
    }
  }

  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param geometry The `geometry` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  Future<CameraOptions> cameraForGeometry(Map<String?, Object?> geometry,
      MbxEdgeInsets padding, double? bearing, double? pitch) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[geometry, padding, bearing, pitch]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraOptions?)!;
    }
  }

  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  Future<CoordinateBounds> coordinateBoundsForCamera(
      CameraOptions camera) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[camera]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CoordinateBounds?)!;
    }
  }

  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  Future<CoordinateBounds> coordinateBoundsForCameraUnwrapped(
      CameraOptions camera) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[camera]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CoordinateBounds?)!;
    }
  }

  /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  Future<CoordinateBoundsZoom> coordinateBoundsZoomForCamera(
      CameraOptions camera) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[camera]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CoordinateBoundsZoom?)!;
    }
  }

  /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  Future<CoordinateBoundsZoom> coordinateBoundsZoomForCameraUnwrapped(
      CameraOptions camera) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[camera]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CoordinateBoundsZoom?)!;
    }
  }

  /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
  /// (i.e., longitude-latitude pair).
  ///
  /// The `screen coordinate` is in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
  ///
  /// @return A `screen coordinate` on the screen in `logical pixels`.
  Future<ScreenCoordinate> pixelForCoordinate(Point coordinate) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[coordinate]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as ScreenCoordinate?)!;
    }
  }

  /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
  /// to a `screen coordinate`.
  ///
  /// The screen coordinate is in `logical pixels`relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
  ///
  /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
  Future<Point> coordinateForPixel(ScreenCoordinate pixel) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[pixel]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Point?)!;
    }
  }

  /// Calculates `screen coordinates` that correspond to geographical `coordinates`
  /// (i.e., longitude-latitude pairs).
  ///
  /// The `screen coordinates` are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
  ///
  /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
  Future<List<ScreenCoordinate?>> pixelsForCoordinates(
      List<Point> coordinates) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[coordinates]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<ScreenCoordinate?>();
    }
  }

  /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
  /// to `screen coordinates`.
  ///
  /// The screen coordinates are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixels A `screen coordinates` in `logical pixels`.
  ///
  /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
  Future<List<Point>> coordinatesForPixels(
      List<ScreenCoordinate?> pixels) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[pixels]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!.cast<Point>();
    }
  }

  /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
  /// The map will retain its current values for any details not passed via the camera options argument.
  /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
  /// different `camera state`.
  ///
  /// @param cameraOptions The new `camera options` to be set.
  Future<void> setCamera(CameraOptions cameraOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[cameraOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the current `camera state`.
  ///
  /// @return The current `camera state`.
  Future<CameraState> getCameraState() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraState?)!;
    }
  }

  /// Sets the `camera bounds options` of the map. The map will retain its current values for any
  /// details not passed via the camera bounds options arguments.
  /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
  /// zoom level of the camera, to prevent out of bounds areas to be visible.
  /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
  ///
  /// @param options The `camera bounds options` to set.
  /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
  Future<void> setBounds(CameraBoundsOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the `camera bounds` of the map.
  /// @return A `camera bounds` of the map.
  Future<CameraBounds> getBounds() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraBounds?)!;
    }
  }
}

abstract class InteractionsListener {
  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  void onInteraction(MapContentGestureContext context,
      FeaturesetFeature feature, int interactionID);

  static void setUp(
    InteractionsListener? api, {
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) {
    messageChannelSuffix =
        messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
    {
      final BasicMessageChannel<
          Object?> pigeonVar_channel = BasicMessageChannel<
              Object?>(
          'dev.flutter.pigeon.mapbox_maps_flutter.InteractionsListener.onInteraction$messageChannelSuffix',
          pigeonChannelCodec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        pigeonVar_channel.setMessageHandler(null);
      } else {
        pigeonVar_channel.setMessageHandler((Object? message) async {
          assert(message != null,
              'Argument for dev.flutter.pigeon.mapbox_maps_flutter.InteractionsListener.onInteraction was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final MapContentGestureContext? arg_context =
              (args[0] as MapContentGestureContext?);
          assert(arg_context != null,
              'Argument for dev.flutter.pigeon.mapbox_maps_flutter.InteractionsListener.onInteraction was null, expected non-null MapContentGestureContext.');
          final FeaturesetFeature? arg_feature =
              (args[1] as FeaturesetFeature?);
          assert(arg_feature != null,
              'Argument for dev.flutter.pigeon.mapbox_maps_flutter.InteractionsListener.onInteraction was null, expected non-null FeaturesetFeature.');
          final int? arg_interactionID = (args[2] as int?);
          assert(arg_interactionID != null,
              'Argument for dev.flutter.pigeon.mapbox_maps_flutter.InteractionsListener.onInteraction was null, expected non-null int.');
          try {
            api.onInteraction(arg_context!, arg_feature!, arg_interactionID!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          } catch (e) {
            return wrapResponse(
                error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

/// Map class provides map rendering functionality.
///
class _MapInterface {
  /// Constructor for [_MapInterface].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _MapInterface(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<void> loadStyleURI(String styleURI) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[styleURI]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> loadStyleJson(String styleJson) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[styleJson]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clearData() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setTileCacheBudget(
      TileCacheBudgetInMegabytes? tileCacheBudgetInMegabytes,
      TileCacheBudgetInTiles? tileCacheBudgetInTiles) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setTileCacheBudget$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[tileCacheBudgetInMegabytes, tileCacheBudgetInTiles])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the size of the map.
  ///
  /// @return The `size` of the map in `logical pixels`.
  Future<Size> getSize() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Size?)!;
    }
  }

  /// Triggers a repaint of the map.
  Future<void> triggerRepaint() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Tells the map rendering engine that there is currently a gesture in progress. This
  /// affects how the map renders labels, as it will use different texture filters if a gesture
  /// is ongoing.
  ///
  /// @param inProgress The `boolean` value representing if a gesture is in progress.
  Future<void> setGestureInProgress(bool inProgress) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[inProgress]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns `true` if a gesture is currently in progress.
  ///
  /// @return `true` if a gesture is currently in progress, `false` otherwise.
  Future<bool> isGestureInProgress() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Tells the map rendering engine that the animation is currently performed by the
  /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
  /// In particular, it brings more stability to symbol placement and rendering.
  ///
  /// @param inProgress The `boolean` value representing if user animation is in progress
  Future<void> setUserAnimationInProgress(bool inProgress) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[inProgress]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns `true` if user animation is currently in progress.
  ///
  /// @return `true` if a user animation is currently in progress, `false` otherwise.
  Future<bool> isUserAnimationInProgress() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
  /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
  /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
  ///
  /// @param delta The new prefetch zoom delta.
  Future<void> setPrefetchZoomDelta(int delta) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[delta]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the map's prefetch zoom delta.
  ///
  /// @return The map's prefetch zoom `delta`.
  Future<int> getPrefetchZoomDelta() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as int?)!;
    }
  }

  /// Sets the north `orientation mode`.
  Future<void> setNorthOrientation(NorthOrientation orientation) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[orientation]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Sets the map `constrain mode`.
  Future<void> setConstrainMode(ConstrainMode mode) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[mode]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Sets the `viewport mode`.
  Future<void> setViewportMode(ViewportMode mode) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[mode]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the `map options`.
  ///
  /// @return The map's `map options`.
  Future<MapOptions> getMapOptions() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as MapOptions?)!;
    }
  }

  Future<List<_MapWidgetDebugOptions>> getDebugOptions() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebugOptions$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<_MapWidgetDebugOptions>();
    }
  }

  Future<void> setDebugOptions(
      List<_MapWidgetDebugOptions> debugOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebugOptions$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[debugOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the `map debug options`.
  ///
  /// @return An array of `map debug options` flags currently set to the map.
  @Deprecated("Use [MapboxMap.debugOptions] instead")
  Future<List<MapDebugOptions?>> getDebug() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<MapDebugOptions?>();
    }
  }

  /// Sets the `map debug options` and enables debug mode based on the passed value.
  ///
  /// @param debugOptions An array of `map debug options` to be set.
  /// @param value A `boolean` value representing the state for a given `map debug options`.
  ///
  @Deprecated("Use [MapboxMap.debugOptions] instead")
  Future<void> setDebug(List<MapDebugOptions?> debugOptions, bool value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[debugOptions, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Queries the map for rendered features.
  ///
  /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
  /// @param options The `render query options` for querying rendered features.
  /// @param completion The `query features completion` called when the query completes.
  /// @return A `cancelable` object that could be used to cancel the pending query.
  Future<List<QueriedRenderedFeature?>> queryRenderedFeatures(
      _RenderedQueryGeometry geometry, RenderedQueryOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[geometry, options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<QueriedRenderedFeature?>();
    }
  }

  /// Queries the map for rendered features with one typed featureset.
  ///
  /// The results array will contain features of the type specified by this featureset.
  ///
  /// - Important: If you need to handle basic gestures on map content,
  /// please prefer to use Interactions API, see `MapboxMap/addInteraction`.
  ///
  /// @param featureset A typed featureset to query with.
  /// @param geometry An optional screen geometry to query. Can be a `CGPoint`, `CGRect`, or an array of `CGPoint`.
  /// If omitted, the full viewport is queried.
  /// @param filter An additional filter for features.
  Future<List<FeaturesetFeature>> queryRenderedFeaturesForFeatureset(
      FeaturesetDescriptor featureset,
      _RenderedQueryGeometry? geometry,
      String? filter) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeaturesForFeatureset$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[featureset, geometry, filter]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<FeaturesetFeature>();
    }
  }

  /// Queries the map for source features.
  ///
  /// @param sourceId The style source identifier used to query for source features.
  /// @param options The `source query options` for querying source features.
  /// @param completion The `query features completion` called when the query completes.
  Future<List<QueriedSourceFeature?>> querySourceFeatures(
      String sourceId, SourceQueryOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<QueriedSourceFeature?>();
    }
  }

  /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
  /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster Cluster from which to retrieve leaves from
  /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
  /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  Future<FeatureExtensionValue> getGeoJsonClusterLeaves(String sourceIdentifier,
      Map<String?, Object?> cluster, int? limit, int? offset) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[sourceIdentifier, cluster, limit, offset])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FeatureExtensionValue?)!;
    }
  }

  /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
  /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve children from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  Future<FeatureExtensionValue> getGeoJsonClusterChildren(
      String sourceIdentifier, Map<String?, Object?> cluster) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceIdentifier, cluster]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FeatureExtensionValue?)!;
    }
  }

  /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
  /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve the expansion zoom from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
  Future<FeatureExtensionValue> getGeoJsonClusterExpansionZoom(
      String sourceIdentifier, Map<String?, Object?> cluster) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceIdentifier, cluster]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as FeatureExtensionValue?)!;
    }
  }

  /// Updates the state object of a feature within a style source.
  ///
  /// Update entries in the `state` object of a given feature within a style source. Only properties of the
  /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
  /// retain its previous value.
  ///
  /// Note that updates to feature `state` are asynchronous, so changes made by this method might not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be updated.
  /// @param state The `state` object with properties to update with their respective new values.
  Future<void> setFeatureState(String sourceId, String? sourceLayerId,
      String featureId, String state) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[sourceId, sourceLayerId, featureId, state])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Update the state map of a feature within a featureset.
  /// Update entries in the state map of a given feature within a style source. Only entries listed in the state map
  /// will be updated. An entry in the feature state map that is not listed in `state` will retain its previous value.
  ///
  /// @param featureset The featureset to look the feature in.
  /// @param featureId Identifier of the feature whose state should be updated.
  /// @param state Map of entries to update with their respective new values
  Future<void> setFeatureStateForFeaturesetDescriptor(
      FeaturesetDescriptor featureset,
      FeaturesetFeatureId featureId,
      Map<String, Object?> state) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureStateForFeaturesetDescriptor$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[featureset, featureId, state]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Update the state map of an individual feature.
  ///
  /// The feature should have a non-nil ``FeaturesetFeatureType/id``. Otherwise,
  /// the operation will be no-op and callback will receive an error.
  ///
  /// @param feature The feature to update.
  /// @param state Map of entries to update with their respective new values
  Future<void> setFeatureStateForFeaturesetFeature(
      FeaturesetFeature feature, Map<String, Object?> state) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureStateForFeaturesetFeature$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[feature, state]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the state map of a feature within a style source.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
  /// immediately visible.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be queried.
  ///
  /// @return A String representing the Feature's state map.
  Future<String> getFeatureState(
      String sourceId, String? sourceLayerId, String featureId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, sourceLayerId, featureId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Get the state map of a feature within a style source.
  ///
  /// @param featureset A featureset the feature belongs to.
  /// @param featureId Identifier of the feature whose state should be queried.
  ///
  /// @return  The Feature's state map or an empty map if the feature could not be found.
  Future<Map<String, Object?>> getFeatureStateForFeaturesetDescriptor(
      FeaturesetDescriptor featureset, FeaturesetFeatureId featureId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureStateForFeaturesetDescriptor$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[featureset, featureId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, Object?>();
    }
  }

  /// Get the state map of a feature within a style source.
  ///
  /// @param feature An interactive feature to query the state of.
  ///
  /// @return  The Feature's state map or an empty map if the feature could not be found.
  Future<Map<String, Object?>> getFeatureStateForFeaturesetFeature(
      FeaturesetFeature feature) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureStateForFeaturesetFeature$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[feature]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, Object?>();
    }
  }

  /// Removes entries from a feature state object.
  ///
  /// Remove a specified property or all property from a feature's state object, depending on the value of
  /// `stateKey`.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method might not be
  /// immediately visible using `getFeatureState`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
  Future<void> removeFeatureState(String sourceId, String? sourceLayerId,
      String featureId, String? stateKey) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
            .send(<Object?>[sourceId, sourceLayerId, featureId, stateKey])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Removes entries from a feature state object of a feature in the specified featureset.
  /// Remove a specified property or all property from a feature's state object, depending on the value of `stateKey`.
  ///
  /// @param featureset A featureset the feature belongs to.
  /// @param featureId Identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `nil`, all feature's state object properties are removed. Defaults to `nil`.
  Future<void> removeFeatureStateForFeaturesetDescriptor(
      FeaturesetDescriptor featureset,
      FeaturesetFeatureId featureId,
      String? stateKey) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureStateForFeaturesetDescriptor$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[featureset, featureId, stateKey]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Removes entries from a specified Feature.
  /// Remove a specified property or all property from a feature's state object, depending on the value of `stateKey`.
  ///
  /// @param feature An interactive feature to update.
  /// @param stateKey The key of the property to remove. If `nil`, all feature's state object properties are removed. Defaults to `nil`.
  Future<void> removeFeatureStateForFeaturesetFeature(
      FeaturesetFeature feature, String? stateKey) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureStateForFeaturesetFeature$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[feature, stateKey]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Reset all the feature states within a featureset.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method might not be
  /// immediately visible using ``MapboxMap/getFeatureState()``.
  ///
  /// @param featureset A featureset descriptor
  Future<void> resetFeatureStatesForFeatureset(
      FeaturesetDescriptor featureset) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.resetFeatureStatesForFeatureset$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[featureset]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Reduces memory use. Useful to call when the application gets paused or sent to background.
  Future<void> reduceMemoryUse() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate The `coordinate` defined as longitude-latitude pair.
  /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  Future<double?> getElevation(Point coordinate) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[coordinate]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as double?);
    }
  }

  /// Returns array of tile identifiers that cover current map camera.
  Future<List<CanonicalTileID>> tileCover(TileCoverOptions options) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.tileCover$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[options]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<CanonicalTileID>();
    }
  }

  /// Set whether legacy mode should be used for [snapshot].
  ///
  /// Legacy mode is not that efficient (as it blocks map rendering when making the snapshot)
  /// but may help with vendor specific issues like described in
  /// https://github.com/mapbox/mapbox-maps-android/issues/2280.
  ///
  /// Note: This method has no effect on iOS platform.
  Future<void> setSnapshotLegacyMode(bool enabled) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setSnapshotLegacyMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[enabled]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// The URL that points to the glyphs used by the style for rendering text labels on the map.
  ///
  /// This property allows setting a custom glyph URL at runtime, making it easier to
  /// apply custom fonts to the map without modifying the base style.
  Future<String> styleGlyphURL() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.styleGlyphURL$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// The URL that points to the glyphs used by the style for rendering text labels on the map.
  ///
  /// This property allows setting a custom glyph URL at runtime, making it easier to
  /// apply custom fonts to the map without modifying the base style.
  Future<void> setStyleGlyphURL(String glyphURL) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setStyleGlyphURL$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[glyphURL]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Collection of [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection methods.
class Projection {
  /// Constructor for [Projection].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Projection(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Calculate distance spanned by one pixel at the specified latitude
  /// and zoom level.
  ///
  /// @param latitude The latitude for which to return the value.
  /// @param zoom The zoom level.
  ///
  /// @return Returns the distance measured in meters.
  Future<double> getMetersPerPixelAtLatitude(
      double latitude, double zoom) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[latitude, zoom]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as double?)!;
    }
  }

  /// Calculate Spherical Mercator ProjectedMeters coordinates.
  ///
  /// @param coordinate A longitude-latitude pair for which to calculate
  /// `projected meters` coordinates.
  ///
  /// @return Returns Spherical Mercator ProjectedMeters coordinates.
  Future<ProjectedMeters> projectedMetersForCoordinate(Point coordinate) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[coordinate]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as ProjectedMeters?)!;
    }
  }

  /// Calculate a longitude-latitude pair for a Spherical Mercator projected
  /// meters.
  ///
  /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
  /// which to calculate a longitude-latitude pair.
  ///
  /// @return Returns a longitude-latitude pair.
  Future<Point> coordinateForProjectedMeters(
      ProjectedMeters projectedMeters) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[projectedMeters]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Point?)!;
    }
  }

  /// Calculate a point on the map in Mercator Projection for a given
  /// coordinate at the specified zoom scale.
  ///
  /// @param coordinate The longitude-latitude pair for which to return the value.
  /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a point on the map in Mercator projection.
  Future<MercatorCoordinate> project(Point coordinate, double zoomScale) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Projection.project$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[coordinate, zoomScale]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as MercatorCoordinate?)!;
    }
  }

  /// Calculate a coordinate for a given point on the map in Mercator Projection.
  ///
  /// @param coordinate Point on the map in Mercator projection.
  /// @param zoomScale The current zoom factor applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a coordinate.
  Future<Point> unproject(
      MercatorCoordinate coordinate, double zoomScale) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[coordinate, zoomScale]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Point?)!;
    }
  }
}

class _MapboxOptions {
  /// Constructor for [_MapboxOptions].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _MapboxOptions(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<String> getAccessToken() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.getAccessToken$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> setAccessToken(String token) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.setAccessToken$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[token]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

class _MapboxMapsOptions {
  /// Constructor for [_MapboxMapsOptions].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  _MapboxMapsOptions(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  Future<String> getBaseUrl() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getBaseUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> setBaseUrl(String url) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setBaseUrl$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[url]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> getDataPath() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getDataPath$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> setDataPath(String path) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setDataPath$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[path]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String> getAssetPath() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getAssetPath$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  Future<void> setAssetPath(String path) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setAssetPath$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[path]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String?> getFlutterAssetPath(String? flutterAssetUri) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getFlutterAssetPath$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[flutterAssetUri]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<TileStoreUsageMode> getTileStoreUsageMode() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getTileStoreUsageMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as TileStoreUsageMode?)!;
    }
  }

  Future<void> setTileStoreUsageMode(TileStoreUsageMode mode) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setTileStoreUsageMode$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[mode]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String?> getWorldview() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getWorldview$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<void> setWorldview(String? worldview) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setWorldview$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[worldview]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<String?> getLanguage() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getLanguage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as String?);
    }
  }

  Future<void> setLanguage(String? language) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setLanguage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[language]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> clearData() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.clearData$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}

/// Settings class provides non-persistent, in-process key-value storage.
class Settings {
  /// Constructor for [Settings].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Settings({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Sets setting value for a specified key.
  ///
  /// @param key A name of the key.
  /// @param value The `value` for the key.
  Future<void> set(String key, String value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Settings.set$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[key, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Return value for a key.
  ///
  /// @param key A name of the key.
  ///
  /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
  Future<String> get(String key) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Settings.get$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[key]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }
}

/// Interface for managing style of the `map`.
class StyleManager {
  /// Constructor for [StyleManager].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  StyleManager(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Get the URI of the current style in use.
  ///
  /// @return A string containing a style URI.
  Future<String> getStyleURI() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Load style from provided URI.
  ///
  /// This is an asynchronous call. To check the result of this operation the user must register an observer observing
  /// `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
  ///
  /// @param uri URI where the style should be loaded from.
  Future<void> setStyleURI(String uri) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[uri]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Get the JSON serialization string of the current style in use.
  ///
  /// @return A JSON string containing a serialized style.
  Future<String> getStyleJSON() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Load the style from a provided JSON string.
  ///
  /// @param json A JSON string containing a serialized style.
  Future<void> setStyleJSON(String json) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[json]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the map style's default camera, if any, or a default camera otherwise.
  /// The map style's default camera is defined as follows:
  /// - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
  /// - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
  /// - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
  /// - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
  ///
  /// The style default camera is re-evaluated when a new style is loaded.
  ///
  /// @return The default `camera options` of the current style in use.
  Future<CameraOptions> getStyleDefaultCamera() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CameraOptions?)!;
    }
  }

  /// Returns the map style's transition options. By default, the style parser will attempt
  /// to read the style default transition options, if any, fallbacking to an immediate transition
  /// otherwise. Transition options can be overridden via `setStyleTransition`, but the options are
  /// reset once a new style has been loaded.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @return The `transition options` of the current style in use.
  Future<TransitionOptions> getStyleTransition() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as TransitionOptions?)!;
    }
  }

  /// Returns the list containing information about existing style import objects.
  Future<List<StyleObjectInfo?>> getStyleImports() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImports$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<StyleObjectInfo?>();
    }
  }

  /// Removes an existing style import.
  ///
  /// @param importId Identifier of the style import to remove.
  Future<void> removeStyleImport(String importId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImport$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[importId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the style import schema.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import schema, containing the default configurations for the style import.
  Future<Object> getStyleImportSchema(String importId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportSchema$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[importId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return pigeonVar_replyList[0]!;
    }
  }

  /// Gets style import config.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  Future<Map<String, StylePropertyValue>> getStyleImportConfigProperties(
      String importId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[importId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as Map<Object?, Object?>?)!
          .cast<String, StylePropertyValue>();
    }
  }

  /// Gets the value of style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  Future<StylePropertyValue> getStyleImportConfigProperty(
      String importId, String config) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[importId, config]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StylePropertyValue?)!;
    }
  }

  /// Sets style import config.
  /// This method can be used to perform batch update for a style import configurations.
  ///
  /// @param importId Identifier of the style import.
  /// @param configs A map of style import configurations.
  Future<void> setStyleImportConfigProperties(
      String importId, Map<String, Object> configs) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[importId, configs]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Sets a value to a style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  /// @param value The style import config value.
  Future<void> setStyleImportConfigProperty(
      String importId, String config, Object value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[importId, config, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Overrides the map style's transition options with user-provided options.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @param transitionOptions The `transition options`.
  Future<void> setStyleTransition(TransitionOptions transitionOptions) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[transitionOptions]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Runtime style layers are valid until they are either removed or a new style is loaded.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  Future<void> addStyleLayer(
      String properties, LayerPosition? layerPosition) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[properties, layerPosition]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Whenever a new style is being parsed and currently used style has persistent layers,
  /// an engine will try to do following:
  ///   - keep the persistent layer at its relative position
  ///   - keep the source used by a persistent layer
  ///   - keep images added through `addStyleImage` method
  ///
  /// In cases when a new style has the same layer, source or image resource, style's resources would be
  /// used instead and `MapLoadingError` event will be emitted.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  Future<void> addPersistentStyleLayer(
      String properties, LayerPosition? layerPosition) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[properties, layerPosition]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Checks if a style layer is persistent.
  ///
  /// @param layerId A style layer identifier.
  /// @return A string describing an error if the operation was not successful, boolean representing state otherwise.
  Future<bool> isStyleLayerPersistent(String layerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[layerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Removes an existing style layer.
  ///
  /// @param layerId An identifier of the style layer to remove.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  Future<void> removeStyleLayer(String layerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[layerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Moves an existing style layer
  ///
  /// @param layerId Identifier of the style layer to move.
  /// @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
  ///                      is provided then the layer is moved to the top of the layerstack.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  Future<void> moveStyleLayer(
      String layerId, LayerPosition? layerPosition) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[layerId, layerPosition]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Checks whether a given style layer exists.
  ///
  /// @param layerId Style layer identifier.
  ///
  /// @return A `true` value if the given style layer exists, `false` otherwise.
  Future<bool> styleLayerExists(String layerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[layerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Returns the existing style layers.
  ///
  /// @return The list containing the information about existing style layer objects.
  Future<List<StyleObjectInfo?>> getStyleLayers() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<StyleObjectInfo?>();
    }
  }

  /// Gets the value of style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @return The `style property value`.
  Future<StylePropertyValue> getStyleLayerProperty(
      String layerId, String property) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[layerId, property]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StylePropertyValue?)!;
    }
  }

  /// Sets a value to a style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @param value The style layer property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleLayerProperty(
      String layerId, String property, Object value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[layerId, property, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets style layer properties.
  ///
  /// @return The style layer properties or a string describing an error if the operation was not successful.
  Future<String> getStyleLayerProperties(String layerId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[layerId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Sets style layer properties.
  /// This method can be used to perform batch update for a style layer properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
  /// Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
  ///
  /// @param layerId A style layer identifier.
  /// @param properties A map of style layer properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleLayerProperties(
      String layerId, String properties) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[layerId, properties]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
  ///
  /// @param sourceId An identifier for the style source.
  /// @param properties A map of style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> addStyleSource(String sourceId, String properties) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, properties]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the value of style source property.
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @return The value of a `property` in the source with a `sourceId`.
  Future<StylePropertyValue> getStyleSourceProperty(
      String sourceId, String property) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, property]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StylePropertyValue?)!;
    }
  }

  /// Sets a value to a style source property.
  /// Note: When setting the `data` property of a `geojson` source, this method never returns an error.
  /// In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
  ///
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @param value The style source property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleSourceProperty(
      String sourceId, String property, Object value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, property, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets style source properties.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return The style source properties or a string describing an error if the operation was not successful.
  Future<String> getStyleSourceProperties(String sourceId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[sourceId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as String?)!;
    }
  }

  /// Sets style source properties.
  ///
  /// This method can be used to perform batch update for a style source properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
  /// Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
  ///
  /// @param sourceId A style source identifier.
  /// @param properties A map of Style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleSourceProperties(
      String sourceId, String properties) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, properties]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Add additional features to a GeoJSON style source.
  ///
  /// The add operation will be scheduled and applied on a GeoJSON serialization queue.
  ///
  /// In order to capture events when actual data is drawn on the map please refer to Events API
  /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
  /// or `onMapLoadingError` with `type = metadata` if data parsing error has occurred.
  ///
  /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
  /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
  /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
  /// in a `map-loading-error`.
  ///
  /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
  /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
  /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
  /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
  /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
  /// call, the data ID in the `source-data-loaded`event will be null.
  ///
  /// @param sourceId The identifier of the style source.
  /// @param dataId An arbitrary string used to track the given GeoJSON data.
  /// @param features An array of GeoJSON features to be added to the source.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> addGeoJSONSourceFeatures(
      String sourceId, String dataId, List<Feature> features) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addGeoJSONSourceFeatures$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, dataId, features]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Update existing features in a GeoJSON style source.
  ///
  /// The update operation will be scheduled and applied on a GeoJSON serialization queue.
  ///
  /// In order to capture events when actual data is drawn on the map please refer to Events API
  /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
  /// or `onMapLoadingError` with `type = metadata` if data parsing error has occurred.
  ///
  /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
  /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
  /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
  /// in a `map-loading-error`.
  ///
  /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
  /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
  /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
  /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
  /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
  /// call, the data ID in the `source-data-loaded`event will be null.
  ///
  /// @param sourceId A style source identifier.
  /// @param dataId An arbitrary string used to track the given GeoJSON data.
  /// @param features The GeoJSON features to be updated in the source.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> updateGeoJSONSourceFeatures(
      String sourceId, String dataId, List<Feature> features) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateGeoJSONSourceFeatures$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, dataId, features]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Remove features from a GeoJSON style source.
  ///
  /// The remove operation will be scheduled and applied on a GeoJSON serialization queue.
  ///
  /// In order to capture events when actual data is drawn on the map please refer to Events API
  /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
  /// or `onMapLoadingError` with `type = metadata` if an error has occurred.
  ///
  /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
  /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
  /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
  /// in a `map-loading-error`.
  ///
  /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
  /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
  /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
  /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
  /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
  /// call, the data ID in the `source-data-loaded`event will be null.
  ///
  /// @param sourceId A style source identifier.
  /// @param dataId An arbitrary string used to track the given GeoJSON data.
  /// @param featureIds The Ids of the features that need to be removed from the source.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> removeGeoJSONSourceFeatures(
      String sourceId, String dataId, List<String> featureIds) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeGeoJSONSourceFeatures$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, dataId, featureIds]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
  ///
  /// @param sourceId A style source identifier.
  /// @param image An `image`.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> updateStyleImageSourceImage(
      String sourceId, MbxImage image) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, image]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Removes an existing style source.
  ///
  /// @param sourceId An identifier of the style source to remove.
  Future<void> removeStyleSource(String sourceId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[sourceId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Checks whether a given style source exists.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return `true` if the given source exists, `false` otherwise.
  Future<bool> styleSourceExists(String sourceId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[sourceId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Returns the existing style sources.
  ///
  /// @return The list containing the information about existing style source objects.
  Future<List<StyleObjectInfo?>> getStyleSources() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<StyleObjectInfo?>();
    }
  }

  /// Returns an ordered list of the current style lights.
  Future<List<StyleObjectInfo?>> getStyleLights() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLights$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<StyleObjectInfo?>();
    }
  }

  /// Set global directional lightning.
  ///
  /// @param flatLight The flat light source.
  Future<void> setLight(FlatLight flatLight) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLight$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[flatLight]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Set dynamic lightning.
  ///
  /// @param ambientLight The ambient light source.
  /// @param directionalLight The directional light source.
  Future<void> setLights(
      AmbientLight ambientLight, DirectionalLight directionalLight) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLights$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[ambientLight, directionalLight]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the value of a style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @return The style light property value.
  Future<StylePropertyValue> getStyleLightProperty(
      String id, String property) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[id, property]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StylePropertyValue?)!;
    }
  }

  /// Sets a value to the the style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @param value The style light property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleLightProperty(
      String id, String property, Object value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[id, property, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
  ///
  /// @param properties A map of style terrain properties values, with their names as a key.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleTerrain(String properties) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[properties]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Gets the value of a style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @return The style terrain property value.
  Future<StylePropertyValue> getStyleTerrainProperty(String property) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[property]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as StylePropertyValue?)!;
    }
  }

  /// Sets a value to the the style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @param value The style terrain property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> setStyleTerrainProperty(String property, Object value) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[property, value]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Get an `image` from the style.
  ///
  /// @param imageId The identifier of the `image`.
  ///
  /// @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
  Future<MbxImage?> getStyleImage(String imageId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imageId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as MbxImage?);
    }
  }

  /// Adds an image to be used in the style. This API can also be used for updating
  /// an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
  ///
  /// The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
  /// [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
  /// [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
  /// [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
  ///
  /// @param imageId An identifier of the image.
  /// @param scale A scale factor for the image.
  /// @param image A pixel data of the image.
  /// @param sdf An option to treat whether image is SDF(signed distance field) or not.
  /// @param stretchX An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched horizontally.
  /// @param stretchY An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched vertically.
  /// @param content An array of four numbers, with the first two specifying the left, top
  /// corner, and the last two specifying the right, bottom corner. If present, and if the
  /// icon uses icon-text-fit, the symbol's text will be fit inside the content box.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> addStyleImage(
      String imageId,
      double scale,
      MbxImage image,
      bool sdf,
      List<ImageStretches?> stretchX,
      List<ImageStretches?> stretchY,
      ImageContent? content) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel.send(
            <Object?>[imageId, scale, image, sdf, stretchX, stretchY, content])
        as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Removes an image from the style.
  ///
  /// @param imageId The identifier of the image to remove.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> removeStyleImage(String imageId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imageId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Checks whether an image exists.
  ///
  /// @param imageId The identifier of the image.
  ///
  /// @return True if image exists, false otherwise.
  Future<bool> hasStyleImage(String imageId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[imageId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Adds a model to be used in the style. This API can also be used for updating
  /// a model. If the model for a given `modelId` was already added, it gets replaced by the new model.
  ///
  /// The model can be used in `model-id` property in model layer.
  ///
  /// @param modelId An identifier of the model.
  /// @param modelUri A URI for the model.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> addStyleModel(String modelId, String modelUri) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleModel$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[modelId, modelUri]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Removes a model from the style.
  ///
  /// @param modelId The identifier of the model to remove.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> removeStyleModel(String modelId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleModel$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[modelId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Set tile data of a custom geometry.
  ///
  /// @param sourceId A style source identifier.
  /// @param tileId A `canonical tile id` of the tile.
  /// @param featureCollection An array with the features to add.
  /// Invalidate tile for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier,.
  /// @param tileId A `canonical tile id` of the tile.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> invalidateStyleCustomGeometrySourceTile(
      String sourceId, CanonicalTileID tileId) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, tileId]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Invalidate region for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier
  /// @param bounds A `coordinate bounds` object.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  Future<void> invalidateStyleCustomGeometrySourceRegion(
      String sourceId, CoordinateBounds bounds) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[sourceId, bounds]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Check if the style is completely loaded.
  ///
  /// Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
  /// Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
  ///
  /// @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
  ///
  Future<bool> isStyleLoaded() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as bool?)!;
    }
  }

  /// Function to get the projection provided by the Style Extension.
  ///
  /// @return Projection that is currently applied to the map
  Future<StyleProjection?> getProjection() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return (pigeonVar_replyList[0] as StyleProjection?);
    }
  }

  /// Function to set the projection provided by the Style Extension.
  ///
  /// @param projection The projection to be set.
  Future<void> setProjection(StyleProjection projection) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(<Object?>[projection]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Function to localize style labels.
  ///
  /// @param locale The locale to apply for localization
  /// @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
  Future<void> localizeLabels(String locale, List<String>? layerIds) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList = await pigeonVar_channel
        .send(<Object?>[locale, layerIds]) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }

  /// Returns the available featuresets in the currently loaded style.
  ///
  /// - Note: This function should only be called after the style is fully loaded; otherwise, the result may be unreliable.
  Future<List<FeaturesetDescriptor>> getFeaturesets() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getFeaturesets$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as List<Object?>?)!
          .cast<FeaturesetDescriptor>();
    }
  }
}

/// Allows to cancel the associated asynchronous operation
///
/// The the associated asynchronous operation is not automatically canceled if this
/// object goes out of scope.
class Cancelable {
  /// Constructor for [Cancelable].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  Cancelable(
      {BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
      : pigeonVar_binaryMessenger = binaryMessenger,
        pigeonVar_messageChannelSuffix =
            messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec =
      MapInterfaces_PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Cancels the associated asynchronous operation
  ///
  /// If the associated asynchronous operation has already finished, this call is ignored.
  Future<void> cancel() async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
      pigeonVar_channelName,
      pigeonChannelCodec,
      binaryMessenger: pigeonVar_binaryMessenger,
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_channel.send(null) as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else {
      return;
    }
  }
}
