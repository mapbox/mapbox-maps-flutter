// Autogenerated from Pigeon (v25.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

part of mapbox_maps_flutter_interface;

/// Describes the coordinate on the screen, measured from top to bottom and from left to right.
/// Note: the `map` uses screen coordinate units measured in `logical pixels`.
class ScreenCoordinate {
  ScreenCoordinate({
    required this.x,
    required this.y,
  });

  /// A value representing the x position of this coordinate.
  double x;

  /// A value representing the y position of this coordinate.
  double y;

  List<Object?> _toList() {
    return <Object?>[
      x,
      y,
    ];
  }

  Object encode() {
    return _toList();
  }

  static ScreenCoordinate decode(Object result) {
    result as List<Object?>;
    return ScreenCoordinate(
      x: result[0]! as double,
      y: result[1]! as double,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! ScreenCoordinate || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return x == other.x && y == other.y;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// The distance on each side between rectangles, when one is contained into other.
///
/// All fields' values are in `logical pixel` units.
class MbxEdgeInsets {
  MbxEdgeInsets({
    required this.top,
    required this.left,
    required this.bottom,
    required this.right,
  });

  /// Padding from the top.
  double top;

  /// Padding from the left.
  double left;

  /// Padding from the bottom.
  double bottom;

  /// Padding from the right.
  double right;

  List<Object?> _toList() {
    return <Object?>[
      top,
      left,
      bottom,
      right,
    ];
  }

  Object encode() {
    return _toList();
  }

  static MbxEdgeInsets decode(Object result) {
    result as List<Object?>;
    return MbxEdgeInsets(
      top: result[0]! as double,
      left: result[1]! as double,
      bottom: result[2]! as double,
      right: result[3]! as double,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! MbxEdgeInsets || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return top == other.top &&
        left == other.left &&
        bottom == other.bottom &&
        right == other.right;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Various options for describing the viewpoint of a camera. All fields are
/// optional.
///
/// Anchor and center points are mutually exclusive, with preference for the
/// center point when both are set.
class CameraOptions {
  CameraOptions({
    this.center,
    this.padding,
    this.anchor,
    this.zoom,
    this.bearing,
    this.pitch,
  });

  /// Coordinate at the center of the camera.
  Point? center;

  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  MbxEdgeInsets? padding;

  /// Point of reference for `zoom` and `angle`, assuming an origin at the
  /// top-left corner of the view.
  ScreenCoordinate? anchor;

  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  double? zoom;

  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  double? bearing;

  /// Pitch toward the horizon measured in degrees.
  double? pitch;

  List<Object?> _toList() {
    return <Object?>[
      center,
      padding,
      anchor,
      zoom,
      bearing,
      pitch,
    ];
  }

  Object encode() {
    return _toList();
  }

  static CameraOptions decode(Object result) {
    result as List<Object?>;
    return CameraOptions(
      center: result[0] as Point?,
      padding: result[1] as MbxEdgeInsets?,
      anchor: result[2] as ScreenCoordinate?,
      zoom: result[3] as double?,
      bearing: result[4] as double?,
      pitch: result[5] as double?,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CameraOptions || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return center == other.center &&
        padding == other.padding &&
        anchor == other.anchor &&
        zoom == other.zoom &&
        bearing == other.bearing &&
        pitch == other.pitch;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Describes the viewpoint of a camera.
class CameraState {
  CameraState({
    required this.center,
    required this.padding,
    required this.zoom,
    required this.bearing,
    required this.pitch,
  });

  /// Coordinate at the center of the camera.
  Point center;

  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  MbxEdgeInsets padding;

  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  double zoom;

  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  double bearing;

  /// Pitch toward the horizon measured in degrees.
  double pitch;

  List<Object?> _toList() {
    return <Object?>[
      center,
      padding,
      zoom,
      bearing,
      pitch,
    ];
  }

  Object encode() {
    return _toList();
  }

  static CameraState decode(Object result) {
    result as List<Object?>;
    return CameraState(
      center: result[0]! as Point,
      padding: result[1]! as MbxEdgeInsets,
      zoom: result[2]! as double,
      bearing: result[3]! as double,
      pitch: result[4]! as double,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CameraState || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return center == other.center &&
        padding == other.padding &&
        zoom == other.zoom &&
        bearing == other.bearing &&
        pitch == other.pitch;
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}
