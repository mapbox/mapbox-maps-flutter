// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.mapbox_maps.pigeons

import android.util.Log
import com.mapbox.geojson.Point
import com.mapbox.maps.mapbox_maps.mapping.turf.*
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError(
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Describes glyphs rasterization modes. */
enum class GlyphsRasterizationMode(val raw: Int) {
  /** No glyphs are rasterized locally. All glyphs are loaded from the server. */
  NO_GLYPHS_RASTERIZED_LOCALLY(0),
  /** Ideographs are rasterized locally, and they are not loaded from the server. */
  IDEOGRAPHS_RASTERIZED_LOCALLY(1),
  /** All glyphs are rasterized locally. No glyphs are loaded from the server. */
  ALL_GLYPHS_RASTERIZED_LOCALLY(2);

  companion object {
    fun ofRaw(raw: Int): GlyphsRasterizationMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Describes the map context mode.
 * We can make some optimizations if we know that the drawing context is not shared with other code.
 */
enum class ContextMode(val raw: Int) {
  /**
   * Unique context mode: in OpenGL, the GL context is not shared, thus we can retain knowledge about the GL state
   * from a previous render pass. It also enables clearing the screen using glClear for the bottommost background
   * layer when no pattern is applied to that layer.
   */
  UNIQUE(0),
  /**
   * Shared context mode: in OpenGL, the GL context is shared with other renderers, thus we cannot rely on the GL
   * state set from a previous render pass.
   */
  SHARED(1);

  companion object {
    fun ofRaw(raw: Int): ContextMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes whether to constrain the map in both axes or only vertically e.g. while panning. */
enum class ConstrainMode(val raw: Int) {
  /** No constrains. */
  NONE(0),
  /** Constrain to height only */
  HEIGHT_ONLY(1),
  /** Constrain both width and height axes. */
  WIDTH_AND_HEIGHT(2);

  companion object {
    fun ofRaw(raw: Int): ConstrainMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards. */
enum class ViewportMode(val raw: Int) {
  /** Default viewport */
  DEFAULT(0),
  /** Viewport flipped on the y-axis. */
  FLIPPED_Y(1);

  companion object {
    fun ofRaw(raw: Int): ViewportMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the map orientation. */
enum class NorthOrientation(val raw: Int) {
  /** Default, map oriented upwards */
  UPWARDS(0),
  /** Map oriented righwards */
  RIGHTWARDS(1),
  /** Map oriented downwards */
  DOWNWARDS(2),
  /** Map oriented leftwards */
  LEFTWARDS(3);

  companion object {
    fun ofRaw(raw: Int): NorthOrientation? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Options for enabling debugging features in a map. */
enum class MapDebugOptionsData(val raw: Int) {
  /**
   * Edges of tile boundaries are shown as thick, red lines to help diagnose
   * tile clipping issues.
   */
  TILE_BORDERS(0),
  /** Each tile shows its tile coordinate (x/y/z) in the upper-left corner. */
  PARSE_STATUS(1),
  /** Each tile shows a timestamp indicating when it was loaded. */
  TIMESTAMPS(2),
  /**
   * Edges of glyphs and symbols are shown as faint, green lines to help
   * diagnose collision and label placement issues.
   */
  COLLISION(3),
  /**
   * Each drawing operation is replaced by a translucent fill. Overlapping
   * drawing operations appear more prominent to help diagnose overdrawing.
   */
  OVERDRAW(4),
  /** The stencil buffer is shown instead of the color buffer. */
  STENCIL_CLIP(5),
  /** The depth buffer is shown instead of the color buffer. */
  DEPTH_BUFFER(6),
  /**
   * Visualize residency of tiles in the render cache. Tile boundaries of cached tiles
   * are rendered with green, tiles waiting for an update with yellow and tiles not in the cache
   * with red.
   */
  RENDER_CACHE(7),
  /** Show 3D model bounding boxes. */
  MODEL_BOUNDS(8),
  /** Show a wireframe for terrain. */
  TERRAIN_WIREFRAME(9);

  companion object {
    fun ofRaw(raw: Int): MapDebugOptionsData? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Enum describing how to place view annotation relatively to geometry. */
enum class ViewAnnotationAnchor(val raw: Int) {
  /** The top of the view annotation is placed closest to the geometry. */
  TOP(0),
  /** The left side of the view annotation is placed closest to the geometry. */
  LEFT(1),
  /** The bottom of the view annotation is placed closest to the geometry. */
  BOTTOM(2),
  /** The right side of the view annotation is placed closest to the geometry. */
  RIGHT(3),
  /** The top-left corner of the view annotation is placed closest to the geometry. */
  TOP_LEFT(4),
  /** The bottom-right corner of the view annotation is placed closest to the geometry. */
  BOTTOM_RIGHT(5),
  /** The top-right corner of the view annotation is placed closest to the geometry. */
  TOP_RIGHT(6),
  /** The bottom-left corner of the view annotation is placed closest to the geometry. */
  BOTTOM_LEFT(7),
  /** The center of the view annotation is placed closest to the geometry. */
  CENTER(8);

  companion object {
    fun ofRaw(raw: Int): ViewAnnotationAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Type information of the variant's content */
enum class Type(val raw: Int) {
  SCREEN_BOX(0),
  SCREEN_COORDINATE(1),
  LIST(2);

  companion object {
    fun ofRaw(raw: Int): Type? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the reason for a style package download request failure. */
enum class StylePackErrorType(val raw: Int) {
  /** The operation was canceled. */
  CANCELED(0),
  /** The style package does not exist. */
  DOES_NOT_EXIST(1),
  /** There is no available space to store the resources. */
  DISK_FULL(2),
  /** Other reason. */
  OTHER(3);

  companion object {
    fun ofRaw(raw: Int): StylePackErrorType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the reason for an offline request response error. */
enum class ResponseErrorReason(val raw: Int) {
  /** No error occurred during the resource request. */
  SUCCESS(0),
  /** The resource is not found. */
  NOT_FOUND(1),
  /** The server error. */
  SERVER(2),
  /** The connection error. */
  CONNECTION(3),
  /** The error happened because of a rate limit. */
  RATE_LIMIT(4),
  /** The resource cannot be loaded because the device is in offline mode. */
  IN_OFFLINE_MODE(5),
  /** Other reason. */
  OTHER(6);

  companion object {
    fun ofRaw(raw: Int): ResponseErrorReason? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the download state of a region. */
enum class OfflineRegionDownloadState(val raw: Int) {
  /** Indicates downloading is inactive. */
  INACTIVE(0),
  /** Indicates downloading is active. */
  ACTIVE(1);

  companion object {
    fun ofRaw(raw: Int): OfflineRegionDownloadState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes tile store usage modes. */
enum class TileStoreUsageMode(val raw: Int) {
  /**
   * Tile store usage is disabled.
   *
   * The implementation skips checking tile store when requesting a tile.
   */
  DISABLED(0),
  /**
   * Tile store enabled for accessing loaded tile packs.
   *
   * The implementation first checks tile store when requesting a tile.
   * If a tile pack is already loaded, the tile will be extracted and returned. Otherwise, the implementation
   * falls back to requesting the individual tile and storing it in the disk cache.
   */
  READ_ONLY(1),
  /**
   * Tile store enabled for accessing local tile packs and for loading new tile packs from server.
   *
   * All tile requests are converted to tile pack requests, i.e.
   * the tile pack that includes the request tile will be loaded, and the tile extracted
   * from it. In this mode, no individual tile requests will be made.
   *
   * This mode can be useful if the map trajectory is predefined and the user cannot pan
   * freely (e.g. navigation use cases), so that there is a good chance tile packs are already loaded
   * in the vicinity of the user.
   *
   * If users can pan freely, this mode is not recommended. Otherwise, panning
   * will download tile packs instead of using individual tiles. Note that this means that we could first
   * download an individual tile, and then a tile pack that also includes this tile. The individual tile in
   * the disk cache wonâ€™t be used as long as the up-to-date tile pack exists in the cache.
   */
  READ_AND_UPDATE(2);

  companion object {
    fun ofRaw(raw: Int): TileStoreUsageMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the kind of a style property value. */
enum class StylePropertyValueKind(val raw: Int) {
  /** The property value is not defined. */
  UNDEFINED(0),
  /** The property value is a constant. */
  CONSTANT(1),
  /** The property value is a style [expression](https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions). */
  EXPRESSION(2),
  /** Property value is a style [transition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#transition). */
  TRANSITION(3);

  companion object {
    fun ofRaw(raw: Int): StylePropertyValueKind? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class StyleProjectionName(val raw: Int) {
  MERCATOR(0),
  GLOBE(1);

  companion object {
    fun ofRaw(raw: Int): StyleProjectionName? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Whether extruded geometries are lit relative to the map or viewport. */
enum class Anchor(val raw: Int) {
  /** The position of the light source is aligned to the rotation of the map. */
  MAP(0),
  /** The position of the light source is aligned to the rotation of the viewport. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): Anchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. */
enum class HttpMethod(val raw: Int) {
  /** The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. */
  GET(0),
  /** The HEAD method asks for a response identical to that of a GET request, but without the response body. */
  HEAD(1),
  /** The POST method sends data (stored in the request body) to a server to create or update a given resource. */
  POST(2);

  companion object {
    fun ofRaw(raw: Int): HttpMethod? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Classify network types based on cost. */
enum class NetworkRestriction(val raw: Int) {
  /** Allow access to all network types. */
  NONE(0),
  /** Forbid network access to expensive networks, such as cellular. */
  DISALLOW_EXPENSIVE(1),
  /** Forbid access to all network types. */
  DISALLOW_ALL(2);

  companion object {
    fun ofRaw(raw: Int): NetworkRestriction? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Enum which describes possible error types which could happen during HTTP request/download calls. */
enum class HttpRequestErrorType(val raw: Int) {
  /** Establishing connection related error. */
  CONNECTION_ERROR(0),
  /** SSL related error. */
  SSLERROR(1),
  /** Request was cancelled by the user. */
  REQUEST_CANCELLED(2),
  /** Timeout error. */
  REQUEST_TIMED_OUT(3),
  /** Range request failed. */
  RANGE_ERROR(4),
  /** Other than above error. */
  OTHER_ERROR(5);

  companion object {
    fun ofRaw(raw: Int): HttpRequestErrorType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Enum which represents different error cases which could happen during download session. */
enum class DownloadErrorCode(val raw: Int) {
  /** General filesystem related error code. For cases like: write error, no such file or directory, not enough space and etc. */
  FILE_SYSTEM_ERROR(0),
  /** General network related error. Should be probably representation of HttpRequestError. */
  NETWORK_ERROR(1);

  companion object {
    fun ofRaw(raw: Int): DownloadErrorCode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Enum representing state of download session. */
enum class DownloadState(val raw: Int) {
  /** Download session initiated but not started yet. */
  PENDING(0),
  /** Download session is in progress. */
  DOWNLOADING(1),
  /** Download session failed. */
  FAILED(2),
  /** Download session successfully finished. */
  FINISHED(3);

  companion object {
    fun ofRaw(raw: Int): DownloadState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the tiles data domain. */
enum class TileDataDomain(val raw: Int) {
  /** Data for Maps. */
  MAPS(0),
  /** Data for Navigation. */
  NAVIGATION(1),
  /** Data for Search. */
  SEARCH(2),
  /** Data for ADAS */
  ADAS(3);

  companion object {
    fun ofRaw(raw: Int): TileDataDomain? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Describes the reason for a tile region download request failure. */
enum class TileRegionErrorType(val raw: Int) {
  /** The operation was canceled. */
  CANCELED(0),
  /** tile region does not exist. */
  DOES_NOT_EXIST(1),
  /** Tileset descriptors resolving failed. */
  TILESET_DESCRIPTOR(2),
  /** There is no available space to store the resources */
  DISK_FULL(3),
  /** Other reason. */
  OTHER(4),
  /** The region contains more tiles than allowed. */
  TILE_COUNT_EXCEEDED(5);

  companion object {
    fun ofRaw(raw: Int): TileRegionErrorType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class _MapEvent(val raw: Int) {
  MAP_LOADED(0),
  MAP_LOADING_ERROR(1),
  STYLE_LOADED(2),
  STYLE_DATA_LOADED(3),
  CAMERA_CHANGED(4),
  MAP_IDLE(5),
  SOURCE_ADDED(6),
  SOURCE_REMOVED(7),
  SOURCE_DATA_LOADED(8),
  STYLE_IMAGE_MISSING(9),
  STYLE_IMAGE_REMOVE_UNUSED(10),
  RENDER_FRAME_STARTED(11),
  RENDER_FRAME_FINISHED(12),
  RESOURCE_REQUEST(13);

  companion object {
    fun ofRaw(raw: Int): _MapEvent? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Various options needed for tile cover.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TileCoverOptions(
  /** Tile size of the source. Defaults to 512. */
  val tileSize: Long? = null,
  /**
   * Min zoom defined in the source between range [0, 22].
   * if not provided or is out of range, defaults to 0.
   */
  val minZoom: Long? = null,
  /**
   * Max zoom defined in the source between range [0, 22].
   * Should be greater than or equal to minZoom.
   * If not provided or is out of range, defaults to 22.
   */
  val maxZoom: Long? = null,
  /**
   * Whether to round zoom values when calculating tilecover.
   * Set this to true for raster and raster-dem sources.
   * If not specified, defaults to false.
   */
  val roundZoom: Boolean? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TileCoverOptions {
      val tileSize = list[0].let { if (it is Int) it.toLong() else it as Long? }
      val minZoom = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val maxZoom = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val roundZoom = list[3] as Boolean?
      return TileCoverOptions(tileSize, minZoom, maxZoom, roundZoom)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      tileSize,
      minZoom,
      maxZoom,
      roundZoom,
    )
  }
}

/**
 * The distance on each side between rectangles, when one is contained into other.
 *
 * All fields' values are in `logical pixel` units.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MbxEdgeInsets(
  /** Padding from the top. */
  val top: Double,
  /** Padding from the left. */
  val left: Double,
  /** Padding from the bottom. */
  val bottom: Double,
  /** Padding from the right. */
  val right: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MbxEdgeInsets {
      val top = list[0] as Double
      val left = list[1] as Double
      val bottom = list[2] as Double
      val right = list[3] as Double
      return MbxEdgeInsets(top, left, bottom, right)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      top,
      left,
      bottom,
      right,
    )
  }
}

/**
 * Various options for describing the viewpoint of a camera. All fields are
 * optional.
 *
 * Anchor and center points are mutually exclusive, with preference for the
 * center point when both are set.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraOptions(
  /** Coordinate at the center of the camera. */
  val center: Point? = null,
  /**
   * Padding around the interior of the view that affects the frame of
   * reference for `center`.
   */
  val padding: MbxEdgeInsets? = null,
  /**
   * Point of reference for `zoom` and `angle`, assuming an origin at the
   * top-left corner of the view.
   */
  val anchor: ScreenCoordinate? = null,
  /**
   * Zero-based zoom level. Constrained to the minimum and maximum zoom
   * levels.
   */
  val zoom: Double? = null,
  /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
  val bearing: Double? = null,
  /** Pitch toward the horizon measured in degrees. */
  val pitch: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CameraOptions {
      val center = (list[0] as List<Any?>?)?.let {
        PointDecoder.fromList(it)
      }
      val padding = (list[1] as List<Any?>?)?.let {
        MbxEdgeInsets.fromList(it)
      }
      val anchor = (list[2] as List<Any?>?)?.let {
        ScreenCoordinate.fromList(it)
      }
      val zoom = list[3] as Double?
      val bearing = list[4] as Double?
      val pitch = list[5] as Double?
      return CameraOptions(center, padding, anchor, zoom, bearing, pitch)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      center?.toList(),
      padding?.toList(),
      anchor?.toList(),
      zoom,
      bearing,
      pitch,
    )
  }
}

/**
 * Describes the viewpoint of a camera.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraState(
  /** Coordinate at the center of the camera. */
  val center: Point,
  /**
   * Padding around the interior of the view that affects the frame of
   * reference for `center`.
   */
  val padding: MbxEdgeInsets,
  /**
   * Zero-based zoom level. Constrained to the minimum and maximum zoom
   * levels.
   */
  val zoom: Double,
  /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
  val bearing: Double,
  /** Pitch toward the horizon measured in degrees. */
  val pitch: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CameraState {
      val center = PointDecoder.fromList(list[0] as List<Any?>)
      val padding = MbxEdgeInsets.fromList(list[1] as List<Any?>)
      val zoom = list[2] as Double
      val bearing = list[3] as Double
      val pitch = list[4] as Double
      return CameraState(center, padding, zoom, bearing, pitch)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      center.toList(),
      padding.toList(),
      zoom,
      bearing,
      pitch,
    )
  }
}

/**
 * Holds options to be used for setting `camera bounds`.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraBoundsOptions(
  /** The latitude and longitude bounds to which the camera center are constrained. */
  val bounds: CoordinateBounds? = null,
  /** The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area. */
  val maxZoom: Double? = null,
  /** The minimum zoom level, in Mapbox zoom levels 0-25.5. */
  val minZoom: Double? = null,
  /** The maximum allowed pitch value in degrees. */
  val maxPitch: Double? = null,
  /** The minimum allowed pitch value in degrees. */
  val minPitch: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CameraBoundsOptions {
      val bounds = (list[0] as List<Any?>?)?.let {
        CoordinateBounds.fromList(it)
      }
      val maxZoom = list[1] as Double?
      val minZoom = list[2] as Double?
      val maxPitch = list[3] as Double?
      val minPitch = list[4] as Double?
      return CameraBoundsOptions(bounds, maxZoom, minZoom, maxPitch, minPitch)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      bounds?.toList(),
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    )
  }
}

/**
 * Holds information about `camera bounds`.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraBounds(
  /** The latitude and longitude bounds to which the camera center are constrained. */
  val bounds: CoordinateBounds,
  /** The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area. */
  val maxZoom: Double,
  /** The minimum zoom level, in Mapbox zoom levels 0-25.5. */
  val minZoom: Double,
  /** The maximum allowed pitch value in degrees. */
  val maxPitch: Double,
  /** The minimum allowed pitch value in degrees. */
  val minPitch: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CameraBounds {
      val bounds = CoordinateBounds.fromList(list[0] as List<Any?>)
      val maxZoom = list[1] as Double
      val minZoom = list[2] as Double
      val maxPitch = list[3] as Double
      val minPitch = list[4] as Double
      return CameraBounds(bounds, maxZoom, minZoom, maxPitch, minPitch)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      bounds.toList(),
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class MapAnimationOptions(
  /**
   * The duration of the animation in milliseconds.
   * If not set explicitly default duration will be taken 300ms
   */
  val duration: Long? = null,
  /**
   * The amount of time, in milliseconds, to delay starting the animation after animation start.
   * If not set explicitly default startDelay will be taken 0ms. This only works for Android.
   */
  val startDelay: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MapAnimationOptions {
      val duration = list[0].let { if (it is Int) it.toLong() else it as Long? }
      val startDelay = list[1].let { if (it is Int) it.toLong() else it as Long? }
      return MapAnimationOptions(duration, startDelay)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      duration,
      startDelay,
    )
  }
}

/**
 * A rectangular area as measured on a two-dimensional map projection.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CoordinateBounds(
  /**
   * Coordinate at the southwest corner.
   * Note: setting this field with invalid values (infinite, NaN) will crash the application.
   */
  val southwest: Point,
  /**
   * Coordinate at the northeast corner.
   * Note: setting this field with invalid values (infinite, NaN) will crash the application.
   */
  val northeast: Point,
  /**
   * If set to `true`, an infinite (unconstrained) bounds covering the world coordinates would be used.
   * Coordinates provided in `southwest` and `northeast` fields would be omitted and have no effect.
   */
  val infiniteBounds: Boolean

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CoordinateBounds {
      val southwest = PointDecoder.fromList(list[0] as List<Any?>)
      val northeast = PointDecoder.fromList(list[1] as List<Any?>)
      val infiniteBounds = list[2] as Boolean
      return CoordinateBounds(southwest, northeast, infiniteBounds)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      southwest.toList(),
      northeast.toList(),
      infiniteBounds,
    )
  }
}

/**
 * Options for enabling debugging features in a map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MapDebugOptions(
  val data: MapDebugOptionsData

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MapDebugOptions {
      val data = MapDebugOptionsData.ofRaw(list[0] as Int)!!
      return MapDebugOptions(data)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      data.raw,
    )
  }
}

/**
 * Describes the glyphs rasterization option values.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GlyphsRasterizationOptions(
  /** Glyphs rasterization mode for client-side text rendering. */
  val rasterizationMode: GlyphsRasterizationMode,
  /**
   * Font family to use as font fallback for client-side text renderings.
   *
   * Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
   * or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
   * font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
   * default font are varied in platforms:
   * - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
   *   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
   * - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
   *
   * Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
   *
   */
  val fontFamily: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): GlyphsRasterizationOptions {
      val rasterizationMode = GlyphsRasterizationMode.ofRaw(list[0] as Int)!!
      val fontFamily = list[1] as String?
      return GlyphsRasterizationOptions(rasterizationMode, fontFamily)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      rasterizationMode.raw,
      fontFamily,
    )
  }
}

/**
 * Map memory budget in megabytes.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TileCacheBudgetInMegabytes(
  val size: Long

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TileCacheBudgetInMegabytes {
      val size = list[0].let { if (it is Int) it.toLong() else it as Long }
      return TileCacheBudgetInMegabytes(size)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      size,
    )
  }
}

/**
 * Map memory budget in tiles.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TileCacheBudgetInTiles(
  val size: Long

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TileCacheBudgetInTiles {
      val size = list[0].let { if (it is Int) it.toLong() else it as Long }
      return TileCacheBudgetInTiles(size)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      size,
    )
  }
}

/**
 * Describes the map option values.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MapOptions(
  /**
   * The map context mode. This can be used to optimizations
   * if we know that the drawing context is not shared with other code.
   */
  val contextMode: ContextMode? = null,
  /**
   * The map constrain mode. This can be used to limit the map
   * to wrap around the globe horizontally. By default, it is set to
   * `HeightOnly`.
   */
  val constrainMode: ConstrainMode? = null,
  /**
   * The viewport mode. This can be used to flip the vertical
   * orientation of the map as some devices may use inverted orientation.
   */
  val viewportMode: ViewportMode? = null,
  /**
   * The orientation of the Map. By default, it is set to
   * `Upwards`.
   */
  val orientation: NorthOrientation? = null,
  /**
   * Specify whether to enable cross-source symbol collision detection
   * or not. By default, it is set to `true`.
   */
  val crossSourceCollisions: Boolean? = null,
  /**
   * The size to resize the map object and renderer backend.
   * The size is given in `logical pixel` units. macOS and iOS platforms use
   * device-independent pixel units, while other platforms, such as Android,
   * use screen pixel units.
   */
  val size: Size? = null,
  /** The custom pixel ratio. By default, it is set to 1.0 */
  val pixelRatio: Double,
  /** Glyphs rasterization options to use for client-side text rendering. */
  val glyphsRasterizationOptions: GlyphsRasterizationOptions? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MapOptions {
      val contextMode = (list[0] as Int?)?.let {
        ContextMode.ofRaw(it)
      }
      val constrainMode = (list[1] as Int?)?.let {
        ConstrainMode.ofRaw(it)
      }
      val viewportMode = (list[2] as Int?)?.let {
        ViewportMode.ofRaw(it)
      }
      val orientation = (list[3] as Int?)?.let {
        NorthOrientation.ofRaw(it)
      }
      val crossSourceCollisions = list[4] as Boolean?
      val size = (list[5] as List<Any?>?)?.let {
        Size.fromList(it)
      }
      val pixelRatio = list[6] as Double
      val glyphsRasterizationOptions = (list[7] as List<Any?>?)?.let {
        GlyphsRasterizationOptions.fromList(it)
      }
      return MapOptions(contextMode, constrainMode, viewportMode, orientation, crossSourceCollisions, size, pixelRatio, glyphsRasterizationOptions)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      contextMode?.raw,
      constrainMode?.raw,
      viewportMode?.raw,
      orientation?.raw,
      crossSourceCollisions,
      size?.toList(),
      pixelRatio,
      glyphsRasterizationOptions?.toList(),
    )
  }
}

/**
 * Describes the coordinate on the screen, measured from top to bottom and from left to right.
 * Note: the `map` uses screen coordinate units measured in `logical pixels`.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ScreenCoordinate(
  /** A value representing the x position of this coordinate. */
  val x: Double,
  /** A value representing the y position of this coordinate. */
  val y: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ScreenCoordinate {
      val x = list[0] as Double
      val y = list[1] as Double
      return ScreenCoordinate(x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      x,
      y,
    )
  }
}

/**
 * Describes the coordinate box on the screen, measured in `logical pixels`
 * from top to bottom and from left to right.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ScreenBox(
  /** The screen coordinate close to the top left corner of the screen. */
  val min: ScreenCoordinate,
  /** The screen coordinate close to the bottom right corner of the screen. */
  val max: ScreenCoordinate

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ScreenBox {
      val min = ScreenCoordinate.fromList(list[0] as List<Any?>)
      val max = ScreenCoordinate.fromList(list[1] as List<Any?>)
      return ScreenBox(min, max)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      min.toList(),
      max.toList(),
    )
  }
}

/**
 * A coordinate bounds and zoom.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CoordinateBoundsZoom(
  /** The latitude and longitude bounds. */
  val bounds: CoordinateBounds,
  /** Zoom. */
  val zoom: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CoordinateBoundsZoom {
      val bounds = CoordinateBounds.fromList(list[0] as List<Any?>)
      val zoom = list[1] as Double
      return CoordinateBoundsZoom(bounds, zoom)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      bounds.toList(),
      zoom,
    )
  }
}

/**
 * Size type.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class Size(
  /** Width of the size. */
  val width: Double,
  /** Height of the size. */
  val height: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): Size {
      val width = list[0] as Double
      val height = list[1] as Double
      return Size(width, height)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      width,
      height,
    )
  }
}

/**
 * Options for querying rendered features.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RenderedQueryOptions(
  /** Layer IDs to include in the query. */
  val layerIds: List<String?>? = null,
  /** Filters the returned features with an expression */
  val filter: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RenderedQueryOptions {
      val layerIds = list[0] as List<String?>?
      val filter = list[1] as String?
      return RenderedQueryOptions(layerIds, filter)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      layerIds,
      filter,
    )
  }
}

/**
 * Options for querying source features.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class SourceQueryOptions(
  /** Source layer IDs to include in the query. */
  val sourceLayerIds: List<String?>? = null,
  /** Filters the returned features with an expression */
  val filter: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): SourceQueryOptions {
      val sourceLayerIds = list[0] as List<String?>?
      val filter = list[1] as String
      return SourceQueryOptions(sourceLayerIds, filter)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      sourceLayerIds,
      filter,
    )
  }
}

/**
 * A value or a collection of a feature extension.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class FeatureExtensionValue(
  /** An optional value of a feature extension */
  val value: String? = null,
  /** An optional array of features from a feature extension. */
  val featureCollection: List<Map<String?, Any?>?>? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): FeatureExtensionValue {
      val value = list[0] as String?
      val featureCollection = list[1] as List<Map<String?, Any?>?>?
      return FeatureExtensionValue(value, featureCollection)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      value,
      featureCollection,
    )
  }
}

/**
 * Specifies position of a layer that is added via addStyleLayer method.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LayerPosition(
  /** Layer should be positioned above specified layer id. */
  val above: String? = null,
  /** Layer should be positioned below specified layer id. */
  val below: String? = null,
  /** Layer should be positioned at specified index in a layers stack. */
  val at: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LayerPosition {
      val above = list[0] as String?
      val below = list[1] as String?
      val at = list[2].let { if (it is Int) it.toLong() else it as Long? }
      return LayerPosition(above, below, at)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      above,
      below,
      at,
    )
  }
}

/**
 * Represents query result that is returned in QueryRenderedFeaturesCallback.
 * @see `queryRenderedFeatures`
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class QueriedRenderedFeature(
  /** Feature returned by the query. */
  val queriedFeature: QueriedFeature,
  /**
   * An array of layer Ids for the queried feature.
   * If the feature has been rendered in multiple layers, multiple Ids will be provided.
   * If the feature is only rendered in one layer, a single Id will be provided.
   */
  val layers: List<String?>

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): QueriedRenderedFeature {
      val queriedFeature = QueriedFeature.fromList(list[0] as List<Any?>)
      val layers = list[1] as List<String?>
      return QueriedRenderedFeature(queriedFeature, layers)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      queriedFeature.toList(),
      layers,
    )
  }
}

/**
 * Represents query result that is returned in QuerySourceFeaturesCallback.
 * @see `querySourceFeatures`
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class QueriedSourceFeature(
  /** Feature returned by the query. */
  val queriedFeature: QueriedFeature

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): QueriedSourceFeature {
      val queriedFeature = QueriedFeature.fromList(list[0] as List<Any?>)
      return QueriedSourceFeature(queriedFeature)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      queriedFeature.toList(),
    )
  }
}

/**
 * Represents query result that is returned in QueryFeaturesCallback.
 * @see `queryRenderedFeatures` or `querySourceFeatures`
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class QueriedFeature(
  /** Feature returned by the query. */
  val feature: Map<String?, Any?>,
  /** Source id for a queried feature. */
  val source: String,
  /**
   * Source layer id for a queried feature. May be null if source does not support layers, e.g., 'geojson' source,
   * or when data provided by the source is not layered.
   */
  val sourceLayer: String? = null,
  /**
   * Feature state for a queried feature. Type of the value is an Object.
   * @see `setFeatureState` and `getFeatureState`
   */
  val state: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): QueriedFeature {
      val feature = list[0] as Map<String?, Any?>
      val source = list[1] as String
      val sourceLayer = list[2] as String?
      val state = list[3] as String
      return QueriedFeature(feature, source, sourceLayer, state)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      feature,
      source,
      sourceLayer,
      state,
    )
  }
}

/**
 * Geometry for querying rendered features.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RenderedQueryGeometry(
  /** ScreenCoordinate/List<ScreenCoordinate>/ScreenBox in Json mode. */
  val value: String,
  val type: Type

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): RenderedQueryGeometry {
      val value = list[0] as String
      val type = Type.ofRaw(list[1] as Int)!!
      return RenderedQueryGeometry(value, type)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      value,
      type.raw,
    )
  }
}

/**
 * An offline region definition is a geographic region defined by a style URL,
 * a geometry, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be â‰¥ 0,
 * and `maxZoom` must be â‰¥ `minZoom`. The `maxZoom` may be âˆž, in which case for each tile source,
 * the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
 * The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class OfflineRegionGeometryDefinition(
  /** The style associated with the offline region */
  val styleURL: String,
  /** The geometry that defines the boundary of the offline region */
  val geometry: Map<String?, Any?>,
  /** Minimum zoom level for the offline region */
  val minZoom: Double,
  /** Maximum zoom level for the offline region */
  val maxZoom: Double,
  /** Pixel ratio to be accounted for when downloading assets */
  val pixelRatio: Double,
  /** Specifies glyphs rasterization mode. It defines which glyphs will be loaded from the server */
  val glyphsRasterizationMode: GlyphsRasterizationMode

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): OfflineRegionGeometryDefinition {
      val styleURL = list[0] as String
      val geometry = list[1] as Map<String?, Any?>
      val minZoom = list[2] as Double
      val maxZoom = list[3] as Double
      val pixelRatio = list[4] as Double
      val glyphsRasterizationMode = GlyphsRasterizationMode.ofRaw(list[5] as Int)!!
      return OfflineRegionGeometryDefinition(styleURL, geometry, minZoom, maxZoom, pixelRatio, glyphsRasterizationMode)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      styleURL,
      geometry,
      minZoom,
      maxZoom,
      pixelRatio,
      glyphsRasterizationMode.raw,
    )
  }
}

/**
 * An offline region definition is a geographic region defined by a style URL,
 * geographic bounding box, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be â‰¥ 0,
 * and `maxZoom` must be â‰¥ `minZoom`. The `maxZoom` may be âˆž, in which case for each tile source,
 * the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
 * The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class OfflineRegionTilePyramidDefinition(
  /** The style associated with the offline region. */
  val styleURL: String,
  /** The bounds covering the region. */
  val bounds: CoordinateBounds,
  /** Minimum zoom level for the offline region. */
  val minZoom: Double,
  /** Maximum zoom level for the offline region. */
  val maxZoom: Double,
  /** Pixel ratio to be accounted for when downloading assets. */
  val pixelRatio: Double,
  /** Specifies glyphs download mode. */
  val glyphsRasterizationMode: GlyphsRasterizationMode

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): OfflineRegionTilePyramidDefinition {
      val styleURL = list[0] as String
      val bounds = CoordinateBounds.fromList(list[1] as List<Any?>)
      val minZoom = list[2] as Double
      val maxZoom = list[3] as Double
      val pixelRatio = list[4] as Double
      val glyphsRasterizationMode = GlyphsRasterizationMode.ofRaw(list[5] as Int)!!
      return OfflineRegionTilePyramidDefinition(styleURL, bounds, minZoom, maxZoom, pixelRatio, glyphsRasterizationMode)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      styleURL,
      bounds.toList(),
      minZoom,
      maxZoom,
      pixelRatio,
      glyphsRasterizationMode.raw,
    )
  }
}

/**
 * ProjectedMeters is a coordinate in a specific
 * [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection.
 *
 * This specific Spherical Mercator projection assumes the Earth is a sphere with a radius
 * of 6,378,137 meters. Coordinates are determined as distances, in meters, on the surface
 * of that sphere.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ProjectedMeters(
  /** Projected meters in north direction. */
  val northing: Double,
  /** Projected meters in east direction. */
  val easting: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ProjectedMeters {
      val northing = list[0] as Double
      val easting = list[1] as Double
      return ProjectedMeters(northing, easting)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      northing,
      easting,
    )
  }
}

/**
 * Describes a point on the map in Mercator projection.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MercatorCoordinate(
  /** A value representing the x position of this coordinate. */
  val x: Double,
  /** A value representing the y position of this coordinate. */
  val y: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MercatorCoordinate {
      val x = list[0] as Double
      val y = list[1] as Double
      return MercatorCoordinate(x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      x,
      y,
    )
  }
}

/**
 * The information about style object (source or layer).
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class StyleObjectInfo(
  /** The object's identifier. */
  val id: String,
  /** The object's type. */
  val type: String

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StyleObjectInfo {
      val id = list[0] as String
      val type = list[1] as String
      return StyleObjectInfo(id, type)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      type,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class StyleProjection(
  val name: StyleProjectionName

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StyleProjection {
      val name = StyleProjectionName.ofRaw(list[0] as Int)!!
      return StyleProjection(name)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      name.raw,
    )
  }
}

/**
 * A global directional light source which is only applied on 3D layers and hillshade layers. Using this type disables other light sources.
 *
 * - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class FlatLight(
  /** Unique light name */
  val id: String,
  /** Whether extruded geometries are lit relative to the map or viewport. */
  val anchor: Anchor? = null,
  /** Color tint for lighting extruded geometries. */
  val color: Long? = null,
  /** Transition property for `color` */
  val colorTransition: TransitionOptions? = null,
  /** Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast. */
  val intensity: Double? = null,
  /** Transition property for `intensity` */
  val intensityTransition: TransitionOptions? = null,
  /** Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0 degree (0 degree when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0 degree when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0 degree, directly above, to 180 degree, directly below). */
  val position: List<Double?>? = null,
  /** Transition property for `position` */
  val positionTransition: TransitionOptions? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): FlatLight {
      val id = list[0] as String
      val anchor = (list[1] as Int?)?.let {
        Anchor.ofRaw(it)
      }
      val color = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val colorTransition = (list[3] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      val intensity = list[4] as Double?
      val intensityTransition = (list[5] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      val position = list[6] as List<Double?>?
      val positionTransition = (list[7] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      return FlatLight(id, anchor, color, colorTransition, intensity, intensityTransition, position, positionTransition)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      anchor?.raw,
      color,
      colorTransition?.toList(),
      intensity,
      intensityTransition?.toList(),
      position,
      positionTransition?.toList(),
    )
  }
}

/**
 * A light that has a direction and is located at infinite, so its rays are parallel. Simulates the sun light and it can cast shadows
 *
 * - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class DirectionalLight(
  /** Unique light name */
  val id: String,
  /** Enable/Disable shadow casting for this light */
  val castShadows: Boolean? = null,
  /** Color of the directional light. */
  val color: Long? = null,
  /** Transition property for `color` */
  val colorTransition: TransitionOptions? = null,
  /** Direction of the light source specified as [a azimuthal angle, p polar angle] where a indicates the azimuthal angle of the light relative to north (in degrees and proceeding clockwise), and p indicates polar angle of the light (from 0 degree, directly above, to 180 degree, directly below). */
  val direction: List<Double?>? = null,
  /** Transition property for `direction` */
  val directionTransition: TransitionOptions? = null,
  /** A multiplier for the color of the directional light. */
  val intensity: Double? = null,
  /** Transition property for `intensity` */
  val intensityTransition: TransitionOptions? = null,
  /** Determines the shadow strength, affecting the shadow receiver surfaces final color. Values near 0.0 reduce the shadow contribution to the final color. Values near to 1.0 make occluded surfaces receive almost no directional light. Designed to be used mostly for transitioning between values 0 and 1. */
  val shadowIntensity: Double? = null,
  /** Transition property for `shadowIntensity` */
  val shadowIntensityTransition: TransitionOptions? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): DirectionalLight {
      val id = list[0] as String
      val castShadows = list[1] as Boolean?
      val color = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val colorTransition = (list[3] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      val direction = list[4] as List<Double?>?
      val directionTransition = (list[5] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      val intensity = list[6] as Double?
      val intensityTransition = (list[7] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      val shadowIntensity = list[8] as Double?
      val shadowIntensityTransition = (list[9] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      return DirectionalLight(id, castShadows, color, colorTransition, direction, directionTransition, intensity, intensityTransition, shadowIntensity, shadowIntensityTransition)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      castShadows,
      color,
      colorTransition?.toList(),
      direction,
      directionTransition?.toList(),
      intensity,
      intensityTransition?.toList(),
      shadowIntensity,
      shadowIntensityTransition?.toList(),
    )
  }
}

/**
 * An indirect light affecting all objects in the map adding a constant amount of light on them. It has no explicit direction and cannot cast shadows.
 *
 * - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AmbientLight(
  /** Unique light name */
  val id: String,
  /** Color of the ambient light. */
  val color: Long? = null,
  /** Transition property for `color` */
  val colorTransition: TransitionOptions? = null,
  /** A multiplier for the color of the ambient light. */
  val intensity: Double? = null,
  /** Transition property for `intensity` */
  val intensityTransition: TransitionOptions? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): AmbientLight {
      val id = list[0] as String
      val color = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val colorTransition = (list[2] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      val intensity = list[3] as Double?
      val intensityTransition = (list[4] as List<Any?>?)?.let {
        TransitionOptions.fromList(it)
      }
      return AmbientLight(id, color, colorTransition, intensity, intensityTransition)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      color,
      colorTransition?.toList(),
      intensity,
      intensityTransition?.toList(),
    )
  }
}

/**
 * Image type.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MbxImage(
  /** The width of the image, in screen pixels. */
  val width: Long,
  /** The height of the image, in screen pixels. */
  val height: Long,
  /**
   * 32-bit premultiplied RGBA image data.
   *
   * An uncompressed image data encoded in 32-bit RGBA format with premultiplied
   * alpha channel. This field should contain exactly `4 * width * height` bytes. It
   * should consist of a sequence of scanlines.
   */
  val data: ByteArray

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): MbxImage {
      val width = list[0].let { if (it is Int) it.toLong() else it as Long }
      val height = list[1].let { if (it is Int) it.toLong() else it as Long }
      val data = list[2] as ByteArray
      return MbxImage(width, height, data)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      width,
      height,
      data,
    )
  }
}

/**
 * Describes the image stretch areas.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ImageStretches(
  /** The first stretchable part in screen pixel units. */
  val first: Double,
  /** The second stretchable part in screen pixel units. */
  val second: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ImageStretches {
      val first = list[0] as Double
      val second = list[1] as Double
      return ImageStretches(first, second)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      first,
      second,
    )
  }
}

/**
 * Describes the image content, e.g. where text can be fit into an image.
 *
 * When sizing icons with `icon-text-fit`, the icon size will be adjusted so that the this content box fits exactly around the text.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ImageContent(
  /** Distance to the left, in screen pixels. */
  val left: Double,
  /** Distance to the top, in screen pixels. */
  val top: Double,
  /** Distance to the right, in screen pixels. */
  val right: Double,
  /** Distance to the bottom, in screen pixels. */
  val bottom: Double

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ImageContent {
      val left = list[0] as Double
      val top = list[1] as Double
      val right = list[2] as Double
      val bottom = list[3] as Double
      return ImageContent(left, top, right, bottom)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      left,
      top,
      right,
      bottom,
    )
  }
}

/**
 * The `transition options` controls timing for the interpolation between a transitionable style
 * property's previous value and new value. These can be used to define the style default property
 * transition behavior. Also, any transitionable style property may also have its own `-transition`
 * property that defines specific transition timing for that specific layer property, overriding
 * the global transition values.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TransitionOptions(
  /** Time allotted for transitions to complete. Units in milliseconds. Defaults to `300.0`. */
  val duration: Long? = null,
  /** Length of time before a transition begins. Units in milliseconds. Defaults to `0.0`. */
  val delay: Long? = null,
  /** Whether the fade in/out symbol placement transition is enabled. Defaults to `true`. */
  val enablePlacementTransitions: Boolean? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): TransitionOptions {
      val duration = list[0].let { if (it is Int) it.toLong() else it as Long? }
      val delay = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val enablePlacementTransitions = list[2] as Boolean?
      return TransitionOptions(duration, delay, enablePlacementTransitions)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      duration,
      delay,
      enablePlacementTransitions,
    )
  }
}

/**
 * Represents a tile coordinate.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CanonicalTileID(
  /** The z value of the coordinate (zoom-level). */
  val z: Long,
  /** The x value of the coordinate. */
  val x: Long,
  /** The y value of the coordinate. */
  val y: Long

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CanonicalTileID {
      val z = list[0].let { if (it is Int) it.toLong() else it as Long }
      val x = list[1].let { if (it is Int) it.toLong() else it as Long }
      val y = list[2].let { if (it is Int) it.toLong() else it as Long }
      return CanonicalTileID(z, x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      z,
      x,
      y,
    )
  }
}

/**
 * Holds a style property value with meta data.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class StylePropertyValue(
  /** The property value. */
  val value: Any? = null,
  /** The kind of the property value. */
  val kind: StylePropertyValueKind

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StylePropertyValue {
      val value = list[0]
      val kind = StylePropertyValueKind.ofRaw(list[1] as Int)!!
      return StylePropertyValue(value, kind)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      value,
      kind.raw,
    )
  }
}
@Suppress("UNCHECKED_CAST")
private object _AnimationManagerCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraOptions.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapAnimationOptions.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxEdgeInsets.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is CameraOptions -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is MapAnimationOptions -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is MbxEdgeInsets -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is Point -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is ScreenCoordinate -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is ScreenCoordinate -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Interface for managing animation.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface _AnimationManager {
  fun easeTo(cameraOptions: CameraOptions, mapAnimationOptions: MapAnimationOptions?)
  fun flyTo(cameraOptions: CameraOptions, mapAnimationOptions: MapAnimationOptions?)
  fun pitchBy(pitch: Double, mapAnimationOptions: MapAnimationOptions?)
  fun scaleBy(amount: Double, screenCoordinate: ScreenCoordinate?, mapAnimationOptions: MapAnimationOptions?)
  fun moveBy(screenCoordinate: ScreenCoordinate, mapAnimationOptions: MapAnimationOptions?)
  fun rotateBy(first: ScreenCoordinate, second: ScreenCoordinate, mapAnimationOptions: MapAnimationOptions?)
  fun cancelCameraAnimation()

  companion object {
    /** The codec used by _AnimationManager. */
    val codec: MessageCodec<Any?> by lazy {
      _AnimationManagerCodec
    }
    /** Sets up an instance of `_AnimationManager` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _AnimationManager?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraOptionsArg = args[0] as CameraOptions
            val mapAnimationOptionsArg = args[1] as MapAnimationOptions?
            var wrapped: List<Any?>
            try {
              api.easeTo(cameraOptionsArg, mapAnimationOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraOptionsArg = args[0] as CameraOptions
            val mapAnimationOptionsArg = args[1] as MapAnimationOptions?
            var wrapped: List<Any?>
            try {
              api.flyTo(cameraOptionsArg, mapAnimationOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pitchArg = args[0] as Double
            val mapAnimationOptionsArg = args[1] as MapAnimationOptions?
            var wrapped: List<Any?>
            try {
              api.pitchBy(pitchArg, mapAnimationOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val amountArg = args[0] as Double
            val screenCoordinateArg = args[1] as ScreenCoordinate?
            val mapAnimationOptionsArg = args[2] as MapAnimationOptions?
            var wrapped: List<Any?>
            try {
              api.scaleBy(amountArg, screenCoordinateArg, mapAnimationOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val screenCoordinateArg = args[0] as ScreenCoordinate
            val mapAnimationOptionsArg = args[1] as MapAnimationOptions?
            var wrapped: List<Any?>
            try {
              api.moveBy(screenCoordinateArg, mapAnimationOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val firstArg = args[0] as ScreenCoordinate
            val secondArg = args[1] as ScreenCoordinate
            val mapAnimationOptionsArg = args[2] as MapAnimationOptions?
            var wrapped: List<Any?>
            try {
              api.rotateBy(firstArg, secondArg, mapAnimationOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.cancelCameraAnimation()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object _CameraManagerCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AmbientLight.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraBounds.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraBoundsOptions.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraOptions.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraState.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CanonicalTileID.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBounds.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBoundsZoom.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DirectionalLight.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FeatureExtensionValue.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FlatLight.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GlyphsRasterizationOptions.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageContent.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageStretches.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LayerPosition.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapAnimationOptions.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapDebugOptions.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapOptions.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxEdgeInsets.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxImage.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MercatorCoordinate.fromList(it)
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionGeometryDefinition.fromList(it)
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionTilePyramidDefinition.fromList(it)
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ProjectedMeters.fromList(it)
        }
      }
      153.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedFeature.fromList(it)
        }
      }
      154.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedRenderedFeature.fromList(it)
        }
      }
      155.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedSourceFeature.fromList(it)
        }
      }
      156.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RenderedQueryGeometry.fromList(it)
        }
      }
      157.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RenderedQueryOptions.fromList(it)
        }
      }
      158.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenBox.fromList(it)
        }
      }
      159.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      160.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Size.fromList(it)
        }
      }
      161.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceQueryOptions.fromList(it)
        }
      }
      162.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StyleObjectInfo.fromList(it)
        }
      }
      163.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StyleProjection.fromList(it)
        }
      }
      164.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StylePropertyValue.fromList(it)
        }
      }
      165.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCacheBudgetInMegabytes.fromList(it)
        }
      }
      166.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCacheBudgetInTiles.fromList(it)
        }
      }
      167.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCoverOptions.fromList(it)
        }
      }
      168.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TransitionOptions.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is AmbientLight -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is CameraBounds -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is CameraBoundsOptions -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is CameraOptions -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is CameraState -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is CanonicalTileID -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is CoordinateBounds -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is CoordinateBoundsZoom -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is DirectionalLight -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is FeatureExtensionValue -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is FlatLight -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is GlyphsRasterizationOptions -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is ImageContent -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is ImageStretches -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is LayerPosition -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is MapAnimationOptions -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is MapDebugOptions -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is MapOptions -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is MbxEdgeInsets -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is MbxImage -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is MercatorCoordinate -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      is OfflineRegionGeometryDefinition -> {
        stream.write(149)
        writeValue(stream, value.toList())
      }
      is OfflineRegionTilePyramidDefinition -> {
        stream.write(150)
        writeValue(stream, value.toList())
      }
      is Point -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is ProjectedMeters -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      is QueriedFeature -> {
        stream.write(153)
        writeValue(stream, value.toList())
      }
      is QueriedRenderedFeature -> {
        stream.write(154)
        writeValue(stream, value.toList())
      }
      is QueriedSourceFeature -> {
        stream.write(155)
        writeValue(stream, value.toList())
      }
      is RenderedQueryGeometry -> {
        stream.write(156)
        writeValue(stream, value.toList())
      }
      is RenderedQueryOptions -> {
        stream.write(157)
        writeValue(stream, value.toList())
      }
      is ScreenBox -> {
        stream.write(158)
        writeValue(stream, value.toList())
      }
      is ScreenCoordinate -> {
        stream.write(159)
        writeValue(stream, value.toList())
      }
      is Size -> {
        stream.write(160)
        writeValue(stream, value.toList())
      }
      is SourceQueryOptions -> {
        stream.write(161)
        writeValue(stream, value.toList())
      }
      is StyleObjectInfo -> {
        stream.write(162)
        writeValue(stream, value.toList())
      }
      is StyleProjection -> {
        stream.write(163)
        writeValue(stream, value.toList())
      }
      is StylePropertyValue -> {
        stream.write(164)
        writeValue(stream, value.toList())
      }
      is TileCacheBudgetInMegabytes -> {
        stream.write(165)
        writeValue(stream, value.toList())
      }
      is TileCacheBudgetInTiles -> {
        stream.write(166)
        writeValue(stream, value.toList())
      }
      is TileCoverOptions -> {
        stream.write(167)
        writeValue(stream, value.toList())
      }
      is TransitionOptions -> {
        stream.write(168)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Interface for managing camera.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface _CameraManager {
  /**
   * Convenience method that returns a `camera options` object for the given parameters.
   *
   * @param coordinates The `coordinates` representing the bounds of the camera.
   * @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
   * If any of the fields in camera options is not provided then the current value from the map for that field will be used.
   * @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
   * This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
   * @param maxZoom The maximum zoom level allowed in the returned camera options.
   * @param offset The center of the given bounds relative to map center in screen points.
   * @return The `camera options` object representing the provided parameters.
   */
  fun cameraForCoordinatesPadding(coordinates: List<Point>, camera: CameraOptions, coordinatesPadding: MbxEdgeInsets?, maxZoom: Double?, offset: ScreenCoordinate?): CameraOptions
  /**
   * Convenience method that returns the `camera options` object for given parameters.
   *
   * @param bounds The `coordinate bounds` of the camera.
   * @param padding The `edge insets` of the camera.
   * @param bearing The bearing of the camera.
   * @param pitch The pitch of the camera.
   * @param maxZoom The maximum zoom level allowed in the returned camera options.
   * @param offset The center of the given bounds relative to map center in screen points.
   * @return The `camera options` object representing the provided parameters.
   */
  fun cameraForCoordinateBounds(bounds: CoordinateBounds, padding: MbxEdgeInsets?, bearing: Double?, pitch: Double?, maxZoom: Double?, offset: ScreenCoordinate?): CameraOptions
  /**
   * Convenience method that returns the `camera options` object for given parameters.
   *
   * @param coordinates The `coordinates` representing the bounds of the camera.
   * @param padding The `edge insets` of the camera.
   * @param bearing The bearing of the camera.
   * @param pitch The pitch of the camera.
   *
   * @return The `camera options` object representing the provided parameters.
   */
  fun cameraForCoordinates(coordinates: List<Point>, padding: MbxEdgeInsets?, bearing: Double?, pitch: Double?): CameraOptions
  /**
   * Convenience method that adjusts the provided `camera options` object for given parameters.
   *
   * Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
   * top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
   * Returns the provided `camera` options object unchanged upon an error.
   * Note that this method may fail if the principal point of the projection is not inside the `box` or
   * if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
   *
   * @param coordinates The `coordinates` representing the bounds of the camera.
   * @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
   * @param box The `screen box` into which `coordinates` should fit.
   *
   * @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
   */
  fun cameraForCoordinatesCameraOptions(coordinates: List<Point>, camera: CameraOptions, box: ScreenBox): CameraOptions
  /**
   * Convenience method that returns the `camera options` object for given parameters.
   *
   * @param geometry The `geometry` representing the bounds of the camera.
   * @param padding The `edge insets` of the camera.
   * @param bearing The bearing of the camera.
   * @param pitch The pitch of the camera.
   *
   * @return The `camera options` object representing the provided parameters.
   */
  fun cameraForGeometry(geometry: Map<String?, Any?>, padding: MbxEdgeInsets, bearing: Double?, pitch: Double?): CameraOptions
  /**
   * Returns the `coordinate bounds` for a given camera.
   *
   * Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
   * might not represent the minimum bounding box.
   *
   * @param camera The `camera options` to use for calculating `coordinate bounds`.
   *
   * @return The `coordinate bounds` object representing a given `camera`.
   *
   */
  fun coordinateBoundsForCamera(camera: CameraOptions): CoordinateBounds
  /**
   * Returns the `coordinate bounds` for a given camera.
   *
   * This method is useful if the `camera` shows the antimeridian.
   *
   * @param camera The `camera options` to use for calculating `coordinate bounds`.
   *
   * @return The `coordinate bounds` object representing a given `camera`.
   *
   */
  fun coordinateBoundsForCameraUnwrapped(camera: CameraOptions): CoordinateBounds
  /**
   * Returns the `coordinate bounds` and the `zoom` for a given `camera`.
   *
   * Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
   * might not represent the minimum bounding box.
   *
   * @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
   *
   * @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
   *
   */
  fun coordinateBoundsZoomForCamera(camera: CameraOptions): CoordinateBoundsZoom
  /**
   * Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
   *
   * This method is useful if the `camera` shows the antimeridian.
   *
   * @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
   *
   * @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
   *
   */
  fun coordinateBoundsZoomForCameraUnwrapped(camera: CameraOptions): CoordinateBoundsZoom
  /**
   * Calculates a `screen coordinate` that corresponds to a geographical coordinate
   * (i.e., longitude-latitude pair).
   *
   * The `screen coordinate` is in `logical pixels` relative to the top left corner
   * of the map (not of the whole screen).
   *
   * @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
   *
   * @return A `screen coordinate` on the screen in `logical pixels`.
   */
  fun pixelForCoordinate(coordinate: Point): ScreenCoordinate
  /**
   * Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
   * to a `screen coordinate`.
   *
   * The screen coordinate is in `logical pixels`relative to the top left corner
   * of the map (not of the whole screen).
   *
   * @param pixel A `screen coordinate` on the screen in `logical pixels`.
   *
   * @return A geographical `coordinate` corresponding to a given `screen coordinate`.
   */
  fun coordinateForPixel(pixel: ScreenCoordinate): Point
  /**
   * Calculates `screen coordinates` that correspond to geographical `coordinates`
   * (i.e., longitude-latitude pairs).
   *
   * The `screen coordinates` are in `logical pixels` relative to the top left corner
   * of the map (not of the whole screen).
   *
   * @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
   *
   * @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
   */
  fun pixelsForCoordinates(coordinates: List<Point>): List<ScreenCoordinate?>
  /**
   * Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
   * to `screen coordinates`.
   *
   * The screen coordinates are in `logical pixels` relative to the top left corner
   * of the map (not of the whole screen).
   *
   * @param pixels A `screen coordinates` in `logical pixels`.
   *
   * @return A `geographical coordinates` that correspond to a given `screen coordinates`.
   */
  fun coordinatesForPixels(pixels: List<ScreenCoordinate?>): List<Point>
  /**
   * Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
   * The map will retain its current values for any details not passed via the camera options argument.
   * It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
   * different `camera state`.
   *
   * @param cameraOptions The new `camera options` to be set.
   */
  fun setCamera(cameraOptions: CameraOptions)
  /**
   * Returns the current `camera state`.
   *
   * @return The current `camera state`.
   */
  fun getCameraState(): CameraState
  /**
   * Sets the `camera bounds options` of the map. The map will retain its current values for any
   * details not passed via the camera bounds options arguments.
   * When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
   * zoom level of the camera, to prevent out of bounds areas to be visible.
   * Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
   *
   * @param options The `camera bounds options` to set.
   * @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
   */
  fun setBounds(options: CameraBoundsOptions)
  /**
   * Returns the `camera bounds` of the map.
   * @return A `camera bounds` of the map.
   */
  fun getBounds(): CameraBounds

  companion object {
    /** The codec used by _CameraManager. */
    val codec: MessageCodec<Any?> by lazy {
      _CameraManagerCodec
    }
    /** Sets up an instance of `_CameraManager` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _CameraManager?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinatesArg = args[0] as List<Point>
            val cameraArg = args[1] as CameraOptions
            val coordinatesPaddingArg = args[2] as MbxEdgeInsets?
            val maxZoomArg = args[3] as Double?
            val offsetArg = args[4] as ScreenCoordinate?
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.cameraForCoordinatesPadding(coordinatesArg, cameraArg, coordinatesPaddingArg, maxZoomArg, offsetArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val boundsArg = args[0] as CoordinateBounds
            val paddingArg = args[1] as MbxEdgeInsets?
            val bearingArg = args[2] as Double?
            val pitchArg = args[3] as Double?
            val maxZoomArg = args[4] as Double?
            val offsetArg = args[5] as ScreenCoordinate?
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.cameraForCoordinateBounds(boundsArg, paddingArg, bearingArg, pitchArg, maxZoomArg, offsetArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinatesArg = args[0] as List<Point>
            val paddingArg = args[1] as MbxEdgeInsets?
            val bearingArg = args[2] as Double?
            val pitchArg = args[3] as Double?
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.cameraForCoordinates(coordinatesArg, paddingArg, bearingArg, pitchArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinatesArg = args[0] as List<Point>
            val cameraArg = args[1] as CameraOptions
            val boxArg = args[2] as ScreenBox
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.cameraForCoordinatesCameraOptions(coordinatesArg, cameraArg, boxArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val geometryArg = args[0] as Map<String?, Any?>
            val paddingArg = args[1] as MbxEdgeInsets
            val bearingArg = args[2] as Double?
            val pitchArg = args[3] as Double?
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.cameraForGeometry(geometryArg, paddingArg, bearingArg, pitchArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraArg = args[0] as CameraOptions
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinateBoundsForCamera(cameraArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraArg = args[0] as CameraOptions
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinateBoundsForCameraUnwrapped(cameraArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraArg = args[0] as CameraOptions
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinateBoundsZoomForCamera(cameraArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraArg = args[0] as CameraOptions
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinateBoundsZoomForCameraUnwrapped(cameraArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinateArg = args[0] as Point
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.pixelForCoordinate(coordinateArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pixelArg = args[0] as ScreenCoordinate
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinateForPixel(pixelArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinatesArg = args[0] as List<Point>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.pixelsForCoordinates(coordinatesArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pixelsArg = args[0] as List<ScreenCoordinate?>
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinatesForPixels(pixelsArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val cameraOptionsArg = args[0] as CameraOptions
            var wrapped: List<Any?>
            try {
              api.setCamera(cameraOptionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getCameraState())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as CameraBoundsOptions
            var wrapped: List<Any?>
            try {
              api.setBounds(optionsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getBounds())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object _MapInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AmbientLight.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraBounds.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraBoundsOptions.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraOptions.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraState.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CanonicalTileID.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBounds.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBoundsZoom.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DirectionalLight.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FeatureExtensionValue.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FlatLight.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GlyphsRasterizationOptions.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageContent.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageStretches.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LayerPosition.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapAnimationOptions.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapDebugOptions.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapOptions.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxEdgeInsets.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxImage.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MercatorCoordinate.fromList(it)
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionGeometryDefinition.fromList(it)
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionTilePyramidDefinition.fromList(it)
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ProjectedMeters.fromList(it)
        }
      }
      153.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedFeature.fromList(it)
        }
      }
      154.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedRenderedFeature.fromList(it)
        }
      }
      155.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedSourceFeature.fromList(it)
        }
      }
      156.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RenderedQueryGeometry.fromList(it)
        }
      }
      157.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RenderedQueryOptions.fromList(it)
        }
      }
      158.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenBox.fromList(it)
        }
      }
      159.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      160.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Size.fromList(it)
        }
      }
      161.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceQueryOptions.fromList(it)
        }
      }
      162.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StyleObjectInfo.fromList(it)
        }
      }
      163.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StyleProjection.fromList(it)
        }
      }
      164.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StylePropertyValue.fromList(it)
        }
      }
      165.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCacheBudgetInMegabytes.fromList(it)
        }
      }
      166.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCacheBudgetInTiles.fromList(it)
        }
      }
      167.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCoverOptions.fromList(it)
        }
      }
      168.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TransitionOptions.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is AmbientLight -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is CameraBounds -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is CameraBoundsOptions -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is CameraOptions -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is CameraState -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is CanonicalTileID -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is CoordinateBounds -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is CoordinateBoundsZoom -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is DirectionalLight -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is FeatureExtensionValue -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is FlatLight -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is GlyphsRasterizationOptions -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is ImageContent -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is ImageStretches -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is LayerPosition -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is MapAnimationOptions -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is MapDebugOptions -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is MapOptions -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is MbxEdgeInsets -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is MbxImage -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is MercatorCoordinate -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      is OfflineRegionGeometryDefinition -> {
        stream.write(149)
        writeValue(stream, value.toList())
      }
      is OfflineRegionTilePyramidDefinition -> {
        stream.write(150)
        writeValue(stream, value.toList())
      }
      is Point -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is ProjectedMeters -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      is QueriedFeature -> {
        stream.write(153)
        writeValue(stream, value.toList())
      }
      is QueriedRenderedFeature -> {
        stream.write(154)
        writeValue(stream, value.toList())
      }
      is QueriedSourceFeature -> {
        stream.write(155)
        writeValue(stream, value.toList())
      }
      is RenderedQueryGeometry -> {
        stream.write(156)
        writeValue(stream, value.toList())
      }
      is RenderedQueryOptions -> {
        stream.write(157)
        writeValue(stream, value.toList())
      }
      is ScreenBox -> {
        stream.write(158)
        writeValue(stream, value.toList())
      }
      is ScreenCoordinate -> {
        stream.write(159)
        writeValue(stream, value.toList())
      }
      is Size -> {
        stream.write(160)
        writeValue(stream, value.toList())
      }
      is SourceQueryOptions -> {
        stream.write(161)
        writeValue(stream, value.toList())
      }
      is StyleObjectInfo -> {
        stream.write(162)
        writeValue(stream, value.toList())
      }
      is StyleProjection -> {
        stream.write(163)
        writeValue(stream, value.toList())
      }
      is StylePropertyValue -> {
        stream.write(164)
        writeValue(stream, value.toList())
      }
      is TileCacheBudgetInMegabytes -> {
        stream.write(165)
        writeValue(stream, value.toList())
      }
      is TileCacheBudgetInTiles -> {
        stream.write(166)
        writeValue(stream, value.toList())
      }
      is TileCoverOptions -> {
        stream.write(167)
        writeValue(stream, value.toList())
      }
      is TransitionOptions -> {
        stream.write(168)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Map class provides map rendering functionality.
 *
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface _MapInterface {
  fun loadStyleURI(styleURI: String, callback: (Result<Unit>) -> Unit)
  fun loadStyleJson(styleJson: String, callback: (Result<Unit>) -> Unit)
  fun clearData(callback: (Result<Unit>) -> Unit)
  fun setTileCacheBudget(tileCacheBudgetInMegabytes: TileCacheBudgetInMegabytes?, tileCacheBudgetInTiles: TileCacheBudgetInTiles?)
  /**
   * Gets the size of the map.
   *
   * @return The `size` of the map in `logical pixels`.
   */
  fun getSize(): Size
  /** Triggers a repaint of the map. */
  fun triggerRepaint()
  /**
   * Tells the map rendering engine that there is currently a gesture in progress. This
   * affects how the map renders labels, as it will use different texture filters if a gesture
   * is ongoing.
   *
   * @param inProgress The `boolean` value representing if a gesture is in progress.
   */
  fun setGestureInProgress(inProgress: Boolean)
  /**
   * Returns `true` if a gesture is currently in progress.
   *
   * @return `true` if a gesture is currently in progress, `false` otherwise.
   */
  fun isGestureInProgress(): Boolean
  /**
   * Tells the map rendering engine that the animation is currently performed by the
   * user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
   * In particular, it brings more stability to symbol placement and rendering.
   *
   * @param inProgress The `boolean` value representing if user animation is in progress
   */
  fun setUserAnimationInProgress(inProgress: Boolean)
  /**
   * Returns `true` if user animation is currently in progress.
   *
   * @return `true` if a user animation is currently in progress, `false` otherwise.
   */
  fun isUserAnimationInProgress(): Boolean
  /**
   * When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
   * the map will first request a tile at zoom level lower than `zoom - delta`, with requested
   * zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
   *
   * @param delta The new prefetch zoom delta.
   */
  fun setPrefetchZoomDelta(delta: Long)
  /**
   * Returns the map's prefetch zoom delta.
   *
   * @return The map's prefetch zoom `delta`.
   */
  fun getPrefetchZoomDelta(): Long
  /** Sets the north `orientation mode`. */
  fun setNorthOrientation(orientation: NorthOrientation)
  /** Sets the map `constrain mode`. */
  fun setConstrainMode(mode: ConstrainMode)
  /** Sets the `viewport mode`. */
  fun setViewportMode(mode: ViewportMode)
  /**
   * Returns the `map options`.
   *
   * @return The map's `map options`.
   */
  fun getMapOptions(): MapOptions
  /**
   * Returns the `map debug options`.
   *
   * @return An array of `map debug options` flags currently set to the map.
   */
  fun getDebug(): List<MapDebugOptions?>
  /**
   * Sets the `map debug options` and enables debug mode based on the passed value.
   *
   * @param debugOptions An array of `map debug options` to be set.
   * @param value A `boolean` value representing the state for a given `map debug options`.
   *
   */
  fun setDebug(debugOptions: List<MapDebugOptions?>, value: Boolean)
  /**
   * Queries the map for rendered features.
   *
   * @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
   * @param options The `render query options` for querying rendered features.
   * @param completion The `query features completion` called when the query completes.
   * @return A `cancelable` object that could be used to cancel the pending query.
   */
  fun queryRenderedFeatures(geometry: RenderedQueryGeometry, options: RenderedQueryOptions, callback: (Result<List<QueriedRenderedFeature?>>) -> Unit)
  /**
   * Queries the map for source features.
   *
   * @param sourceId The style source identifier used to query for source features.
   * @param options The `source query options` for querying source features.
   * @param completion The `query features completion` called when the query completes.
   */
  fun querySourceFeatures(sourceId: String, options: SourceQueryOptions, callback: (Result<List<QueriedSourceFeature?>>) -> Unit)
  /**
   * Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
   * to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
   *
   * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
   *
   * @param sourceIdentifier GeoJsonSource identifier.
   * @param cluster Cluster from which to retrieve leaves from
   * @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
   * @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
   * @param completion The result will be returned through the completion block.
   *         The result is a feature collection or a string describing an error if the operation was not successful.
   */
  fun getGeoJsonClusterLeaves(sourceIdentifier: String, cluster: Map<String?, Any?>, limit: Long?, offset: Long?, callback: (Result<FeatureExtensionValue>) -> Unit)
  /**
   * Returns the children (original points or clusters) of a cluster (on the next zoom level)
   * given its id (cluster_id value from feature properties) from a GeoJsonSource.
   *
   * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
   *
   * @param sourceIdentifier GeoJsonSource identifier.
   * @param cluster cluster from which to retrieve children from
   * @param completion The result will be returned through the completion block.
   *         The result is a feature collection or a string describing an error if the operation was not successful.
   */
  fun getGeoJsonClusterChildren(sourceIdentifier: String, cluster: Map<String?, Any?>, callback: (Result<FeatureExtensionValue>) -> Unit)
  /**
   * Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
   * given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
   *
   * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
   *
   * @param sourceIdentifier GeoJsonSource identifier.
   * @param cluster cluster from which to retrieve the expansion zoom from
   * @param completion The result will be returned through the completion block.
   *         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
   */
  fun getGeoJsonClusterExpansionZoom(sourceIdentifier: String, cluster: Map<String?, Any?>, callback: (Result<FeatureExtensionValue>) -> Unit)
  /**
   * Updates the state object of a feature within a style source.
   *
   * Update entries in the `state` object of a given feature within a style source. Only properties of the
   * `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
   * retain its previous value.
   *
   * Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
   * immediately visible using `getStateFeature`.
   *
   * @param sourceId The style source identifier.
   * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
   * @param featureId The feature identifier of the feature whose state should be updated.
   * @param state The `state` object with properties to update with their respective new values.
   */
  fun setFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, state: String, callback: (Result<Unit>) -> Unit)
  /**
   * Gets the state map of a feature within a style source.
   *
   * Note that updates to feature state are asynchronous, so changes made by other methods might not be
   * immediately visible.
   *
   * @param sourceId The style source identifier.
   * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
   * @param featureId The feature identifier of the feature whose state should be queried.
   * @param completion The `query feature state completion` called when the query completes.
   */
  fun getFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, callback: (Result<String>) -> Unit)
  /**
   * Removes entries from a feature state object.
   *
   * Remove a specified property or all property from a feature's state object, depending on the value of
   * `stateKey`.
   *
   * Note that updates to feature state are asynchronous, so changes made by this method migth not be
   * immediately visible using `getStateFeature`.
   *
   * @param sourceId The style source identifier.
   * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
   * @param featureId The feature identifier of the feature whose state should be removed.
   * @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
   */
  fun removeFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, stateKey: String?, callback: (Result<Unit>) -> Unit)
  /** Reduces memory use. Useful to call when the application gets paused or sent to background. */
  fun reduceMemoryUse()
  /**
   * Gets elevation for the given coordinate.
   * Note: Elevation is only available for the visible region on the screen.
   *
   * @param coordinate The `coordinate` defined as longitude-latitude pair.
   * @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
   */
  fun getElevation(coordinate: Point): Double?
  /** Returns array of tile identifiers that cover current map camera. */
  fun tileCover(options: TileCoverOptions): List<CanonicalTileID>

  companion object {
    /** The codec used by _MapInterface. */
    val codec: MessageCodec<Any?> by lazy {
      _MapInterfaceCodec
    }
    /** Sets up an instance of `_MapInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _MapInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleURIArg = args[0] as String
            api.loadStyleURI(styleURIArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleJsonArg = args[0] as String
            api.loadStyleJson(styleJsonArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.clearData() { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setTileCacheBudget$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tileCacheBudgetInMegabytesArg = args[0] as TileCacheBudgetInMegabytes?
            val tileCacheBudgetInTilesArg = args[1] as TileCacheBudgetInTiles?
            var wrapped: List<Any?>
            try {
              api.setTileCacheBudget(tileCacheBudgetInMegabytesArg, tileCacheBudgetInTilesArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSize())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.triggerRepaint()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val inProgressArg = args[0] as Boolean
            var wrapped: List<Any?>
            try {
              api.setGestureInProgress(inProgressArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isGestureInProgress())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val inProgressArg = args[0] as Boolean
            var wrapped: List<Any?>
            try {
              api.setUserAnimationInProgress(inProgressArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isUserAnimationInProgress())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val deltaArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.setPrefetchZoomDelta(deltaArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getPrefetchZoomDelta())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val orientationArg = NorthOrientation.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setNorthOrientation(orientationArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modeArg = ConstrainMode.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setConstrainMode(modeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modeArg = ViewportMode.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setViewportMode(modeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMapOptions())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDebug())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val debugOptionsArg = args[0] as List<MapDebugOptions?>
            val valueArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.setDebug(debugOptionsArg, valueArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val geometryArg = args[0] as RenderedQueryGeometry
            val optionsArg = args[1] as RenderedQueryOptions
            api.queryRenderedFeatures(geometryArg, optionsArg) { result: Result<List<QueriedRenderedFeature?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val optionsArg = args[1] as SourceQueryOptions
            api.querySourceFeatures(sourceIdArg, optionsArg) { result: Result<List<QueriedSourceFeature?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdentifierArg = args[0] as String
            val clusterArg = args[1] as Map<String?, Any?>
            val limitArg = args[2].let { if (it is Int) it.toLong() else it as Long? }
            val offsetArg = args[3].let { if (it is Int) it.toLong() else it as Long? }
            api.getGeoJsonClusterLeaves(sourceIdentifierArg, clusterArg, limitArg, offsetArg) { result: Result<FeatureExtensionValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdentifierArg = args[0] as String
            val clusterArg = args[1] as Map<String?, Any?>
            api.getGeoJsonClusterChildren(sourceIdentifierArg, clusterArg) { result: Result<FeatureExtensionValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdentifierArg = args[0] as String
            val clusterArg = args[1] as Map<String?, Any?>
            api.getGeoJsonClusterExpansionZoom(sourceIdentifierArg, clusterArg) { result: Result<FeatureExtensionValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val sourceLayerIdArg = args[1] as String?
            val featureIdArg = args[2] as String
            val stateArg = args[3] as String
            api.setFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, stateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val sourceLayerIdArg = args[1] as String?
            val featureIdArg = args[2] as String
            api.getFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val sourceLayerIdArg = args[1] as String?
            val featureIdArg = args[2] as String
            val stateKeyArg = args[3] as String?
            api.removeFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, stateKeyArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.reduceMemoryUse()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinateArg = args[0] as Point
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getElevation(coordinateArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.tileCover$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val optionsArg = args[0] as TileCoverOptions
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.tileCover(optionsArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object OfflineRegionCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBounds.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionGeometryDefinition.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionTilePyramidDefinition.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is CoordinateBounds -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is OfflineRegionGeometryDefinition -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is OfflineRegionTilePyramidDefinition -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is Point -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * An offline region represents an identifiable geographic region with optional metadata.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface OfflineRegion {
  /** The regions identifier */
  fun getIdentifier(): Long
  /**
   * The tile pyramid defining the region. Tile pyramid and geometry definitions are
   * mutually exclusive.
   *
   * @return A definition describing the tile pyramid including attributes, otherwise empty.
   */
  fun getTilePyramidDefinition(): OfflineRegionTilePyramidDefinition?
  /**
   * The geometry defining the region. Geometry and tile pyramid definitions are
   * mutually exclusive.
   *
   * @return A definition describing the geometry including attributes, otherwise empty.
   */
  fun getGeometryDefinition(): OfflineRegionGeometryDefinition?
  /**
   * Arbitrary binary region metadata.
   *
   * @return The metadata associated with the region.
   */
  fun getMetadata(): ByteArray
  /**
   * Sets arbitrary binary region metadata for the region.
   *
   * Note that this setter is asynchronous and the given metadata is applied only
   * after the resulting callback is invoked with no error.
   *
   * @param metadata The metadata associated with the region.
   * @param callback Called once the request is complete or an error occurred.
   */
  fun setMetadata(metadata: ByteArray, callback: (Result<Unit>) -> Unit)
  /**
   * Sets the download state of an offline region
   * A region is either inactive (not downloading, but previously-downloaded
   * resources are available for use), or active (resources are being downloaded
   * or will be downloaded, if necessary, when network access is available).
   *
   * If the region is already in the given state, this call is ignored.
   *
   * @param state The new state to set.
   */
  fun setOfflineRegionDownloadState(state: OfflineRegionDownloadState)
  /**
   * Invalidate all the tiles for the region forcing to revalidate
   * the tiles with the server before using. This is more efficient than deleting the
   * offline region and downloading it again because if the data on the cache matches
   * the server, no new data gets transmitted.
   *
   * @param callback Called once the request is complete or an error occurred.
   */
  fun invalidate(callback: (Result<Unit>) -> Unit)
  /**
   * Remove an offline region from the database and perform any resources
   * evictions necessary as a result.
   *
   * @param callback Called once the request is complete or an error occurred.
   */
  fun purge(callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by OfflineRegion. */
    val codec: MessageCodec<Any?> by lazy {
      OfflineRegionCodec
    }
    /** Sets up an instance of `OfflineRegion` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: OfflineRegion?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getIdentifier$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getIdentifier())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getTilePyramidDefinition$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getTilePyramidDefinition())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getGeometryDefinition$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getGeometryDefinition())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getMetadata$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMetadata())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setMetadata$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val metadataArg = args[0] as ByteArray
            api.setMetadata(metadataArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setOfflineRegionDownloadState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val stateArg = OfflineRegionDownloadState.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setOfflineRegionDownloadState(stateArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.invalidate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.invalidate() { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.purge$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.purge() { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * The `offline region manager` that manages offline packs. All of the classâ€™s instance methods are asynchronous
 * reflecting the fact that offline resources are stored in a database. The offline manager maintains a canonical
 * collection of offline packs.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface OfflineRegionManager {
  /**
   * Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
   *
   * By default, the limit is set to 6,000.
   * Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
   * fires every additional attempt to download additional tiles until already downloaded tiles are removed
   * by calling `OfflineRegion.purge()` API.
   *
   * @param limit the maximum number of tiles allowed to be downloaded
   */
  fun setOfflineMapboxTileCountLimit(limit: Long)

  companion object {
    /** The codec used by OfflineRegionManager. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `OfflineRegionManager` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: OfflineRegionManager?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegionManager.setOfflineMapboxTileCountLimit$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val limitArg = args[0].let { if (it is Int) it.toLong() else it as Long }
            var wrapped: List<Any?>
            try {
              api.setOfflineMapboxTileCountLimit(limitArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object ProjectionCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MercatorCoordinate.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ProjectedMeters.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is MercatorCoordinate -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is Point -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is ProjectedMeters -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Collection of [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection methods.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface Projection {
  /**
   * Calculate distance spanned by one pixel at the specified latitude
   * and zoom level.
   *
   * @param latitude The latitude for which to return the value.
   * @param zoom The zoom level.
   *
   * @return Returns the distance measured in meters.
   */
  fun getMetersPerPixelAtLatitude(latitude: Double, zoom: Double): Double
  /**
   * Calculate Spherical Mercator ProjectedMeters coordinates.
   *
   * @param coordinate A longitude-latitude pair for which to calculate
   * `projected meters` coordinates.
   *
   * @return Returns Spherical Mercator ProjectedMeters coordinates.
   */
  fun projectedMetersForCoordinate(coordinate: Point): ProjectedMeters
  /**
   * Calculate a longitude-latitude pair for a Spherical Mercator projected
   * meters.
   *
   * @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
   * which to calculate a longitude-latitude pair.
   *
   * @return Returns a longitude-latitude pair.
   */
  fun coordinateForProjectedMeters(projectedMeters: ProjectedMeters): Point
  /**
   * Calculate a point on the map in Mercator Projection for a given
   * coordinate at the specified zoom scale.
   *
   * @param coordinate The longitude-latitude pair for which to return the value.
   * @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
   * calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
   * where tileSize is the width of a tile in pixels.
   *
   * @return Returns a point on the map in Mercator projection.
   */
  fun project(coordinate: Point, zoomScale: Double): MercatorCoordinate
  /**
   * Calculate a coordinate for a given point on the map in Mercator Projection.
   *
   * @param coordinate Point on the map in Mercator projection.
   * @param zoomScale The current zoom factor applied on the map, is used to
   * calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
   * where tileSize is the width of a tile in pixels.
   *
   * @return Returns a coordinate.
   */
  fun unproject(coordinate: MercatorCoordinate, zoomScale: Double): Point

  companion object {
    /** The codec used by Projection. */
    val codec: MessageCodec<Any?> by lazy {
      ProjectionCodec
    }
    /** Sets up an instance of `Projection` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: Projection?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val latitudeArg = args[0] as Double
            val zoomArg = args[1] as Double
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getMetersPerPixelAtLatitude(latitudeArg, zoomArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinateArg = args[0] as Point
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.projectedMetersForCoordinate(coordinateArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val projectedMetersArg = args[0] as ProjectedMeters
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.coordinateForProjectedMeters(projectedMetersArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.project$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinateArg = args[0] as Point
            val zoomScaleArg = args[1] as Double
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.project(coordinateArg, zoomScaleArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val coordinateArg = args[0] as MercatorCoordinate
            val zoomScaleArg = args[1] as Double
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.unproject(coordinateArg, zoomScaleArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface _MapboxOptions {
  fun getAccessToken(): String
  fun setAccessToken(token: String)

  companion object {
    /** The codec used by _MapboxOptions. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `_MapboxOptions` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _MapboxOptions?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.getAccessToken$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getAccessToken())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.setAccessToken$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tokenArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.setAccessToken(tokenArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface _MapboxMapsOptions {
  fun getBaseUrl(): String
  fun setBaseUrl(url: String)
  fun getDataPath(): String
  fun setDataPath(path: String)
  fun getAssetPath(): String
  fun setAssetPath(path: String)
  fun getTileStoreUsageMode(): TileStoreUsageMode
  fun setTileStoreUsageMode(mode: TileStoreUsageMode)
  fun getWorldview(): String?
  fun setWorldview(worldview: String?)
  fun getLanguage(): String?
  fun setLanguage(language: String?)

  companion object {
    /** The codec used by _MapboxMapsOptions. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `_MapboxMapsOptions` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _MapboxMapsOptions?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getBaseUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getBaseUrl())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setBaseUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.setBaseUrl(urlArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getDataPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getDataPath())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setDataPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pathArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.setDataPath(pathArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getAssetPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getAssetPath())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setAssetPath$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val pathArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.setAssetPath(pathArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getTileStoreUsageMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getTileStoreUsageMode().raw)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setTileStoreUsageMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modeArg = TileStoreUsageMode.ofRaw(args[0] as Int)!!
            var wrapped: List<Any?>
            try {
              api.setTileStoreUsageMode(modeArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getWorldview$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getWorldview())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setWorldview$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val worldviewArg = args[0] as String?
            var wrapped: List<Any?>
            try {
              api.setWorldview(worldviewArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getLanguage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getLanguage())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setLanguage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val languageArg = args[0] as String?
            var wrapped: List<Any?>
            try {
              api.setLanguage(languageArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Settings class provides non-persistent, in-process key-value storage.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface Settings {
  /**
   * Sets setting value for a specified key.
   *
   * @param key A name of the key.
   * @param value The `value` for the key.
   */
  fun set(key: String, value: String)
  /**
   * Return value for a key.
   *
   * @param key A name of the key.
   *
   * @return `value` if a key exists in settings otherwise a `null value` will be returned.
   */
  fun get(key: String): String

  companion object {
    /** The codec used by Settings. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `Settings` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: Settings?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Settings.set$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val keyArg = args[0] as String
            val valueArg = args[1] as String
            var wrapped: List<Any?>
            try {
              api.set(keyArg, valueArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Settings.get$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val keyArg = args[0] as String
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.get(keyArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object StyleManagerCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AmbientLight.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraBounds.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraBoundsOptions.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraOptions.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CameraState.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CanonicalTileID.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBounds.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CoordinateBoundsZoom.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DirectionalLight.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FeatureExtensionValue.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FlatLight.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GlyphsRasterizationOptions.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageContent.fromList(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageStretches.fromList(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LayerPosition.fromList(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapAnimationOptions.fromList(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapDebugOptions.fromList(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MapOptions.fromList(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxEdgeInsets.fromList(it)
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MbxImage.fromList(it)
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MercatorCoordinate.fromList(it)
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionGeometryDefinition.fromList(it)
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          OfflineRegionTilePyramidDefinition.fromList(it)
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ProjectedMeters.fromList(it)
        }
      }
      153.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedFeature.fromList(it)
        }
      }
      154.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedRenderedFeature.fromList(it)
        }
      }
      155.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          QueriedSourceFeature.fromList(it)
        }
      }
      156.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RenderedQueryGeometry.fromList(it)
        }
      }
      157.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RenderedQueryOptions.fromList(it)
        }
      }
      158.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenBox.fromList(it)
        }
      }
      159.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      160.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Size.fromList(it)
        }
      }
      161.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceQueryOptions.fromList(it)
        }
      }
      162.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StyleObjectInfo.fromList(it)
        }
      }
      163.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StyleProjection.fromList(it)
        }
      }
      164.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StylePropertyValue.fromList(it)
        }
      }
      165.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCacheBudgetInMegabytes.fromList(it)
        }
      }
      166.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCacheBudgetInTiles.fromList(it)
        }
      }
      167.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TileCoverOptions.fromList(it)
        }
      }
      168.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TransitionOptions.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is AmbientLight -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is CameraBounds -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is CameraBoundsOptions -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is CameraOptions -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is CameraState -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is CanonicalTileID -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is CoordinateBounds -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is CoordinateBoundsZoom -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is DirectionalLight -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is FeatureExtensionValue -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is FlatLight -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is GlyphsRasterizationOptions -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is ImageContent -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      is ImageStretches -> {
        stream.write(141)
        writeValue(stream, value.toList())
      }
      is LayerPosition -> {
        stream.write(142)
        writeValue(stream, value.toList())
      }
      is MapAnimationOptions -> {
        stream.write(143)
        writeValue(stream, value.toList())
      }
      is MapDebugOptions -> {
        stream.write(144)
        writeValue(stream, value.toList())
      }
      is MapOptions -> {
        stream.write(145)
        writeValue(stream, value.toList())
      }
      is MbxEdgeInsets -> {
        stream.write(146)
        writeValue(stream, value.toList())
      }
      is MbxImage -> {
        stream.write(147)
        writeValue(stream, value.toList())
      }
      is MercatorCoordinate -> {
        stream.write(148)
        writeValue(stream, value.toList())
      }
      is OfflineRegionGeometryDefinition -> {
        stream.write(149)
        writeValue(stream, value.toList())
      }
      is OfflineRegionTilePyramidDefinition -> {
        stream.write(150)
        writeValue(stream, value.toList())
      }
      is Point -> {
        stream.write(151)
        writeValue(stream, value.toList())
      }
      is ProjectedMeters -> {
        stream.write(152)
        writeValue(stream, value.toList())
      }
      is QueriedFeature -> {
        stream.write(153)
        writeValue(stream, value.toList())
      }
      is QueriedRenderedFeature -> {
        stream.write(154)
        writeValue(stream, value.toList())
      }
      is QueriedSourceFeature -> {
        stream.write(155)
        writeValue(stream, value.toList())
      }
      is RenderedQueryGeometry -> {
        stream.write(156)
        writeValue(stream, value.toList())
      }
      is RenderedQueryOptions -> {
        stream.write(157)
        writeValue(stream, value.toList())
      }
      is ScreenBox -> {
        stream.write(158)
        writeValue(stream, value.toList())
      }
      is ScreenCoordinate -> {
        stream.write(159)
        writeValue(stream, value.toList())
      }
      is Size -> {
        stream.write(160)
        writeValue(stream, value.toList())
      }
      is SourceQueryOptions -> {
        stream.write(161)
        writeValue(stream, value.toList())
      }
      is StyleObjectInfo -> {
        stream.write(162)
        writeValue(stream, value.toList())
      }
      is StyleProjection -> {
        stream.write(163)
        writeValue(stream, value.toList())
      }
      is StylePropertyValue -> {
        stream.write(164)
        writeValue(stream, value.toList())
      }
      is TileCacheBudgetInMegabytes -> {
        stream.write(165)
        writeValue(stream, value.toList())
      }
      is TileCacheBudgetInTiles -> {
        stream.write(166)
        writeValue(stream, value.toList())
      }
      is TileCoverOptions -> {
        stream.write(167)
        writeValue(stream, value.toList())
      }
      is TransitionOptions -> {
        stream.write(168)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Interface for managing style of the `map`.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface StyleManager {
  /**
   * Get the URI of the current style in use.
   *
   * @return A string containing a style URI.
   */
  fun getStyleURI(callback: (Result<String>) -> Unit)
  /**
   * Load style from provided URI.
   *
   * This is an asynchronous call. To check the result of this operation the user must register an observer observing
   * `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
   *
   * @param uri URI where the style should be loaded from.
   */
  fun setStyleURI(uri: String, callback: (Result<Unit>) -> Unit)
  /**
   * Get the JSON serialization string of the current style in use.
   *
   * @return A JSON string containing a serialized style.
   */
  fun getStyleJSON(callback: (Result<String>) -> Unit)
  /**
   * Load the style from a provided JSON string.
   *
   * @param json A JSON string containing a serialized style.
   */
  fun setStyleJSON(json: String, callback: (Result<Unit>) -> Unit)
  /**
   * Returns the map style's default camera, if any, or a default camera otherwise.
   * The map style's default camera is defined as follows:
   * - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
   * - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
   * - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
   * - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
   *
   * The style default camera is re-evaluated when a new style is loaded.
   *
   * @return The default `camera options` of the current style in use.
   */
  fun getStyleDefaultCamera(callback: (Result<CameraOptions>) -> Unit)
  /**
   * Returns the map style's transition options. By default, the style parser will attempt
   * to read the style default transition options, if any, fallbacking to an immediate transition
   * otherwise. Transition options can be overriden via `setStyleTransition`, but the options are
   * reset once a new style has been loaded.
   *
   * The style transition is re-evaluated when a new style is loaded.
   *
   * @return The `transition options` of the current style in use.
   */
  fun getStyleTransition(callback: (Result<TransitionOptions>) -> Unit)
  /** Returns the list containing information about existing style import objects. */
  fun getStyleImports(): List<StyleObjectInfo?>
  /**
   * Removes an existing style import.
   *
   * @param importId Identifier of the style import to remove.
   */
  fun removeStyleImport(importId: String)
  /**
   * Gets the style import schema.
   *
   * @param importId Identifier of the style import.
   *
   * Returns the style import schema, containing the default configurations for the style import.
   */
  fun getStyleImportSchema(importId: String): Any
  /**
   * Gets style import config.
   *
   * @param importId Identifier of the style import.
   *
   * Returns the style import configuration or a string describing an error if the operation was not successful.
   */
  fun getStyleImportConfigProperties(importId: String): Map<String, StylePropertyValue>
  /**
   * Gets the value of style import config.
   *
   * @param importId Identifier of the style import.
   * @param config The style import config name.
   *
   * Returns the style import configuration or a string describing an error if the operation was not successful.
   */
  fun getStyleImportConfigProperty(importId: String, config: String): StylePropertyValue
  /**
   * Sets style import config.
   * This method can be used to perform batch update for a style import configurations.
   *
   * @param importId Identifier of the style import.
   * @param configs A map of style import configurations.
   */
  fun setStyleImportConfigProperties(importId: String, configs: Map<String, Any>)
  /**
   * Sets a value to a style import config.
   *
   * @param importId Identifier of the style import.
   * @param config The style import config name.
   * @param value The style import config value.
   */
  fun setStyleImportConfigProperty(importId: String, config: String, value: Any)
  /**
   * Overrides the map style's transition options with user-provided options.
   *
   * The style transition is re-evaluated when a new style is loaded.
   *
   * @param transitionOptions The `transition options`.
   */
  fun setStyleTransition(transitionOptions: TransitionOptions, callback: (Result<Unit>) -> Unit)
  /**
   * Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
   *
   * Runtime style layers are valid until they are either removed or a new style is loaded.
   *
   * @param properties A map of style layer properties.
   * @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
   *
   * @return A string describing an error if the operation was not successful, or empty otherwise.
   */
  fun addStyleLayer(properties: String, layerPosition: LayerPosition?, callback: (Result<Unit>) -> Unit)
  /**
   * Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
   *
   * Whenever a new style is being parsed and currently used style has persistent layers,
   * an engine will try to do following:
   *   - keep the persistent layer at its relative position
   *   - keep the source used by a persistent layer
   *   - keep images added through `addStyleImage` method
   *
   * In cases when a new style has the same layer, source or image resource, style's resources would be
   * used instead and `MapLoadingError` event will be emitted.
   *
   * @param properties A map of style layer properties.
   * @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
   *
   * @return A string describing an error if the operation was not successful, or empty otherwise.
   */
  fun addPersistentStyleLayer(properties: String, layerPosition: LayerPosition?, callback: (Result<Unit>) -> Unit)
  /**
   * Checks if a style layer is persistent.
   *
   * @param layerId A style layer identifier.
   * @return A string describing an error if the operation was not successful, boolean representing state otherwise.
   */
  fun isStyleLayerPersistent(layerId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Removes an existing style layer.
   *
   * @param layerId An identifier of the style layer to remove.
   *
   * @return A string describing an error if the operation was not successful, or empty otherwise.
   */
  fun removeStyleLayer(layerId: String, callback: (Result<Unit>) -> Unit)
  /**
   * Moves an existing style layer
   *
   * @param layerId Identifier of the style layer to move.
   * @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
   *                      is provided then the layer is moved to the top of the layerstack.
   *
   * @return A string describing an error if the operation was not successful, or empty otherwise.
   */
  fun moveStyleLayer(layerId: String, layerPosition: LayerPosition?, callback: (Result<Unit>) -> Unit)
  /**
   * Checks whether a given style layer exists.
   *
   * @param layerId Style layer identifier.
   *
   * @return A `true` value if the given style layer exists, `false` otherwise.
   */
  fun styleLayerExists(layerId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Returns the existing style layers.
   *
   * @return The list containing the information about existing style layer objects.
   */
  fun getStyleLayers(callback: (Result<List<StyleObjectInfo?>>) -> Unit)
  /**
   * Gets the value of style layer property.
   *
   * @param layerId A style layer identifier.
   * @param property The style layer property name.
   * @return The `style property value`.
   */
  fun getStyleLayerProperty(layerId: String, property: String, callback: (Result<StylePropertyValue>) -> Unit)
  /**
   * Sets a value to a style layer property.
   *
   * @param layerId A style layer identifier.
   * @param property The style layer property name.
   * @param value The style layer property value.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleLayerProperty(layerId: String, property: String, value: Any, callback: (Result<Unit>) -> Unit)
  /**
   * Gets style layer properties.
   *
   * @return The style layer properties or a string describing an error if the operation was not successful.
   */
  fun getStyleLayerProperties(layerId: String, callback: (Result<String>) -> Unit)
  /**
   * Sets style layer properties.
   * This method can be used to perform batch update for a style layer properties. The structure of a
   * provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
   * Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
   *
   * @param layerId A style layer identifier.
   * @param properties A map of style layer properties.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleLayerProperties(layerId: String, properties: String, callback: (Result<Unit>) -> Unit)
  /**
   * Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
   *
   * @param sourceId An identifier for the style source.
   * @param properties A map of style source properties.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun addStyleSource(sourceId: String, properties: String, callback: (Result<Unit>) -> Unit)
  /**
   * Gets the value of style source property.
   *
   * @param sourceId A style source identifier.
   * @param property The style source property name.
   * @return The value of a `property` in the source with a `sourceId`.
   */
  fun getStyleSourceProperty(sourceId: String, property: String, callback: (Result<StylePropertyValue>) -> Unit)
  /**
   * Sets a value to a style source property.
   * Note: When setting the `data` property of a `geojson` source, this method never returns an error.
   * In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
   *
   *
   * @param sourceId A style source identifier.
   * @param property The style source property name.
   * @param value The style source property value.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleSourceProperty(sourceId: String, property: String, value: Any, callback: (Result<Unit>) -> Unit)
  /**
   * Gets style source properties.
   *
   * @param sourceId A style source identifier.
   *
   * @return The style source properties or a string describing an error if the operation was not successful.
   */
  fun getStyleSourceProperties(sourceId: String, callback: (Result<String>) -> Unit)
  /**
   * Sets style source properties.
   *
   * This method can be used to perform batch update for a style source properties. The structure of a
   * provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
   * Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
   *
   * @param sourceId A style source identifier.
   * @param properties A map of Style source properties.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleSourceProperties(sourceId: String, properties: String, callback: (Result<Unit>) -> Unit)
  /**
   * Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
   *
   * @param sourceId A style source identifier.
   * @param image An `image`.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun updateStyleImageSourceImage(sourceId: String, image: MbxImage, callback: (Result<Unit>) -> Unit)
  /**
   * Removes an existing style source.
   *
   * @param sourceId An identifier of the style source to remove.
   */
  fun removeStyleSource(sourceId: String, callback: (Result<Unit>) -> Unit)
  /**
   * Checks whether a given style source exists.
   *
   * @param sourceId A style source identifier.
   *
   * @return `true` if the given source exists, `false` otherwise.
   */
  fun styleSourceExists(sourceId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Returns the existing style sources.
   *
   * @return The list containing the information about existing style source objects.
   */
  fun getStyleSources(callback: (Result<List<StyleObjectInfo?>>) -> Unit)
  /** Returns an ordered list of the current style lights. */
  fun getStyleLights(): List<StyleObjectInfo?>
  /**
   * Set global directional lightning.
   *
   * @param flatLight The flat light source.
   */
  fun setLight(flatLight: FlatLight)
  /**
   * Set dynamic lightning.
   *
   * @param ambientLight The ambient light source.
   * @param directionalLight The directional light source.
   */
  fun setLights(ambientLight: AmbientLight, directionalLight: DirectionalLight)
  /**
   * Gets the value of a style light property.
   *
   * @param property The style light property name.
   * @param id The unique identifier of the style light in lights list.
   * @return The style light property value.
   */
  fun getStyleLightProperty(id: String, property: String, callback: (Result<StylePropertyValue>) -> Unit)
  /**
   * Sets a value to the the style light property.
   *
   * @param property The style light property name.
   * @param id The unique identifier of the style light in lights list.
   * @param value The style light property value.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleLightProperty(id: String, property: String, value: Any, callback: (Result<Unit>) -> Unit)
  /**
   * Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
   *
   * @param properties A map of style terrain properties values, with their names as a key.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleTerrain(properties: String, callback: (Result<Unit>) -> Unit)
  /**
   * Gets the value of a style terrain property.
   *
   * @param property The style terrain property name.
   * @return The style terrain property value.
   */
  fun getStyleTerrainProperty(property: String, callback: (Result<StylePropertyValue>) -> Unit)
  /**
   * Sets a value to the the style terrain property.
   *
   * @param property The style terrain property name.
   * @param value The style terrain property value.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun setStyleTerrainProperty(property: String, value: Any, callback: (Result<Unit>) -> Unit)
  /**
   * Get an `image` from the style.
   *
   * @param imageId The identifier of the `image`.
   *
   * @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
   */
  fun getStyleImage(imageId: String, callback: (Result<MbxImage?>) -> Unit)
  /**
   * Adds an image to be used in the style. This API can also be used for updating
   * an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
   *
   * The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
   * [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
   * [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
   * [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
   *
   * @param imageId An identifier of the image.
   * @param scale A scale factor for the image.
   * @param image A pixel data of the image.
   * @param sdf An option to treat whether image is SDF(signed distance field) or not.
   * @param stretchX An array of two-element arrays, consisting of two numbers that represent
   * the from position and the to position of areas that can be stretched horizontally.
   * @param stretchY An array of two-element arrays, consisting of two numbers that represent
   * the from position and the to position of areas that can be stretched vertically.
   * @param content An array of four numbers, with the first two specifying the left, top
   * corner, and the last two specifying the right, bottom corner. If present, and if the
   * icon uses icon-text-fit, the symbol's text will be fit inside the content box.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun addStyleImage(imageId: String, scale: Double, image: MbxImage, sdf: Boolean, stretchX: List<ImageStretches?>, stretchY: List<ImageStretches?>, content: ImageContent?, callback: (Result<Unit>) -> Unit)
  /**
   * Removes an image from the style.
   *
   * @param imageId The identifier of the image to remove.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun removeStyleImage(imageId: String, callback: (Result<Unit>) -> Unit)
  /**
   * Checks whether an image exists.
   *
   * @param imageId The identifier of the image.
   *
   * @return True if image exists, false otherwise.
   */
  fun hasStyleImage(imageId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Set tile data of a custom geometry.
   *
   * @param sourceId A style source identifier.
   * @param tileId A `canonical tile id` of the tile.
   * @param featureCollection An array with the features to add.
   * Invalidate tile for provided custom geometry source.
   *
   * @param sourceId A style source identifier,.
   * @param tileId A `canonical tile id` of the tile.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun invalidateStyleCustomGeometrySourceTile(sourceId: String, tileId: CanonicalTileID, callback: (Result<Unit>) -> Unit)
  /**
   * Invalidate region for provided custom geometry source.
   *
   * @param sourceId A style source identifier
   * @param bounds A `coordinate bounds` object.
   *
   * @return A string describing an error if the operation was not successful, empty otherwise.
   */
  fun invalidateStyleCustomGeometrySourceRegion(sourceId: String, bounds: CoordinateBounds, callback: (Result<Unit>) -> Unit)
  /**
   * Check if the style is completely loaded.
   *
   * Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
   * Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
   *
   * @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
   *
   */
  fun isStyleLoaded(callback: (Result<Boolean>) -> Unit)
  /**
   * Function to get the projection provided by the Style Extension.
   *
   * @return Projection that is currently applied to the map
   */
  fun getProjection(): StyleProjection?
  /**
   * Function to set the projection provided by the Style Extension.
   *
   * @param projection The projection to be set.
   */
  fun setProjection(projection: StyleProjection)
  /**
   * Function to localize style labels.
   *
   * @param locale The locale to apply for localization
   * @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
   */
  fun localizeLabels(locale: String, layerIds: List<String>?, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by StyleManager. */
    val codec: MessageCodec<Any?> by lazy {
      StyleManagerCodec
    }
    /** Sets up an instance of `StyleManager` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: StyleManager?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getStyleURI() { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val uriArg = args[0] as String
            api.setStyleURI(uriArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getStyleJSON() { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val jsonArg = args[0] as String
            api.setStyleJSON(jsonArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getStyleDefaultCamera() { result: Result<CameraOptions> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getStyleTransition() { result: Result<TransitionOptions> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImports$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getStyleImports())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImport$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val importIdArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.removeStyleImport(importIdArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportSchema$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val importIdArg = args[0] as String
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getStyleImportSchema(importIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val importIdArg = args[0] as String
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getStyleImportConfigProperties(importIdArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val importIdArg = args[0] as String
            val configArg = args[1] as String
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getStyleImportConfigProperty(importIdArg, configArg))
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val importIdArg = args[0] as String
            val configsArg = args[1] as Map<String, Any>
            var wrapped: List<Any?>
            try {
              api.setStyleImportConfigProperties(importIdArg, configsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val importIdArg = args[0] as String
            val configArg = args[1] as String
            val valueArg = args[2] as Any
            var wrapped: List<Any?>
            try {
              api.setStyleImportConfigProperty(importIdArg, configArg, valueArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val transitionOptionsArg = args[0] as TransitionOptions
            api.setStyleTransition(transitionOptionsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val propertiesArg = args[0] as String
            val layerPositionArg = args[1] as LayerPosition?
            api.addStyleLayer(propertiesArg, layerPositionArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val propertiesArg = args[0] as String
            val layerPositionArg = args[1] as LayerPosition?
            api.addPersistentStyleLayer(propertiesArg, layerPositionArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            api.isStyleLayerPersistent(layerIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            api.removeStyleLayer(layerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            val layerPositionArg = args[1] as LayerPosition?
            api.moveStyleLayer(layerIdArg, layerPositionArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            api.styleLayerExists(layerIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getStyleLayers() { result: Result<List<StyleObjectInfo?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            val propertyArg = args[1] as String
            api.getStyleLayerProperty(layerIdArg, propertyArg) { result: Result<StylePropertyValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            val propertyArg = args[1] as String
            val valueArg = args[2] as Any
            api.setStyleLayerProperty(layerIdArg, propertyArg, valueArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            api.getStyleLayerProperties(layerIdArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val layerIdArg = args[0] as String
            val propertiesArg = args[1] as String
            api.setStyleLayerProperties(layerIdArg, propertiesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val propertiesArg = args[1] as String
            api.addStyleSource(sourceIdArg, propertiesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val propertyArg = args[1] as String
            api.getStyleSourceProperty(sourceIdArg, propertyArg) { result: Result<StylePropertyValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val propertyArg = args[1] as String
            val valueArg = args[2] as Any
            api.setStyleSourceProperty(sourceIdArg, propertyArg, valueArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            api.getStyleSourceProperties(sourceIdArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val propertiesArg = args[1] as String
            api.setStyleSourceProperties(sourceIdArg, propertiesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val imageArg = args[1] as MbxImage
            api.updateStyleImageSourceImage(sourceIdArg, imageArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            api.removeStyleSource(sourceIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            api.styleSourceExists(sourceIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getStyleSources() { result: Result<List<StyleObjectInfo?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLights$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getStyleLights())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLight$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val flatLightArg = args[0] as FlatLight
            var wrapped: List<Any?>
            try {
              api.setLight(flatLightArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLights$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val ambientLightArg = args[0] as AmbientLight
            val directionalLightArg = args[1] as DirectionalLight
            var wrapped: List<Any?>
            try {
              api.setLights(ambientLightArg, directionalLightArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idArg = args[0] as String
            val propertyArg = args[1] as String
            api.getStyleLightProperty(idArg, propertyArg) { result: Result<StylePropertyValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idArg = args[0] as String
            val propertyArg = args[1] as String
            val valueArg = args[2] as Any
            api.setStyleLightProperty(idArg, propertyArg, valueArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val propertiesArg = args[0] as String
            api.setStyleTerrain(propertiesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val propertyArg = args[0] as String
            api.getStyleTerrainProperty(propertyArg) { result: Result<StylePropertyValue> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val propertyArg = args[0] as String
            val valueArg = args[1] as Any
            api.setStyleTerrainProperty(propertyArg, valueArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageIdArg = args[0] as String
            api.getStyleImage(imageIdArg) { result: Result<MbxImage?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageIdArg = args[0] as String
            val scaleArg = args[1] as Double
            val imageArg = args[2] as MbxImage
            val sdfArg = args[3] as Boolean
            val stretchXArg = args[4] as List<ImageStretches?>
            val stretchYArg = args[5] as List<ImageStretches?>
            val contentArg = args[6] as ImageContent?
            api.addStyleImage(imageIdArg, scaleArg, imageArg, sdfArg, stretchXArg, stretchYArg, contentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageIdArg = args[0] as String
            api.removeStyleImage(imageIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val imageIdArg = args[0] as String
            api.hasStyleImage(imageIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val tileIdArg = args[1] as CanonicalTileID
            api.invalidateStyleCustomGeometrySourceTile(sourceIdArg, tileIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sourceIdArg = args[0] as String
            val boundsArg = args[1] as CoordinateBounds
            api.invalidateStyleCustomGeometrySourceRegion(sourceIdArg, boundsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.isStyleLoaded() { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getProjection())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val projectionArg = args[0] as StyleProjection
            var wrapped: List<Any?>
            try {
              api.setProjection(projectionArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val localeArg = args[0] as String
            val layerIdsArg = args[1] as List<String>?
            api.localizeLabels(localeArg, layerIdsArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Allows to cancel the associated asynchronous operation
 *
 * The the associated asynchronous operation is not automatically canceled if this
 * object goes out of scope.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface Cancelable {
  /**
   * Cancels the associated asynchronous operation
   *
   * If the associated asynchronous operation has already finished, this call is ignored.
   */
  fun cancel()

  companion object {
    /** The codec used by Cancelable. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `Cancelable` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: Cancelable?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.cancel()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Instance that allows connecting or disconnecting the Mapbox stack to the network.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface OfflineSwitch {
  /**
   * Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
   * with HttpRequestErrorType#ConnectionError.
   *
   * @param connected Set false to disconnect the Mapbox stack
   */
  fun setMapboxStackConnected(connected: Boolean)
  /**
   * Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
   *
   * @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
   */
  fun isMapboxStackConnected(): Boolean
  /**
   * Releases the OfflineSwitch singleton instance.
   *
   * Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
   * If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
   */
  fun reset()

  companion object {
    /** The codec used by OfflineSwitch. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `OfflineSwitch` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: OfflineSwitch?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.setMapboxStackConnected$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val connectedArg = args[0] as Boolean
            var wrapped: List<Any?>
            try {
              api.setMapboxStackConnected(connectedArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.isMapboxStackConnected$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.isMapboxStackConnected())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.reset$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              api.reset()
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * A bundle that encapsulates tilesets creation for the tile store implementation.
 *
 * Tileset descriptors describe the type of data that should be part of the Offline Region, like the routing profile for Navigation and the Tilesets of the Map style.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface TilesetDescriptor {

  companion object {
    /** The codec used by TilesetDescriptor. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `TilesetDescriptor` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: TilesetDescriptor?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    }
  }
}