// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.mapbox_maps.pigeons

import android.util.Log
import com.mapbox.geojson.Point
import com.mapbox.maps.mapbox_maps.mapping.turf.*
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error", "Unable to establish connection on channel: '$channelName'.", "")
}

/** Part of the icon placed closest to the anchor. */
enum class IconAnchor(val raw: Int) {
  /** The center of the icon is placed closest to the anchor. */
  CENTER(0),
  /** The left side of the icon is placed closest to the anchor. */
  LEFT(1),
  /** The right side of the icon is placed closest to the anchor. */
  RIGHT(2),
  /** The top of the icon is placed closest to the anchor. */
  TOP(3),
  /** The bottom of the icon is placed closest to the anchor. */
  BOTTOM(4),
  /** The top left corner of the icon is placed closest to the anchor. */
  TOP_LEFT(5),
  /** The top right corner of the icon is placed closest to the anchor. */
  TOP_RIGHT(6),
  /** The bottom left corner of the icon is placed closest to the anchor. */
  BOTTOM_LEFT(7),
  /** The bottom right corner of the icon is placed closest to the anchor. */
  BOTTOM_RIGHT(8);

  companion object {
    fun ofRaw(raw: Int): IconAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Orientation of icon when map is pitched. */
enum class IconPitchAlignment(val raw: Int) {
  /** The icon is aligned to the plane of the map. */
  MAP(0),
  /** The icon is aligned to the plane of the viewport. */
  VIEWPORT(1),
  /** Automatically matches the value of {@link ICON_ROTATION_ALIGNMENT}. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): IconPitchAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** In combination with `symbol-placement`, determines the rotation behavior of icons. */
enum class IconRotationAlignment(val raw: Int) {
  /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns icons east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns icon x-axes with the line. */
  MAP(0),
  /** Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}. */
  VIEWPORT(1),
  /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_MAP}. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): IconRotationAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Scales the icon to fit around the associated text. */
enum class IconTextFit(val raw: Int) {
  /** The icon is displayed at its intrinsic aspect ratio. */
  NONE(0),
  /** The icon is scaled in the x-dimension to fit the width of the text. */
  WIDTH(1),
  /** The icon is scaled in the y-dimension to fit the height of the text. */
  HEIGHT(2),
  /** The icon is scaled in both x- and y-dimensions. */
  BOTH(3);

  companion object {
    fun ofRaw(raw: Int): IconTextFit? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Label placement relative to its geometry. */
enum class SymbolPlacement(val raw: Int) {
  /** The label is placed at the point where the geometry is located. */
  POINT(0),
  /** The label is placed along the line of the geometry. Can only be used on LineString and Polygon geometries. */
  LINE(1),
  /** The label is placed at the center of the line of the geometry. Can only be used on LineString and Polygon geometries. Note that a single feature in a vector tile may contain multiple line geometries. */
  LINE_CENTER(2);

  companion object {
    fun ofRaw(raw: Int): SymbolPlacement? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`. */
enum class SymbolZOrder(val raw: Int) {
  /** Sorts symbols by symbol sort key if set. Otherwise, sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}. */
  AUTO(0),
  /** Sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}. */
  VIEWPORT_Y(1),
  /** Sorts symbols by symbol sort key if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data. */
  SOURCE(2);

  companion object {
    fun ofRaw(raw: Int): SymbolZOrder? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Part of the text placed closest to the anchor. */
enum class TextAnchor(val raw: Int) {
  /** The center of the text is placed closest to the anchor. */
  CENTER(0),
  /** The left side of the text is placed closest to the anchor. */
  LEFT(1),
  /** The right side of the text is placed closest to the anchor. */
  RIGHT(2),
  /** The top of the text is placed closest to the anchor. */
  TOP(3),
  /** The bottom of the text is placed closest to the anchor. */
  BOTTOM(4),
  /** The top left corner of the text is placed closest to the anchor. */
  TOP_LEFT(5),
  /** The top right corner of the text is placed closest to the anchor. */
  TOP_RIGHT(6),
  /** The bottom left corner of the text is placed closest to the anchor. */
  BOTTOM_LEFT(7),
  /** The bottom right corner of the text is placed closest to the anchor. */
  BOTTOM_RIGHT(8);

  companion object {
    fun ofRaw(raw: Int): TextAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Text justification options. */
enum class TextJustify(val raw: Int) {
  /** The text is aligned towards the anchor position. */
  AUTO(0),
  /** The text is aligned to the left. */
  LEFT(1),
  /** The text is centered. */
  CENTER(2),
  /** The text is aligned to the right. */
  RIGHT(3);

  companion object {
    fun ofRaw(raw: Int): TextJustify? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Orientation of text when map is pitched. */
enum class TextPitchAlignment(val raw: Int) {
  /** The text is aligned to the plane of the map. */
  MAP(0),
  /** The text is aligned to the plane of the viewport. */
  VIEWPORT(1),
  /** Automatically matches the value of {@link TEXT_ROTATION_ALIGNMENT}. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): TextPitchAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text. */
enum class TextRotationAlignment(val raw: Int) {
  /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns text east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns text x-axes with the line. */
  MAP(0),
  /** Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}. */
  VIEWPORT(1),
  /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_MAP}. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): TextRotationAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
enum class TextTransform(val raw: Int) {
  /** The text is not altered. */
  NONE(0),
  /** Forces all letters to be displayed in uppercase. */
  UPPERCASE(1),
  /** Forces all letters to be displayed in lowercase. */
  LOWERCASE(2);

  companion object {
    fun ofRaw(raw: Int): TextTransform? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`. */
enum class TextVariableAnchor(val raw: Int) {
  /** The center of the text is placed closest to the anchor. */
  CENTER(0),
  /** The left side of the text is placed closest to the anchor. */
  LEFT(1),
  /** The right side of the text is placed closest to the anchor. */
  RIGHT(2),
  /** The top of the text is placed closest to the anchor. */
  TOP(3),
  /** The bottom of the text is placed closest to the anchor. */
  BOTTOM(4),
  /** The top left corner of the text is placed closest to the anchor. */
  TOP_LEFT(5),
  /** The top right corner of the text is placed closest to the anchor. */
  TOP_RIGHT(6),
  /** The bottom left corner of the text is placed closest to the anchor. */
  BOTTOM_LEFT(7),
  /** The bottom right corner of the text is placed closest to the anchor. */
  BOTTOM_RIGHT(8);

  companion object {
    fun ofRaw(raw: Int): TextVariableAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement. */
enum class TextWritingMode(val raw: Int) {
  /** If a text's language supports horizontal writing mode, symbols would be laid out horizontally. */
  HORIZONTAL(0),
  /** If a text's language supports vertical writing mode, symbols would be laid out vertically. */
  VERTICAL(1);

  companion object {
    fun ofRaw(raw: Int): TextWritingMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Controls the frame of reference for `icon-translate`. */
enum class IconTranslateAnchor(val raw: Int) {
  /** Icons are translated relative to the map. */
  MAP(0),
  /** Icons are translated relative to the viewport. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): IconTranslateAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Controls the frame of reference for `text-translate`. */
enum class TextTranslateAnchor(val raw: Int) {
  /** The text is translated relative to the map. */
  MAP(0),
  /** The text is translated relative to the viewport. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): TextTranslateAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PointAnnotation(
  /** The id for annotation */
  val id: String,
  /** The geometry that determines the location/shape of this annotation */
  val geometry: Point,
  /**
   * The bitmap image for this Annotation
   * Will not take effect if [iconImage] has been set.
   */
  val image: ByteArray? = null,
  /** Part of the icon placed closest to the anchor. */
  val iconAnchor: IconAnchor? = null,
  /** Name of image in sprite to use for drawing an image background. */
  val iconImage: String? = null,
  /** Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up. */
  val iconOffset: List<Double?>? = null,
  /** Rotates the icon clockwise. */
  val iconRotate: Double? = null,
  /** Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image. */
  val iconSize: Double? = null,
  /** Scales the icon to fit around the associated text. */
  val iconTextFit: IconTextFit? = null,
  /** Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left. */
  val iconTextFitPadding: List<Double?>? = null,
  /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
  val symbolSortKey: Double? = null,
  /** Part of the text placed closest to the anchor. */
  val textAnchor: TextAnchor? = null,
  /** Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored. */
  val textField: String? = null,
  /** Text justification options. */
  val textJustify: TextJustify? = null,
  /** Text tracking amount. */
  val textLetterSpacing: Double? = null,
  /** Text leading value for multi-line text. */
  val textLineHeight: Double? = null,
  /** The maximum line width for text wrapping. */
  val textMaxWidth: Double? = null,
  /** Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position. */
  val textOffset: List<Double?>? = null,
  /** Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present. */
  val textRadialOffset: Double? = null,
  /** Rotates the text clockwise. */
  val textRotate: Double? = null,
  /** Font size. */
  val textSize: Double? = null,
  /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
  val textTransform: TextTransform? = null,
  /** The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
  val iconColor: Long? = null,
  /** Controls the intensity of light emitted on the source features. */
  val iconEmissiveStrength: Double? = null,
  /** Fade out the halo towards the outside. */
  val iconHaloBlur: Double? = null,
  /** The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
  val iconHaloColor: Long? = null,
  /** Distance of halo to the icon outline. */
  val iconHaloWidth: Double? = null,
  /** Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together. */
  val iconImageCrossFade: Double? = null,
  /** The opacity at which the icon will be drawn. */
  val iconOpacity: Double? = null,
  /** The color with which the text will be drawn. */
  val textColor: Long? = null,
  /** Controls the intensity of light emitted on the source features. */
  val textEmissiveStrength: Double? = null,
  /** The halo's fadeout distance towards the outside. */
  val textHaloBlur: Double? = null,
  /** The color of the text's halo, which helps it stand out from backgrounds. */
  val textHaloColor: Long? = null,
  /** Distance of halo to the font outline. Max text halo width is 1/4 of the font-size. */
  val textHaloWidth: Double? = null,
  /** The opacity at which the text will be drawn. */
  val textOpacity: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PointAnnotation {
      val id = list[0] as String
      val geometry = PointDecoder.fromList(list[1] as List<Any?>)
      val image = list[2] as ByteArray?
      val iconAnchor = (list[3] as Int?)?.let {
        IconAnchor.ofRaw(it)
      }
      val iconImage = list[4] as String?
      val iconOffset = list[5] as List<Double?>?
      val iconRotate = list[6] as Double?
      val iconSize = list[7] as Double?
      val iconTextFit = (list[8] as Int?)?.let {
        IconTextFit.ofRaw(it)
      }
      val iconTextFitPadding = list[9] as List<Double?>?
      val symbolSortKey = list[10] as Double?
      val textAnchor = (list[11] as Int?)?.let {
        TextAnchor.ofRaw(it)
      }
      val textField = list[12] as String?
      val textJustify = (list[13] as Int?)?.let {
        TextJustify.ofRaw(it)
      }
      val textLetterSpacing = list[14] as Double?
      val textLineHeight = list[15] as Double?
      val textMaxWidth = list[16] as Double?
      val textOffset = list[17] as List<Double?>?
      val textRadialOffset = list[18] as Double?
      val textRotate = list[19] as Double?
      val textSize = list[20] as Double?
      val textTransform = (list[21] as Int?)?.let {
        TextTransform.ofRaw(it)
      }
      val iconColor = list[22].let { if (it is Int) it.toLong() else it as Long? }
      val iconEmissiveStrength = list[23] as Double?
      val iconHaloBlur = list[24] as Double?
      val iconHaloColor = list[25].let { if (it is Int) it.toLong() else it as Long? }
      val iconHaloWidth = list[26] as Double?
      val iconImageCrossFade = list[27] as Double?
      val iconOpacity = list[28] as Double?
      val textColor = list[29].let { if (it is Int) it.toLong() else it as Long? }
      val textEmissiveStrength = list[30] as Double?
      val textHaloBlur = list[31] as Double?
      val textHaloColor = list[32].let { if (it is Int) it.toLong() else it as Long? }
      val textHaloWidth = list[33] as Double?
      val textOpacity = list[34] as Double?
      return PointAnnotation(id, geometry, image, iconAnchor, iconImage, iconOffset, iconRotate, iconSize, iconTextFit, iconTextFitPadding, symbolSortKey, textAnchor, textField, textJustify, textLetterSpacing, textLineHeight, textMaxWidth, textOffset, textRadialOffset, textRotate, textSize, textTransform, iconColor, iconEmissiveStrength, iconHaloBlur, iconHaloColor, iconHaloWidth, iconImageCrossFade, iconOpacity, textColor, textEmissiveStrength, textHaloBlur, textHaloColor, textHaloWidth, textOpacity)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      id,
      geometry.toList(),
      image,
      iconAnchor?.raw,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit?.raw,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor?.raw,
      textField,
      textJustify?.raw,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform?.raw,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PointAnnotationOptions(
  /** The geometry that determines the location/shape of this annotation */
  val geometry: Point,
  /**
   * The bitmap image for this Annotation
   * Will not take effect if [iconImage] has been set.
   */
  val image: ByteArray? = null,
  /** Part of the icon placed closest to the anchor. */
  val iconAnchor: IconAnchor? = null,
  /** Name of image in sprite to use for drawing an image background. */
  val iconImage: String? = null,
  /** Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up. */
  val iconOffset: List<Double?>? = null,
  /** Rotates the icon clockwise. */
  val iconRotate: Double? = null,
  /** Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image. */
  val iconSize: Double? = null,
  /** Scales the icon to fit around the associated text. */
  val iconTextFit: IconTextFit? = null,
  /** Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left. */
  val iconTextFitPadding: List<Double?>? = null,
  /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
  val symbolSortKey: Double? = null,
  /** Part of the text placed closest to the anchor. */
  val textAnchor: TextAnchor? = null,
  /** Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored. */
  val textField: String? = null,
  /** Text justification options. */
  val textJustify: TextJustify? = null,
  /** Text tracking amount. */
  val textLetterSpacing: Double? = null,
  /** Text leading value for multi-line text. */
  val textLineHeight: Double? = null,
  /** The maximum line width for text wrapping. */
  val textMaxWidth: Double? = null,
  /** Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position. */
  val textOffset: List<Double?>? = null,
  /** Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present. */
  val textRadialOffset: Double? = null,
  /** Rotates the text clockwise. */
  val textRotate: Double? = null,
  /** Font size. */
  val textSize: Double? = null,
  /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
  val textTransform: TextTransform? = null,
  /** The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
  val iconColor: Long? = null,
  /** Controls the intensity of light emitted on the source features. */
  val iconEmissiveStrength: Double? = null,
  /** Fade out the halo towards the outside. */
  val iconHaloBlur: Double? = null,
  /** The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
  val iconHaloColor: Long? = null,
  /** Distance of halo to the icon outline. */
  val iconHaloWidth: Double? = null,
  /** Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together. */
  val iconImageCrossFade: Double? = null,
  /** The opacity at which the icon will be drawn. */
  val iconOpacity: Double? = null,
  /** The color with which the text will be drawn. */
  val textColor: Long? = null,
  /** Controls the intensity of light emitted on the source features. */
  val textEmissiveStrength: Double? = null,
  /** The halo's fadeout distance towards the outside. */
  val textHaloBlur: Double? = null,
  /** The color of the text's halo, which helps it stand out from backgrounds. */
  val textHaloColor: Long? = null,
  /** Distance of halo to the font outline. Max text halo width is 1/4 of the font-size. */
  val textHaloWidth: Double? = null,
  /** The opacity at which the text will be drawn. */
  val textOpacity: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): PointAnnotationOptions {
      val geometry = PointDecoder.fromList(list[0] as List<Any?>)
      val image = list[1] as ByteArray?
      val iconAnchor = (list[2] as Int?)?.let {
        IconAnchor.ofRaw(it)
      }
      val iconImage = list[3] as String?
      val iconOffset = list[4] as List<Double?>?
      val iconRotate = list[5] as Double?
      val iconSize = list[6] as Double?
      val iconTextFit = (list[7] as Int?)?.let {
        IconTextFit.ofRaw(it)
      }
      val iconTextFitPadding = list[8] as List<Double?>?
      val symbolSortKey = list[9] as Double?
      val textAnchor = (list[10] as Int?)?.let {
        TextAnchor.ofRaw(it)
      }
      val textField = list[11] as String?
      val textJustify = (list[12] as Int?)?.let {
        TextJustify.ofRaw(it)
      }
      val textLetterSpacing = list[13] as Double?
      val textLineHeight = list[14] as Double?
      val textMaxWidth = list[15] as Double?
      val textOffset = list[16] as List<Double?>?
      val textRadialOffset = list[17] as Double?
      val textRotate = list[18] as Double?
      val textSize = list[19] as Double?
      val textTransform = (list[20] as Int?)?.let {
        TextTransform.ofRaw(it)
      }
      val iconColor = list[21].let { if (it is Int) it.toLong() else it as Long? }
      val iconEmissiveStrength = list[22] as Double?
      val iconHaloBlur = list[23] as Double?
      val iconHaloColor = list[24].let { if (it is Int) it.toLong() else it as Long? }
      val iconHaloWidth = list[25] as Double?
      val iconImageCrossFade = list[26] as Double?
      val iconOpacity = list[27] as Double?
      val textColor = list[28].let { if (it is Int) it.toLong() else it as Long? }
      val textEmissiveStrength = list[29] as Double?
      val textHaloBlur = list[30] as Double?
      val textHaloColor = list[31].let { if (it is Int) it.toLong() else it as Long? }
      val textHaloWidth = list[32] as Double?
      val textOpacity = list[33] as Double?
      return PointAnnotationOptions(geometry, image, iconAnchor, iconImage, iconOffset, iconRotate, iconSize, iconTextFit, iconTextFitPadding, symbolSortKey, textAnchor, textField, textJustify, textLetterSpacing, textLineHeight, textMaxWidth, textOffset, textRadialOffset, textRotate, textSize, textTransform, iconColor, iconEmissiveStrength, iconHaloBlur, iconHaloColor, iconHaloWidth, iconImageCrossFade, iconOpacity, textColor, textEmissiveStrength, textHaloBlur, textHaloColor, textHaloWidth, textOpacity)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      geometry.toList(),
      image,
      iconAnchor?.raw,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit?.raw,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor?.raw,
      textField,
      textJustify?.raw,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform?.raw,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    )
  }
}
@Suppress("UNCHECKED_CAST")
private object OnPointAnnotationClickListenerCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotation.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is Point -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is PointAnnotation -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
@Suppress("UNCHECKED_CAST")
class OnPointAnnotationClickListener(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by OnPointAnnotationClickListener. */
    val codec: MessageCodec<Any?> by lazy {
      OnPointAnnotationClickListenerCodec
    }
  }
  fun onPointAnnotationClick(annotationArg: PointAnnotation, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(annotationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object _PointAnnotationMessengerCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotation.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotation.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotationOptions.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotationOptions.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is Point -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is PointAnnotation -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is PointAnnotation -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is PointAnnotationOptions -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is PointAnnotationOptions -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface _PointAnnotationMessenger {
  fun create(managerId: String, annotationOption: PointAnnotationOptions, callback: (Result<PointAnnotation>) -> Unit)
  fun createMulti(managerId: String, annotationOptions: List<PointAnnotationOptions>, callback: (Result<List<PointAnnotation>>) -> Unit)
  fun update(managerId: String, annotation: PointAnnotation, callback: (Result<Unit>) -> Unit)
  fun delete(managerId: String, annotation: PointAnnotation, callback: (Result<Unit>) -> Unit)
  fun deleteAll(managerId: String, callback: (Result<Unit>) -> Unit)
  fun setIconAllowOverlap(managerId: String, iconAllowOverlap: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconAllowOverlap(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconIgnorePlacement(managerId: String, iconIgnorePlacement: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconIgnorePlacement(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconKeepUpright(managerId: String, iconKeepUpright: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconKeepUpright(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconOptional(managerId: String, iconOptional: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconOptional(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconPadding(managerId: String, iconPadding: Double, callback: (Result<Unit>) -> Unit)
  fun getIconPadding(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setIconPitchAlignment(managerId: String, iconPitchAlignment: IconPitchAlignment, callback: (Result<Unit>) -> Unit)
  fun getIconPitchAlignment(managerId: String, callback: (Result<IconPitchAlignment?>) -> Unit)
  fun setIconRotationAlignment(managerId: String, iconRotationAlignment: IconRotationAlignment, callback: (Result<Unit>) -> Unit)
  fun getIconRotationAlignment(managerId: String, callback: (Result<IconRotationAlignment?>) -> Unit)
  fun setSymbolAvoidEdges(managerId: String, symbolAvoidEdges: Boolean, callback: (Result<Unit>) -> Unit)
  fun getSymbolAvoidEdges(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setSymbolPlacement(managerId: String, symbolPlacement: SymbolPlacement, callback: (Result<Unit>) -> Unit)
  fun getSymbolPlacement(managerId: String, callback: (Result<SymbolPlacement?>) -> Unit)
  fun setSymbolSpacing(managerId: String, symbolSpacing: Double, callback: (Result<Unit>) -> Unit)
  fun getSymbolSpacing(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setSymbolZElevate(managerId: String, symbolZElevate: Boolean, callback: (Result<Unit>) -> Unit)
  fun getSymbolZElevate(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setSymbolZOrder(managerId: String, symbolZOrder: SymbolZOrder, callback: (Result<Unit>) -> Unit)
  fun getSymbolZOrder(managerId: String, callback: (Result<SymbolZOrder?>) -> Unit)
  fun setTextAllowOverlap(managerId: String, textAllowOverlap: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextAllowOverlap(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextFont(managerId: String, textFont: List<String?>, callback: (Result<Unit>) -> Unit)
  fun getTextFont(managerId: String, callback: (Result<List<String?>?>) -> Unit)
  fun setTextIgnorePlacement(managerId: String, textIgnorePlacement: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextIgnorePlacement(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextKeepUpright(managerId: String, textKeepUpright: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextKeepUpright(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextMaxAngle(managerId: String, textMaxAngle: Double, callback: (Result<Unit>) -> Unit)
  fun getTextMaxAngle(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setTextOptional(managerId: String, textOptional: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextOptional(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextPadding(managerId: String, textPadding: Double, callback: (Result<Unit>) -> Unit)
  fun getTextPadding(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setTextPitchAlignment(managerId: String, textPitchAlignment: TextPitchAlignment, callback: (Result<Unit>) -> Unit)
  fun getTextPitchAlignment(managerId: String, callback: (Result<TextPitchAlignment?>) -> Unit)
  fun setTextRotationAlignment(managerId: String, textRotationAlignment: TextRotationAlignment, callback: (Result<Unit>) -> Unit)
  fun getTextRotationAlignment(managerId: String, callback: (Result<TextRotationAlignment?>) -> Unit)
  fun setIconColorSaturation(managerId: String, iconColorSaturation: Double, callback: (Result<Unit>) -> Unit)
  fun getIconColorSaturation(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setIconTranslate(managerId: String, iconTranslate: List<Double?>, callback: (Result<Unit>) -> Unit)
  fun getIconTranslate(managerId: String, callback: (Result<List<Double?>?>) -> Unit)
  fun setIconTranslateAnchor(managerId: String, iconTranslateAnchor: IconTranslateAnchor, callback: (Result<Unit>) -> Unit)
  fun getIconTranslateAnchor(managerId: String, callback: (Result<IconTranslateAnchor?>) -> Unit)
  fun setTextTranslate(managerId: String, textTranslate: List<Double?>, callback: (Result<Unit>) -> Unit)
  fun getTextTranslate(managerId: String, callback: (Result<List<Double?>?>) -> Unit)
  fun setTextTranslateAnchor(managerId: String, textTranslateAnchor: TextTranslateAnchor, callback: (Result<Unit>) -> Unit)
  fun getTextTranslateAnchor(managerId: String, callback: (Result<TextTranslateAnchor?>) -> Unit)

  companion object {
    /** The codec used by _PointAnnotationMessenger. */
    val codec: MessageCodec<Any?> by lazy {
      _PointAnnotationMessengerCodec
    }
    /** Sets up an instance of `_PointAnnotationMessenger` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _PointAnnotationMessenger?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.create$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationOptionArg = args[1] as PointAnnotationOptions
            api.create(managerIdArg, annotationOptionArg) { result: Result<PointAnnotation> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.createMulti$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationOptionsArg = args[1] as List<PointAnnotationOptions>
            api.createMulti(managerIdArg, annotationOptionsArg) { result: Result<List<PointAnnotation>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.update$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationArg = args[1] as PointAnnotation
            api.update(managerIdArg, annotationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.delete$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationArg = args[1] as PointAnnotation
            api.delete(managerIdArg, annotationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.deleteAll$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.deleteAll(managerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconAllowOverlapArg = args[1] as Boolean
            api.setIconAllowOverlap(managerIdArg, iconAllowOverlapArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconAllowOverlap(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconIgnorePlacementArg = args[1] as Boolean
            api.setIconIgnorePlacement(managerIdArg, iconIgnorePlacementArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconIgnorePlacement(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconKeepUprightArg = args[1] as Boolean
            api.setIconKeepUpright(managerIdArg, iconKeepUprightArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconKeepUpright(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconOptionalArg = args[1] as Boolean
            api.setIconOptional(managerIdArg, iconOptionalArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconOptional(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconPaddingArg = args[1] as Double
            api.setIconPadding(managerIdArg, iconPaddingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconPadding(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconPitchAlignmentArg = IconPitchAlignment.ofRaw(args[1] as Int)!!
            api.setIconPitchAlignment(managerIdArg, iconPitchAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconPitchAlignment(managerIdArg) { result: Result<IconPitchAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconRotationAlignmentArg = IconRotationAlignment.ofRaw(args[1] as Int)!!
            api.setIconRotationAlignment(managerIdArg, iconRotationAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconRotationAlignment(managerIdArg) { result: Result<IconRotationAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolAvoidEdges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolAvoidEdgesArg = args[1] as Boolean
            api.setSymbolAvoidEdges(managerIdArg, symbolAvoidEdgesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolAvoidEdges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolAvoidEdges(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolPlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolPlacementArg = SymbolPlacement.ofRaw(args[1] as Int)!!
            api.setSymbolPlacement(managerIdArg, symbolPlacementArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolPlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolPlacement(managerIdArg) { result: Result<SymbolPlacement?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolSpacing$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolSpacingArg = args[1] as Double
            api.setSymbolSpacing(managerIdArg, symbolSpacingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolSpacing$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolSpacing(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZElevate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolZElevateArg = args[1] as Boolean
            api.setSymbolZElevate(managerIdArg, symbolZElevateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZElevate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolZElevate(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZOrder$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolZOrderArg = SymbolZOrder.ofRaw(args[1] as Int)!!
            api.setSymbolZOrder(managerIdArg, symbolZOrderArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZOrder$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolZOrder(managerIdArg) { result: Result<SymbolZOrder?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textAllowOverlapArg = args[1] as Boolean
            api.setTextAllowOverlap(managerIdArg, textAllowOverlapArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextAllowOverlap(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextFont$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textFontArg = args[1] as List<String?>
            api.setTextFont(managerIdArg, textFontArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextFont$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextFont(managerIdArg) { result: Result<List<String?>?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textIgnorePlacementArg = args[1] as Boolean
            api.setTextIgnorePlacement(managerIdArg, textIgnorePlacementArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextIgnorePlacement(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textKeepUprightArg = args[1] as Boolean
            api.setTextKeepUpright(managerIdArg, textKeepUprightArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextKeepUpright(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextMaxAngle$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textMaxAngleArg = args[1] as Double
            api.setTextMaxAngle(managerIdArg, textMaxAngleArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextMaxAngle$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextMaxAngle(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textOptionalArg = args[1] as Boolean
            api.setTextOptional(managerIdArg, textOptionalArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextOptional(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textPaddingArg = args[1] as Double
            api.setTextPadding(managerIdArg, textPaddingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextPadding(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textPitchAlignmentArg = TextPitchAlignment.ofRaw(args[1] as Int)!!
            api.setTextPitchAlignment(managerIdArg, textPitchAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextPitchAlignment(managerIdArg) { result: Result<TextPitchAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textRotationAlignmentArg = TextRotationAlignment.ofRaw(args[1] as Int)!!
            api.setTextRotationAlignment(managerIdArg, textRotationAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextRotationAlignment(managerIdArg) { result: Result<TextRotationAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconColorSaturation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconColorSaturationArg = args[1] as Double
            api.setIconColorSaturation(managerIdArg, iconColorSaturationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconColorSaturation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconColorSaturation(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconTranslateArg = args[1] as List<Double?>
            api.setIconTranslate(managerIdArg, iconTranslateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconTranslate(managerIdArg) { result: Result<List<Double?>?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconTranslateAnchorArg = IconTranslateAnchor.ofRaw(args[1] as Int)!!
            api.setIconTranslateAnchor(managerIdArg, iconTranslateAnchorArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconTranslateAnchor(managerIdArg) { result: Result<IconTranslateAnchor?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textTranslateArg = args[1] as List<Double?>
            api.setTextTranslate(managerIdArg, textTranslateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextTranslate(managerIdArg) { result: Result<List<Double?>?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textTranslateAnchorArg = TextTranslateAnchor.ofRaw(args[1] as Int)!!
            api.setTextTranslateAnchor(managerIdArg, textTranslateAnchorArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextTranslateAnchor(managerIdArg) { result: Result<TextTranslateAnchor?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data?.raw))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}