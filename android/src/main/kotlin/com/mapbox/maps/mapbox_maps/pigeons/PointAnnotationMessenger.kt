// Autogenerated from Pigeon (v21.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.mapbox.maps.mapbox_maps.pigeons

import android.util.Log
import com.mapbox.geojson.Point
import com.mapbox.maps.mapbox_maps.mapping.turf.*
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

private fun createConnectionError(channelName: String): FlutterError {
  return FlutterError("channel-error", "Unable to establish connection on channel: '$channelName'.", "")
}

/**
 * Part of the icon placed closest to the anchor.
 * Default value: "center".
 */
enum class IconAnchor(val raw: Int) {
  /** The center of the icon is placed closest to the anchor. */
  CENTER(0),
  /** The left side of the icon is placed closest to the anchor. */
  LEFT(1),
  /** The right side of the icon is placed closest to the anchor. */
  RIGHT(2),
  /** The top of the icon is placed closest to the anchor. */
  TOP(3),
  /** The bottom of the icon is placed closest to the anchor. */
  BOTTOM(4),
  /** The top left corner of the icon is placed closest to the anchor. */
  TOP_LEFT(5),
  /** The top right corner of the icon is placed closest to the anchor. */
  TOP_RIGHT(6),
  /** The bottom left corner of the icon is placed closest to the anchor. */
  BOTTOM_LEFT(7),
  /** The bottom right corner of the icon is placed closest to the anchor. */
  BOTTOM_RIGHT(8);

  companion object {
    fun ofRaw(raw: Int): IconAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Orientation of icon when map is pitched.
 * Default value: "auto".
 */
enum class IconPitchAlignment(val raw: Int) {
  /** The icon is aligned to the plane of the map. */
  MAP(0),
  /** The icon is aligned to the plane of the viewport. */
  VIEWPORT(1),
  /** Automatically matches the value of `icon-rotation-alignment`. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): IconPitchAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * In combination with `symbol-placement`, determines the rotation behavior of icons.
 * Default value: "auto".
 */
enum class IconRotationAlignment(val raw: Int) {
  /** When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line. */
  MAP(0),
  /** Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`. */
  VIEWPORT(1),
  /** When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): IconRotationAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Scales the icon to fit around the associated text.
 * Default value: "none".
 */
enum class IconTextFit(val raw: Int) {
  /** The icon is displayed at its intrinsic aspect ratio. */
  NONE(0),
  /** The icon is scaled in the x-dimension to fit the width of the text. */
  WIDTH(1),
  /** The icon is scaled in the y-dimension to fit the height of the text. */
  HEIGHT(2),
  /** The icon is scaled in both x- and y-dimensions. */
  BOTH(3);

  companion object {
    fun ofRaw(raw: Int): IconTextFit? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Label placement relative to its geometry.
 * Default value: "point".
 */
enum class SymbolPlacement(val raw: Int) {
  /** The label is placed at the point where the geometry is located. */
  POINT(0),
  /** The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. */
  LINE(1),
  /** The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries. */
  LINE_CENTER(2);

  companion object {
    fun ofRaw(raw: Int): SymbolPlacement? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.
 * Default value: "auto".
 */
enum class SymbolZOrder(val raw: Int) {
  /** Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`. */
  AUTO(0),
  /** Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`. */
  VIEWPORT_Y(1),
  /** Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data. */
  SOURCE(2);

  companion object {
    fun ofRaw(raw: Int): SymbolZOrder? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Part of the text placed closest to the anchor.
 * Default value: "center".
 */
enum class TextAnchor(val raw: Int) {
  /** The center of the text is placed closest to the anchor. */
  CENTER(0),
  /** The left side of the text is placed closest to the anchor. */
  LEFT(1),
  /** The right side of the text is placed closest to the anchor. */
  RIGHT(2),
  /** The top of the text is placed closest to the anchor. */
  TOP(3),
  /** The bottom of the text is placed closest to the anchor. */
  BOTTOM(4),
  /** The top left corner of the text is placed closest to the anchor. */
  TOP_LEFT(5),
  /** The top right corner of the text is placed closest to the anchor. */
  TOP_RIGHT(6),
  /** The bottom left corner of the text is placed closest to the anchor. */
  BOTTOM_LEFT(7),
  /** The bottom right corner of the text is placed closest to the anchor. */
  BOTTOM_RIGHT(8);

  companion object {
    fun ofRaw(raw: Int): TextAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Text justification options.
 * Default value: "center".
 */
enum class TextJustify(val raw: Int) {
  /** The text is aligned towards the anchor position. */
  AUTO(0),
  /** The text is aligned to the left. */
  LEFT(1),
  /** The text is centered. */
  CENTER(2),
  /** The text is aligned to the right. */
  RIGHT(3);

  companion object {
    fun ofRaw(raw: Int): TextJustify? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Orientation of text when map is pitched.
 * Default value: "auto".
 */
enum class TextPitchAlignment(val raw: Int) {
  /** The text is aligned to the plane of the map. */
  MAP(0),
  /** The text is aligned to the plane of the viewport. */
  VIEWPORT(1),
  /** Automatically matches the value of `text-rotation-alignment`. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): TextPitchAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.
 * Default value: "auto".
 */
enum class TextRotationAlignment(val raw: Int) {
  /** When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line. */
  MAP(0),
  /** Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`. */
  VIEWPORT(1),
  /** When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`. */
  AUTO(2);

  companion object {
    fun ofRaw(raw: Int): TextRotationAlignment? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Specifies how to capitalize text, similar to the CSS `text-transform` property.
 * Default value: "none".
 */
enum class TextTransform(val raw: Int) {
  /** The text is not altered. */
  NONE(0),
  /** Forces all letters to be displayed in uppercase. */
  UPPERCASE(1),
  /** Forces all letters to be displayed in lowercase. */
  LOWERCASE(2);

  companion object {
    fun ofRaw(raw: Int): TextTransform? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`. */
enum class TextVariableAnchor(val raw: Int) {
  /** The center of the text is placed closest to the anchor. */
  CENTER(0),
  /** The left side of the text is placed closest to the anchor. */
  LEFT(1),
  /** The right side of the text is placed closest to the anchor. */
  RIGHT(2),
  /** The top of the text is placed closest to the anchor. */
  TOP(3),
  /** The bottom of the text is placed closest to the anchor. */
  BOTTOM(4),
  /** The top left corner of the text is placed closest to the anchor. */
  TOP_LEFT(5),
  /** The top right corner of the text is placed closest to the anchor. */
  TOP_RIGHT(6),
  /** The bottom left corner of the text is placed closest to the anchor. */
  BOTTOM_LEFT(7),
  /** The bottom right corner of the text is placed closest to the anchor. */
  BOTTOM_RIGHT(8);

  companion object {
    fun ofRaw(raw: Int): TextVariableAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnâ€™t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement. */
enum class TextWritingMode(val raw: Int) {
  /** If a text's language supports horizontal writing mode, symbols would be laid out horizontally. */
  HORIZONTAL(0),
  /** If a text's language supports vertical writing mode, symbols would be laid out vertically. */
  VERTICAL(1);

  companion object {
    fun ofRaw(raw: Int): TextWritingMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Controls the frame of reference for `icon-translate`.
 * Default value: "map".
 */
enum class IconTranslateAnchor(val raw: Int) {
  /** Icons are translated relative to the map. */
  MAP(0),
  /** Icons are translated relative to the viewport. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): IconTranslateAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Controls the frame of reference for `text-translate`.
 * Default value: "map".
 */
enum class TextTranslateAnchor(val raw: Int) {
  /** The text is translated relative to the map. */
  MAP(0),
  /** The text is translated relative to the viewport. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): TextTranslateAnchor? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PointAnnotation(
  /** The id for annotation */
  val id: String,
  /** The geometry that determines the location/shape of this annotation */
  val geometry: Point,
  /**
   * The bitmap image for this Annotation
   * Will not take effect if [iconImage] has been set.
   */
  val image: ByteArray? = null,
  /**
   * Part of the icon placed closest to the anchor.
   * Default value: "center".
   */
  val iconAnchor: IconAnchor? = null,
  /** Name of image in sprite to use for drawing an image background. */
  val iconImage: String? = null,
  /**
   * Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
   * Default value: [0,0].
   */
  val iconOffset: List<Double?>? = null,
  /**
   * Rotates the icon clockwise.
   * Default value: 0.
   */
  val iconRotate: Double? = null,
  /**
   * Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
   * Default value: 1. Minimum value: 0.
   */
  val iconSize: Double? = null,
  /**
   * Scales the icon to fit around the associated text.
   * Default value: "none".
   */
  val iconTextFit: IconTextFit? = null,
  /**
   * Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
   * Default value: [0,0,0,0].
   */
  val iconTextFitPadding: List<Double?>? = null,
  /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
  val symbolSortKey: Double? = null,
  /**
   * Part of the text placed closest to the anchor.
   * Default value: "center".
   */
  val textAnchor: TextAnchor? = null,
  /**
   * Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
   * Default value: "".
   */
  val textField: String? = null,
  /**
   * Text justification options.
   * Default value: "center".
   */
  val textJustify: TextJustify? = null,
  /**
   * Text tracking amount.
   * Default value: 0.
   */
  val textLetterSpacing: Double? = null,
  /**
   * Text leading value for multi-line text.
   * Default value: 1.2.
   */
  val textLineHeight: Double? = null,
  /**
   * The maximum line width for text wrapping.
   * Default value: 10. Minimum value: 0.
   */
  val textMaxWidth: Double? = null,
  /**
   * Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
   * Default value: [0,0].
   */
  val textOffset: List<Double?>? = null,
  /**
   * Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
   * Default value: 0.
   */
  val textRadialOffset: Double? = null,
  /**
   * Rotates the text clockwise.
   * Default value: 0.
   */
  val textRotate: Double? = null,
  /**
   * Font size.
   * Default value: 16. Minimum value: 0.
   */
  val textSize: Double? = null,
  /**
   * Specifies how to capitalize text, similar to the CSS `text-transform` property.
   * Default value: "none".
   */
  val textTransform: TextTransform? = null,
  /**
   * The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
   * Default value: "#000000".
   */
  val iconColor: Long? = null,
  /**
   * Controls the intensity of light emitted on the source features.
   * Default value: 1. Minimum value: 0.
   */
  val iconEmissiveStrength: Double? = null,
  /**
   * Fade out the halo towards the outside.
   * Default value: 0. Minimum value: 0.
   */
  val iconHaloBlur: Double? = null,
  /**
   * The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
   * Default value: "rgba(0, 0, 0, 0)".
   */
  val iconHaloColor: Long? = null,
  /**
   * Distance of halo to the icon outline.
   * Default value: 0. Minimum value: 0.
   */
  val iconHaloWidth: Double? = null,
  /**
   * Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
   * Default value: 0. Value range: [0, 1]
   */
  val iconImageCrossFade: Double? = null,
  /**
   * The opacity at which the icon will be drawn.
   * Default value: 1. Value range: [0, 1]
   */
  val iconOpacity: Double? = null,
  /**
   * The color with which the text will be drawn.
   * Default value: "#000000".
   */
  val textColor: Long? = null,
  /**
   * Controls the intensity of light emitted on the source features.
   * Default value: 1. Minimum value: 0.
   */
  val textEmissiveStrength: Double? = null,
  /**
   * The halo's fadeout distance towards the outside.
   * Default value: 0. Minimum value: 0.
   */
  val textHaloBlur: Double? = null,
  /**
   * The color of the text's halo, which helps it stand out from backgrounds.
   * Default value: "rgba(0, 0, 0, 0)".
   */
  val textHaloColor: Long? = null,
  /**
   * Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
   * Default value: 0. Minimum value: 0.
   */
  val textHaloWidth: Double? = null,
  /**
   * The opacity at which the text will be drawn.
   * Default value: 1. Value range: [0, 1]
   */
  val textOpacity: Double? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): PointAnnotation {
      val id = __pigeon_list[0] as String
      val geometry = __pigeon_list[1] as Point
      val image = __pigeon_list[2] as ByteArray?
      val iconAnchor = __pigeon_list[3] as IconAnchor?
      val iconImage = __pigeon_list[4] as String?
      val iconOffset = __pigeon_list[5] as List<Double?>?
      val iconRotate = __pigeon_list[6] as Double?
      val iconSize = __pigeon_list[7] as Double?
      val iconTextFit = __pigeon_list[8] as IconTextFit?
      val iconTextFitPadding = __pigeon_list[9] as List<Double?>?
      val symbolSortKey = __pigeon_list[10] as Double?
      val textAnchor = __pigeon_list[11] as TextAnchor?
      val textField = __pigeon_list[12] as String?
      val textJustify = __pigeon_list[13] as TextJustify?
      val textLetterSpacing = __pigeon_list[14] as Double?
      val textLineHeight = __pigeon_list[15] as Double?
      val textMaxWidth = __pigeon_list[16] as Double?
      val textOffset = __pigeon_list[17] as List<Double?>?
      val textRadialOffset = __pigeon_list[18] as Double?
      val textRotate = __pigeon_list[19] as Double?
      val textSize = __pigeon_list[20] as Double?
      val textTransform = __pigeon_list[21] as TextTransform?
      val iconColor = __pigeon_list[22].let { num -> if (num is Int) num.toLong() else num as Long? }
      val iconEmissiveStrength = __pigeon_list[23] as Double?
      val iconHaloBlur = __pigeon_list[24] as Double?
      val iconHaloColor = __pigeon_list[25].let { num -> if (num is Int) num.toLong() else num as Long? }
      val iconHaloWidth = __pigeon_list[26] as Double?
      val iconImageCrossFade = __pigeon_list[27] as Double?
      val iconOpacity = __pigeon_list[28] as Double?
      val textColor = __pigeon_list[29].let { num -> if (num is Int) num.toLong() else num as Long? }
      val textEmissiveStrength = __pigeon_list[30] as Double?
      val textHaloBlur = __pigeon_list[31] as Double?
      val textHaloColor = __pigeon_list[32].let { num -> if (num is Int) num.toLong() else num as Long? }
      val textHaloWidth = __pigeon_list[33] as Double?
      val textOpacity = __pigeon_list[34] as Double?
      return PointAnnotation(id, geometry, image, iconAnchor, iconImage, iconOffset, iconRotate, iconSize, iconTextFit, iconTextFitPadding, symbolSortKey, textAnchor, textField, textJustify, textLetterSpacing, textLineHeight, textMaxWidth, textOffset, textRadialOffset, textRotate, textSize, textTransform, iconColor, iconEmissiveStrength, iconHaloBlur, iconHaloColor, iconHaloWidth, iconImageCrossFade, iconOpacity, textColor, textEmissiveStrength, textHaloBlur, textHaloColor, textHaloWidth, textOpacity)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      geometry,
      image,
      iconAnchor,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor,
      textField,
      textJustify,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PointAnnotationOptions(
  /** The geometry that determines the location/shape of this annotation */
  val geometry: Point,
  /**
   * The bitmap image for this Annotation
   * Will not take effect if [iconImage] has been set.
   */
  val image: ByteArray? = null,
  /**
   * Part of the icon placed closest to the anchor.
   * Default value: "center".
   */
  val iconAnchor: IconAnchor? = null,
  /** Name of image in sprite to use for drawing an image background. */
  val iconImage: String? = null,
  /**
   * Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
   * Default value: [0,0].
   */
  val iconOffset: List<Double?>? = null,
  /**
   * Rotates the icon clockwise.
   * Default value: 0.
   */
  val iconRotate: Double? = null,
  /**
   * Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
   * Default value: 1. Minimum value: 0.
   */
  val iconSize: Double? = null,
  /**
   * Scales the icon to fit around the associated text.
   * Default value: "none".
   */
  val iconTextFit: IconTextFit? = null,
  /**
   * Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
   * Default value: [0,0,0,0].
   */
  val iconTextFitPadding: List<Double?>? = null,
  /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
  val symbolSortKey: Double? = null,
  /**
   * Part of the text placed closest to the anchor.
   * Default value: "center".
   */
  val textAnchor: TextAnchor? = null,
  /**
   * Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
   * Default value: "".
   */
  val textField: String? = null,
  /**
   * Text justification options.
   * Default value: "center".
   */
  val textJustify: TextJustify? = null,
  /**
   * Text tracking amount.
   * Default value: 0.
   */
  val textLetterSpacing: Double? = null,
  /**
   * Text leading value for multi-line text.
   * Default value: 1.2.
   */
  val textLineHeight: Double? = null,
  /**
   * The maximum line width for text wrapping.
   * Default value: 10. Minimum value: 0.
   */
  val textMaxWidth: Double? = null,
  /**
   * Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
   * Default value: [0,0].
   */
  val textOffset: List<Double?>? = null,
  /**
   * Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
   * Default value: 0.
   */
  val textRadialOffset: Double? = null,
  /**
   * Rotates the text clockwise.
   * Default value: 0.
   */
  val textRotate: Double? = null,
  /**
   * Font size.
   * Default value: 16. Minimum value: 0.
   */
  val textSize: Double? = null,
  /**
   * Specifies how to capitalize text, similar to the CSS `text-transform` property.
   * Default value: "none".
   */
  val textTransform: TextTransform? = null,
  /**
   * The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
   * Default value: "#000000".
   */
  val iconColor: Long? = null,
  /**
   * Controls the intensity of light emitted on the source features.
   * Default value: 1. Minimum value: 0.
   */
  val iconEmissiveStrength: Double? = null,
  /**
   * Fade out the halo towards the outside.
   * Default value: 0. Minimum value: 0.
   */
  val iconHaloBlur: Double? = null,
  /**
   * The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
   * Default value: "rgba(0, 0, 0, 0)".
   */
  val iconHaloColor: Long? = null,
  /**
   * Distance of halo to the icon outline.
   * Default value: 0. Minimum value: 0.
   */
  val iconHaloWidth: Double? = null,
  /**
   * Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
   * Default value: 0. Value range: [0, 1]
   */
  val iconImageCrossFade: Double? = null,
  /**
   * The opacity at which the icon will be drawn.
   * Default value: 1. Value range: [0, 1]
   */
  val iconOpacity: Double? = null,
  /**
   * The color with which the text will be drawn.
   * Default value: "#000000".
   */
  val textColor: Long? = null,
  /**
   * Controls the intensity of light emitted on the source features.
   * Default value: 1. Minimum value: 0.
   */
  val textEmissiveStrength: Double? = null,
  /**
   * The halo's fadeout distance towards the outside.
   * Default value: 0. Minimum value: 0.
   */
  val textHaloBlur: Double? = null,
  /**
   * The color of the text's halo, which helps it stand out from backgrounds.
   * Default value: "rgba(0, 0, 0, 0)".
   */
  val textHaloColor: Long? = null,
  /**
   * Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
   * Default value: 0. Minimum value: 0.
   */
  val textHaloWidth: Double? = null,
  /**
   * The opacity at which the text will be drawn.
   * Default value: 1. Value range: [0, 1]
   */
  val textOpacity: Double? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): PointAnnotationOptions {
      val geometry = __pigeon_list[0] as Point
      val image = __pigeon_list[1] as ByteArray?
      val iconAnchor = __pigeon_list[2] as IconAnchor?
      val iconImage = __pigeon_list[3] as String?
      val iconOffset = __pigeon_list[4] as List<Double?>?
      val iconRotate = __pigeon_list[5] as Double?
      val iconSize = __pigeon_list[6] as Double?
      val iconTextFit = __pigeon_list[7] as IconTextFit?
      val iconTextFitPadding = __pigeon_list[8] as List<Double?>?
      val symbolSortKey = __pigeon_list[9] as Double?
      val textAnchor = __pigeon_list[10] as TextAnchor?
      val textField = __pigeon_list[11] as String?
      val textJustify = __pigeon_list[12] as TextJustify?
      val textLetterSpacing = __pigeon_list[13] as Double?
      val textLineHeight = __pigeon_list[14] as Double?
      val textMaxWidth = __pigeon_list[15] as Double?
      val textOffset = __pigeon_list[16] as List<Double?>?
      val textRadialOffset = __pigeon_list[17] as Double?
      val textRotate = __pigeon_list[18] as Double?
      val textSize = __pigeon_list[19] as Double?
      val textTransform = __pigeon_list[20] as TextTransform?
      val iconColor = __pigeon_list[21].let { num -> if (num is Int) num.toLong() else num as Long? }
      val iconEmissiveStrength = __pigeon_list[22] as Double?
      val iconHaloBlur = __pigeon_list[23] as Double?
      val iconHaloColor = __pigeon_list[24].let { num -> if (num is Int) num.toLong() else num as Long? }
      val iconHaloWidth = __pigeon_list[25] as Double?
      val iconImageCrossFade = __pigeon_list[26] as Double?
      val iconOpacity = __pigeon_list[27] as Double?
      val textColor = __pigeon_list[28].let { num -> if (num is Int) num.toLong() else num as Long? }
      val textEmissiveStrength = __pigeon_list[29] as Double?
      val textHaloBlur = __pigeon_list[30] as Double?
      val textHaloColor = __pigeon_list[31].let { num -> if (num is Int) num.toLong() else num as Long? }
      val textHaloWidth = __pigeon_list[32] as Double?
      val textOpacity = __pigeon_list[33] as Double?
      return PointAnnotationOptions(geometry, image, iconAnchor, iconImage, iconOffset, iconRotate, iconSize, iconTextFit, iconTextFitPadding, symbolSortKey, textAnchor, textField, textJustify, textLetterSpacing, textLineHeight, textMaxWidth, textOffset, textRadialOffset, textRotate, textSize, textTransform, iconColor, iconEmissiveStrength, iconHaloBlur, iconHaloColor, iconHaloWidth, iconImageCrossFade, iconOpacity, textColor, textEmissiveStrength, textHaloBlur, textHaloColor, textHaloWidth, textOpacity)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      geometry,
      image,
      iconAnchor,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor,
      textField,
      textJustify,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    )
  }
}
private object PointAnnotationMessengerPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointDecoder.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotation.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PointAnnotationOptions.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          IconAnchor.ofRaw(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          IconPitchAlignment.ofRaw(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          IconRotationAlignment.ofRaw(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          IconTextFit.ofRaw(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          SymbolPlacement.ofRaw(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          SymbolZOrder.ofRaw(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextAnchor.ofRaw(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextJustify.ofRaw(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextPitchAlignment.ofRaw(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextRotationAlignment.ofRaw(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextTransform.ofRaw(it)
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextVariableAnchor.ofRaw(it)
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextWritingMode.ofRaw(it)
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          IconTranslateAnchor.ofRaw(it)
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          TextTranslateAnchor.ofRaw(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is Point -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is PointAnnotation -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is PointAnnotationOptions -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is IconAnchor -> {
        stream.write(132)
        writeValue(stream, value.raw)
      }
      is IconPitchAlignment -> {
        stream.write(133)
        writeValue(stream, value.raw)
      }
      is IconRotationAlignment -> {
        stream.write(134)
        writeValue(stream, value.raw)
      }
      is IconTextFit -> {
        stream.write(135)
        writeValue(stream, value.raw)
      }
      is SymbolPlacement -> {
        stream.write(136)
        writeValue(stream, value.raw)
      }
      is SymbolZOrder -> {
        stream.write(137)
        writeValue(stream, value.raw)
      }
      is TextAnchor -> {
        stream.write(138)
        writeValue(stream, value.raw)
      }
      is TextJustify -> {
        stream.write(139)
        writeValue(stream, value.raw)
      }
      is TextPitchAlignment -> {
        stream.write(140)
        writeValue(stream, value.raw)
      }
      is TextRotationAlignment -> {
        stream.write(141)
        writeValue(stream, value.raw)
      }
      is TextTransform -> {
        stream.write(142)
        writeValue(stream, value.raw)
      }
      is TextVariableAnchor -> {
        stream.write(143)
        writeValue(stream, value.raw)
      }
      is TextWritingMode -> {
        stream.write(144)
        writeValue(stream, value.raw)
      }
      is IconTranslateAnchor -> {
        stream.write(145)
        writeValue(stream, value.raw)
      }
      is TextTranslateAnchor -> {
        stream.write(146)
        writeValue(stream, value.raw)
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class OnPointAnnotationClickListener(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by OnPointAnnotationClickListener. */
    val codec: MessageCodec<Any?> by lazy {
      PointAnnotationMessengerPigeonCodec
    }
  }
  fun onPointAnnotationClick(annotationArg: PointAnnotation, callback: (Result<Unit>) -> Unit) {
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(annotationArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(createConnectionError(channelName)))
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface _PointAnnotationMessenger {
  fun create(managerId: String, annotationOption: PointAnnotationOptions, callback: (Result<PointAnnotation>) -> Unit)
  fun createMulti(managerId: String, annotationOptions: List<PointAnnotationOptions>, callback: (Result<List<PointAnnotation>>) -> Unit)
  fun update(managerId: String, annotation: PointAnnotation, callback: (Result<Unit>) -> Unit)
  fun delete(managerId: String, annotation: PointAnnotation, callback: (Result<Unit>) -> Unit)
  fun deleteAll(managerId: String, callback: (Result<Unit>) -> Unit)
  fun setIconAllowOverlap(managerId: String, iconAllowOverlap: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconAllowOverlap(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconIgnorePlacement(managerId: String, iconIgnorePlacement: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconIgnorePlacement(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconKeepUpright(managerId: String, iconKeepUpright: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconKeepUpright(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconOptional(managerId: String, iconOptional: Boolean, callback: (Result<Unit>) -> Unit)
  fun getIconOptional(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setIconPadding(managerId: String, iconPadding: Double, callback: (Result<Unit>) -> Unit)
  fun getIconPadding(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setIconPitchAlignment(managerId: String, iconPitchAlignment: IconPitchAlignment, callback: (Result<Unit>) -> Unit)
  fun getIconPitchAlignment(managerId: String, callback: (Result<IconPitchAlignment?>) -> Unit)
  fun setIconRotationAlignment(managerId: String, iconRotationAlignment: IconRotationAlignment, callback: (Result<Unit>) -> Unit)
  fun getIconRotationAlignment(managerId: String, callback: (Result<IconRotationAlignment?>) -> Unit)
  fun setSymbolAvoidEdges(managerId: String, symbolAvoidEdges: Boolean, callback: (Result<Unit>) -> Unit)
  fun getSymbolAvoidEdges(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setSymbolPlacement(managerId: String, symbolPlacement: SymbolPlacement, callback: (Result<Unit>) -> Unit)
  fun getSymbolPlacement(managerId: String, callback: (Result<SymbolPlacement?>) -> Unit)
  fun setSymbolSpacing(managerId: String, symbolSpacing: Double, callback: (Result<Unit>) -> Unit)
  fun getSymbolSpacing(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setSymbolZElevate(managerId: String, symbolZElevate: Boolean, callback: (Result<Unit>) -> Unit)
  fun getSymbolZElevate(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setSymbolZOrder(managerId: String, symbolZOrder: SymbolZOrder, callback: (Result<Unit>) -> Unit)
  fun getSymbolZOrder(managerId: String, callback: (Result<SymbolZOrder?>) -> Unit)
  fun setTextAllowOverlap(managerId: String, textAllowOverlap: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextAllowOverlap(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextFont(managerId: String, textFont: List<String?>, callback: (Result<Unit>) -> Unit)
  fun getTextFont(managerId: String, callback: (Result<List<String?>?>) -> Unit)
  fun setTextIgnorePlacement(managerId: String, textIgnorePlacement: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextIgnorePlacement(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextKeepUpright(managerId: String, textKeepUpright: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextKeepUpright(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextMaxAngle(managerId: String, textMaxAngle: Double, callback: (Result<Unit>) -> Unit)
  fun getTextMaxAngle(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setTextOptional(managerId: String, textOptional: Boolean, callback: (Result<Unit>) -> Unit)
  fun getTextOptional(managerId: String, callback: (Result<Boolean?>) -> Unit)
  fun setTextPadding(managerId: String, textPadding: Double, callback: (Result<Unit>) -> Unit)
  fun getTextPadding(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setTextPitchAlignment(managerId: String, textPitchAlignment: TextPitchAlignment, callback: (Result<Unit>) -> Unit)
  fun getTextPitchAlignment(managerId: String, callback: (Result<TextPitchAlignment?>) -> Unit)
  fun setTextRotationAlignment(managerId: String, textRotationAlignment: TextRotationAlignment, callback: (Result<Unit>) -> Unit)
  fun getTextRotationAlignment(managerId: String, callback: (Result<TextRotationAlignment?>) -> Unit)
  fun setIconColorSaturation(managerId: String, iconColorSaturation: Double, callback: (Result<Unit>) -> Unit)
  fun getIconColorSaturation(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setIconOcclusionOpacity(managerId: String, iconOcclusionOpacity: Double, callback: (Result<Unit>) -> Unit)
  fun getIconOcclusionOpacity(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setIconTranslate(managerId: String, iconTranslate: List<Double?>, callback: (Result<Unit>) -> Unit)
  fun getIconTranslate(managerId: String, callback: (Result<List<Double?>?>) -> Unit)
  fun setIconTranslateAnchor(managerId: String, iconTranslateAnchor: IconTranslateAnchor, callback: (Result<Unit>) -> Unit)
  fun getIconTranslateAnchor(managerId: String, callback: (Result<IconTranslateAnchor?>) -> Unit)
  fun setTextOcclusionOpacity(managerId: String, textOcclusionOpacity: Double, callback: (Result<Unit>) -> Unit)
  fun getTextOcclusionOpacity(managerId: String, callback: (Result<Double?>) -> Unit)
  fun setTextTranslate(managerId: String, textTranslate: List<Double?>, callback: (Result<Unit>) -> Unit)
  fun getTextTranslate(managerId: String, callback: (Result<List<Double?>?>) -> Unit)
  fun setTextTranslateAnchor(managerId: String, textTranslateAnchor: TextTranslateAnchor, callback: (Result<Unit>) -> Unit)
  fun getTextTranslateAnchor(managerId: String, callback: (Result<TextTranslateAnchor?>) -> Unit)

  companion object {
    /** The codec used by _PointAnnotationMessenger. */
    val codec: MessageCodec<Any?> by lazy {
      PointAnnotationMessengerPigeonCodec
    }
    /** Sets up an instance of `_PointAnnotationMessenger` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: _PointAnnotationMessenger?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.create$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationOptionArg = args[1] as PointAnnotationOptions
            api.create(managerIdArg, annotationOptionArg) { result: Result<PointAnnotation> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.createMulti$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationOptionsArg = args[1] as List<PointAnnotationOptions>
            api.createMulti(managerIdArg, annotationOptionsArg) { result: Result<List<PointAnnotation>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.update$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationArg = args[1] as PointAnnotation
            api.update(managerIdArg, annotationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.delete$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val annotationArg = args[1] as PointAnnotation
            api.delete(managerIdArg, annotationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.deleteAll$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.deleteAll(managerIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconAllowOverlapArg = args[1] as Boolean
            api.setIconAllowOverlap(managerIdArg, iconAllowOverlapArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconAllowOverlap(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconIgnorePlacementArg = args[1] as Boolean
            api.setIconIgnorePlacement(managerIdArg, iconIgnorePlacementArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconIgnorePlacement(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconKeepUprightArg = args[1] as Boolean
            api.setIconKeepUpright(managerIdArg, iconKeepUprightArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconKeepUpright(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconOptionalArg = args[1] as Boolean
            api.setIconOptional(managerIdArg, iconOptionalArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconOptional(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconPaddingArg = args[1] as Double
            api.setIconPadding(managerIdArg, iconPaddingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconPadding(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconPitchAlignmentArg = args[1] as IconPitchAlignment
            api.setIconPitchAlignment(managerIdArg, iconPitchAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconPitchAlignment(managerIdArg) { result: Result<IconPitchAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconRotationAlignmentArg = args[1] as IconRotationAlignment
            api.setIconRotationAlignment(managerIdArg, iconRotationAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconRotationAlignment(managerIdArg) { result: Result<IconRotationAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolAvoidEdges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolAvoidEdgesArg = args[1] as Boolean
            api.setSymbolAvoidEdges(managerIdArg, symbolAvoidEdgesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolAvoidEdges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolAvoidEdges(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolPlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolPlacementArg = args[1] as SymbolPlacement
            api.setSymbolPlacement(managerIdArg, symbolPlacementArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolPlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolPlacement(managerIdArg) { result: Result<SymbolPlacement?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolSpacing$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolSpacingArg = args[1] as Double
            api.setSymbolSpacing(managerIdArg, symbolSpacingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolSpacing$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolSpacing(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZElevate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolZElevateArg = args[1] as Boolean
            api.setSymbolZElevate(managerIdArg, symbolZElevateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZElevate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolZElevate(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZOrder$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val symbolZOrderArg = args[1] as SymbolZOrder
            api.setSymbolZOrder(managerIdArg, symbolZOrderArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZOrder$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getSymbolZOrder(managerIdArg) { result: Result<SymbolZOrder?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textAllowOverlapArg = args[1] as Boolean
            api.setTextAllowOverlap(managerIdArg, textAllowOverlapArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextAllowOverlap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextAllowOverlap(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextFont$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textFontArg = args[1] as List<String?>
            api.setTextFont(managerIdArg, textFontArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextFont$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextFont(managerIdArg) { result: Result<List<String?>?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textIgnorePlacementArg = args[1] as Boolean
            api.setTextIgnorePlacement(managerIdArg, textIgnorePlacementArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextIgnorePlacement$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextIgnorePlacement(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textKeepUprightArg = args[1] as Boolean
            api.setTextKeepUpright(managerIdArg, textKeepUprightArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextKeepUpright$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextKeepUpright(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextMaxAngle$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textMaxAngleArg = args[1] as Double
            api.setTextMaxAngle(managerIdArg, textMaxAngleArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextMaxAngle$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextMaxAngle(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textOptionalArg = args[1] as Boolean
            api.setTextOptional(managerIdArg, textOptionalArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOptional$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextOptional(managerIdArg) { result: Result<Boolean?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textPaddingArg = args[1] as Double
            api.setTextPadding(managerIdArg, textPaddingArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPadding$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextPadding(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textPitchAlignmentArg = args[1] as TextPitchAlignment
            api.setTextPitchAlignment(managerIdArg, textPitchAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPitchAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextPitchAlignment(managerIdArg) { result: Result<TextPitchAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textRotationAlignmentArg = args[1] as TextRotationAlignment
            api.setTextRotationAlignment(managerIdArg, textRotationAlignmentArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRotationAlignment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextRotationAlignment(managerIdArg) { result: Result<TextRotationAlignment?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconColorSaturation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconColorSaturationArg = args[1] as Double
            api.setIconColorSaturation(managerIdArg, iconColorSaturationArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconColorSaturation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconColorSaturation(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOcclusionOpacity$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconOcclusionOpacityArg = args[1] as Double
            api.setIconOcclusionOpacity(managerIdArg, iconOcclusionOpacityArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOcclusionOpacity$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconOcclusionOpacity(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconTranslateArg = args[1] as List<Double?>
            api.setIconTranslate(managerIdArg, iconTranslateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconTranslate(managerIdArg) { result: Result<List<Double?>?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val iconTranslateAnchorArg = args[1] as IconTranslateAnchor
            api.setIconTranslateAnchor(managerIdArg, iconTranslateAnchorArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getIconTranslateAnchor(managerIdArg) { result: Result<IconTranslateAnchor?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOcclusionOpacity$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textOcclusionOpacityArg = args[1] as Double
            api.setTextOcclusionOpacity(managerIdArg, textOcclusionOpacityArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOcclusionOpacity$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextOcclusionOpacity(managerIdArg) { result: Result<Double?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textTranslateArg = args[1] as List<Double?>
            api.setTextTranslate(managerIdArg, textTranslateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextTranslate(managerIdArg) { result: Result<List<Double?>?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            val textTranslateAnchorArg = args[1] as TextTranslateAnchor
            api.setTextTranslateAnchor(managerIdArg, textTranslateAnchorArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslateAnchor$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val managerIdArg = args[0] as String
            api.getTextTranslateAnchor(managerIdArg) { result: Result<TextTranslateAnchor?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}