// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.mapbox_maps.pigeons

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/** Describes glyphs rasterization modes. */
enum class GlyphsRasterizationMode(val raw: Int) {
  /** No glyphs are rasterized locally. All glyphs are loaded from the server. */
  NO_GLYPHS_RASTERIZED_LOCALLY(0),
  /** Ideographs are rasterized locally, and they are not loaded from the server. */
  IDEOGRAPHS_RASTERIZED_LOCALLY(1),
  /** All glyphs are rasterized locally. No glyphs are loaded from the server. */
  ALL_GLYPHS_RASTERIZED_LOCALLY(2);

  companion object {
    fun ofRaw(raw: Int): GlyphsRasterizationMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Describes the glyphs rasterization option values.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GlyphsRasterizationOptions(
  /** Glyphs rasterization mode for client-side text rendering. */
  val rasterizationMode: GlyphsRasterizationMode,
  /**
   * Font family to use as font fallback for client-side text renderings.
   *
   * Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
   * or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
   * font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
   * default font are varied in platforms:
   * - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
   *   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
   * - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
   *
   * Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
   *
   */
  val fontFamily: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): GlyphsRasterizationOptions {
      val rasterizationMode = GlyphsRasterizationMode.ofRaw(list[0] as Int)!!
      val fontFamily = list[1] as String?
      return GlyphsRasterizationOptions(rasterizationMode, fontFamily)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      rasterizationMode.raw,
      fontFamily,
    )
  }
}

/**
 * Describes the style package load option values.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class StylePackLoadOptions(
  /**
   * Specifies glyphs rasterization mode.
   *
   * If provided, updates the style package's glyphs rasterization mode,
   * which defines which glyphs will be loaded from the server.
   *
   * By default, ideographs are rasterized locally and other glyphs are loaded
   * from network (i.e. `IdeographsRasterizedLocally` value is used).
   */
  val glyphsRasterizationMode: GlyphsRasterizationMode? = null,
  /**
   * A custom Mapbox value associated with this style package for storing metadata.
   *
   * If provided, the custom value value will be stored alongside the style package. Previous values will
   * be replaced with the new value.
   *
   * Developers can use this field to store custom metadata associated with a style package.
   */
  val metadata: String? = null,
  /**
   * Accepts expired data when loading style resources.
   *
   * This flag should be set to true to accept expired responses. When a style resource is already loaded but expired,
   * no attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
   * for a style is up-to-date.
   */
  val acceptExpired: Boolean

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StylePackLoadOptions {
      val glyphsRasterizationMode = (list[0] as Int?)?.let {
        GlyphsRasterizationMode.ofRaw(it)
      }
      val metadata = list[1] as String?
      val acceptExpired = list[2] as Boolean
      return StylePackLoadOptions(glyphsRasterizationMode, metadata, acceptExpired)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      glyphsRasterizationMode?.raw,
      metadata,
      acceptExpired,
    )
  }
}

/**
 * The `style pack` represents a stored style package.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class StylePack(
  /** The style associated with the style package. */
  val styleURI: String,
  /**
   * The glyphs rasterization mode of the style package.
   *
   * It defines which glyphs will be loaded from the server.
   */
  val glyphsRasterizationMode: GlyphsRasterizationMode,
  /** The number of resources that are known to be required for this style package. */
  val requiredResourceCount: Long,
  /**
   * The number of resources that have been fully downloaded and are ready for
   * offline access.
   */
  val completedResourceCount: Long,
  /**
   * The cumulative size, in bytes, of all resources that have
   * been fully downloaded.
   */
  val completedResourceSize: Long,
  /**
   * The earliest point in time when any of the style package resources gets expired.
   *
   * Unitialized for incomplete style packages or for complete style packages with all immutable resources.
   */
  val expires: Long? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StylePack {
      val styleURI = list[0] as String
      val glyphsRasterizationMode = GlyphsRasterizationMode.ofRaw(list[1] as Int)!!
      val requiredResourceCount = list[2].let { if (it is Int) it.toLong() else it as Long }
      val completedResourceCount = list[3].let { if (it is Int) it.toLong() else it as Long }
      val completedResourceSize = list[4].let { if (it is Int) it.toLong() else it as Long }
      val expires = list[5].let { if (it is Int) it.toLong() else it as Long? }
      return StylePack(styleURI, glyphsRasterizationMode, requiredResourceCount, completedResourceCount, completedResourceSize, expires)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      styleURI,
      glyphsRasterizationMode.raw,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    )
  }
}

/**
 * A `style pack load` progress includes information about
 * the number of resources that have completed downloading
 * and the total number of resources that are required.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class StylePackLoadProgress(
  /** The number of resources that are ready for offline access. */
  val completedResourceCount: Long,
  /** The cumulative size, in bytes, of all resources that are ready for offline access. */
  val completedResourceSize: Long,
  /** The number of resources that have failed to download due to an error. */
  val erroredResourceCount: Long,
  /** The number of resources that are known to be required for this style package. */
  val requiredResourceCount: Long,
  /** The number of resources that have been fully downloaded from the network. */
  val loadedResourceCount: Long,
  /**
   * The cumulative size, in bytes, of all resources that have been fully downloaded
   * from the network.
   */
  val loadedResourceSize: Long

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): StylePackLoadProgress {
      val completedResourceCount = list[0].let { if (it is Int) it.toLong() else it as Long }
      val completedResourceSize = list[1].let { if (it is Int) it.toLong() else it as Long }
      val erroredResourceCount = list[2].let { if (it is Int) it.toLong() else it as Long }
      val requiredResourceCount = list[3].let { if (it is Int) it.toLong() else it as Long }
      val loadedResourceCount = list[4].let { if (it is Int) it.toLong() else it as Long }
      val loadedResourceSize = list[5].let { if (it is Int) it.toLong() else it as Long }
      return StylePackLoadProgress(completedResourceCount, completedResourceSize, erroredResourceCount, requiredResourceCount, loadedResourceCount, loadedResourceSize)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    )
  }
}
@Suppress("UNCHECKED_CAST")
private object HolderCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GlyphsRasterizationOptions.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StylePackLoadProgress.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is GlyphsRasterizationOptions -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is StylePackLoadProgress -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface Holder {
  fun options(): GlyphsRasterizationOptions
  fun progress(): StylePackLoadProgress

  companion object {
    /** The codec used by Holder. */
    val codec: MessageCodec<Any?> by lazy {
      HolderCodec
    }
    /** Sets up an instance of `Holder` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: Holder?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Holder.options$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.options())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Holder.progress$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.progress())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object _OfflineManagerCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StylePack.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          StylePackLoadOptions.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is StylePack -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is StylePackLoadOptions -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface _OfflineManager {
  fun loadStylePack(styleURI: String, loadOptions: StylePackLoadOptions, callback: (Result<StylePack>) -> Unit)
  fun removeStylePack(styleURI: String, callback: (Result<StylePack>) -> Unit)
  fun addStylePackLoadProgressListener(styleURI: String)
  fun stylePack(styleURI: String, callback: (Result<StylePack>) -> Unit)
  fun stylePackMetadata(styleURI: String, callback: (Result<String?>) -> Unit)

  companion object {
    /** The codec used by _OfflineManager. */
    val codec: MessageCodec<Any?> by lazy {
      _OfflineManagerCodec
    }
    /** Sets up an instance of `_OfflineManager` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _OfflineManager?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.loadStylePack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleURIArg = args[0] as String
            val loadOptionsArg = args[1] as StylePackLoadOptions
            api.loadStylePack(styleURIArg, loadOptionsArg) { result: Result<StylePack> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.removeStylePack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleURIArg = args[0] as String
            api.removeStylePack(styleURIArg) { result: Result<StylePack> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.addStylePackLoadProgressListener$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleURIArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.addStylePackLoadProgressListener(styleURIArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleURIArg = args[0] as String
            api.stylePack(styleURIArg) { result: Result<StylePack> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePackMetadata$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val styleURIArg = args[0] as String
            api.stylePackMetadata(styleURIArg) { result: Result<String?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface _OfflineMapInstanceManager {
  fun setupOfflineManager(channelSuffix: String)
  fun tearDownOfflineManager(channelSuffix: String)

  companion object {
    /** The codec used by _OfflineMapInstanceManager. */
    val codec: MessageCodec<Any?> by lazy {
      StandardMessageCodec()
    }
    /** Sets up an instance of `_OfflineMapInstanceManager` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _OfflineMapInstanceManager?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.setupOfflineManager$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val channelSuffixArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.setupOfflineManager(channelSuffixArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.tearDownOfflineManager$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val channelSuffixArg = args[0] as String
            var wrapped: List<Any?>
            try {
              api.tearDownOfflineManager(channelSuffixArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}