// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.mapbox_maps.pigeons

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  if (exception is FlutterError) {
    return listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    return listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

enum class OrnamentPosition(val raw: Int) {
  TOP_LEFT(0),
  TOP_RIGHT(1),
  BOTTOM_RIGHT(2),
  BOTTOM_LEFT(3);

  companion object {
    fun ofRaw(raw: Int): OrnamentPosition? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Configures the directions in which the map is allowed to move during a scroll gesture. */
enum class ScrollMode(val raw: Int) {
  /** The map may only move horizontally. */
  HORIZONTAL(0),
  /** The map may only move vertically. */
  VERTICAL(1),
  /** The map may move both horizontally and vertically. */
  HORIZONTAL_AND_VERTICAL(2);

  companion object {
    fun ofRaw(raw: Int): ScrollMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The enum controls how the puck is oriented */
enum class PuckBearing(val raw: Int) {
  /** Orients the puck to match the direction in which the device is facing. */
  HEADING(0),
  /** Orients the puck to match the direction in which the device is moving. */
  COURSE(1);

  companion object {
    fun ofRaw(raw: Int): PuckBearing? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Defines scaling mode. Only applies to location-indicator type layers. */
enum class ModelScaleMode(val raw: Int) {
  /** Model is scaled so that it's always the same size relative to other map features. The property model-scale specifies how many meters each unit in the model file should cover. */
  MAP(0),
  /** Model is scaled so that it's always the same size on the screen. The property model-scale specifies how many pixels each unit in model file should cover. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): ModelScaleMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Gesture configuration allows to control the user touch interaction.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GesturesSettings(
  /** Whether the rotate gesture is enabled. */
  val rotateEnabled: Boolean? = null,
  /** Whether the pinch to zoom gesture is enabled. */
  val pinchToZoomEnabled: Boolean? = null,
  /** Whether the single-touch scroll gesture is enabled. */
  val scrollEnabled: Boolean? = null,
  /** Whether rotation is enabled for the pinch to zoom gesture. */
  val simultaneousRotateAndPinchToZoomEnabled: Boolean? = null,
  /** Whether the pitch gesture is enabled. */
  val pitchEnabled: Boolean? = null,
  /** Configures the directions in which the map is allowed to move during a scroll gesture. */
  val scrollMode: ScrollMode? = null,
  /** Whether double tapping the map with one touch results in a zoom-in animation. */
  val doubleTapToZoomInEnabled: Boolean? = null,
  /** Whether single tapping the map with two touches results in a zoom-out animation. */
  val doubleTouchToZoomOutEnabled: Boolean? = null,
  /** Whether the quick zoom gesture is enabled. */
  val quickZoomEnabled: Boolean? = null,
  /** By default, gestures rotate and zoom around the center of the gesture. Set this property to rotate and zoom around a fixed point instead. */
  val focalPoint: ScreenCoordinate? = null,
  /** Whether a deceleration animation following a pinch-to-zoom gesture is enabled. True by default. */
  val pinchToZoomDecelerationEnabled: Boolean? = null,
  /** Whether a deceleration animation following a rotate gesture is enabled. True by default. */
  val rotateDecelerationEnabled: Boolean? = null,
  /** Whether a deceleration animation following a scroll gesture is enabled. True by default. */
  val scrollDecelerationEnabled: Boolean? = null,
  /** Whether rotate threshold increases when pinching to zoom. true by default. */
  val increaseRotateThresholdWhenPinchingToZoom: Boolean? = null,
  /** Whether pinch to zoom threshold increases when rotating. true by default. */
  val increasePinchToZoomThresholdWhenRotating: Boolean? = null,
  /** The amount by which the zoom level increases or decreases during a double-tap-to-zoom-in or double-touch-to-zoom-out gesture. 1.0 by default. Must be positive. */
  val zoomAnimationAmount: Double? = null,
  /** Whether pan is enabled for the pinch gesture. */
  val pinchPanEnabled: Boolean? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): GesturesSettings {
      val rotateEnabled = list[0] as Boolean?
      val pinchToZoomEnabled = list[1] as Boolean?
      val scrollEnabled = list[2] as Boolean?
      val simultaneousRotateAndPinchToZoomEnabled = list[3] as Boolean?
      val pitchEnabled = list[4] as Boolean?
      val scrollMode = (list[5] as Int?)?.let {
        ScrollMode.ofRaw(it)
      }
      val doubleTapToZoomInEnabled = list[6] as Boolean?
      val doubleTouchToZoomOutEnabled = list[7] as Boolean?
      val quickZoomEnabled = list[8] as Boolean?
      val focalPoint = (list[9] as List<Any?>?)?.let {
        ScreenCoordinate.fromList(it)
      }
      val pinchToZoomDecelerationEnabled = list[10] as Boolean?
      val rotateDecelerationEnabled = list[11] as Boolean?
      val scrollDecelerationEnabled = list[12] as Boolean?
      val increaseRotateThresholdWhenPinchingToZoom = list[13] as Boolean?
      val increasePinchToZoomThresholdWhenRotating = list[14] as Boolean?
      val zoomAnimationAmount = list[15] as Double?
      val pinchPanEnabled = list[16] as Boolean?
      return GesturesSettings(rotateEnabled, pinchToZoomEnabled, scrollEnabled, simultaneousRotateAndPinchToZoomEnabled, pitchEnabled, scrollMode, doubleTapToZoomInEnabled, doubleTouchToZoomOutEnabled, quickZoomEnabled, focalPoint, pinchToZoomDecelerationEnabled, rotateDecelerationEnabled, scrollDecelerationEnabled, increaseRotateThresholdWhenPinchingToZoom, increasePinchToZoomThresholdWhenRotating, zoomAnimationAmount, pinchPanEnabled)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      rotateEnabled,
      pinchToZoomEnabled,
      scrollEnabled,
      simultaneousRotateAndPinchToZoomEnabled,
      pitchEnabled,
      scrollMode?.raw,
      doubleTapToZoomInEnabled,
      doubleTouchToZoomOutEnabled,
      quickZoomEnabled,
      focalPoint?.toList(),
      pinchToZoomDecelerationEnabled,
      rotateDecelerationEnabled,
      scrollDecelerationEnabled,
      increaseRotateThresholdWhenPinchingToZoom,
      increasePinchToZoomThresholdWhenRotating,
      zoomAnimationAmount,
      pinchPanEnabled,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LocationPuck2D(
  /** Name of image in sprite to use as the top of the location indicator. */
  val topImage: ByteArray? = null,
  /** Name of image in sprite to use as the middle of the location indicator. */
  val bearingImage: ByteArray? = null,
  /** Name of image in sprite to use as the background of the location indicator. */
  val shadowImage: ByteArray? = null,
  /** The scale expression of the images. If defined, it will be applied to all the three images. */
  val scaleExpression: String? = null,
  /** The opacity of the entire location puck */
  val opacity: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LocationPuck2D {
      val topImage = list[0] as ByteArray?
      val bearingImage = list[1] as ByteArray?
      val shadowImage = list[2] as ByteArray?
      val scaleExpression = list[3] as String?
      val opacity = list[4] as Double?
      return LocationPuck2D(topImage, bearingImage, shadowImage, scaleExpression, opacity)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      topImage,
      bearingImage,
      shadowImage,
      scaleExpression,
      opacity,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LocationPuck3D(
  /** An URL for the model file in gltf format. */
  val modelUri: String? = null,
  /** The position of the model. */
  val position: List<Double?>? = null,
  /** The opacity of the model. */
  val modelOpacity: Double? = null,
  /** The scale of the model. */
  val modelScale: List<Double?>? = null,
  /** The scale expression of the model, which will overwrite the default scale expression that keeps the model size constant during zoom. */
  val modelScaleExpression: String? = null,
  /** The translation of the model [lon, lat, z] */
  val modelTranslation: List<Double?>? = null,
  /** The rotation of the model. */
  val modelRotation: List<Double?>? = null,
  /** Enable/Disable shadow casting for the 3D location puck. */
  val modelCastShadows: Boolean? = null,
  /** Enable/Disable shadow receiving for the 3D location puck. */
  val modelReceiveShadows: Boolean? = null,
  /** Defines scaling mode. Only applies to location-indicator type layers. */
  val modelScaleMode: ModelScaleMode? = null,
  /** Strength of the emission. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors). */
  val modelEmissiveStrength: Double? = null,
  /** Strength of the emission as Expression string, note that when [modelEmissiveStrengthExpression] is specified, it will overwrite the [modelEmissiveStrength] property. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors). */
  val modelEmissiveStrengthExpression: String? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LocationPuck3D {
      val modelUri = list[0] as String?
      val position = list[1] as List<Double?>?
      val modelOpacity = list[2] as Double?
      val modelScale = list[3] as List<Double?>?
      val modelScaleExpression = list[4] as String?
      val modelTranslation = list[5] as List<Double?>?
      val modelRotation = list[6] as List<Double?>?
      val modelCastShadows = list[7] as Boolean?
      val modelReceiveShadows = list[8] as Boolean?
      val modelScaleMode = (list[9] as Int?)?.let {
        ModelScaleMode.ofRaw(it)
      }
      val modelEmissiveStrength = list[10] as Double?
      val modelEmissiveStrengthExpression = list[11] as String?
      return LocationPuck3D(modelUri, position, modelOpacity, modelScale, modelScaleExpression, modelTranslation, modelRotation, modelCastShadows, modelReceiveShadows, modelScaleMode, modelEmissiveStrength, modelEmissiveStrengthExpression)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      modelUri,
      position,
      modelOpacity,
      modelScale,
      modelScaleExpression,
      modelTranslation,
      modelRotation,
      modelCastShadows,
      modelReceiveShadows,
      modelScaleMode?.raw,
      modelEmissiveStrength,
      modelEmissiveStrengthExpression,
    )
  }
}

/**
 * Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LocationPuck(
  val locationPuck2D: LocationPuck2D? = null,
  val locationPuck3D: LocationPuck3D? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LocationPuck {
      val locationPuck2D = (list[0] as List<Any?>?)?.let {
        LocationPuck2D.fromList(it)
      }
      val locationPuck3D = (list[1] as List<Any?>?)?.let {
        LocationPuck3D.fromList(it)
      }
      return LocationPuck(locationPuck2D, locationPuck3D)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      locationPuck2D?.toList(),
      locationPuck3D?.toList(),
    )
  }
}

/**
 * Shows a location puck on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LocationComponentSettings(
  /** Whether the user location is visible on the map. */
  val enabled: Boolean? = null,
  /** Whether the location puck is pulsing on the map. Works for 2D location puck only. */
  val pulsingEnabled: Boolean? = null,
  /** The color of the pulsing circle. Works for 2D location puck only. */
  val pulsingColor: Long? = null,
  /** The maximum radius of the pulsing circle. Works for 2D location puck only. Note: Setting [pulsingMaxRadius] to LocationComponentConstants.PULSING_MAX_RADIUS_FOLLOW_ACCURACY will set the pulsing circle's maximum radius to follow location accuracy circle. This property is specified in pixels. */
  val pulsingMaxRadius: Double? = null,
  /** Whether show accuracy ring with location puck. Works for 2D location puck only. */
  val showAccuracyRing: Boolean? = null,
  /** The color of the accuracy ring. Works for 2D location puck only. */
  val accuracyRingColor: Long? = null,
  /** The color of the accuracy ring border. Works for 2D location puck only. */
  val accuracyRingBorderColor: Long? = null,
  /** Sets the id of the layer that's added above to when placing the component on the map. */
  val layerAbove: String? = null,
  /** Sets the id of the layer that's added below to when placing the component on the map. */
  val layerBelow: String? = null,
  /** Whether the puck rotates to track the bearing source. */
  val puckBearingEnabled: Boolean? = null,
  /** The enum controls how the puck is oriented */
  val puckBearing: PuckBearing? = null,
  /** Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time. */
  val locationPuck: LocationPuck? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LocationComponentSettings {
      val enabled = list[0] as Boolean?
      val pulsingEnabled = list[1] as Boolean?
      val pulsingColor = list[2].let { if (it is Int) it.toLong() else it as Long? }
      val pulsingMaxRadius = list[3] as Double?
      val showAccuracyRing = list[4] as Boolean?
      val accuracyRingColor = list[5].let { if (it is Int) it.toLong() else it as Long? }
      val accuracyRingBorderColor = list[6].let { if (it is Int) it.toLong() else it as Long? }
      val layerAbove = list[7] as String?
      val layerBelow = list[8] as String?
      val puckBearingEnabled = list[9] as Boolean?
      val puckBearing = (list[10] as Int?)?.let {
        PuckBearing.ofRaw(it)
      }
      val locationPuck = (list[11] as List<Any?>?)?.let {
        LocationPuck.fromList(it)
      }
      return LocationComponentSettings(enabled, pulsingEnabled, pulsingColor, pulsingMaxRadius, showAccuracyRing, accuracyRingColor, accuracyRingBorderColor, layerAbove, layerBelow, puckBearingEnabled, puckBearing, locationPuck)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      enabled,
      pulsingEnabled,
      pulsingColor,
      pulsingMaxRadius,
      showAccuracyRing,
      accuracyRingColor,
      accuracyRingBorderColor,
      layerAbove,
      layerBelow,
      puckBearingEnabled,
      puckBearing?.raw,
      locationPuck?.toList(),
    )
  }
}

/**
 * Shows the scale bar on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ScaleBarSettings(
  /** Whether the scale is visible on the map. */
  val enabled: Boolean? = null,
  /** Defines where the scale bar is positioned on the map */
  val position: OrnamentPosition? = null,
  /** Defines the margin to the left that the scale bar honors. This property is specified in pixels. */
  val marginLeft: Double? = null,
  /** Defines the margin to the top that the scale bar honors. This property is specified in pixels. */
  val marginTop: Double? = null,
  /** Defines the margin to the right that the scale bar honors. This property is specified in pixels. */
  val marginRight: Double? = null,
  /** Defines the margin to the bottom that the scale bar honors. This property is specified in pixels. */
  val marginBottom: Double? = null,
  /** Defines text color of the scale bar. */
  val textColor: Long? = null,
  /** Defines primary color of the scale bar. */
  val primaryColor: Long? = null,
  /** Defines secondary color of the scale bar. */
  val secondaryColor: Long? = null,
  /** Defines width of the border for the scale bar. This property is specified in pixels. */
  val borderWidth: Double? = null,
  /** Defines height of the scale bar. This property is specified in pixels. */
  val height: Double? = null,
  /** Defines margin of the text bar of the scale bar. This property is specified in pixels. */
  val textBarMargin: Double? = null,
  /** Defines text border width of the scale bar. This property is specified in pixels. */
  val textBorderWidth: Double? = null,
  /** Defines text size of the scale bar. This property is specified in pixels. */
  val textSize: Double? = null,
  /** Whether the scale bar is using metric unit. True if the scale bar is using metric system, false if the scale bar is using imperial units. */
  val isMetricUnits: Boolean? = null,
  /** Configures minimum refresh interval, in millisecond, default is 15. */
  val refreshInterval: Long? = null,
  /** Configures whether to show the text border or not, default is true. */
  val showTextBorder: Boolean? = null,
  /** configures ratio of scale bar max width compared with MapView width, default is 0.5. */
  val ratio: Double? = null,
  /** If set to True scale bar will be triggering onDraw depending on [ScaleBarSettings.refreshInterval] even if actual data did not change. If set to False scale bar will redraw only on demand. Defaults to False and should not be changed explicitly in most cases. Could be set to True to produce correct GPU frame metrics when running gfxinfo command. */
  val useContinuousRendering: Boolean? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): ScaleBarSettings {
      val enabled = list[0] as Boolean?
      val position = (list[1] as Int?)?.let {
        OrnamentPosition.ofRaw(it)
      }
      val marginLeft = list[2] as Double?
      val marginTop = list[3] as Double?
      val marginRight = list[4] as Double?
      val marginBottom = list[5] as Double?
      val textColor = list[6].let { if (it is Int) it.toLong() else it as Long? }
      val primaryColor = list[7].let { if (it is Int) it.toLong() else it as Long? }
      val secondaryColor = list[8].let { if (it is Int) it.toLong() else it as Long? }
      val borderWidth = list[9] as Double?
      val height = list[10] as Double?
      val textBarMargin = list[11] as Double?
      val textBorderWidth = list[12] as Double?
      val textSize = list[13] as Double?
      val isMetricUnits = list[14] as Boolean?
      val refreshInterval = list[15].let { if (it is Int) it.toLong() else it as Long? }
      val showTextBorder = list[16] as Boolean?
      val ratio = list[17] as Double?
      val useContinuousRendering = list[18] as Boolean?
      return ScaleBarSettings(enabled, position, marginLeft, marginTop, marginRight, marginBottom, textColor, primaryColor, secondaryColor, borderWidth, height, textBarMargin, textBorderWidth, textSize, isMetricUnits, refreshInterval, showTextBorder, ratio, useContinuousRendering)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      enabled,
      position?.raw,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      textColor,
      primaryColor,
      secondaryColor,
      borderWidth,
      height,
      textBarMargin,
      textBorderWidth,
      textSize,
      isMetricUnits,
      refreshInterval,
      showTextBorder,
      ratio,
      useContinuousRendering,
    )
  }
}

/**
 * Shows the compass on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CompassSettings(
  /** Whether the compass is visible on the map. */
  val enabled: Boolean? = null,
  /** Defines where the compass is positioned on the map */
  val position: OrnamentPosition? = null,
  /** Defines the margin to the left that the compass icon honors. This property is specified in pixels. */
  val marginLeft: Double? = null,
  /** Defines the margin to the top that the compass icon honors. This property is specified in pixels. */
  val marginTop: Double? = null,
  /** Defines the margin to the right that the compass icon honors. This property is specified in pixels. */
  val marginRight: Double? = null,
  /** Defines the margin to the bottom that the compass icon honors. This property is specified in pixels. */
  val marginBottom: Double? = null,
  /** The alpha channel value of the compass image */
  val opacity: Double? = null,
  /** The clockwise rotation value in degrees of the compass. */
  val rotation: Double? = null,
  /** Whether the compass is displayed. */
  val visibility: Boolean? = null,
  /** Whether the compass fades out to invisible when facing north direction. */
  val fadeWhenFacingNorth: Boolean? = null,
  /** Whether the compass can be clicked and click events can be registered. */
  val clickable: Boolean? = null,
  /** The compass image, the visual representation of the compass. */
  val image: ByteArray? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): CompassSettings {
      val enabled = list[0] as Boolean?
      val position = (list[1] as Int?)?.let {
        OrnamentPosition.ofRaw(it)
      }
      val marginLeft = list[2] as Double?
      val marginTop = list[3] as Double?
      val marginRight = list[4] as Double?
      val marginBottom = list[5] as Double?
      val opacity = list[6] as Double?
      val rotation = list[7] as Double?
      val visibility = list[8] as Boolean?
      val fadeWhenFacingNorth = list[9] as Boolean?
      val clickable = list[10] as Boolean?
      val image = list[11] as ByteArray?
      return CompassSettings(enabled, position, marginLeft, marginTop, marginRight, marginBottom, opacity, rotation, visibility, fadeWhenFacingNorth, clickable, image)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      enabled,
      position?.raw,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      opacity,
      rotation,
      visibility,
      fadeWhenFacingNorth,
      clickable,
      image,
    )
  }
}

/**
 * Shows the attribution icon on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AttributionSettings(
  /**
   * Whether the attribution icon is visible on the map.
   * Restricted API. Please contact Mapbox to discuss your use case if you intend to use this property.
   */
  val enabled: Boolean? = null,
  /** Defines text color of the attribution icon. */
  val iconColor: Long? = null,
  /** Defines where the attribution icon is positioned on the map */
  val position: OrnamentPosition? = null,
  /** Defines the margin to the left that the attribution icon honors. This property is specified in pixels. */
  val marginLeft: Double? = null,
  /** Defines the margin to the top that the attribution icon honors. This property is specified in pixels. */
  val marginTop: Double? = null,
  /** Defines the margin to the right that the attribution icon honors. This property is specified in pixels. */
  val marginRight: Double? = null,
  /** Defines the margin to the bottom that the attribution icon honors. This property is specified in pixels. */
  val marginBottom: Double? = null,
  /** Whether the attribution can be clicked and click events can be registered. */
  val clickable: Boolean? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): AttributionSettings {
      val enabled = list[0] as Boolean?
      val iconColor = list[1].let { if (it is Int) it.toLong() else it as Long? }
      val position = (list[2] as Int?)?.let {
        OrnamentPosition.ofRaw(it)
      }
      val marginLeft = list[3] as Double?
      val marginTop = list[4] as Double?
      val marginRight = list[5] as Double?
      val marginBottom = list[6] as Double?
      val clickable = list[7] as Boolean?
      return AttributionSettings(enabled, iconColor, position, marginLeft, marginTop, marginRight, marginBottom, clickable)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      enabled,
      iconColor,
      position?.raw,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      clickable,
    )
  }
}

/**
 * Shows the Mapbox logo on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LogoSettings(
  /**
   * Whether the logo is visible on the map.
   * Restricted API. Please contact Mapbox to discuss your use case if you intend to use this property.
   */
  val enabled: Boolean? = null,
  /** Defines where the logo is positioned on the map */
  val position: OrnamentPosition? = null,
  /** Defines the margin to the left that the attribution icon honors. This property is specified in pixels. */
  val marginLeft: Double? = null,
  /** Defines the margin to the top that the attribution icon honors. This property is specified in pixels. */
  val marginTop: Double? = null,
  /** Defines the margin to the right that the attribution icon honors. This property is specified in pixels. */
  val marginRight: Double? = null,
  /** Defines the margin to the bottom that the attribution icon honors. This property is specified in pixels. */
  val marginBottom: Double? = null

) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromList(list: List<Any?>): LogoSettings {
      val enabled = list[0] as Boolean?
      val position = (list[1] as Int?)?.let {
        OrnamentPosition.ofRaw(it)
      }
      val marginLeft = list[2] as Double?
      val marginTop = list[3] as Double?
      val marginRight = list[4] as Double?
      val marginBottom = list[5] as Double?
      return LogoSettings(enabled, position, marginLeft, marginTop, marginRight, marginBottom)
    }
  }
  fun toList(): List<Any?> {
    return listOf<Any?>(
      enabled,
      position?.raw,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
    )
  }
}
@Suppress("UNCHECKED_CAST")
private object GesturesSettingsInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GesturesSettings.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is GesturesSettings -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is ScreenCoordinate -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Gesture configuration allows to control the user touch interaction.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GesturesSettingsInterface {
  fun getSettings(): GesturesSettings
  fun updateSettings(settings: GesturesSettings)

  companion object {
    /** The codec used by GesturesSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      GesturesSettingsInterfaceCodec
    }
    /** Sets up an instance of `GesturesSettingsInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: GesturesSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSettings())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as GesturesSettings
            var wrapped: List<Any?>
            try {
              api.updateSettings(settingsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object _LocationComponentSettingsInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationComponentSettings.fromList(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationPuck.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationPuck2D.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationPuck3D.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is LocationComponentSettings -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      is LocationPuck -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is LocationPuck2D -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is LocationPuck3D -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Shows a location puck on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface _LocationComponentSettingsInterface {
  fun getSettings(): LocationComponentSettings
  fun updateSettings(settings: LocationComponentSettings, useDefaultPuck2DIfNeeded: Boolean)

  companion object {
    /** The codec used by _LocationComponentSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      _LocationComponentSettingsInterfaceCodec
    }
    /** Sets up an instance of `_LocationComponentSettingsInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: _LocationComponentSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSettings())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as LocationComponentSettings
            val useDefaultPuck2DIfNeededArg = args[1] as Boolean
            var wrapped: List<Any?>
            try {
              api.updateSettings(settingsArg, useDefaultPuck2DIfNeededArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object ScaleBarSettingsInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScaleBarSettings.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is ScaleBarSettings -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Shows the scale bar on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface ScaleBarSettingsInterface {
  fun getSettings(): ScaleBarSettings
  fun updateSettings(settings: ScaleBarSettings)

  companion object {
    /** The codec used by ScaleBarSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      ScaleBarSettingsInterfaceCodec
    }
    /** Sets up an instance of `ScaleBarSettingsInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: ScaleBarSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSettings())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as ScaleBarSettings
            var wrapped: List<Any?>
            try {
              api.updateSettings(settingsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object CompassSettingsInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CompassSettings.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is CompassSettings -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Shows the compass on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface CompassSettingsInterface {
  fun getSettings(): CompassSettings
  fun updateSettings(settings: CompassSettings)

  companion object {
    /** The codec used by CompassSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      CompassSettingsInterfaceCodec
    }
    /** Sets up an instance of `CompassSettingsInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: CompassSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSettings())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as CompassSettings
            var wrapped: List<Any?>
            try {
              api.updateSettings(settingsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object AttributionSettingsInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AttributionSettings.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is AttributionSettings -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Shows the attribution icon on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface AttributionSettingsInterface {
  fun getSettings(): AttributionSettings
  fun updateSettings(settings: AttributionSettings)

  companion object {
    /** The codec used by AttributionSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      AttributionSettingsInterfaceCodec
    }
    /** Sets up an instance of `AttributionSettingsInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: AttributionSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSettings())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as AttributionSettings
            var wrapped: List<Any?>
            try {
              api.updateSettings(settingsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
@Suppress("UNCHECKED_CAST")
private object LogoSettingsInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LogoSettings.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is LogoSettings -> {
        stream.write(128)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Shows the Mapbox logo on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface LogoSettingsInterface {
  fun getSettings(): LogoSettings
  fun updateSettings(settings: LogoSettings)

  companion object {
    /** The codec used by LogoSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      LogoSettingsInterfaceCodec
    }
    /** Sets up an instance of `LogoSettingsInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: LogoSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            var wrapped: List<Any?>
            try {
              wrapped = listOf<Any?>(api.getSettings())
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as LogoSettings
            var wrapped: List<Any?>
            try {
              api.updateSettings(settingsArg)
              wrapped = listOf<Any?>(null)
            } catch (exception: Throwable) {
              wrapped = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}