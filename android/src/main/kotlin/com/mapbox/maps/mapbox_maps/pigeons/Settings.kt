// Autogenerated from Pigeon (v21.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.mapbox.maps.mapbox_maps.pigeons

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

enum class OrnamentPosition(val raw: Int) {
  TOP_LEFT(0),
  TOP_RIGHT(1),
  BOTTOM_RIGHT(2),
  BOTTOM_LEFT(3);

  companion object {
    fun ofRaw(raw: Int): OrnamentPosition? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Configures the directions in which the map is allowed to move during a scroll gesture.
 * Default value: "horizontal-and-vertical".
 */
enum class ScrollMode(val raw: Int) {
  /** The map may only move horizontally. */
  HORIZONTAL(0),
  /** The map may only move vertically. */
  VERTICAL(1),
  /** The map may move both horizontally and vertically. */
  HORIZONTAL_AND_VERTICAL(2);

  companion object {
    fun ofRaw(raw: Int): ScrollMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * The enum controls how the puck is oriented
 * Default value: "heading".
 */
enum class PuckBearing(val raw: Int) {
  /** Orients the puck to match the direction in which the device is facing. */
  HEADING(0),
  /** Orients the puck to match the direction in which the device is moving. */
  COURSE(1);

  companion object {
    fun ofRaw(raw: Int): PuckBearing? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Defines scaling mode. Only applies to location-indicator type layers.
 * Default value: "map".
 */
enum class ModelScaleMode(val raw: Int) {
  /** Model is scaled so that it's always the same size relative to other map features. The property model-scale specifies how many meters each unit in the model file should cover. */
  MAP(0),
  /** Model is scaled so that it's always the same size on the screen. The property model-scale specifies how many pixels each unit in model file should cover. */
  VIEWPORT(1);

  companion object {
    fun ofRaw(raw: Int): ModelScaleMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Gesture configuration allows to control the user touch interaction.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GesturesSettings(
  /**
   * Whether the rotate gesture is enabled.
   * Default value: true.
   */
  val rotateEnabled: Boolean? = null,
  /**
   * Whether the pinch to zoom gesture is enabled.
   * Default value: true.
   */
  val pinchToZoomEnabled: Boolean? = null,
  /**
   * Whether the single-touch scroll gesture is enabled.
   * Default value: true.
   */
  val scrollEnabled: Boolean? = null,
  /**
   * Whether rotation is enabled for the pinch to zoom gesture.
   * Default value: true.
   */
  val simultaneousRotateAndPinchToZoomEnabled: Boolean? = null,
  /**
   * Whether the pitch gesture is enabled.
   * Default value: true.
   */
  val pitchEnabled: Boolean? = null,
  /**
   * Configures the directions in which the map is allowed to move during a scroll gesture.
   * Default value: "horizontal-and-vertical".
   */
  val scrollMode: ScrollMode? = null,
  /**
   * Whether double tapping the map with one touch results in a zoom-in animation.
   * Default value: true.
   */
  val doubleTapToZoomInEnabled: Boolean? = null,
  /**
   * Whether single tapping the map with two touches results in a zoom-out animation.
   * Default value: true.
   */
  val doubleTouchToZoomOutEnabled: Boolean? = null,
  /**
   * Whether the quick zoom gesture is enabled.
   * Default value: true.
   */
  val quickZoomEnabled: Boolean? = null,
  /** By default, gestures rotate and zoom around the center of the gesture. Set this property to rotate and zoom around a fixed point instead. */
  val focalPoint: ScreenCoordinate? = null,
  /**
   * Whether a deceleration animation following a pinch-to-zoom gesture is enabled. True by default.
   * Default value: true.
   */
  val pinchToZoomDecelerationEnabled: Boolean? = null,
  /**
   * Whether a deceleration animation following a rotate gesture is enabled. True by default.
   * Default value: true.
   */
  val rotateDecelerationEnabled: Boolean? = null,
  /**
   * Whether a deceleration animation following a scroll gesture is enabled. True by default.
   * Default value: true.
   */
  val scrollDecelerationEnabled: Boolean? = null,
  /**
   * Whether rotate threshold increases when pinching to zoom. true by default.
   * Default value: true.
   */
  val increaseRotateThresholdWhenPinchingToZoom: Boolean? = null,
  /**
   * Whether pinch to zoom threshold increases when rotating. true by default.
   * Default value: true.
   */
  val increasePinchToZoomThresholdWhenRotating: Boolean? = null,
  /**
   * The amount by which the zoom level increases or decreases during a double-tap-to-zoom-in or double-touch-to-zoom-out gesture. 1.0 by default. Must be positive.
   * Default value: 1.
   */
  val zoomAnimationAmount: Double? = null,
  /**
   * Whether pan is enabled for the pinch gesture.
   * Default value: true.
   */
  val pinchPanEnabled: Boolean? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): GesturesSettings {
      val rotateEnabled = __pigeon_list[0] as Boolean?
      val pinchToZoomEnabled = __pigeon_list[1] as Boolean?
      val scrollEnabled = __pigeon_list[2] as Boolean?
      val simultaneousRotateAndPinchToZoomEnabled = __pigeon_list[3] as Boolean?
      val pitchEnabled = __pigeon_list[4] as Boolean?
      val scrollMode = __pigeon_list[5] as ScrollMode?
      val doubleTapToZoomInEnabled = __pigeon_list[6] as Boolean?
      val doubleTouchToZoomOutEnabled = __pigeon_list[7] as Boolean?
      val quickZoomEnabled = __pigeon_list[8] as Boolean?
      val focalPoint = __pigeon_list[9] as ScreenCoordinate?
      val pinchToZoomDecelerationEnabled = __pigeon_list[10] as Boolean?
      val rotateDecelerationEnabled = __pigeon_list[11] as Boolean?
      val scrollDecelerationEnabled = __pigeon_list[12] as Boolean?
      val increaseRotateThresholdWhenPinchingToZoom = __pigeon_list[13] as Boolean?
      val increasePinchToZoomThresholdWhenRotating = __pigeon_list[14] as Boolean?
      val zoomAnimationAmount = __pigeon_list[15] as Double?
      val pinchPanEnabled = __pigeon_list[16] as Boolean?
      return GesturesSettings(rotateEnabled, pinchToZoomEnabled, scrollEnabled, simultaneousRotateAndPinchToZoomEnabled, pitchEnabled, scrollMode, doubleTapToZoomInEnabled, doubleTouchToZoomOutEnabled, quickZoomEnabled, focalPoint, pinchToZoomDecelerationEnabled, rotateDecelerationEnabled, scrollDecelerationEnabled, increaseRotateThresholdWhenPinchingToZoom, increasePinchToZoomThresholdWhenRotating, zoomAnimationAmount, pinchPanEnabled)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      rotateEnabled,
      pinchToZoomEnabled,
      scrollEnabled,
      simultaneousRotateAndPinchToZoomEnabled,
      pitchEnabled,
      scrollMode,
      doubleTapToZoomInEnabled,
      doubleTouchToZoomOutEnabled,
      quickZoomEnabled,
      focalPoint,
      pinchToZoomDecelerationEnabled,
      rotateDecelerationEnabled,
      scrollDecelerationEnabled,
      increaseRotateThresholdWhenPinchingToZoom,
      increasePinchToZoomThresholdWhenRotating,
      zoomAnimationAmount,
      pinchPanEnabled,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LocationPuck2D(
  /** Name of image in sprite to use as the top of the location indicator. */
  val topImage: ByteArray? = null,
  /** Name of image in sprite to use as the middle of the location indicator. */
  val bearingImage: ByteArray? = null,
  /** Name of image in sprite to use as the background of the location indicator. */
  val shadowImage: ByteArray? = null,
  /** The scale expression of the images. If defined, it will be applied to all the three images. */
  val scaleExpression: String? = null,
  /**
   * The opacity of the entire location puck
   * Default value: 1. Value range: [0, 1]
   */
  val opacity: Double? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): LocationPuck2D {
      val topImage = __pigeon_list[0] as ByteArray?
      val bearingImage = __pigeon_list[1] as ByteArray?
      val shadowImage = __pigeon_list[2] as ByteArray?
      val scaleExpression = __pigeon_list[3] as String?
      val opacity = __pigeon_list[4] as Double?
      return LocationPuck2D(topImage, bearingImage, shadowImage, scaleExpression, opacity)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      topImage,
      bearingImage,
      shadowImage,
      scaleExpression,
      opacity,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LocationPuck3D(
  /**
   * An URL for the model file in gltf format.
   * Default value: null.
   */
  val modelUri: String? = null,
  /**
   * The position of the model.
   * Default value: [0,0].
   */
  val position: List<Double?>? = null,
  /**
   * The opacity of the model.
   * Default value: 1. Value range: [0, 1]
   */
  val modelOpacity: Double? = null,
  /**
   * The scale of the model.
   * Default value: [1,1,1].
   */
  val modelScale: List<Double?>? = null,
  /** The scale expression of the model, which will overwrite the default scale expression that keeps the model size constant during zoom. */
  val modelScaleExpression: String? = null,
  /**
   * The translation of the model [lon, lat, z]
   * Default value: [0,0,0].
   */
  val modelTranslation: List<Double?>? = null,
  /**
   * The rotation of the model.
   * Default value: [0,0,90].
   */
  val modelRotation: List<Double?>? = null,
  /**
   * Enable/Disable shadow casting for the 3D location puck.
   * Default value: true.
   */
  val modelCastShadows: Boolean? = null,
  /**
   * Enable/Disable shadow receiving for the 3D location puck.
   * Default value: true.
   */
  val modelReceiveShadows: Boolean? = null,
  /**
   * Defines scaling mode. Only applies to location-indicator type layers.
   * Default value: "map".
   */
  val modelScaleMode: ModelScaleMode? = null,
  /**
   * Strength of the emission. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors).
   * Default value: 1. Value range: [0, 5]
   */
  val modelEmissiveStrength: Double? = null,
  /** Strength of the emission as Expression string, note that when [modelEmissiveStrengthExpression] is specified, it will overwrite the [modelEmissiveStrength] property. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors). */
  val modelEmissiveStrengthExpression: String? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): LocationPuck3D {
      val modelUri = __pigeon_list[0] as String?
      val position = __pigeon_list[1] as List<Double?>?
      val modelOpacity = __pigeon_list[2] as Double?
      val modelScale = __pigeon_list[3] as List<Double?>?
      val modelScaleExpression = __pigeon_list[4] as String?
      val modelTranslation = __pigeon_list[5] as List<Double?>?
      val modelRotation = __pigeon_list[6] as List<Double?>?
      val modelCastShadows = __pigeon_list[7] as Boolean?
      val modelReceiveShadows = __pigeon_list[8] as Boolean?
      val modelScaleMode = __pigeon_list[9] as ModelScaleMode?
      val modelEmissiveStrength = __pigeon_list[10] as Double?
      val modelEmissiveStrengthExpression = __pigeon_list[11] as String?
      return LocationPuck3D(modelUri, position, modelOpacity, modelScale, modelScaleExpression, modelTranslation, modelRotation, modelCastShadows, modelReceiveShadows, modelScaleMode, modelEmissiveStrength, modelEmissiveStrengthExpression)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      modelUri,
      position,
      modelOpacity,
      modelScale,
      modelScaleExpression,
      modelTranslation,
      modelRotation,
      modelCastShadows,
      modelReceiveShadows,
      modelScaleMode,
      modelEmissiveStrength,
      modelEmissiveStrengthExpression,
    )
  }
}

/**
 * Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LocationPuck(
  val locationPuck2D: LocationPuck2D? = null,
  val locationPuck3D: LocationPuck3D? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): LocationPuck {
      val locationPuck2D = __pigeon_list[0] as LocationPuck2D?
      val locationPuck3D = __pigeon_list[1] as LocationPuck3D?
      return LocationPuck(locationPuck2D, locationPuck3D)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      locationPuck2D,
      locationPuck3D,
    )
  }
}

/**
 * Shows a location puck on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LocationComponentSettings(
  /**
   * Whether the user location is visible on the map.
   * Default value: false.
   */
  val enabled: Boolean? = null,
  /**
   * Whether the location puck is pulsing on the map. Works for 2D location puck only.
   * Default value: false.
   */
  val pulsingEnabled: Boolean? = null,
  /**
   * The color of the pulsing circle. Works for 2D location puck only.
   * Default value: "#4A90E2".
   */
  val pulsingColor: Long? = null,
  /**
   * The maximum radius of the pulsing circle. Works for 2D location puck only. Note: Setting [pulsingMaxRadius] to LocationComponentConstants.PULSING_MAX_RADIUS_FOLLOW_ACCURACY will set the pulsing circle's maximum radius to follow location accuracy circle.
   * Default value: 10.
   */
  val pulsingMaxRadius: Double? = null,
  /**
   * Whether show accuracy ring with location puck. Works for 2D location puck only.
   * Default value: false.
   */
  val showAccuracyRing: Boolean? = null,
  /**
   * The color of the accuracy ring. Works for 2D location puck only.
   * Default value: "#4d89cff0".
   */
  val accuracyRingColor: Long? = null,
  /**
   * The color of the accuracy ring border. Works for 2D location puck only.
   * Default value: "#4d89cff0".
   */
  val accuracyRingBorderColor: Long? = null,
  /** Sets the id of the layer that's added above to when placing the component on the map. */
  val layerAbove: String? = null,
  /** Sets the id of the layer that's added below to when placing the component on the map. */
  val layerBelow: String? = null,
  /**
   * Whether the puck rotates to track the bearing source.
   * Default value: false.
   */
  val puckBearingEnabled: Boolean? = null,
  /**
   * The enum controls how the puck is oriented
   * Default value: "heading".
   */
  val puckBearing: PuckBearing? = null,
  /** The slot this layer is assigned to. If specified, and a slot with that name exists, it will be placed at that position in the layer order. */
  val slot: String? = null,
  /** Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time. */
  val locationPuck: LocationPuck? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): LocationComponentSettings {
      val enabled = __pigeon_list[0] as Boolean?
      val pulsingEnabled = __pigeon_list[1] as Boolean?
      val pulsingColor = __pigeon_list[2].let { num -> if (num is Int) num.toLong() else num as Long? }
      val pulsingMaxRadius = __pigeon_list[3] as Double?
      val showAccuracyRing = __pigeon_list[4] as Boolean?
      val accuracyRingColor = __pigeon_list[5].let { num -> if (num is Int) num.toLong() else num as Long? }
      val accuracyRingBorderColor = __pigeon_list[6].let { num -> if (num is Int) num.toLong() else num as Long? }
      val layerAbove = __pigeon_list[7] as String?
      val layerBelow = __pigeon_list[8] as String?
      val puckBearingEnabled = __pigeon_list[9] as Boolean?
      val puckBearing = __pigeon_list[10] as PuckBearing?
      val slot = __pigeon_list[11] as String?
      val locationPuck = __pigeon_list[12] as LocationPuck?
      return LocationComponentSettings(enabled, pulsingEnabled, pulsingColor, pulsingMaxRadius, showAccuracyRing, accuracyRingColor, accuracyRingBorderColor, layerAbove, layerBelow, puckBearingEnabled, puckBearing, slot, locationPuck)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      enabled,
      pulsingEnabled,
      pulsingColor,
      pulsingMaxRadius,
      showAccuracyRing,
      accuracyRingColor,
      accuracyRingBorderColor,
      layerAbove,
      layerBelow,
      puckBearingEnabled,
      puckBearing,
      slot,
      locationPuck,
    )
  }
}

/**
 * Shows the scale bar on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ScaleBarSettings(
  /**
   * Whether the scale is visible on the map.
   * Default value: true.
   */
  val enabled: Boolean? = null,
  /**
   * Defines where the scale bar is positioned on the map
   * Default value: "top-left".
   */
  val position: OrnamentPosition? = null,
  /**
   * Defines the margin to the left that the scale bar honors.
   * Default value: 4.
   */
  val marginLeft: Double? = null,
  /**
   * Defines the margin to the top that the scale bar honors.
   * Default value: 4.
   */
  val marginTop: Double? = null,
  /**
   * Defines the margin to the right that the scale bar honors.
   * Default value: 4.
   */
  val marginRight: Double? = null,
  /**
   * Defines the margin to the bottom that the scale bar honors.
   * Default value: 4.
   */
  val marginBottom: Double? = null,
  /**
   * Defines text color of the scale bar.
   * Default value: "black".
   */
  val textColor: Long? = null,
  /**
   * Defines primary color of the scale bar.
   * Default value: "black".
   */
  val primaryColor: Long? = null,
  /**
   * Defines secondary color of the scale bar.
   * Default value: "white".
   */
  val secondaryColor: Long? = null,
  /**
   * Defines width of the border for the scale bar.
   * Default value: 2.
   */
  val borderWidth: Double? = null,
  /**
   * Defines height of the scale bar.
   * Default value: 2.
   */
  val height: Double? = null,
  /**
   * Defines margin of the text bar of the scale bar.
   * Default value: 8.
   */
  val textBarMargin: Double? = null,
  /**
   * Defines text border width of the scale bar.
   * Default value: 2.
   */
  val textBorderWidth: Double? = null,
  /**
   * Defines text size of the scale bar.
   * Default value: 8.
   */
  val textSize: Double? = null,
  /**
   * Whether the scale bar is using metric unit. True if the scale bar is using metric system, false if the scale bar is using imperial units.
   * Default value: true.
   */
  val isMetricUnits: Boolean? = null,
  /**
   * Configures minimum refresh interval, in millisecond, default is 15.
   * Default value: 15.
   */
  val refreshInterval: Long? = null,
  /**
   * Configures whether to show the text border or not, default is true.
   * Default value: true.
   */
  val showTextBorder: Boolean? = null,
  /**
   * configures ratio of scale bar max width compared with MapView width, default is 0.5.
   * Default value: 0.5.
   */
  val ratio: Double? = null,
  /**
   * If set to True scale bar will be triggering onDraw depending on [ScaleBarSettings.refreshInterval] even if actual data did not change. If set to False scale bar will redraw only on demand. Defaults to False and should not be changed explicitly in most cases. Could be set to True to produce correct GPU frame metrics when running gfxinfo command.
   * Default value: false.
   */
  val useContinuousRendering: Boolean? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): ScaleBarSettings {
      val enabled = __pigeon_list[0] as Boolean?
      val position = __pigeon_list[1] as OrnamentPosition?
      val marginLeft = __pigeon_list[2] as Double?
      val marginTop = __pigeon_list[3] as Double?
      val marginRight = __pigeon_list[4] as Double?
      val marginBottom = __pigeon_list[5] as Double?
      val textColor = __pigeon_list[6].let { num -> if (num is Int) num.toLong() else num as Long? }
      val primaryColor = __pigeon_list[7].let { num -> if (num is Int) num.toLong() else num as Long? }
      val secondaryColor = __pigeon_list[8].let { num -> if (num is Int) num.toLong() else num as Long? }
      val borderWidth = __pigeon_list[9] as Double?
      val height = __pigeon_list[10] as Double?
      val textBarMargin = __pigeon_list[11] as Double?
      val textBorderWidth = __pigeon_list[12] as Double?
      val textSize = __pigeon_list[13] as Double?
      val isMetricUnits = __pigeon_list[14] as Boolean?
      val refreshInterval = __pigeon_list[15].let { num -> if (num is Int) num.toLong() else num as Long? }
      val showTextBorder = __pigeon_list[16] as Boolean?
      val ratio = __pigeon_list[17] as Double?
      val useContinuousRendering = __pigeon_list[18] as Boolean?
      return ScaleBarSettings(enabled, position, marginLeft, marginTop, marginRight, marginBottom, textColor, primaryColor, secondaryColor, borderWidth, height, textBarMargin, textBorderWidth, textSize, isMetricUnits, refreshInterval, showTextBorder, ratio, useContinuousRendering)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      enabled,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      textColor,
      primaryColor,
      secondaryColor,
      borderWidth,
      height,
      textBarMargin,
      textBorderWidth,
      textSize,
      isMetricUnits,
      refreshInterval,
      showTextBorder,
      ratio,
      useContinuousRendering,
    )
  }
}

/**
 * Shows the compass on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CompassSettings(
  /**
   * Whether the compass is visible on the map.
   * Default value: true.
   */
  val enabled: Boolean? = null,
  /**
   * Defines where the compass is positioned on the map
   * Default value: "top-right".
   */
  val position: OrnamentPosition? = null,
  /**
   * Defines the margin to the left that the compass icon honors.
   * Default value: 4.
   */
  val marginLeft: Double? = null,
  /**
   * Defines the margin to the top that the compass icon honors.
   * Default value: 4.
   */
  val marginTop: Double? = null,
  /**
   * Defines the margin to the right that the compass icon honors.
   * Default value: 4.
   */
  val marginRight: Double? = null,
  /**
   * Defines the margin to the bottom that the compass icon honors.
   * Default value: 4.
   */
  val marginBottom: Double? = null,
  /**
   * The alpha channel value of the compass image
   * Default value: 1.
   */
  val opacity: Double? = null,
  /**
   * The clockwise rotation value in degrees of the compass.
   * Default value: 0.
   */
  val rotation: Double? = null,
  /**
   * Whether the compass is displayed.
   * Default value: true.
   */
  val visibility: Boolean? = null,
  /**
   * Whether the compass fades out to invisible when facing north direction.
   * Default value: true.
   */
  val fadeWhenFacingNorth: Boolean? = null,
  /**
   * Whether the compass can be clicked and click events can be registered.
   * Default value: true.
   */
  val clickable: Boolean? = null,
  /** The compass image, the visual representation of the compass. */
  val image: ByteArray? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): CompassSettings {
      val enabled = __pigeon_list[0] as Boolean?
      val position = __pigeon_list[1] as OrnamentPosition?
      val marginLeft = __pigeon_list[2] as Double?
      val marginTop = __pigeon_list[3] as Double?
      val marginRight = __pigeon_list[4] as Double?
      val marginBottom = __pigeon_list[5] as Double?
      val opacity = __pigeon_list[6] as Double?
      val rotation = __pigeon_list[7] as Double?
      val visibility = __pigeon_list[8] as Boolean?
      val fadeWhenFacingNorth = __pigeon_list[9] as Boolean?
      val clickable = __pigeon_list[10] as Boolean?
      val image = __pigeon_list[11] as ByteArray?
      return CompassSettings(enabled, position, marginLeft, marginTop, marginRight, marginBottom, opacity, rotation, visibility, fadeWhenFacingNorth, clickable, image)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      enabled,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      opacity,
      rotation,
      visibility,
      fadeWhenFacingNorth,
      clickable,
      image,
    )
  }
}

/**
 * Shows the attribution icon on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AttributionSettings(
  /**
   * Whether the attribution icon is visible on the map.
   * Default value: true.
   * Restricted API. Please contact Mapbox to discuss your use case if you intend to use this property.
   */
  val enabled: Boolean? = null,
  /**
   * Defines text color of the attribution icon.
   * Default value: "#FF1E8CAB".
   */
  val iconColor: Long? = null,
  /**
   * Defines where the attribution icon is positioned on the map
   * Default value: "bottom-left".
   */
  val position: OrnamentPosition? = null,
  /**
   * Defines the margin to the left that the attribution icon honors.
   * Default value: 92.
   */
  val marginLeft: Double? = null,
  /**
   * Defines the margin to the top that the attribution icon honors.
   * Default value: 4.
   */
  val marginTop: Double? = null,
  /**
   * Defines the margin to the right that the attribution icon honors.
   * Default value: 4.
   */
  val marginRight: Double? = null,
  /**
   * Defines the margin to the bottom that the attribution icon honors.
   * Default value: 4.
   */
  val marginBottom: Double? = null,
  /**
   * Whether the attribution can be clicked and click events can be registered.
   * Default value: true.
   */
  val clickable: Boolean? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): AttributionSettings {
      val enabled = __pigeon_list[0] as Boolean?
      val iconColor = __pigeon_list[1].let { num -> if (num is Int) num.toLong() else num as Long? }
      val position = __pigeon_list[2] as OrnamentPosition?
      val marginLeft = __pigeon_list[3] as Double?
      val marginTop = __pigeon_list[4] as Double?
      val marginRight = __pigeon_list[5] as Double?
      val marginBottom = __pigeon_list[6] as Double?
      val clickable = __pigeon_list[7] as Boolean?
      return AttributionSettings(enabled, iconColor, position, marginLeft, marginTop, marginRight, marginBottom, clickable)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      enabled,
      iconColor,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      clickable,
    )
  }
}

/**
 * Shows the Mapbox logo on the map.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LogoSettings(
  /**
   * Whether the logo is visible on the map.
   * Default value: true.
   * Restricted API. Please contact Mapbox to discuss your use case if you intend to use this property.
   */
  val enabled: Boolean? = null,
  /**
   * Defines where the logo is positioned on the map
   * Default value: "bottom-left".
   */
  val position: OrnamentPosition? = null,
  /**
   * Defines the margin to the left that the attribution icon honors.
   * Default value: 4.
   */
  val marginLeft: Double? = null,
  /**
   * Defines the margin to the top that the attribution icon honors.
   * Default value: 4.
   */
  val marginTop: Double? = null,
  /**
   * Defines the margin to the right that the attribution icon honors.
   * Default value: 4.
   */
  val marginRight: Double? = null,
  /**
   * Defines the margin to the bottom that the attribution icon honors.
   * Default value: 4.
   */
  val marginBottom: Double? = null

) {
  companion object {
    @Suppress("LocalVariableName")
    fun fromList(__pigeon_list: List<Any?>): LogoSettings {
      val enabled = __pigeon_list[0] as Boolean?
      val position = __pigeon_list[1] as OrnamentPosition?
      val marginLeft = __pigeon_list[2] as Double?
      val marginTop = __pigeon_list[3] as Double?
      val marginRight = __pigeon_list[4] as Double?
      val marginBottom = __pigeon_list[5] as Double?
      return LogoSettings(enabled, position, marginLeft, marginTop, marginRight, marginBottom)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      enabled,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
    )
  }
}
private object SettingsPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScreenCoordinate.fromList(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GesturesSettings.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationPuck2D.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationPuck3D.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationPuck.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LocationComponentSettings.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ScaleBarSettings.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CompassSettings.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AttributionSettings.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LogoSettings.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          OrnamentPosition.ofRaw(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          ScrollMode.ofRaw(it)
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          PuckBearing.ofRaw(it)
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as Int?)?.let {
          ModelScaleMode.ofRaw(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
    when (value) {
      is ScreenCoordinate -> {
        stream.write(129)
        writeValue(stream, value.toList())
      }
      is GesturesSettings -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is LocationPuck2D -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is LocationPuck3D -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is LocationPuck -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is LocationComponentSettings -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is ScaleBarSettings -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is CompassSettings -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is AttributionSettings -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is LogoSettings -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is OrnamentPosition -> {
        stream.write(139)
        writeValue(stream, value.raw)
      }
      is ScrollMode -> {
        stream.write(140)
        writeValue(stream, value.raw)
      }
      is PuckBearing -> {
        stream.write(141)
        writeValue(stream, value.raw)
      }
      is ModelScaleMode -> {
        stream.write(142)
        writeValue(stream, value.raw)
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/**
 * Gesture configuration allows to control the user touch interaction.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GesturesSettingsInterface {
  fun getSettings(): GesturesSettings
  fun updateSettings(settings: GesturesSettings)

  companion object {
    /** The codec used by GesturesSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      SettingsPigeonCodec
    }
    /** Sets up an instance of `GesturesSettingsInterface` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GesturesSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSettings())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as GesturesSettings
            val wrapped: List<Any?> = try {
              api.updateSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Shows a location puck on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface _LocationComponentSettingsInterface {
  fun getSettings(): LocationComponentSettings
  fun updateSettings(settings: LocationComponentSettings, useDefaultPuck2DIfNeeded: Boolean)

  companion object {
    /** The codec used by _LocationComponentSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      SettingsPigeonCodec
    }
    /** Sets up an instance of `_LocationComponentSettingsInterface` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: _LocationComponentSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSettings())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as LocationComponentSettings
            val useDefaultPuck2DIfNeededArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.updateSettings(settingsArg, useDefaultPuck2DIfNeededArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Shows the scale bar on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface ScaleBarSettingsInterface {
  fun getSettings(): ScaleBarSettings
  fun updateSettings(settings: ScaleBarSettings)

  companion object {
    /** The codec used by ScaleBarSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      SettingsPigeonCodec
    }
    /** Sets up an instance of `ScaleBarSettingsInterface` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: ScaleBarSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSettings())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as ScaleBarSettings
            val wrapped: List<Any?> = try {
              api.updateSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Shows the compass on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface CompassSettingsInterface {
  fun getSettings(): CompassSettings
  fun updateSettings(settings: CompassSettings)

  companion object {
    /** The codec used by CompassSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      SettingsPigeonCodec
    }
    /** Sets up an instance of `CompassSettingsInterface` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: CompassSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSettings())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as CompassSettings
            val wrapped: List<Any?> = try {
              api.updateSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Shows the attribution icon on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface AttributionSettingsInterface {
  fun getSettings(): AttributionSettings
  fun updateSettings(settings: AttributionSettings)

  companion object {
    /** The codec used by AttributionSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      SettingsPigeonCodec
    }
    /** Sets up an instance of `AttributionSettingsInterface` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: AttributionSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSettings())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as AttributionSettings
            val wrapped: List<Any?> = try {
              api.updateSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Shows the Mapbox logo on the map.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface LogoSettingsInterface {
  fun getSettings(): LogoSettings
  fun updateSettings(settings: LogoSettings)

  companion object {
    /** The codec used by LogoSettingsInterface. */
    val codec: MessageCodec<Any?> by lazy {
      SettingsPigeonCodec
    }
    /** Sets up an instance of `LogoSettingsInterface` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: LogoSettingsInterface?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.getSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getSettings())
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.updateSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as LogoSettings
            val wrapped: List<Any?> = try {
              api.updateSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}