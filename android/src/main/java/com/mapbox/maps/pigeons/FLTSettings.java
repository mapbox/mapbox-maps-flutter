// Autogenerated from Pigeon (v16.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.pigeons;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.CLASS;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class FLTSettings {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) 
    {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
        "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  @Target(METHOD)
  @Retention(CLASS)
  @interface CanIgnoreReturnValue {}

  public enum OrnamentPosition {
    TOP_LEFT(0),
    TOP_RIGHT(1),
    BOTTOM_RIGHT(2),
    BOTTOM_LEFT(3);

    final int index;

    private OrnamentPosition(final int index) {
      this.index = index;
    }
  }

  /** Configures the directions in which the map is allowed to move during a scroll gesture. */
  public enum ScrollMode {
    /** The map may only move horizontally. */
    HORIZONTAL(0),
    /** The map may only move vertically. */
    VERTICAL(1),
    /** The map may move both horizontally and vertically. */
    HORIZONTAL_AND_VERTICAL(2);

    final int index;

    private ScrollMode(final int index) {
      this.index = index;
    }
  }

  /** The enum controls how the puck is oriented */
  public enum PuckBearing {
    /** Orients the puck to match the direction in which the device is facing. */
    HEADING(0),
    /** Orients the puck to match the direction in which the device is moving. */
    COURSE(1);

    final int index;

    private PuckBearing(final int index) {
      this.index = index;
    }
  }

  /** Defines scaling mode. Only applies to location-indicator type layers. */
  public enum ModelScaleMode {
    /** Model is scaled so that it's always the same size relative to other map features. The property model-scale specifies how many meters each unit in the model file should cover. */
    MAP(0),
    /** Model is scaled so that it's always the same size on the screen. The property model-scale specifies how many pixels each unit in model file should cover. */
    VIEWPORT(1);

    final int index;

    private ModelScaleMode(final int index) {
      this.index = index;
    }
  }

  /**
   * Describes the coordinate on the screen, measured from top to bottom and from left to right.
   * Note: the `map` uses screen coordinate units measured in `platform pixels`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ScreenCoordinate {
    /** A value representing the x position of this coordinate. */
    private @NonNull Double x;

    public @NonNull Double getX() {
      return x;
    }

    public void setX(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** A value representing the y position of this coordinate. */
    private @NonNull Double y;

    public @NonNull Double getY() {
      return y;
    }

    public void setY(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ScreenCoordinate() {}

    public static final class Builder {

      private @Nullable Double x;

      @CanIgnoreReturnValue
      public @NonNull Builder setX(@NonNull Double setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Double y;

      @CanIgnoreReturnValue
      public @NonNull Builder setY(@NonNull Double setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull ScreenCoordinate build() {
        ScreenCoordinate pigeonReturn = new ScreenCoordinate();
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull ScreenCoordinate fromList(@NonNull ArrayList<Object> list) {
      ScreenCoordinate pigeonResult = new ScreenCoordinate();
      Object x = list.get(0);
      pigeonResult.setX((Double) x);
      Object y = list.get(1);
      pigeonResult.setY((Double) y);
      return pigeonResult;
    }
  }

  /**
   * Gesture configuration allows to control the user touch interaction.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class GesturesSettings {
    /** Whether the rotate gesture is enabled. */
    private @Nullable Boolean rotateEnabled;

    public @Nullable Boolean getRotateEnabled() {
      return rotateEnabled;
    }

    public void setRotateEnabled(@Nullable Boolean setterArg) {
      this.rotateEnabled = setterArg;
    }

    /** Whether the pinch to zoom gesture is enabled. */
    private @Nullable Boolean pinchToZoomEnabled;

    public @Nullable Boolean getPinchToZoomEnabled() {
      return pinchToZoomEnabled;
    }

    public void setPinchToZoomEnabled(@Nullable Boolean setterArg) {
      this.pinchToZoomEnabled = setterArg;
    }

    /** Whether the single-touch scroll gesture is enabled. */
    private @Nullable Boolean scrollEnabled;

    public @Nullable Boolean getScrollEnabled() {
      return scrollEnabled;
    }

    public void setScrollEnabled(@Nullable Boolean setterArg) {
      this.scrollEnabled = setterArg;
    }

    /** Whether rotation is enabled for the pinch to zoom gesture. */
    private @Nullable Boolean simultaneousRotateAndPinchToZoomEnabled;

    public @Nullable Boolean getSimultaneousRotateAndPinchToZoomEnabled() {
      return simultaneousRotateAndPinchToZoomEnabled;
    }

    public void setSimultaneousRotateAndPinchToZoomEnabled(@Nullable Boolean setterArg) {
      this.simultaneousRotateAndPinchToZoomEnabled = setterArg;
    }

    /** Whether the pitch gesture is enabled. */
    private @Nullable Boolean pitchEnabled;

    public @Nullable Boolean getPitchEnabled() {
      return pitchEnabled;
    }

    public void setPitchEnabled(@Nullable Boolean setterArg) {
      this.pitchEnabled = setterArg;
    }

    /** Configures the directions in which the map is allowed to move during a scroll gesture. */
    private @Nullable ScrollMode scrollMode;

    public @Nullable ScrollMode getScrollMode() {
      return scrollMode;
    }

    public void setScrollMode(@Nullable ScrollMode setterArg) {
      this.scrollMode = setterArg;
    }

    /** Whether double tapping the map with one touch results in a zoom-in animation. */
    private @Nullable Boolean doubleTapToZoomInEnabled;

    public @Nullable Boolean getDoubleTapToZoomInEnabled() {
      return doubleTapToZoomInEnabled;
    }

    public void setDoubleTapToZoomInEnabled(@Nullable Boolean setterArg) {
      this.doubleTapToZoomInEnabled = setterArg;
    }

    /** Whether single tapping the map with two touches results in a zoom-out animation. */
    private @Nullable Boolean doubleTouchToZoomOutEnabled;

    public @Nullable Boolean getDoubleTouchToZoomOutEnabled() {
      return doubleTouchToZoomOutEnabled;
    }

    public void setDoubleTouchToZoomOutEnabled(@Nullable Boolean setterArg) {
      this.doubleTouchToZoomOutEnabled = setterArg;
    }

    /** Whether the quick zoom gesture is enabled. */
    private @Nullable Boolean quickZoomEnabled;

    public @Nullable Boolean getQuickZoomEnabled() {
      return quickZoomEnabled;
    }

    public void setQuickZoomEnabled(@Nullable Boolean setterArg) {
      this.quickZoomEnabled = setterArg;
    }

    /** By default, gestures rotate and zoom around the center of the gesture. Set this property to rotate and zoom around a fixed point instead. */
    private @Nullable ScreenCoordinate focalPoint;

    public @Nullable ScreenCoordinate getFocalPoint() {
      return focalPoint;
    }

    public void setFocalPoint(@Nullable ScreenCoordinate setterArg) {
      this.focalPoint = setterArg;
    }

    /** Whether a deceleration animation following a pinch-to-zoom gesture is enabled. True by default. */
    private @Nullable Boolean pinchToZoomDecelerationEnabled;

    public @Nullable Boolean getPinchToZoomDecelerationEnabled() {
      return pinchToZoomDecelerationEnabled;
    }

    public void setPinchToZoomDecelerationEnabled(@Nullable Boolean setterArg) {
      this.pinchToZoomDecelerationEnabled = setterArg;
    }

    /** Whether a deceleration animation following a rotate gesture is enabled. True by default. */
    private @Nullable Boolean rotateDecelerationEnabled;

    public @Nullable Boolean getRotateDecelerationEnabled() {
      return rotateDecelerationEnabled;
    }

    public void setRotateDecelerationEnabled(@Nullable Boolean setterArg) {
      this.rotateDecelerationEnabled = setterArg;
    }

    /** Whether a deceleration animation following a scroll gesture is enabled. True by default. */
    private @Nullable Boolean scrollDecelerationEnabled;

    public @Nullable Boolean getScrollDecelerationEnabled() {
      return scrollDecelerationEnabled;
    }

    public void setScrollDecelerationEnabled(@Nullable Boolean setterArg) {
      this.scrollDecelerationEnabled = setterArg;
    }

    /** Whether rotate threshold increases when pinching to zoom. true by default. */
    private @Nullable Boolean increaseRotateThresholdWhenPinchingToZoom;

    public @Nullable Boolean getIncreaseRotateThresholdWhenPinchingToZoom() {
      return increaseRotateThresholdWhenPinchingToZoom;
    }

    public void setIncreaseRotateThresholdWhenPinchingToZoom(@Nullable Boolean setterArg) {
      this.increaseRotateThresholdWhenPinchingToZoom = setterArg;
    }

    /** Whether pinch to zoom threshold increases when rotating. true by default. */
    private @Nullable Boolean increasePinchToZoomThresholdWhenRotating;

    public @Nullable Boolean getIncreasePinchToZoomThresholdWhenRotating() {
      return increasePinchToZoomThresholdWhenRotating;
    }

    public void setIncreasePinchToZoomThresholdWhenRotating(@Nullable Boolean setterArg) {
      this.increasePinchToZoomThresholdWhenRotating = setterArg;
    }

    /** The amount by which the zoom level increases or decreases during a double-tap-to-zoom-in or double-touch-to-zoom-out gesture. 1.0 by default. Must be positive. */
    private @Nullable Double zoomAnimationAmount;

    public @Nullable Double getZoomAnimationAmount() {
      return zoomAnimationAmount;
    }

    public void setZoomAnimationAmount(@Nullable Double setterArg) {
      this.zoomAnimationAmount = setterArg;
    }

    /** Whether pan is enabled for the pinch gesture. */
    private @Nullable Boolean pinchPanEnabled;

    public @Nullable Boolean getPinchPanEnabled() {
      return pinchPanEnabled;
    }

    public void setPinchPanEnabled(@Nullable Boolean setterArg) {
      this.pinchPanEnabled = setterArg;
    }

    public static final class Builder {

      private @Nullable Boolean rotateEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setRotateEnabled(@Nullable Boolean setterArg) {
        this.rotateEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean pinchToZoomEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setPinchToZoomEnabled(@Nullable Boolean setterArg) {
        this.pinchToZoomEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean scrollEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setScrollEnabled(@Nullable Boolean setterArg) {
        this.scrollEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean simultaneousRotateAndPinchToZoomEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setSimultaneousRotateAndPinchToZoomEnabled(@Nullable Boolean setterArg) {
        this.simultaneousRotateAndPinchToZoomEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean pitchEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setPitchEnabled(@Nullable Boolean setterArg) {
        this.pitchEnabled = setterArg;
        return this;
      }

      private @Nullable ScrollMode scrollMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setScrollMode(@Nullable ScrollMode setterArg) {
        this.scrollMode = setterArg;
        return this;
      }

      private @Nullable Boolean doubleTapToZoomInEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setDoubleTapToZoomInEnabled(@Nullable Boolean setterArg) {
        this.doubleTapToZoomInEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean doubleTouchToZoomOutEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setDoubleTouchToZoomOutEnabled(@Nullable Boolean setterArg) {
        this.doubleTouchToZoomOutEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean quickZoomEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setQuickZoomEnabled(@Nullable Boolean setterArg) {
        this.quickZoomEnabled = setterArg;
        return this;
      }

      private @Nullable ScreenCoordinate focalPoint;

      @CanIgnoreReturnValue
      public @NonNull Builder setFocalPoint(@Nullable ScreenCoordinate setterArg) {
        this.focalPoint = setterArg;
        return this;
      }

      private @Nullable Boolean pinchToZoomDecelerationEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setPinchToZoomDecelerationEnabled(@Nullable Boolean setterArg) {
        this.pinchToZoomDecelerationEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean rotateDecelerationEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setRotateDecelerationEnabled(@Nullable Boolean setterArg) {
        this.rotateDecelerationEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean scrollDecelerationEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setScrollDecelerationEnabled(@Nullable Boolean setterArg) {
        this.scrollDecelerationEnabled = setterArg;
        return this;
      }

      private @Nullable Boolean increaseRotateThresholdWhenPinchingToZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setIncreaseRotateThresholdWhenPinchingToZoom(@Nullable Boolean setterArg) {
        this.increaseRotateThresholdWhenPinchingToZoom = setterArg;
        return this;
      }

      private @Nullable Boolean increasePinchToZoomThresholdWhenRotating;

      @CanIgnoreReturnValue
      public @NonNull Builder setIncreasePinchToZoomThresholdWhenRotating(@Nullable Boolean setterArg) {
        this.increasePinchToZoomThresholdWhenRotating = setterArg;
        return this;
      }

      private @Nullable Double zoomAnimationAmount;

      @CanIgnoreReturnValue
      public @NonNull Builder setZoomAnimationAmount(@Nullable Double setterArg) {
        this.zoomAnimationAmount = setterArg;
        return this;
      }

      private @Nullable Boolean pinchPanEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setPinchPanEnabled(@Nullable Boolean setterArg) {
        this.pinchPanEnabled = setterArg;
        return this;
      }

      public @NonNull GesturesSettings build() {
        GesturesSettings pigeonReturn = new GesturesSettings();
        pigeonReturn.setRotateEnabled(rotateEnabled);
        pigeonReturn.setPinchToZoomEnabled(pinchToZoomEnabled);
        pigeonReturn.setScrollEnabled(scrollEnabled);
        pigeonReturn.setSimultaneousRotateAndPinchToZoomEnabled(simultaneousRotateAndPinchToZoomEnabled);
        pigeonReturn.setPitchEnabled(pitchEnabled);
        pigeonReturn.setScrollMode(scrollMode);
        pigeonReturn.setDoubleTapToZoomInEnabled(doubleTapToZoomInEnabled);
        pigeonReturn.setDoubleTouchToZoomOutEnabled(doubleTouchToZoomOutEnabled);
        pigeonReturn.setQuickZoomEnabled(quickZoomEnabled);
        pigeonReturn.setFocalPoint(focalPoint);
        pigeonReturn.setPinchToZoomDecelerationEnabled(pinchToZoomDecelerationEnabled);
        pigeonReturn.setRotateDecelerationEnabled(rotateDecelerationEnabled);
        pigeonReturn.setScrollDecelerationEnabled(scrollDecelerationEnabled);
        pigeonReturn.setIncreaseRotateThresholdWhenPinchingToZoom(increaseRotateThresholdWhenPinchingToZoom);
        pigeonReturn.setIncreasePinchToZoomThresholdWhenRotating(increasePinchToZoomThresholdWhenRotating);
        pigeonReturn.setZoomAnimationAmount(zoomAnimationAmount);
        pigeonReturn.setPinchPanEnabled(pinchPanEnabled);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(17);
      toListResult.add(rotateEnabled);
      toListResult.add(pinchToZoomEnabled);
      toListResult.add(scrollEnabled);
      toListResult.add(simultaneousRotateAndPinchToZoomEnabled);
      toListResult.add(pitchEnabled);
      toListResult.add(scrollMode == null ? null : scrollMode.index);
      toListResult.add(doubleTapToZoomInEnabled);
      toListResult.add(doubleTouchToZoomOutEnabled);
      toListResult.add(quickZoomEnabled);
      toListResult.add((focalPoint == null) ? null : focalPoint.toList());
      toListResult.add(pinchToZoomDecelerationEnabled);
      toListResult.add(rotateDecelerationEnabled);
      toListResult.add(scrollDecelerationEnabled);
      toListResult.add(increaseRotateThresholdWhenPinchingToZoom);
      toListResult.add(increasePinchToZoomThresholdWhenRotating);
      toListResult.add(zoomAnimationAmount);
      toListResult.add(pinchPanEnabled);
      return toListResult;
    }

    static @NonNull GesturesSettings fromList(@NonNull ArrayList<Object> list) {
      GesturesSettings pigeonResult = new GesturesSettings();
      Object rotateEnabled = list.get(0);
      pigeonResult.setRotateEnabled((Boolean) rotateEnabled);
      Object pinchToZoomEnabled = list.get(1);
      pigeonResult.setPinchToZoomEnabled((Boolean) pinchToZoomEnabled);
      Object scrollEnabled = list.get(2);
      pigeonResult.setScrollEnabled((Boolean) scrollEnabled);
      Object simultaneousRotateAndPinchToZoomEnabled = list.get(3);
      pigeonResult.setSimultaneousRotateAndPinchToZoomEnabled((Boolean) simultaneousRotateAndPinchToZoomEnabled);
      Object pitchEnabled = list.get(4);
      pigeonResult.setPitchEnabled((Boolean) pitchEnabled);
      Object scrollMode = list.get(5);
      pigeonResult.setScrollMode(scrollMode == null ? null : ScrollMode.values()[(int) scrollMode]);
      Object doubleTapToZoomInEnabled = list.get(6);
      pigeonResult.setDoubleTapToZoomInEnabled((Boolean) doubleTapToZoomInEnabled);
      Object doubleTouchToZoomOutEnabled = list.get(7);
      pigeonResult.setDoubleTouchToZoomOutEnabled((Boolean) doubleTouchToZoomOutEnabled);
      Object quickZoomEnabled = list.get(8);
      pigeonResult.setQuickZoomEnabled((Boolean) quickZoomEnabled);
      Object focalPoint = list.get(9);
      pigeonResult.setFocalPoint((focalPoint == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) focalPoint));
      Object pinchToZoomDecelerationEnabled = list.get(10);
      pigeonResult.setPinchToZoomDecelerationEnabled((Boolean) pinchToZoomDecelerationEnabled);
      Object rotateDecelerationEnabled = list.get(11);
      pigeonResult.setRotateDecelerationEnabled((Boolean) rotateDecelerationEnabled);
      Object scrollDecelerationEnabled = list.get(12);
      pigeonResult.setScrollDecelerationEnabled((Boolean) scrollDecelerationEnabled);
      Object increaseRotateThresholdWhenPinchingToZoom = list.get(13);
      pigeonResult.setIncreaseRotateThresholdWhenPinchingToZoom((Boolean) increaseRotateThresholdWhenPinchingToZoom);
      Object increasePinchToZoomThresholdWhenRotating = list.get(14);
      pigeonResult.setIncreasePinchToZoomThresholdWhenRotating((Boolean) increasePinchToZoomThresholdWhenRotating);
      Object zoomAnimationAmount = list.get(15);
      pigeonResult.setZoomAnimationAmount((Double) zoomAnimationAmount);
      Object pinchPanEnabled = list.get(16);
      pigeonResult.setPinchPanEnabled((Boolean) pinchPanEnabled);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class LocationPuck2D {
    /** Name of image in sprite to use as the top of the location indicator. */
    private @Nullable byte[] topImage;

    public @Nullable byte[] getTopImage() {
      return topImage;
    }

    public void setTopImage(@Nullable byte[] setterArg) {
      this.topImage = setterArg;
    }

    /** Name of image in sprite to use as the middle of the location indicator. */
    private @Nullable byte[] bearingImage;

    public @Nullable byte[] getBearingImage() {
      return bearingImage;
    }

    public void setBearingImage(@Nullable byte[] setterArg) {
      this.bearingImage = setterArg;
    }

    /** Name of image in sprite to use as the background of the location indicator. */
    private @Nullable byte[] shadowImage;

    public @Nullable byte[] getShadowImage() {
      return shadowImage;
    }

    public void setShadowImage(@Nullable byte[] setterArg) {
      this.shadowImage = setterArg;
    }

    /** The scale expression of the images. If defined, it will be applied to all the three images. */
    private @Nullable String scaleExpression;

    public @Nullable String getScaleExpression() {
      return scaleExpression;
    }

    public void setScaleExpression(@Nullable String setterArg) {
      this.scaleExpression = setterArg;
    }

    /** The opacity of the entire location puck */
    private @Nullable Double opacity;

    public @Nullable Double getOpacity() {
      return opacity;
    }

    public void setOpacity(@Nullable Double setterArg) {
      this.opacity = setterArg;
    }

    public static final class Builder {

      private @Nullable byte[] topImage;

      @CanIgnoreReturnValue
      public @NonNull Builder setTopImage(@Nullable byte[] setterArg) {
        this.topImage = setterArg;
        return this;
      }

      private @Nullable byte[] bearingImage;

      @CanIgnoreReturnValue
      public @NonNull Builder setBearingImage(@Nullable byte[] setterArg) {
        this.bearingImage = setterArg;
        return this;
      }

      private @Nullable byte[] shadowImage;

      @CanIgnoreReturnValue
      public @NonNull Builder setShadowImage(@Nullable byte[] setterArg) {
        this.shadowImage = setterArg;
        return this;
      }

      private @Nullable String scaleExpression;

      @CanIgnoreReturnValue
      public @NonNull Builder setScaleExpression(@Nullable String setterArg) {
        this.scaleExpression = setterArg;
        return this;
      }

      private @Nullable Double opacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setOpacity(@Nullable Double setterArg) {
        this.opacity = setterArg;
        return this;
      }

      public @NonNull LocationPuck2D build() {
        LocationPuck2D pigeonReturn = new LocationPuck2D();
        pigeonReturn.setTopImage(topImage);
        pigeonReturn.setBearingImage(bearingImage);
        pigeonReturn.setShadowImage(shadowImage);
        pigeonReturn.setScaleExpression(scaleExpression);
        pigeonReturn.setOpacity(opacity);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(topImage);
      toListResult.add(bearingImage);
      toListResult.add(shadowImage);
      toListResult.add(scaleExpression);
      toListResult.add(opacity);
      return toListResult;
    }

    static @NonNull LocationPuck2D fromList(@NonNull ArrayList<Object> list) {
      LocationPuck2D pigeonResult = new LocationPuck2D();
      Object topImage = list.get(0);
      pigeonResult.setTopImage((byte[]) topImage);
      Object bearingImage = list.get(1);
      pigeonResult.setBearingImage((byte[]) bearingImage);
      Object shadowImage = list.get(2);
      pigeonResult.setShadowImage((byte[]) shadowImage);
      Object scaleExpression = list.get(3);
      pigeonResult.setScaleExpression((String) scaleExpression);
      Object opacity = list.get(4);
      pigeonResult.setOpacity((Double) opacity);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class LocationPuck3D {
    /** An URL for the model file in gltf format. */
    private @Nullable String modelUri;

    public @Nullable String getModelUri() {
      return modelUri;
    }

    public void setModelUri(@Nullable String setterArg) {
      this.modelUri = setterArg;
    }

    /** The position of the model. */
    private @Nullable List<Double> position;

    public @Nullable List<Double> getPosition() {
      return position;
    }

    public void setPosition(@Nullable List<Double> setterArg) {
      this.position = setterArg;
    }

    /** The opacity of the model. */
    private @Nullable Double modelOpacity;

    public @Nullable Double getModelOpacity() {
      return modelOpacity;
    }

    public void setModelOpacity(@Nullable Double setterArg) {
      this.modelOpacity = setterArg;
    }

    /** The scale of the model. */
    private @Nullable List<Double> modelScale;

    public @Nullable List<Double> getModelScale() {
      return modelScale;
    }

    public void setModelScale(@Nullable List<Double> setterArg) {
      this.modelScale = setterArg;
    }

    /** The scale expression of the model, which will overwrite the default scale expression that keeps the model size constant during zoom. */
    private @Nullable String modelScaleExpression;

    public @Nullable String getModelScaleExpression() {
      return modelScaleExpression;
    }

    public void setModelScaleExpression(@Nullable String setterArg) {
      this.modelScaleExpression = setterArg;
    }

    /** The translation of the model [lon, lat, z] */
    private @Nullable List<Double> modelTranslation;

    public @Nullable List<Double> getModelTranslation() {
      return modelTranslation;
    }

    public void setModelTranslation(@Nullable List<Double> setterArg) {
      this.modelTranslation = setterArg;
    }

    /** The rotation of the model. */
    private @Nullable List<Double> modelRotation;

    public @Nullable List<Double> getModelRotation() {
      return modelRotation;
    }

    public void setModelRotation(@Nullable List<Double> setterArg) {
      this.modelRotation = setterArg;
    }

    /** Enable/Disable shadow casting for the 3D location puck. */
    private @Nullable Boolean modelCastShadows;

    public @Nullable Boolean getModelCastShadows() {
      return modelCastShadows;
    }

    public void setModelCastShadows(@Nullable Boolean setterArg) {
      this.modelCastShadows = setterArg;
    }

    /** Enable/Disable shadow receiving for the 3D location puck. */
    private @Nullable Boolean modelReceiveShadows;

    public @Nullable Boolean getModelReceiveShadows() {
      return modelReceiveShadows;
    }

    public void setModelReceiveShadows(@Nullable Boolean setterArg) {
      this.modelReceiveShadows = setterArg;
    }

    /** Defines scaling mode. Only applies to location-indicator type layers. */
    private @Nullable ModelScaleMode modelScaleMode;

    public @Nullable ModelScaleMode getModelScaleMode() {
      return modelScaleMode;
    }

    public void setModelScaleMode(@Nullable ModelScaleMode setterArg) {
      this.modelScaleMode = setterArg;
    }

    /** Strength of the emission. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors). */
    private @Nullable Double modelEmissiveStrength;

    public @Nullable Double getModelEmissiveStrength() {
      return modelEmissiveStrength;
    }

    public void setModelEmissiveStrength(@Nullable Double setterArg) {
      this.modelEmissiveStrength = setterArg;
    }

    /** Strength of the emission as Expression string, note that when [modelEmissiveStrengthExpression] is specified, it will overwrite the [modelEmissiveStrength] property. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors). */
    private @Nullable String modelEmissiveStrengthExpression;

    public @Nullable String getModelEmissiveStrengthExpression() {
      return modelEmissiveStrengthExpression;
    }

    public void setModelEmissiveStrengthExpression(@Nullable String setterArg) {
      this.modelEmissiveStrengthExpression = setterArg;
    }

    public static final class Builder {

      private @Nullable String modelUri;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelUri(@Nullable String setterArg) {
        this.modelUri = setterArg;
        return this;
      }

      private @Nullable List<Double> position;

      @CanIgnoreReturnValue
      public @NonNull Builder setPosition(@Nullable List<Double> setterArg) {
        this.position = setterArg;
        return this;
      }

      private @Nullable Double modelOpacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelOpacity(@Nullable Double setterArg) {
        this.modelOpacity = setterArg;
        return this;
      }

      private @Nullable List<Double> modelScale;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelScale(@Nullable List<Double> setterArg) {
        this.modelScale = setterArg;
        return this;
      }

      private @Nullable String modelScaleExpression;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelScaleExpression(@Nullable String setterArg) {
        this.modelScaleExpression = setterArg;
        return this;
      }

      private @Nullable List<Double> modelTranslation;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelTranslation(@Nullable List<Double> setterArg) {
        this.modelTranslation = setterArg;
        return this;
      }

      private @Nullable List<Double> modelRotation;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelRotation(@Nullable List<Double> setterArg) {
        this.modelRotation = setterArg;
        return this;
      }

      private @Nullable Boolean modelCastShadows;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelCastShadows(@Nullable Boolean setterArg) {
        this.modelCastShadows = setterArg;
        return this;
      }

      private @Nullable Boolean modelReceiveShadows;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelReceiveShadows(@Nullable Boolean setterArg) {
        this.modelReceiveShadows = setterArg;
        return this;
      }

      private @Nullable ModelScaleMode modelScaleMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelScaleMode(@Nullable ModelScaleMode setterArg) {
        this.modelScaleMode = setterArg;
        return this;
      }

      private @Nullable Double modelEmissiveStrength;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelEmissiveStrength(@Nullable Double setterArg) {
        this.modelEmissiveStrength = setterArg;
        return this;
      }

      private @Nullable String modelEmissiveStrengthExpression;

      @CanIgnoreReturnValue
      public @NonNull Builder setModelEmissiveStrengthExpression(@Nullable String setterArg) {
        this.modelEmissiveStrengthExpression = setterArg;
        return this;
      }

      public @NonNull LocationPuck3D build() {
        LocationPuck3D pigeonReturn = new LocationPuck3D();
        pigeonReturn.setModelUri(modelUri);
        pigeonReturn.setPosition(position);
        pigeonReturn.setModelOpacity(modelOpacity);
        pigeonReturn.setModelScale(modelScale);
        pigeonReturn.setModelScaleExpression(modelScaleExpression);
        pigeonReturn.setModelTranslation(modelTranslation);
        pigeonReturn.setModelRotation(modelRotation);
        pigeonReturn.setModelCastShadows(modelCastShadows);
        pigeonReturn.setModelReceiveShadows(modelReceiveShadows);
        pigeonReturn.setModelScaleMode(modelScaleMode);
        pigeonReturn.setModelEmissiveStrength(modelEmissiveStrength);
        pigeonReturn.setModelEmissiveStrengthExpression(modelEmissiveStrengthExpression);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(12);
      toListResult.add(modelUri);
      toListResult.add(position);
      toListResult.add(modelOpacity);
      toListResult.add(modelScale);
      toListResult.add(modelScaleExpression);
      toListResult.add(modelTranslation);
      toListResult.add(modelRotation);
      toListResult.add(modelCastShadows);
      toListResult.add(modelReceiveShadows);
      toListResult.add(modelScaleMode == null ? null : modelScaleMode.index);
      toListResult.add(modelEmissiveStrength);
      toListResult.add(modelEmissiveStrengthExpression);
      return toListResult;
    }

    static @NonNull LocationPuck3D fromList(@NonNull ArrayList<Object> list) {
      LocationPuck3D pigeonResult = new LocationPuck3D();
      Object modelUri = list.get(0);
      pigeonResult.setModelUri((String) modelUri);
      Object position = list.get(1);
      pigeonResult.setPosition((List<Double>) position);
      Object modelOpacity = list.get(2);
      pigeonResult.setModelOpacity((Double) modelOpacity);
      Object modelScale = list.get(3);
      pigeonResult.setModelScale((List<Double>) modelScale);
      Object modelScaleExpression = list.get(4);
      pigeonResult.setModelScaleExpression((String) modelScaleExpression);
      Object modelTranslation = list.get(5);
      pigeonResult.setModelTranslation((List<Double>) modelTranslation);
      Object modelRotation = list.get(6);
      pigeonResult.setModelRotation((List<Double>) modelRotation);
      Object modelCastShadows = list.get(7);
      pigeonResult.setModelCastShadows((Boolean) modelCastShadows);
      Object modelReceiveShadows = list.get(8);
      pigeonResult.setModelReceiveShadows((Boolean) modelReceiveShadows);
      Object modelScaleMode = list.get(9);
      pigeonResult.setModelScaleMode(modelScaleMode == null ? null : ModelScaleMode.values()[(int) modelScaleMode]);
      Object modelEmissiveStrength = list.get(10);
      pigeonResult.setModelEmissiveStrength((Double) modelEmissiveStrength);
      Object modelEmissiveStrengthExpression = list.get(11);
      pigeonResult.setModelEmissiveStrengthExpression((String) modelEmissiveStrengthExpression);
      return pigeonResult;
    }
  }

  /**
   * Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class LocationPuck {
    private @Nullable LocationPuck2D locationPuck2D;

    public @Nullable LocationPuck2D getLocationPuck2D() {
      return locationPuck2D;
    }

    public void setLocationPuck2D(@Nullable LocationPuck2D setterArg) {
      this.locationPuck2D = setterArg;
    }

    private @Nullable LocationPuck3D locationPuck3D;

    public @Nullable LocationPuck3D getLocationPuck3D() {
      return locationPuck3D;
    }

    public void setLocationPuck3D(@Nullable LocationPuck3D setterArg) {
      this.locationPuck3D = setterArg;
    }

    public static final class Builder {

      private @Nullable LocationPuck2D locationPuck2D;

      @CanIgnoreReturnValue
      public @NonNull Builder setLocationPuck2D(@Nullable LocationPuck2D setterArg) {
        this.locationPuck2D = setterArg;
        return this;
      }

      private @Nullable LocationPuck3D locationPuck3D;

      @CanIgnoreReturnValue
      public @NonNull Builder setLocationPuck3D(@Nullable LocationPuck3D setterArg) {
        this.locationPuck3D = setterArg;
        return this;
      }

      public @NonNull LocationPuck build() {
        LocationPuck pigeonReturn = new LocationPuck();
        pigeonReturn.setLocationPuck2D(locationPuck2D);
        pigeonReturn.setLocationPuck3D(locationPuck3D);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add((locationPuck2D == null) ? null : locationPuck2D.toList());
      toListResult.add((locationPuck3D == null) ? null : locationPuck3D.toList());
      return toListResult;
    }

    static @NonNull LocationPuck fromList(@NonNull ArrayList<Object> list) {
      LocationPuck pigeonResult = new LocationPuck();
      Object locationPuck2D = list.get(0);
      pigeonResult.setLocationPuck2D((locationPuck2D == null) ? null : LocationPuck2D.fromList((ArrayList<Object>) locationPuck2D));
      Object locationPuck3D = list.get(1);
      pigeonResult.setLocationPuck3D((locationPuck3D == null) ? null : LocationPuck3D.fromList((ArrayList<Object>) locationPuck3D));
      return pigeonResult;
    }
  }

  /**
   * Shows a location puck on the map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class LocationComponentSettings {
    /** Whether the user location is visible on the map. */
    private @Nullable Boolean enabled;

    public @Nullable Boolean getEnabled() {
      return enabled;
    }

    public void setEnabled(@Nullable Boolean setterArg) {
      this.enabled = setterArg;
    }

    /** Whether the location puck is pulsing on the map. Works for 2D location puck only. */
    private @Nullable Boolean pulsingEnabled;

    public @Nullable Boolean getPulsingEnabled() {
      return pulsingEnabled;
    }

    public void setPulsingEnabled(@Nullable Boolean setterArg) {
      this.pulsingEnabled = setterArg;
    }

    /** The color of the pulsing circle. Works for 2D location puck only. */
    private @Nullable Long pulsingColor;

    public @Nullable Long getPulsingColor() {
      return pulsingColor;
    }

    public void setPulsingColor(@Nullable Long setterArg) {
      this.pulsingColor = setterArg;
    }

    /** The maximum radius of the pulsing circle. Works for 2D location puck only. Note: Setting [pulsingMaxRadius] to LocationComponentConstants.PULSING_MAX_RADIUS_FOLLOW_ACCURACY will set the pulsing circle's maximum radius to follow location accuracy circle. This property is specified in pixels. */
    private @Nullable Double pulsingMaxRadius;

    public @Nullable Double getPulsingMaxRadius() {
      return pulsingMaxRadius;
    }

    public void setPulsingMaxRadius(@Nullable Double setterArg) {
      this.pulsingMaxRadius = setterArg;
    }

    /** Whether show accuracy ring with location puck. Works for 2D location puck only. */
    private @Nullable Boolean showAccuracyRing;

    public @Nullable Boolean getShowAccuracyRing() {
      return showAccuracyRing;
    }

    public void setShowAccuracyRing(@Nullable Boolean setterArg) {
      this.showAccuracyRing = setterArg;
    }

    /** The color of the accuracy ring. Works for 2D location puck only. */
    private @Nullable Long accuracyRingColor;

    public @Nullable Long getAccuracyRingColor() {
      return accuracyRingColor;
    }

    public void setAccuracyRingColor(@Nullable Long setterArg) {
      this.accuracyRingColor = setterArg;
    }

    /** The color of the accuracy ring border. Works for 2D location puck only. */
    private @Nullable Long accuracyRingBorderColor;

    public @Nullable Long getAccuracyRingBorderColor() {
      return accuracyRingBorderColor;
    }

    public void setAccuracyRingBorderColor(@Nullable Long setterArg) {
      this.accuracyRingBorderColor = setterArg;
    }

    /** Sets the id of the layer that's added above to when placing the component on the map. */
    private @Nullable String layerAbove;

    public @Nullable String getLayerAbove() {
      return layerAbove;
    }

    public void setLayerAbove(@Nullable String setterArg) {
      this.layerAbove = setterArg;
    }

    /** Sets the id of the layer that's added below to when placing the component on the map. */
    private @Nullable String layerBelow;

    public @Nullable String getLayerBelow() {
      return layerBelow;
    }

    public void setLayerBelow(@Nullable String setterArg) {
      this.layerBelow = setterArg;
    }

    /** Whether the puck rotates to track the bearing source. */
    private @Nullable Boolean puckBearingEnabled;

    public @Nullable Boolean getPuckBearingEnabled() {
      return puckBearingEnabled;
    }

    public void setPuckBearingEnabled(@Nullable Boolean setterArg) {
      this.puckBearingEnabled = setterArg;
    }

    /** The enum controls how the puck is oriented */
    private @Nullable PuckBearing puckBearing;

    public @Nullable PuckBearing getPuckBearing() {
      return puckBearing;
    }

    public void setPuckBearing(@Nullable PuckBearing setterArg) {
      this.puckBearing = setterArg;
    }

    /** Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time. */
    private @Nullable LocationPuck locationPuck;

    public @Nullable LocationPuck getLocationPuck() {
      return locationPuck;
    }

    public void setLocationPuck(@Nullable LocationPuck setterArg) {
      this.locationPuck = setterArg;
    }

    public static final class Builder {

      private @Nullable Boolean enabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setEnabled(@Nullable Boolean setterArg) {
        this.enabled = setterArg;
        return this;
      }

      private @Nullable Boolean pulsingEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setPulsingEnabled(@Nullable Boolean setterArg) {
        this.pulsingEnabled = setterArg;
        return this;
      }

      private @Nullable Long pulsingColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setPulsingColor(@Nullable Long setterArg) {
        this.pulsingColor = setterArg;
        return this;
      }

      private @Nullable Double pulsingMaxRadius;

      @CanIgnoreReturnValue
      public @NonNull Builder setPulsingMaxRadius(@Nullable Double setterArg) {
        this.pulsingMaxRadius = setterArg;
        return this;
      }

      private @Nullable Boolean showAccuracyRing;

      @CanIgnoreReturnValue
      public @NonNull Builder setShowAccuracyRing(@Nullable Boolean setterArg) {
        this.showAccuracyRing = setterArg;
        return this;
      }

      private @Nullable Long accuracyRingColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setAccuracyRingColor(@Nullable Long setterArg) {
        this.accuracyRingColor = setterArg;
        return this;
      }

      private @Nullable Long accuracyRingBorderColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setAccuracyRingBorderColor(@Nullable Long setterArg) {
        this.accuracyRingBorderColor = setterArg;
        return this;
      }

      private @Nullable String layerAbove;

      @CanIgnoreReturnValue
      public @NonNull Builder setLayerAbove(@Nullable String setterArg) {
        this.layerAbove = setterArg;
        return this;
      }

      private @Nullable String layerBelow;

      @CanIgnoreReturnValue
      public @NonNull Builder setLayerBelow(@Nullable String setterArg) {
        this.layerBelow = setterArg;
        return this;
      }

      private @Nullable Boolean puckBearingEnabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setPuckBearingEnabled(@Nullable Boolean setterArg) {
        this.puckBearingEnabled = setterArg;
        return this;
      }

      private @Nullable PuckBearing puckBearing;

      @CanIgnoreReturnValue
      public @NonNull Builder setPuckBearing(@Nullable PuckBearing setterArg) {
        this.puckBearing = setterArg;
        return this;
      }

      private @Nullable LocationPuck locationPuck;

      @CanIgnoreReturnValue
      public @NonNull Builder setLocationPuck(@Nullable LocationPuck setterArg) {
        this.locationPuck = setterArg;
        return this;
      }

      public @NonNull LocationComponentSettings build() {
        LocationComponentSettings pigeonReturn = new LocationComponentSettings();
        pigeonReturn.setEnabled(enabled);
        pigeonReturn.setPulsingEnabled(pulsingEnabled);
        pigeonReturn.setPulsingColor(pulsingColor);
        pigeonReturn.setPulsingMaxRadius(pulsingMaxRadius);
        pigeonReturn.setShowAccuracyRing(showAccuracyRing);
        pigeonReturn.setAccuracyRingColor(accuracyRingColor);
        pigeonReturn.setAccuracyRingBorderColor(accuracyRingBorderColor);
        pigeonReturn.setLayerAbove(layerAbove);
        pigeonReturn.setLayerBelow(layerBelow);
        pigeonReturn.setPuckBearingEnabled(puckBearingEnabled);
        pigeonReturn.setPuckBearing(puckBearing);
        pigeonReturn.setLocationPuck(locationPuck);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(12);
      toListResult.add(enabled);
      toListResult.add(pulsingEnabled);
      toListResult.add(pulsingColor);
      toListResult.add(pulsingMaxRadius);
      toListResult.add(showAccuracyRing);
      toListResult.add(accuracyRingColor);
      toListResult.add(accuracyRingBorderColor);
      toListResult.add(layerAbove);
      toListResult.add(layerBelow);
      toListResult.add(puckBearingEnabled);
      toListResult.add(puckBearing == null ? null : puckBearing.index);
      toListResult.add((locationPuck == null) ? null : locationPuck.toList());
      return toListResult;
    }

    static @NonNull LocationComponentSettings fromList(@NonNull ArrayList<Object> list) {
      LocationComponentSettings pigeonResult = new LocationComponentSettings();
      Object enabled = list.get(0);
      pigeonResult.setEnabled((Boolean) enabled);
      Object pulsingEnabled = list.get(1);
      pigeonResult.setPulsingEnabled((Boolean) pulsingEnabled);
      Object pulsingColor = list.get(2);
      pigeonResult.setPulsingColor((pulsingColor == null) ? null : ((pulsingColor instanceof Integer) ? (Integer) pulsingColor : (Long) pulsingColor));
      Object pulsingMaxRadius = list.get(3);
      pigeonResult.setPulsingMaxRadius((Double) pulsingMaxRadius);
      Object showAccuracyRing = list.get(4);
      pigeonResult.setShowAccuracyRing((Boolean) showAccuracyRing);
      Object accuracyRingColor = list.get(5);
      pigeonResult.setAccuracyRingColor((accuracyRingColor == null) ? null : ((accuracyRingColor instanceof Integer) ? (Integer) accuracyRingColor : (Long) accuracyRingColor));
      Object accuracyRingBorderColor = list.get(6);
      pigeonResult.setAccuracyRingBorderColor((accuracyRingBorderColor == null) ? null : ((accuracyRingBorderColor instanceof Integer) ? (Integer) accuracyRingBorderColor : (Long) accuracyRingBorderColor));
      Object layerAbove = list.get(7);
      pigeonResult.setLayerAbove((String) layerAbove);
      Object layerBelow = list.get(8);
      pigeonResult.setLayerBelow((String) layerBelow);
      Object puckBearingEnabled = list.get(9);
      pigeonResult.setPuckBearingEnabled((Boolean) puckBearingEnabled);
      Object puckBearing = list.get(10);
      pigeonResult.setPuckBearing(puckBearing == null ? null : PuckBearing.values()[(int) puckBearing]);
      Object locationPuck = list.get(11);
      pigeonResult.setLocationPuck((locationPuck == null) ? null : LocationPuck.fromList((ArrayList<Object>) locationPuck));
      return pigeonResult;
    }
  }

  /**
   * Shows the scale bar on the map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ScaleBarSettings {
    /** Whether the scale is visible on the map. */
    private @Nullable Boolean enabled;

    public @Nullable Boolean getEnabled() {
      return enabled;
    }

    public void setEnabled(@Nullable Boolean setterArg) {
      this.enabled = setterArg;
    }

    /** Defines where the scale bar is positioned on the map */
    private @Nullable OrnamentPosition position;

    public @Nullable OrnamentPosition getPosition() {
      return position;
    }

    public void setPosition(@Nullable OrnamentPosition setterArg) {
      this.position = setterArg;
    }

    /** Defines the margin to the left that the scale bar honors. This property is specified in pixels. */
    private @Nullable Double marginLeft;

    public @Nullable Double getMarginLeft() {
      return marginLeft;
    }

    public void setMarginLeft(@Nullable Double setterArg) {
      this.marginLeft = setterArg;
    }

    /** Defines the margin to the top that the scale bar honors. This property is specified in pixels. */
    private @Nullable Double marginTop;

    public @Nullable Double getMarginTop() {
      return marginTop;
    }

    public void setMarginTop(@Nullable Double setterArg) {
      this.marginTop = setterArg;
    }

    /** Defines the margin to the right that the scale bar honors. This property is specified in pixels. */
    private @Nullable Double marginRight;

    public @Nullable Double getMarginRight() {
      return marginRight;
    }

    public void setMarginRight(@Nullable Double setterArg) {
      this.marginRight = setterArg;
    }

    /** Defines the margin to the bottom that the scale bar honors. This property is specified in pixels. */
    private @Nullable Double marginBottom;

    public @Nullable Double getMarginBottom() {
      return marginBottom;
    }

    public void setMarginBottom(@Nullable Double setterArg) {
      this.marginBottom = setterArg;
    }

    /** Defines text color of the scale bar. */
    private @Nullable Long textColor;

    public @Nullable Long getTextColor() {
      return textColor;
    }

    public void setTextColor(@Nullable Long setterArg) {
      this.textColor = setterArg;
    }

    /** Defines primary color of the scale bar. */
    private @Nullable Long primaryColor;

    public @Nullable Long getPrimaryColor() {
      return primaryColor;
    }

    public void setPrimaryColor(@Nullable Long setterArg) {
      this.primaryColor = setterArg;
    }

    /** Defines secondary color of the scale bar. */
    private @Nullable Long secondaryColor;

    public @Nullable Long getSecondaryColor() {
      return secondaryColor;
    }

    public void setSecondaryColor(@Nullable Long setterArg) {
      this.secondaryColor = setterArg;
    }

    /** Defines width of the border for the scale bar. This property is specified in pixels. */
    private @Nullable Double borderWidth;

    public @Nullable Double getBorderWidth() {
      return borderWidth;
    }

    public void setBorderWidth(@Nullable Double setterArg) {
      this.borderWidth = setterArg;
    }

    /** Defines height of the scale bar. This property is specified in pixels. */
    private @Nullable Double height;

    public @Nullable Double getHeight() {
      return height;
    }

    public void setHeight(@Nullable Double setterArg) {
      this.height = setterArg;
    }

    /** Defines margin of the text bar of the scale bar. This property is specified in pixels. */
    private @Nullable Double textBarMargin;

    public @Nullable Double getTextBarMargin() {
      return textBarMargin;
    }

    public void setTextBarMargin(@Nullable Double setterArg) {
      this.textBarMargin = setterArg;
    }

    /** Defines text border width of the scale bar. This property is specified in pixels. */
    private @Nullable Double textBorderWidth;

    public @Nullable Double getTextBorderWidth() {
      return textBorderWidth;
    }

    public void setTextBorderWidth(@Nullable Double setterArg) {
      this.textBorderWidth = setterArg;
    }

    /** Defines text size of the scale bar. This property is specified in pixels. */
    private @Nullable Double textSize;

    public @Nullable Double getTextSize() {
      return textSize;
    }

    public void setTextSize(@Nullable Double setterArg) {
      this.textSize = setterArg;
    }

    /** Whether the scale bar is using metric unit. True if the scale bar is using metric system, false if the scale bar is using imperial units. */
    private @Nullable Boolean isMetricUnits;

    public @Nullable Boolean getIsMetricUnits() {
      return isMetricUnits;
    }

    public void setIsMetricUnits(@Nullable Boolean setterArg) {
      this.isMetricUnits = setterArg;
    }

    /** Configures minimum refresh interval, in millisecond, default is 15. */
    private @Nullable Long refreshInterval;

    public @Nullable Long getRefreshInterval() {
      return refreshInterval;
    }

    public void setRefreshInterval(@Nullable Long setterArg) {
      this.refreshInterval = setterArg;
    }

    /** Configures whether to show the text border or not, default is true. */
    private @Nullable Boolean showTextBorder;

    public @Nullable Boolean getShowTextBorder() {
      return showTextBorder;
    }

    public void setShowTextBorder(@Nullable Boolean setterArg) {
      this.showTextBorder = setterArg;
    }

    /** configures ratio of scale bar max width compared with MapView width, default is 0.5. */
    private @Nullable Double ratio;

    public @Nullable Double getRatio() {
      return ratio;
    }

    public void setRatio(@Nullable Double setterArg) {
      this.ratio = setterArg;
    }

    /** If set to True scale bar will be triggering onDraw depending on [ScaleBarSettings.refreshInterval] even if actual data did not change. If set to False scale bar will redraw only on demand. Defaults to False and should not be changed explicitly in most cases. Could be set to True to produce correct GPU frame metrics when running gfxinfo command. */
    private @Nullable Boolean useContinuousRendering;

    public @Nullable Boolean getUseContinuousRendering() {
      return useContinuousRendering;
    }

    public void setUseContinuousRendering(@Nullable Boolean setterArg) {
      this.useContinuousRendering = setterArg;
    }

    public static final class Builder {

      private @Nullable Boolean enabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setEnabled(@Nullable Boolean setterArg) {
        this.enabled = setterArg;
        return this;
      }

      private @Nullable OrnamentPosition position;

      @CanIgnoreReturnValue
      public @NonNull Builder setPosition(@Nullable OrnamentPosition setterArg) {
        this.position = setterArg;
        return this;
      }

      private @Nullable Double marginLeft;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginLeft(@Nullable Double setterArg) {
        this.marginLeft = setterArg;
        return this;
      }

      private @Nullable Double marginTop;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginTop(@Nullable Double setterArg) {
        this.marginTop = setterArg;
        return this;
      }

      private @Nullable Double marginRight;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginRight(@Nullable Double setterArg) {
        this.marginRight = setterArg;
        return this;
      }

      private @Nullable Double marginBottom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginBottom(@Nullable Double setterArg) {
        this.marginBottom = setterArg;
        return this;
      }

      private @Nullable Long textColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextColor(@Nullable Long setterArg) {
        this.textColor = setterArg;
        return this;
      }

      private @Nullable Long primaryColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setPrimaryColor(@Nullable Long setterArg) {
        this.primaryColor = setterArg;
        return this;
      }

      private @Nullable Long secondaryColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setSecondaryColor(@Nullable Long setterArg) {
        this.secondaryColor = setterArg;
        return this;
      }

      private @Nullable Double borderWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setBorderWidth(@Nullable Double setterArg) {
        this.borderWidth = setterArg;
        return this;
      }

      private @Nullable Double height;

      @CanIgnoreReturnValue
      public @NonNull Builder setHeight(@Nullable Double setterArg) {
        this.height = setterArg;
        return this;
      }

      private @Nullable Double textBarMargin;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextBarMargin(@Nullable Double setterArg) {
        this.textBarMargin = setterArg;
        return this;
      }

      private @Nullable Double textBorderWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextBorderWidth(@Nullable Double setterArg) {
        this.textBorderWidth = setterArg;
        return this;
      }

      private @Nullable Double textSize;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextSize(@Nullable Double setterArg) {
        this.textSize = setterArg;
        return this;
      }

      private @Nullable Boolean isMetricUnits;

      @CanIgnoreReturnValue
      public @NonNull Builder setIsMetricUnits(@Nullable Boolean setterArg) {
        this.isMetricUnits = setterArg;
        return this;
      }

      private @Nullable Long refreshInterval;

      @CanIgnoreReturnValue
      public @NonNull Builder setRefreshInterval(@Nullable Long setterArg) {
        this.refreshInterval = setterArg;
        return this;
      }

      private @Nullable Boolean showTextBorder;

      @CanIgnoreReturnValue
      public @NonNull Builder setShowTextBorder(@Nullable Boolean setterArg) {
        this.showTextBorder = setterArg;
        return this;
      }

      private @Nullable Double ratio;

      @CanIgnoreReturnValue
      public @NonNull Builder setRatio(@Nullable Double setterArg) {
        this.ratio = setterArg;
        return this;
      }

      private @Nullable Boolean useContinuousRendering;

      @CanIgnoreReturnValue
      public @NonNull Builder setUseContinuousRendering(@Nullable Boolean setterArg) {
        this.useContinuousRendering = setterArg;
        return this;
      }

      public @NonNull ScaleBarSettings build() {
        ScaleBarSettings pigeonReturn = new ScaleBarSettings();
        pigeonReturn.setEnabled(enabled);
        pigeonReturn.setPosition(position);
        pigeonReturn.setMarginLeft(marginLeft);
        pigeonReturn.setMarginTop(marginTop);
        pigeonReturn.setMarginRight(marginRight);
        pigeonReturn.setMarginBottom(marginBottom);
        pigeonReturn.setTextColor(textColor);
        pigeonReturn.setPrimaryColor(primaryColor);
        pigeonReturn.setSecondaryColor(secondaryColor);
        pigeonReturn.setBorderWidth(borderWidth);
        pigeonReturn.setHeight(height);
        pigeonReturn.setTextBarMargin(textBarMargin);
        pigeonReturn.setTextBorderWidth(textBorderWidth);
        pigeonReturn.setTextSize(textSize);
        pigeonReturn.setIsMetricUnits(isMetricUnits);
        pigeonReturn.setRefreshInterval(refreshInterval);
        pigeonReturn.setShowTextBorder(showTextBorder);
        pigeonReturn.setRatio(ratio);
        pigeonReturn.setUseContinuousRendering(useContinuousRendering);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(19);
      toListResult.add(enabled);
      toListResult.add(position == null ? null : position.index);
      toListResult.add(marginLeft);
      toListResult.add(marginTop);
      toListResult.add(marginRight);
      toListResult.add(marginBottom);
      toListResult.add(textColor);
      toListResult.add(primaryColor);
      toListResult.add(secondaryColor);
      toListResult.add(borderWidth);
      toListResult.add(height);
      toListResult.add(textBarMargin);
      toListResult.add(textBorderWidth);
      toListResult.add(textSize);
      toListResult.add(isMetricUnits);
      toListResult.add(refreshInterval);
      toListResult.add(showTextBorder);
      toListResult.add(ratio);
      toListResult.add(useContinuousRendering);
      return toListResult;
    }

    static @NonNull ScaleBarSettings fromList(@NonNull ArrayList<Object> list) {
      ScaleBarSettings pigeonResult = new ScaleBarSettings();
      Object enabled = list.get(0);
      pigeonResult.setEnabled((Boolean) enabled);
      Object position = list.get(1);
      pigeonResult.setPosition(position == null ? null : OrnamentPosition.values()[(int) position]);
      Object marginLeft = list.get(2);
      pigeonResult.setMarginLeft((Double) marginLeft);
      Object marginTop = list.get(3);
      pigeonResult.setMarginTop((Double) marginTop);
      Object marginRight = list.get(4);
      pigeonResult.setMarginRight((Double) marginRight);
      Object marginBottom = list.get(5);
      pigeonResult.setMarginBottom((Double) marginBottom);
      Object textColor = list.get(6);
      pigeonResult.setTextColor((textColor == null) ? null : ((textColor instanceof Integer) ? (Integer) textColor : (Long) textColor));
      Object primaryColor = list.get(7);
      pigeonResult.setPrimaryColor((primaryColor == null) ? null : ((primaryColor instanceof Integer) ? (Integer) primaryColor : (Long) primaryColor));
      Object secondaryColor = list.get(8);
      pigeonResult.setSecondaryColor((secondaryColor == null) ? null : ((secondaryColor instanceof Integer) ? (Integer) secondaryColor : (Long) secondaryColor));
      Object borderWidth = list.get(9);
      pigeonResult.setBorderWidth((Double) borderWidth);
      Object height = list.get(10);
      pigeonResult.setHeight((Double) height);
      Object textBarMargin = list.get(11);
      pigeonResult.setTextBarMargin((Double) textBarMargin);
      Object textBorderWidth = list.get(12);
      pigeonResult.setTextBorderWidth((Double) textBorderWidth);
      Object textSize = list.get(13);
      pigeonResult.setTextSize((Double) textSize);
      Object isMetricUnits = list.get(14);
      pigeonResult.setIsMetricUnits((Boolean) isMetricUnits);
      Object refreshInterval = list.get(15);
      pigeonResult.setRefreshInterval((refreshInterval == null) ? null : ((refreshInterval instanceof Integer) ? (Integer) refreshInterval : (Long) refreshInterval));
      Object showTextBorder = list.get(16);
      pigeonResult.setShowTextBorder((Boolean) showTextBorder);
      Object ratio = list.get(17);
      pigeonResult.setRatio((Double) ratio);
      Object useContinuousRendering = list.get(18);
      pigeonResult.setUseContinuousRendering((Boolean) useContinuousRendering);
      return pigeonResult;
    }
  }

  /**
   * Shows the compass on the map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CompassSettings {
    /** Whether the compass is visible on the map. */
    private @Nullable Boolean enabled;

    public @Nullable Boolean getEnabled() {
      return enabled;
    }

    public void setEnabled(@Nullable Boolean setterArg) {
      this.enabled = setterArg;
    }

    /** Defines where the compass is positioned on the map */
    private @Nullable OrnamentPosition position;

    public @Nullable OrnamentPosition getPosition() {
      return position;
    }

    public void setPosition(@Nullable OrnamentPosition setterArg) {
      this.position = setterArg;
    }

    /** Defines the margin to the left that the compass icon honors. This property is specified in pixels. */
    private @Nullable Double marginLeft;

    public @Nullable Double getMarginLeft() {
      return marginLeft;
    }

    public void setMarginLeft(@Nullable Double setterArg) {
      this.marginLeft = setterArg;
    }

    /** Defines the margin to the top that the compass icon honors. This property is specified in pixels. */
    private @Nullable Double marginTop;

    public @Nullable Double getMarginTop() {
      return marginTop;
    }

    public void setMarginTop(@Nullable Double setterArg) {
      this.marginTop = setterArg;
    }

    /** Defines the margin to the right that the compass icon honors. This property is specified in pixels. */
    private @Nullable Double marginRight;

    public @Nullable Double getMarginRight() {
      return marginRight;
    }

    public void setMarginRight(@Nullable Double setterArg) {
      this.marginRight = setterArg;
    }

    /** Defines the margin to the bottom that the compass icon honors. This property is specified in pixels. */
    private @Nullable Double marginBottom;

    public @Nullable Double getMarginBottom() {
      return marginBottom;
    }

    public void setMarginBottom(@Nullable Double setterArg) {
      this.marginBottom = setterArg;
    }

    /** The alpha channel value of the compass image */
    private @Nullable Double opacity;

    public @Nullable Double getOpacity() {
      return opacity;
    }

    public void setOpacity(@Nullable Double setterArg) {
      this.opacity = setterArg;
    }

    /** The clockwise rotation value in degrees of the compass. */
    private @Nullable Double rotation;

    public @Nullable Double getRotation() {
      return rotation;
    }

    public void setRotation(@Nullable Double setterArg) {
      this.rotation = setterArg;
    }

    /** Whether the compass is displayed. */
    private @Nullable Boolean visibility;

    public @Nullable Boolean getVisibility() {
      return visibility;
    }

    public void setVisibility(@Nullable Boolean setterArg) {
      this.visibility = setterArg;
    }

    /** Whether the compass fades out to invisible when facing north direction. */
    private @Nullable Boolean fadeWhenFacingNorth;

    public @Nullable Boolean getFadeWhenFacingNorth() {
      return fadeWhenFacingNorth;
    }

    public void setFadeWhenFacingNorth(@Nullable Boolean setterArg) {
      this.fadeWhenFacingNorth = setterArg;
    }

    /** Whether the compass can be clicked and click events can be registered. */
    private @Nullable Boolean clickable;

    public @Nullable Boolean getClickable() {
      return clickable;
    }

    public void setClickable(@Nullable Boolean setterArg) {
      this.clickable = setterArg;
    }

    /** The compass image, the visual representation of the compass. */
    private @Nullable byte[] image;

    public @Nullable byte[] getImage() {
      return image;
    }

    public void setImage(@Nullable byte[] setterArg) {
      this.image = setterArg;
    }

    public static final class Builder {

      private @Nullable Boolean enabled;

      @CanIgnoreReturnValue
      public @NonNull Builder setEnabled(@Nullable Boolean setterArg) {
        this.enabled = setterArg;
        return this;
      }

      private @Nullable OrnamentPosition position;

      @CanIgnoreReturnValue
      public @NonNull Builder setPosition(@Nullable OrnamentPosition setterArg) {
        this.position = setterArg;
        return this;
      }

      private @Nullable Double marginLeft;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginLeft(@Nullable Double setterArg) {
        this.marginLeft = setterArg;
        return this;
      }

      private @Nullable Double marginTop;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginTop(@Nullable Double setterArg) {
        this.marginTop = setterArg;
        return this;
      }

      private @Nullable Double marginRight;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginRight(@Nullable Double setterArg) {
        this.marginRight = setterArg;
        return this;
      }

      private @Nullable Double marginBottom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginBottom(@Nullable Double setterArg) {
        this.marginBottom = setterArg;
        return this;
      }

      private @Nullable Double opacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setOpacity(@Nullable Double setterArg) {
        this.opacity = setterArg;
        return this;
      }

      private @Nullable Double rotation;

      @CanIgnoreReturnValue
      public @NonNull Builder setRotation(@Nullable Double setterArg) {
        this.rotation = setterArg;
        return this;
      }

      private @Nullable Boolean visibility;

      @CanIgnoreReturnValue
      public @NonNull Builder setVisibility(@Nullable Boolean setterArg) {
        this.visibility = setterArg;
        return this;
      }

      private @Nullable Boolean fadeWhenFacingNorth;

      @CanIgnoreReturnValue
      public @NonNull Builder setFadeWhenFacingNorth(@Nullable Boolean setterArg) {
        this.fadeWhenFacingNorth = setterArg;
        return this;
      }

      private @Nullable Boolean clickable;

      @CanIgnoreReturnValue
      public @NonNull Builder setClickable(@Nullable Boolean setterArg) {
        this.clickable = setterArg;
        return this;
      }

      private @Nullable byte[] image;

      @CanIgnoreReturnValue
      public @NonNull Builder setImage(@Nullable byte[] setterArg) {
        this.image = setterArg;
        return this;
      }

      public @NonNull CompassSettings build() {
        CompassSettings pigeonReturn = new CompassSettings();
        pigeonReturn.setEnabled(enabled);
        pigeonReturn.setPosition(position);
        pigeonReturn.setMarginLeft(marginLeft);
        pigeonReturn.setMarginTop(marginTop);
        pigeonReturn.setMarginRight(marginRight);
        pigeonReturn.setMarginBottom(marginBottom);
        pigeonReturn.setOpacity(opacity);
        pigeonReturn.setRotation(rotation);
        pigeonReturn.setVisibility(visibility);
        pigeonReturn.setFadeWhenFacingNorth(fadeWhenFacingNorth);
        pigeonReturn.setClickable(clickable);
        pigeonReturn.setImage(image);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(12);
      toListResult.add(enabled);
      toListResult.add(position == null ? null : position.index);
      toListResult.add(marginLeft);
      toListResult.add(marginTop);
      toListResult.add(marginRight);
      toListResult.add(marginBottom);
      toListResult.add(opacity);
      toListResult.add(rotation);
      toListResult.add(visibility);
      toListResult.add(fadeWhenFacingNorth);
      toListResult.add(clickable);
      toListResult.add(image);
      return toListResult;
    }

    static @NonNull CompassSettings fromList(@NonNull ArrayList<Object> list) {
      CompassSettings pigeonResult = new CompassSettings();
      Object enabled = list.get(0);
      pigeonResult.setEnabled((Boolean) enabled);
      Object position = list.get(1);
      pigeonResult.setPosition(position == null ? null : OrnamentPosition.values()[(int) position]);
      Object marginLeft = list.get(2);
      pigeonResult.setMarginLeft((Double) marginLeft);
      Object marginTop = list.get(3);
      pigeonResult.setMarginTop((Double) marginTop);
      Object marginRight = list.get(4);
      pigeonResult.setMarginRight((Double) marginRight);
      Object marginBottom = list.get(5);
      pigeonResult.setMarginBottom((Double) marginBottom);
      Object opacity = list.get(6);
      pigeonResult.setOpacity((Double) opacity);
      Object rotation = list.get(7);
      pigeonResult.setRotation((Double) rotation);
      Object visibility = list.get(8);
      pigeonResult.setVisibility((Boolean) visibility);
      Object fadeWhenFacingNorth = list.get(9);
      pigeonResult.setFadeWhenFacingNorth((Boolean) fadeWhenFacingNorth);
      Object clickable = list.get(10);
      pigeonResult.setClickable((Boolean) clickable);
      Object image = list.get(11);
      pigeonResult.setImage((byte[]) image);
      return pigeonResult;
    }
  }

  /**
   * Shows the attribution icon on the map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class AttributionSettings {
    /** Defines text color of the attribution icon. */
    private @Nullable Long iconColor;

    public @Nullable Long getIconColor() {
      return iconColor;
    }

    public void setIconColor(@Nullable Long setterArg) {
      this.iconColor = setterArg;
    }

    /** Defines where the attribution icon is positioned on the map */
    private @Nullable OrnamentPosition position;

    public @Nullable OrnamentPosition getPosition() {
      return position;
    }

    public void setPosition(@Nullable OrnamentPosition setterArg) {
      this.position = setterArg;
    }

    /** Defines the margin to the left that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginLeft;

    public @Nullable Double getMarginLeft() {
      return marginLeft;
    }

    public void setMarginLeft(@Nullable Double setterArg) {
      this.marginLeft = setterArg;
    }

    /** Defines the margin to the top that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginTop;

    public @Nullable Double getMarginTop() {
      return marginTop;
    }

    public void setMarginTop(@Nullable Double setterArg) {
      this.marginTop = setterArg;
    }

    /** Defines the margin to the right that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginRight;

    public @Nullable Double getMarginRight() {
      return marginRight;
    }

    public void setMarginRight(@Nullable Double setterArg) {
      this.marginRight = setterArg;
    }

    /** Defines the margin to the bottom that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginBottom;

    public @Nullable Double getMarginBottom() {
      return marginBottom;
    }

    public void setMarginBottom(@Nullable Double setterArg) {
      this.marginBottom = setterArg;
    }

    /** Whether the attribution can be clicked and click events can be registered. */
    private @Nullable Boolean clickable;

    public @Nullable Boolean getClickable() {
      return clickable;
    }

    public void setClickable(@Nullable Boolean setterArg) {
      this.clickable = setterArg;
    }

    public static final class Builder {

      private @Nullable Long iconColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconColor(@Nullable Long setterArg) {
        this.iconColor = setterArg;
        return this;
      }

      private @Nullable OrnamentPosition position;

      @CanIgnoreReturnValue
      public @NonNull Builder setPosition(@Nullable OrnamentPosition setterArg) {
        this.position = setterArg;
        return this;
      }

      private @Nullable Double marginLeft;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginLeft(@Nullable Double setterArg) {
        this.marginLeft = setterArg;
        return this;
      }

      private @Nullable Double marginTop;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginTop(@Nullable Double setterArg) {
        this.marginTop = setterArg;
        return this;
      }

      private @Nullable Double marginRight;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginRight(@Nullable Double setterArg) {
        this.marginRight = setterArg;
        return this;
      }

      private @Nullable Double marginBottom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginBottom(@Nullable Double setterArg) {
        this.marginBottom = setterArg;
        return this;
      }

      private @Nullable Boolean clickable;

      @CanIgnoreReturnValue
      public @NonNull Builder setClickable(@Nullable Boolean setterArg) {
        this.clickable = setterArg;
        return this;
      }

      public @NonNull AttributionSettings build() {
        AttributionSettings pigeonReturn = new AttributionSettings();
        pigeonReturn.setIconColor(iconColor);
        pigeonReturn.setPosition(position);
        pigeonReturn.setMarginLeft(marginLeft);
        pigeonReturn.setMarginTop(marginTop);
        pigeonReturn.setMarginRight(marginRight);
        pigeonReturn.setMarginBottom(marginBottom);
        pigeonReturn.setClickable(clickable);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(7);
      toListResult.add(iconColor);
      toListResult.add(position == null ? null : position.index);
      toListResult.add(marginLeft);
      toListResult.add(marginTop);
      toListResult.add(marginRight);
      toListResult.add(marginBottom);
      toListResult.add(clickable);
      return toListResult;
    }

    static @NonNull AttributionSettings fromList(@NonNull ArrayList<Object> list) {
      AttributionSettings pigeonResult = new AttributionSettings();
      Object iconColor = list.get(0);
      pigeonResult.setIconColor((iconColor == null) ? null : ((iconColor instanceof Integer) ? (Integer) iconColor : (Long) iconColor));
      Object position = list.get(1);
      pigeonResult.setPosition(position == null ? null : OrnamentPosition.values()[(int) position]);
      Object marginLeft = list.get(2);
      pigeonResult.setMarginLeft((Double) marginLeft);
      Object marginTop = list.get(3);
      pigeonResult.setMarginTop((Double) marginTop);
      Object marginRight = list.get(4);
      pigeonResult.setMarginRight((Double) marginRight);
      Object marginBottom = list.get(5);
      pigeonResult.setMarginBottom((Double) marginBottom);
      Object clickable = list.get(6);
      pigeonResult.setClickable((Boolean) clickable);
      return pigeonResult;
    }
  }

  /**
   * Shows the Mapbox logo on the map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class LogoSettings {
    /** Defines where the logo is positioned on the map */
    private @Nullable OrnamentPosition position;

    public @Nullable OrnamentPosition getPosition() {
      return position;
    }

    public void setPosition(@Nullable OrnamentPosition setterArg) {
      this.position = setterArg;
    }

    /** Defines the margin to the left that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginLeft;

    public @Nullable Double getMarginLeft() {
      return marginLeft;
    }

    public void setMarginLeft(@Nullable Double setterArg) {
      this.marginLeft = setterArg;
    }

    /** Defines the margin to the top that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginTop;

    public @Nullable Double getMarginTop() {
      return marginTop;
    }

    public void setMarginTop(@Nullable Double setterArg) {
      this.marginTop = setterArg;
    }

    /** Defines the margin to the right that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginRight;

    public @Nullable Double getMarginRight() {
      return marginRight;
    }

    public void setMarginRight(@Nullable Double setterArg) {
      this.marginRight = setterArg;
    }

    /** Defines the margin to the bottom that the attribution icon honors. This property is specified in pixels. */
    private @Nullable Double marginBottom;

    public @Nullable Double getMarginBottom() {
      return marginBottom;
    }

    public void setMarginBottom(@Nullable Double setterArg) {
      this.marginBottom = setterArg;
    }

    public static final class Builder {

      private @Nullable OrnamentPosition position;

      @CanIgnoreReturnValue
      public @NonNull Builder setPosition(@Nullable OrnamentPosition setterArg) {
        this.position = setterArg;
        return this;
      }

      private @Nullable Double marginLeft;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginLeft(@Nullable Double setterArg) {
        this.marginLeft = setterArg;
        return this;
      }

      private @Nullable Double marginTop;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginTop(@Nullable Double setterArg) {
        this.marginTop = setterArg;
        return this;
      }

      private @Nullable Double marginRight;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginRight(@Nullable Double setterArg) {
        this.marginRight = setterArg;
        return this;
      }

      private @Nullable Double marginBottom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMarginBottom(@Nullable Double setterArg) {
        this.marginBottom = setterArg;
        return this;
      }

      public @NonNull LogoSettings build() {
        LogoSettings pigeonReturn = new LogoSettings();
        pigeonReturn.setPosition(position);
        pigeonReturn.setMarginLeft(marginLeft);
        pigeonReturn.setMarginTop(marginTop);
        pigeonReturn.setMarginRight(marginRight);
        pigeonReturn.setMarginBottom(marginBottom);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(position == null ? null : position.index);
      toListResult.add(marginLeft);
      toListResult.add(marginTop);
      toListResult.add(marginRight);
      toListResult.add(marginBottom);
      return toListResult;
    }

    static @NonNull LogoSettings fromList(@NonNull ArrayList<Object> list) {
      LogoSettings pigeonResult = new LogoSettings();
      Object position = list.get(0);
      pigeonResult.setPosition(position == null ? null : OrnamentPosition.values()[(int) position]);
      Object marginLeft = list.get(1);
      pigeonResult.setMarginLeft((Double) marginLeft);
      Object marginTop = list.get(2);
      pigeonResult.setMarginTop((Double) marginTop);
      Object marginRight = list.get(3);
      pigeonResult.setMarginRight((Double) marginRight);
      Object marginBottom = list.get(4);
      pigeonResult.setMarginBottom((Double) marginBottom);
      return pigeonResult;
    }
  }

  private static class GesturesSettingsInterfaceCodec extends StandardMessageCodec {
    public static final GesturesSettingsInterfaceCodec INSTANCE = new GesturesSettingsInterfaceCodec();

    private GesturesSettingsInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return GesturesSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof GesturesSettings) {
        stream.write(128);
        writeValue(stream, ((GesturesSettings) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(129);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Gesture configuration allows to control the user touch interaction.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface GesturesSettingsInterface {

    @NonNull 
    GesturesSettings getSettings();

    void updateSettings(@NonNull GesturesSettings settings);

    /** The codec used by GesturesSettingsInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return GesturesSettingsInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `GesturesSettingsInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable GesturesSettingsInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.getSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  GesturesSettings output = api.getSettings();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.updateSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                GesturesSettings settingsArg = (GesturesSettings) args.get(0);
                try {
                  api.updateSettings(settingsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class _LocationComponentSettingsInterfaceCodec extends StandardMessageCodec {
    public static final _LocationComponentSettingsInterfaceCodec INSTANCE = new _LocationComponentSettingsInterfaceCodec();

    private _LocationComponentSettingsInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return LocationComponentSettings.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return LocationPuck.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return LocationPuck2D.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return LocationPuck3D.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof LocationComponentSettings) {
        stream.write(128);
        writeValue(stream, ((LocationComponentSettings) value).toList());
      } else if (value instanceof LocationPuck) {
        stream.write(129);
        writeValue(stream, ((LocationPuck) value).toList());
      } else if (value instanceof LocationPuck2D) {
        stream.write(130);
        writeValue(stream, ((LocationPuck2D) value).toList());
      } else if (value instanceof LocationPuck3D) {
        stream.write(131);
        writeValue(stream, ((LocationPuck3D) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Shows a location puck on the map.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _LocationComponentSettingsInterface {

    @NonNull 
    LocationComponentSettings getSettings();

    void updateSettings(@NonNull LocationComponentSettings settings, @NonNull Boolean useDefaultPuck2DIfNeeded);

    /** The codec used by _LocationComponentSettingsInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _LocationComponentSettingsInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `_LocationComponentSettingsInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _LocationComponentSettingsInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.getSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  LocationComponentSettings output = api.getSettings();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.updateSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                LocationComponentSettings settingsArg = (LocationComponentSettings) args.get(0);
                Boolean useDefaultPuck2DIfNeededArg = (Boolean) args.get(1);
                try {
                  api.updateSettings(settingsArg, useDefaultPuck2DIfNeededArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class ScaleBarSettingsInterfaceCodec extends StandardMessageCodec {
    public static final ScaleBarSettingsInterfaceCodec INSTANCE = new ScaleBarSettingsInterfaceCodec();

    private ScaleBarSettingsInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return ScaleBarSettings.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof ScaleBarSettings) {
        stream.write(128);
        writeValue(stream, ((ScaleBarSettings) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Shows the scale bar on the map.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface ScaleBarSettingsInterface {

    @NonNull 
    ScaleBarSettings getSettings();

    void updateSettings(@NonNull ScaleBarSettings settings);

    /** The codec used by ScaleBarSettingsInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return ScaleBarSettingsInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `ScaleBarSettingsInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable ScaleBarSettingsInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.getSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  ScaleBarSettings output = api.getSettings();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.updateSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScaleBarSettings settingsArg = (ScaleBarSettings) args.get(0);
                try {
                  api.updateSettings(settingsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class CompassSettingsInterfaceCodec extends StandardMessageCodec {
    public static final CompassSettingsInterfaceCodec INSTANCE = new CompassSettingsInterfaceCodec();

    private CompassSettingsInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CompassSettings.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CompassSettings) {
        stream.write(128);
        writeValue(stream, ((CompassSettings) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Shows the compass on the map.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface CompassSettingsInterface {

    @NonNull 
    CompassSettings getSettings();

    void updateSettings(@NonNull CompassSettings settings);

    /** The codec used by CompassSettingsInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return CompassSettingsInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `CompassSettingsInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable CompassSettingsInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.getSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  CompassSettings output = api.getSettings();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.updateSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CompassSettings settingsArg = (CompassSettings) args.get(0);
                try {
                  api.updateSettings(settingsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class AttributionSettingsInterfaceCodec extends StandardMessageCodec {
    public static final AttributionSettingsInterfaceCodec INSTANCE = new AttributionSettingsInterfaceCodec();

    private AttributionSettingsInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AttributionSettings.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AttributionSettings) {
        stream.write(128);
        writeValue(stream, ((AttributionSettings) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Shows the attribution icon on the map.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface AttributionSettingsInterface {

    @NonNull 
    AttributionSettings getSettings();

    void updateSettings(@NonNull AttributionSettings settings);

    /** The codec used by AttributionSettingsInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return AttributionSettingsInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `AttributionSettingsInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable AttributionSettingsInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.getSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  AttributionSettings output = api.getSettings();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.updateSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AttributionSettings settingsArg = (AttributionSettings) args.get(0);
                try {
                  api.updateSettings(settingsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class LogoSettingsInterfaceCodec extends StandardMessageCodec {
    public static final LogoSettingsInterfaceCodec INSTANCE = new LogoSettingsInterfaceCodec();

    private LogoSettingsInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return LogoSettings.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof LogoSettings) {
        stream.write(128);
        writeValue(stream, ((LogoSettings) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Shows the Mapbox logo on the map.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface LogoSettingsInterface {

    @NonNull 
    LogoSettings getSettings();

    void updateSettings(@NonNull LogoSettings settings);

    /** The codec used by LogoSettingsInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return LogoSettingsInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `LogoSettingsInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable LogoSettingsInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.getSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  LogoSettings output = api.getSettings();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.updateSettings", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                LogoSettings settingsArg = (LogoSettings) args.get(0);
                try {
                  api.updateSettings(settingsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
}
