// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.pigeons;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class FLTPointAnnotationMessager {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) 
    {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
        "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  /** Part of the icon placed closest to the anchor. */
  public enum IconAnchor {
    /** The center of the icon is placed closest to the anchor. */
    CENTER(0),
    /** The left side of the icon is placed closest to the anchor. */
    LEFT(1),
    /** The right side of the icon is placed closest to the anchor. */
    RIGHT(2),
    /** The top of the icon is placed closest to the anchor. */
    TOP(3),
    /** The bottom of the icon is placed closest to the anchor. */
    BOTTOM(4),
    /** The top left corner of the icon is placed closest to the anchor. */
    TOP_LEFT(5),
    /** The top right corner of the icon is placed closest to the anchor. */
    TOP_RIGHT(6),
    /** The bottom left corner of the icon is placed closest to the anchor. */
    BOTTOM_LEFT(7),
    /** The bottom right corner of the icon is placed closest to the anchor. */
    BOTTOM_RIGHT(8);

    final int index;

    private IconAnchor(final int index) {
      this.index = index;
    }
  }

  /** Orientation of icon when map is pitched. */
  public enum IconPitchAlignment {
    /** The icon is aligned to the plane of the map. */
    MAP(0),
    /** The icon is aligned to the plane of the viewport. */
    VIEWPORT(1),
    /** Automatically matches the value of {@link ICON_ROTATION_ALIGNMENT}. */
    AUTO(2);

    final int index;

    private IconPitchAlignment(final int index) {
      this.index = index;
    }
  }

  /** In combination with `symbol-placement`, determines the rotation behavior of icons. */
  public enum IconRotationAlignment {
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns icons east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns icon x-axes with the line. */
    MAP(0),
    /** Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}. */
    VIEWPORT(1),
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_MAP}. */
    AUTO(2);

    final int index;

    private IconRotationAlignment(final int index) {
      this.index = index;
    }
  }

  /** Scales the icon to fit around the associated text. */
  public enum IconTextFit {
    /** The icon is displayed at its intrinsic aspect ratio. */
    NONE(0),
    /** The icon is scaled in the x-dimension to fit the width of the text. */
    WIDTH(1),
    /** The icon is scaled in the y-dimension to fit the height of the text. */
    HEIGHT(2),
    /** The icon is scaled in both x- and y-dimensions. */
    BOTH(3);

    final int index;

    private IconTextFit(final int index) {
      this.index = index;
    }
  }

  /** Label placement relative to its geometry. */
  public enum SymbolPlacement {
    /** The label is placed at the point where the geometry is located. */
    POINT(0),
    /** The label is placed along the line of the geometry. Can only be used on LineString and Polygon geometries. */
    LINE(1),
    /** The label is placed at the center of the line of the geometry. Can only be used on LineString and Polygon geometries. Note that a single feature in a vector tile may contain multiple line geometries. */
    LINE_CENTER(2);

    final int index;

    private SymbolPlacement(final int index) {
      this.index = index;
    }
  }

  /** Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`. */
  public enum SymbolZOrder {
    /** Sorts symbols by symbol sort key if set. Otherwise, sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}. */
    AUTO(0),
    /** Sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}. */
    VIEWPORT_Y(1),
    /** Sorts symbols by symbol sort key if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data. */
    SOURCE(2);

    final int index;

    private SymbolZOrder(final int index) {
      this.index = index;
    }
  }

  /** Part of the text placed closest to the anchor. */
  public enum TextAnchor {
    /** The center of the text is placed closest to the anchor. */
    CENTER(0),
    /** The left side of the text is placed closest to the anchor. */
    LEFT(1),
    /** The right side of the text is placed closest to the anchor. */
    RIGHT(2),
    /** The top of the text is placed closest to the anchor. */
    TOP(3),
    /** The bottom of the text is placed closest to the anchor. */
    BOTTOM(4),
    /** The top left corner of the text is placed closest to the anchor. */
    TOP_LEFT(5),
    /** The top right corner of the text is placed closest to the anchor. */
    TOP_RIGHT(6),
    /** The bottom left corner of the text is placed closest to the anchor. */
    BOTTOM_LEFT(7),
    /** The bottom right corner of the text is placed closest to the anchor. */
    BOTTOM_RIGHT(8);

    final int index;

    private TextAnchor(final int index) {
      this.index = index;
    }
  }

  /** Text justification options. */
  public enum TextJustify {
    /** The text is aligned towards the anchor position. */
    AUTO(0),
    /** The text is aligned to the left. */
    LEFT(1),
    /** The text is centered. */
    CENTER(2),
    /** The text is aligned to the right. */
    RIGHT(3);

    final int index;

    private TextJustify(final int index) {
      this.index = index;
    }
  }

  /** Orientation of text when map is pitched. */
  public enum TextPitchAlignment {
    /** The text is aligned to the plane of the map. */
    MAP(0),
    /** The text is aligned to the plane of the viewport. */
    VIEWPORT(1),
    /** Automatically matches the value of {@link TEXT_ROTATION_ALIGNMENT}. */
    AUTO(2);

    final int index;

    private TextPitchAlignment(final int index) {
      this.index = index;
    }
  }

  /** In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text. */
  public enum TextRotationAlignment {
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns text east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns text x-axes with the line. */
    MAP(0),
    /** Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}. */
    VIEWPORT(1),
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_MAP}. */
    AUTO(2);

    final int index;

    private TextRotationAlignment(final int index) {
      this.index = index;
    }
  }

  /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
  public enum TextTransform {
    /** The text is not altered. */
    NONE(0),
    /** Forces all letters to be displayed in uppercase. */
    UPPERCASE(1),
    /** Forces all letters to be displayed in lowercase. */
    LOWERCASE(2);

    final int index;

    private TextTransform(final int index) {
      this.index = index;
    }
  }

  /** To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`. */
  public enum TextVariableAnchor {
    /** The center of the text is placed closest to the anchor. */
    CENTER(0),
    /** The left side of the text is placed closest to the anchor. */
    LEFT(1),
    /** The right side of the text is placed closest to the anchor. */
    RIGHT(2),
    /** The top of the text is placed closest to the anchor. */
    TOP(3),
    /** The bottom of the text is placed closest to the anchor. */
    BOTTOM(4),
    /** The top left corner of the text is placed closest to the anchor. */
    TOP_LEFT(5),
    /** The top right corner of the text is placed closest to the anchor. */
    TOP_RIGHT(6),
    /** The bottom left corner of the text is placed closest to the anchor. */
    BOTTOM_LEFT(7),
    /** The bottom right corner of the text is placed closest to the anchor. */
    BOTTOM_RIGHT(8);

    final int index;

    private TextVariableAnchor(final int index) {
      this.index = index;
    }
  }

  /** The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnâ€™t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. The order of elements in an array define priority order for the placement of an orientation variant. */
  public enum TextWritingMode {
    /** If a text's language supports horizontal writing mode, symbols with point placement would be laid out horizontally. */
    HORIZONTAL(0),
    /** If a text's language supports vertical writing mode, symbols with point placement would be laid out vertically. */
    VERTICAL(1);

    final int index;

    private TextWritingMode(final int index) {
      this.index = index;
    }
  }

  /** Controls the frame of reference for `icon-translate`. */
  public enum IconTranslateAnchor {
    /** Icons are translated relative to the map. */
    MAP(0),
    /** Icons are translated relative to the viewport. */
    VIEWPORT(1);

    final int index;

    private IconTranslateAnchor(final int index) {
      this.index = index;
    }
  }

  /** Controls the frame of reference for `text-translate`. */
  public enum TextTranslateAnchor {
    /** The text is translated relative to the map. */
    MAP(0),
    /** The text is translated relative to the viewport. */
    VIEWPORT(1);

    final int index;

    private TextTranslateAnchor(final int index) {
      this.index = index;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PointAnnotation {
    /** The id for annotation */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** The geometry that determines the location/shape of this annotation */
    private @Nullable Map<String, Object> geometry;

    public @Nullable Map<String, Object> getGeometry() {
      return geometry;
    }

    public void setGeometry(@Nullable Map<String, Object> setterArg) {
      this.geometry = setterArg;
    }

    /**
     * The bitmap image for this Annotation
     * Will not take effect if [iconImage] has been set.
     */
    private @Nullable byte[] image;

    public @Nullable byte[] getImage() {
      return image;
    }

    public void setImage(@Nullable byte[] setterArg) {
      this.image = setterArg;
    }

    /** Part of the icon placed closest to the anchor. */
    private @Nullable IconAnchor iconAnchor;

    public @Nullable IconAnchor getIconAnchor() {
      return iconAnchor;
    }

    public void setIconAnchor(@Nullable IconAnchor setterArg) {
      this.iconAnchor = setterArg;
    }

    /** Name of image in sprite to use for drawing an image background. */
    private @Nullable String iconImage;

    public @Nullable String getIconImage() {
      return iconImage;
    }

    public void setIconImage(@Nullable String setterArg) {
      this.iconImage = setterArg;
    }

    /** Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up. */
    private @Nullable List<Double> iconOffset;

    public @Nullable List<Double> getIconOffset() {
      return iconOffset;
    }

    public void setIconOffset(@Nullable List<Double> setterArg) {
      this.iconOffset = setterArg;
    }

    /** Rotates the icon clockwise. */
    private @Nullable Double iconRotate;

    public @Nullable Double getIconRotate() {
      return iconRotate;
    }

    public void setIconRotate(@Nullable Double setterArg) {
      this.iconRotate = setterArg;
    }

    /** Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image. */
    private @Nullable Double iconSize;

    public @Nullable Double getIconSize() {
      return iconSize;
    }

    public void setIconSize(@Nullable Double setterArg) {
      this.iconSize = setterArg;
    }

    /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
    private @Nullable Double symbolSortKey;

    public @Nullable Double getSymbolSortKey() {
      return symbolSortKey;
    }

    public void setSymbolSortKey(@Nullable Double setterArg) {
      this.symbolSortKey = setterArg;
    }

    /** Part of the text placed closest to the anchor. */
    private @Nullable TextAnchor textAnchor;

    public @Nullable TextAnchor getTextAnchor() {
      return textAnchor;
    }

    public void setTextAnchor(@Nullable TextAnchor setterArg) {
      this.textAnchor = setterArg;
    }

    /** Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. */
    private @Nullable String textField;

    public @Nullable String getTextField() {
      return textField;
    }

    public void setTextField(@Nullable String setterArg) {
      this.textField = setterArg;
    }

    /** Text justification options. */
    private @Nullable TextJustify textJustify;

    public @Nullable TextJustify getTextJustify() {
      return textJustify;
    }

    public void setTextJustify(@Nullable TextJustify setterArg) {
      this.textJustify = setterArg;
    }

    /** Text tracking amount. */
    private @Nullable Double textLetterSpacing;

    public @Nullable Double getTextLetterSpacing() {
      return textLetterSpacing;
    }

    public void setTextLetterSpacing(@Nullable Double setterArg) {
      this.textLetterSpacing = setterArg;
    }

    /** The maximum line width for text wrapping. */
    private @Nullable Double textMaxWidth;

    public @Nullable Double getTextMaxWidth() {
      return textMaxWidth;
    }

    public void setTextMaxWidth(@Nullable Double setterArg) {
      this.textMaxWidth = setterArg;
    }

    /** Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position. */
    private @Nullable List<Double> textOffset;

    public @Nullable List<Double> getTextOffset() {
      return textOffset;
    }

    public void setTextOffset(@Nullable List<Double> setterArg) {
      this.textOffset = setterArg;
    }

    /** Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present. */
    private @Nullable Double textRadialOffset;

    public @Nullable Double getTextRadialOffset() {
      return textRadialOffset;
    }

    public void setTextRadialOffset(@Nullable Double setterArg) {
      this.textRadialOffset = setterArg;
    }

    /** Rotates the text clockwise. */
    private @Nullable Double textRotate;

    public @Nullable Double getTextRotate() {
      return textRotate;
    }

    public void setTextRotate(@Nullable Double setterArg) {
      this.textRotate = setterArg;
    }

    /** Font size. */
    private @Nullable Double textSize;

    public @Nullable Double getTextSize() {
      return textSize;
    }

    public void setTextSize(@Nullable Double setterArg) {
      this.textSize = setterArg;
    }

    /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
    private @Nullable TextTransform textTransform;

    public @Nullable TextTransform getTextTransform() {
      return textTransform;
    }

    public void setTextTransform(@Nullable TextTransform setterArg) {
      this.textTransform = setterArg;
    }

    /** The color of the icon. This can only be used with sdf icons. */
    private @Nullable Long iconColor;

    public @Nullable Long getIconColor() {
      return iconColor;
    }

    public void setIconColor(@Nullable Long setterArg) {
      this.iconColor = setterArg;
    }

    /** Fade out the halo towards the outside. */
    private @Nullable Double iconHaloBlur;

    public @Nullable Double getIconHaloBlur() {
      return iconHaloBlur;
    }

    public void setIconHaloBlur(@Nullable Double setterArg) {
      this.iconHaloBlur = setterArg;
    }

    /** The color of the icon's halo. Icon halos can only be used with SDF icons. */
    private @Nullable Long iconHaloColor;

    public @Nullable Long getIconHaloColor() {
      return iconHaloColor;
    }

    public void setIconHaloColor(@Nullable Long setterArg) {
      this.iconHaloColor = setterArg;
    }

    /** Distance of halo to the icon outline. */
    private @Nullable Double iconHaloWidth;

    public @Nullable Double getIconHaloWidth() {
      return iconHaloWidth;
    }

    public void setIconHaloWidth(@Nullable Double setterArg) {
      this.iconHaloWidth = setterArg;
    }

    /** The opacity at which the icon will be drawn. */
    private @Nullable Double iconOpacity;

    public @Nullable Double getIconOpacity() {
      return iconOpacity;
    }

    public void setIconOpacity(@Nullable Double setterArg) {
      this.iconOpacity = setterArg;
    }

    /** The color with which the text will be drawn. */
    private @Nullable Long textColor;

    public @Nullable Long getTextColor() {
      return textColor;
    }

    public void setTextColor(@Nullable Long setterArg) {
      this.textColor = setterArg;
    }

    /** The halo's fadeout distance towards the outside. */
    private @Nullable Double textHaloBlur;

    public @Nullable Double getTextHaloBlur() {
      return textHaloBlur;
    }

    public void setTextHaloBlur(@Nullable Double setterArg) {
      this.textHaloBlur = setterArg;
    }

    /** The color of the text's halo, which helps it stand out from backgrounds. */
    private @Nullable Long textHaloColor;

    public @Nullable Long getTextHaloColor() {
      return textHaloColor;
    }

    public void setTextHaloColor(@Nullable Long setterArg) {
      this.textHaloColor = setterArg;
    }

    /** Distance of halo to the font outline. Max text halo width is 1/4 of the font-size. */
    private @Nullable Double textHaloWidth;

    public @Nullable Double getTextHaloWidth() {
      return textHaloWidth;
    }

    public void setTextHaloWidth(@Nullable Double setterArg) {
      this.textHaloWidth = setterArg;
    }

    /** The opacity at which the text will be drawn. */
    private @Nullable Double textOpacity;

    public @Nullable Double getTextOpacity() {
      return textOpacity;
    }

    public void setTextOpacity(@Nullable Double setterArg) {
      this.textOpacity = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PointAnnotation() {}

    public static final class Builder {

      private @Nullable String id;

      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> geometry;

      public @NonNull Builder setGeometry(@Nullable Map<String, Object> setterArg) {
        this.geometry = setterArg;
        return this;
      }

      private @Nullable byte[] image;

      public @NonNull Builder setImage(@Nullable byte[] setterArg) {
        this.image = setterArg;
        return this;
      }

      private @Nullable IconAnchor iconAnchor;

      public @NonNull Builder setIconAnchor(@Nullable IconAnchor setterArg) {
        this.iconAnchor = setterArg;
        return this;
      }

      private @Nullable String iconImage;

      public @NonNull Builder setIconImage(@Nullable String setterArg) {
        this.iconImage = setterArg;
        return this;
      }

      private @Nullable List<Double> iconOffset;

      public @NonNull Builder setIconOffset(@Nullable List<Double> setterArg) {
        this.iconOffset = setterArg;
        return this;
      }

      private @Nullable Double iconRotate;

      public @NonNull Builder setIconRotate(@Nullable Double setterArg) {
        this.iconRotate = setterArg;
        return this;
      }

      private @Nullable Double iconSize;

      public @NonNull Builder setIconSize(@Nullable Double setterArg) {
        this.iconSize = setterArg;
        return this;
      }

      private @Nullable Double symbolSortKey;

      public @NonNull Builder setSymbolSortKey(@Nullable Double setterArg) {
        this.symbolSortKey = setterArg;
        return this;
      }

      private @Nullable TextAnchor textAnchor;

      public @NonNull Builder setTextAnchor(@Nullable TextAnchor setterArg) {
        this.textAnchor = setterArg;
        return this;
      }

      private @Nullable String textField;

      public @NonNull Builder setTextField(@Nullable String setterArg) {
        this.textField = setterArg;
        return this;
      }

      private @Nullable TextJustify textJustify;

      public @NonNull Builder setTextJustify(@Nullable TextJustify setterArg) {
        this.textJustify = setterArg;
        return this;
      }

      private @Nullable Double textLetterSpacing;

      public @NonNull Builder setTextLetterSpacing(@Nullable Double setterArg) {
        this.textLetterSpacing = setterArg;
        return this;
      }

      private @Nullable Double textMaxWidth;

      public @NonNull Builder setTextMaxWidth(@Nullable Double setterArg) {
        this.textMaxWidth = setterArg;
        return this;
      }

      private @Nullable List<Double> textOffset;

      public @NonNull Builder setTextOffset(@Nullable List<Double> setterArg) {
        this.textOffset = setterArg;
        return this;
      }

      private @Nullable Double textRadialOffset;

      public @NonNull Builder setTextRadialOffset(@Nullable Double setterArg) {
        this.textRadialOffset = setterArg;
        return this;
      }

      private @Nullable Double textRotate;

      public @NonNull Builder setTextRotate(@Nullable Double setterArg) {
        this.textRotate = setterArg;
        return this;
      }

      private @Nullable Double textSize;

      public @NonNull Builder setTextSize(@Nullable Double setterArg) {
        this.textSize = setterArg;
        return this;
      }

      private @Nullable TextTransform textTransform;

      public @NonNull Builder setTextTransform(@Nullable TextTransform setterArg) {
        this.textTransform = setterArg;
        return this;
      }

      private @Nullable Long iconColor;

      public @NonNull Builder setIconColor(@Nullable Long setterArg) {
        this.iconColor = setterArg;
        return this;
      }

      private @Nullable Double iconHaloBlur;

      public @NonNull Builder setIconHaloBlur(@Nullable Double setterArg) {
        this.iconHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long iconHaloColor;

      public @NonNull Builder setIconHaloColor(@Nullable Long setterArg) {
        this.iconHaloColor = setterArg;
        return this;
      }

      private @Nullable Double iconHaloWidth;

      public @NonNull Builder setIconHaloWidth(@Nullable Double setterArg) {
        this.iconHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double iconOpacity;

      public @NonNull Builder setIconOpacity(@Nullable Double setterArg) {
        this.iconOpacity = setterArg;
        return this;
      }

      private @Nullable Long textColor;

      public @NonNull Builder setTextColor(@Nullable Long setterArg) {
        this.textColor = setterArg;
        return this;
      }

      private @Nullable Double textHaloBlur;

      public @NonNull Builder setTextHaloBlur(@Nullable Double setterArg) {
        this.textHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long textHaloColor;

      public @NonNull Builder setTextHaloColor(@Nullable Long setterArg) {
        this.textHaloColor = setterArg;
        return this;
      }

      private @Nullable Double textHaloWidth;

      public @NonNull Builder setTextHaloWidth(@Nullable Double setterArg) {
        this.textHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double textOpacity;

      public @NonNull Builder setTextOpacity(@Nullable Double setterArg) {
        this.textOpacity = setterArg;
        return this;
      }

      public @NonNull PointAnnotation build() {
        PointAnnotation pigeonReturn = new PointAnnotation();
        pigeonReturn.setId(id);
        pigeonReturn.setGeometry(geometry);
        pigeonReturn.setImage(image);
        pigeonReturn.setIconAnchor(iconAnchor);
        pigeonReturn.setIconImage(iconImage);
        pigeonReturn.setIconOffset(iconOffset);
        pigeonReturn.setIconRotate(iconRotate);
        pigeonReturn.setIconSize(iconSize);
        pigeonReturn.setSymbolSortKey(symbolSortKey);
        pigeonReturn.setTextAnchor(textAnchor);
        pigeonReturn.setTextField(textField);
        pigeonReturn.setTextJustify(textJustify);
        pigeonReturn.setTextLetterSpacing(textLetterSpacing);
        pigeonReturn.setTextMaxWidth(textMaxWidth);
        pigeonReturn.setTextOffset(textOffset);
        pigeonReturn.setTextRadialOffset(textRadialOffset);
        pigeonReturn.setTextRotate(textRotate);
        pigeonReturn.setTextSize(textSize);
        pigeonReturn.setTextTransform(textTransform);
        pigeonReturn.setIconColor(iconColor);
        pigeonReturn.setIconHaloBlur(iconHaloBlur);
        pigeonReturn.setIconHaloColor(iconHaloColor);
        pigeonReturn.setIconHaloWidth(iconHaloWidth);
        pigeonReturn.setIconOpacity(iconOpacity);
        pigeonReturn.setTextColor(textColor);
        pigeonReturn.setTextHaloBlur(textHaloBlur);
        pigeonReturn.setTextHaloColor(textHaloColor);
        pigeonReturn.setTextHaloWidth(textHaloWidth);
        pigeonReturn.setTextOpacity(textOpacity);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(29);
      toListResult.add(id);
      toListResult.add(geometry);
      toListResult.add(image);
      toListResult.add(iconAnchor == null ? null : iconAnchor.index);
      toListResult.add(iconImage);
      toListResult.add(iconOffset);
      toListResult.add(iconRotate);
      toListResult.add(iconSize);
      toListResult.add(symbolSortKey);
      toListResult.add(textAnchor == null ? null : textAnchor.index);
      toListResult.add(textField);
      toListResult.add(textJustify == null ? null : textJustify.index);
      toListResult.add(textLetterSpacing);
      toListResult.add(textMaxWidth);
      toListResult.add(textOffset);
      toListResult.add(textRadialOffset);
      toListResult.add(textRotate);
      toListResult.add(textSize);
      toListResult.add(textTransform == null ? null : textTransform.index);
      toListResult.add(iconColor);
      toListResult.add(iconHaloBlur);
      toListResult.add(iconHaloColor);
      toListResult.add(iconHaloWidth);
      toListResult.add(iconOpacity);
      toListResult.add(textColor);
      toListResult.add(textHaloBlur);
      toListResult.add(textHaloColor);
      toListResult.add(textHaloWidth);
      toListResult.add(textOpacity);
      return toListResult;
    }

    static @NonNull PointAnnotation fromList(@NonNull ArrayList<Object> list) {
      PointAnnotation pigeonResult = new PointAnnotation();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object geometry = list.get(1);
      pigeonResult.setGeometry((Map<String, Object>) geometry);
      Object image = list.get(2);
      pigeonResult.setImage((byte[]) image);
      Object iconAnchor = list.get(3);
      pigeonResult.setIconAnchor(iconAnchor == null ? null : IconAnchor.values()[(int) iconAnchor]);
      Object iconImage = list.get(4);
      pigeonResult.setIconImage((String) iconImage);
      Object iconOffset = list.get(5);
      pigeonResult.setIconOffset((List<Double>) iconOffset);
      Object iconRotate = list.get(6);
      pigeonResult.setIconRotate((Double) iconRotate);
      Object iconSize = list.get(7);
      pigeonResult.setIconSize((Double) iconSize);
      Object symbolSortKey = list.get(8);
      pigeonResult.setSymbolSortKey((Double) symbolSortKey);
      Object textAnchor = list.get(9);
      pigeonResult.setTextAnchor(textAnchor == null ? null : TextAnchor.values()[(int) textAnchor]);
      Object textField = list.get(10);
      pigeonResult.setTextField((String) textField);
      Object textJustify = list.get(11);
      pigeonResult.setTextJustify(textJustify == null ? null : TextJustify.values()[(int) textJustify]);
      Object textLetterSpacing = list.get(12);
      pigeonResult.setTextLetterSpacing((Double) textLetterSpacing);
      Object textMaxWidth = list.get(13);
      pigeonResult.setTextMaxWidth((Double) textMaxWidth);
      Object textOffset = list.get(14);
      pigeonResult.setTextOffset((List<Double>) textOffset);
      Object textRadialOffset = list.get(15);
      pigeonResult.setTextRadialOffset((Double) textRadialOffset);
      Object textRotate = list.get(16);
      pigeonResult.setTextRotate((Double) textRotate);
      Object textSize = list.get(17);
      pigeonResult.setTextSize((Double) textSize);
      Object textTransform = list.get(18);
      pigeonResult.setTextTransform(textTransform == null ? null : TextTransform.values()[(int) textTransform]);
      Object iconColor = list.get(19);
      pigeonResult.setIconColor((iconColor == null) ? null : ((iconColor instanceof Integer) ? (Integer) iconColor : (Long) iconColor));
      Object iconHaloBlur = list.get(20);
      pigeonResult.setIconHaloBlur((Double) iconHaloBlur);
      Object iconHaloColor = list.get(21);
      pigeonResult.setIconHaloColor((iconHaloColor == null) ? null : ((iconHaloColor instanceof Integer) ? (Integer) iconHaloColor : (Long) iconHaloColor));
      Object iconHaloWidth = list.get(22);
      pigeonResult.setIconHaloWidth((Double) iconHaloWidth);
      Object iconOpacity = list.get(23);
      pigeonResult.setIconOpacity((Double) iconOpacity);
      Object textColor = list.get(24);
      pigeonResult.setTextColor((textColor == null) ? null : ((textColor instanceof Integer) ? (Integer) textColor : (Long) textColor));
      Object textHaloBlur = list.get(25);
      pigeonResult.setTextHaloBlur((Double) textHaloBlur);
      Object textHaloColor = list.get(26);
      pigeonResult.setTextHaloColor((textHaloColor == null) ? null : ((textHaloColor instanceof Integer) ? (Integer) textHaloColor : (Long) textHaloColor));
      Object textHaloWidth = list.get(27);
      pigeonResult.setTextHaloWidth((Double) textHaloWidth);
      Object textOpacity = list.get(28);
      pigeonResult.setTextOpacity((Double) textOpacity);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PointAnnotationOptions {
    /** The geometry that determines the location/shape of this annotation */
    private @Nullable Map<String, Object> geometry;

    public @Nullable Map<String, Object> getGeometry() {
      return geometry;
    }

    public void setGeometry(@Nullable Map<String, Object> setterArg) {
      this.geometry = setterArg;
    }

    /**
     * The bitmap image for this Annotation
     * Will not take effect if [iconImage] has been set.
     */
    private @Nullable byte[] image;

    public @Nullable byte[] getImage() {
      return image;
    }

    public void setImage(@Nullable byte[] setterArg) {
      this.image = setterArg;
    }

    /** Part of the icon placed closest to the anchor. */
    private @Nullable IconAnchor iconAnchor;

    public @Nullable IconAnchor getIconAnchor() {
      return iconAnchor;
    }

    public void setIconAnchor(@Nullable IconAnchor setterArg) {
      this.iconAnchor = setterArg;
    }

    /** Name of image in sprite to use for drawing an image background. */
    private @Nullable String iconImage;

    public @Nullable String getIconImage() {
      return iconImage;
    }

    public void setIconImage(@Nullable String setterArg) {
      this.iconImage = setterArg;
    }

    /** Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up. */
    private @Nullable List<Double> iconOffset;

    public @Nullable List<Double> getIconOffset() {
      return iconOffset;
    }

    public void setIconOffset(@Nullable List<Double> setterArg) {
      this.iconOffset = setterArg;
    }

    /** Rotates the icon clockwise. */
    private @Nullable Double iconRotate;

    public @Nullable Double getIconRotate() {
      return iconRotate;
    }

    public void setIconRotate(@Nullable Double setterArg) {
      this.iconRotate = setterArg;
    }

    /** Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image. */
    private @Nullable Double iconSize;

    public @Nullable Double getIconSize() {
      return iconSize;
    }

    public void setIconSize(@Nullable Double setterArg) {
      this.iconSize = setterArg;
    }

    /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
    private @Nullable Double symbolSortKey;

    public @Nullable Double getSymbolSortKey() {
      return symbolSortKey;
    }

    public void setSymbolSortKey(@Nullable Double setterArg) {
      this.symbolSortKey = setterArg;
    }

    /** Part of the text placed closest to the anchor. */
    private @Nullable TextAnchor textAnchor;

    public @Nullable TextAnchor getTextAnchor() {
      return textAnchor;
    }

    public void setTextAnchor(@Nullable TextAnchor setterArg) {
      this.textAnchor = setterArg;
    }

    /** Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. */
    private @Nullable String textField;

    public @Nullable String getTextField() {
      return textField;
    }

    public void setTextField(@Nullable String setterArg) {
      this.textField = setterArg;
    }

    /** Text justification options. */
    private @Nullable TextJustify textJustify;

    public @Nullable TextJustify getTextJustify() {
      return textJustify;
    }

    public void setTextJustify(@Nullable TextJustify setterArg) {
      this.textJustify = setterArg;
    }

    /** Text tracking amount. */
    private @Nullable Double textLetterSpacing;

    public @Nullable Double getTextLetterSpacing() {
      return textLetterSpacing;
    }

    public void setTextLetterSpacing(@Nullable Double setterArg) {
      this.textLetterSpacing = setterArg;
    }

    /** The maximum line width for text wrapping. */
    private @Nullable Double textMaxWidth;

    public @Nullable Double getTextMaxWidth() {
      return textMaxWidth;
    }

    public void setTextMaxWidth(@Nullable Double setterArg) {
      this.textMaxWidth = setterArg;
    }

    /** Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position. */
    private @Nullable List<Double> textOffset;

    public @Nullable List<Double> getTextOffset() {
      return textOffset;
    }

    public void setTextOffset(@Nullable List<Double> setterArg) {
      this.textOffset = setterArg;
    }

    /** Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present. */
    private @Nullable Double textRadialOffset;

    public @Nullable Double getTextRadialOffset() {
      return textRadialOffset;
    }

    public void setTextRadialOffset(@Nullable Double setterArg) {
      this.textRadialOffset = setterArg;
    }

    /** Rotates the text clockwise. */
    private @Nullable Double textRotate;

    public @Nullable Double getTextRotate() {
      return textRotate;
    }

    public void setTextRotate(@Nullable Double setterArg) {
      this.textRotate = setterArg;
    }

    /** Font size. */
    private @Nullable Double textSize;

    public @Nullable Double getTextSize() {
      return textSize;
    }

    public void setTextSize(@Nullable Double setterArg) {
      this.textSize = setterArg;
    }

    /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
    private @Nullable TextTransform textTransform;

    public @Nullable TextTransform getTextTransform() {
      return textTransform;
    }

    public void setTextTransform(@Nullable TextTransform setterArg) {
      this.textTransform = setterArg;
    }

    /** The color of the icon. This can only be used with sdf icons. */
    private @Nullable Long iconColor;

    public @Nullable Long getIconColor() {
      return iconColor;
    }

    public void setIconColor(@Nullable Long setterArg) {
      this.iconColor = setterArg;
    }

    /** Fade out the halo towards the outside. */
    private @Nullable Double iconHaloBlur;

    public @Nullable Double getIconHaloBlur() {
      return iconHaloBlur;
    }

    public void setIconHaloBlur(@Nullable Double setterArg) {
      this.iconHaloBlur = setterArg;
    }

    /** The color of the icon's halo. Icon halos can only be used with SDF icons. */
    private @Nullable Long iconHaloColor;

    public @Nullable Long getIconHaloColor() {
      return iconHaloColor;
    }

    public void setIconHaloColor(@Nullable Long setterArg) {
      this.iconHaloColor = setterArg;
    }

    /** Distance of halo to the icon outline. */
    private @Nullable Double iconHaloWidth;

    public @Nullable Double getIconHaloWidth() {
      return iconHaloWidth;
    }

    public void setIconHaloWidth(@Nullable Double setterArg) {
      this.iconHaloWidth = setterArg;
    }

    /** The opacity at which the icon will be drawn. */
    private @Nullable Double iconOpacity;

    public @Nullable Double getIconOpacity() {
      return iconOpacity;
    }

    public void setIconOpacity(@Nullable Double setterArg) {
      this.iconOpacity = setterArg;
    }

    /** The color with which the text will be drawn. */
    private @Nullable Long textColor;

    public @Nullable Long getTextColor() {
      return textColor;
    }

    public void setTextColor(@Nullable Long setterArg) {
      this.textColor = setterArg;
    }

    /** The halo's fadeout distance towards the outside. */
    private @Nullable Double textHaloBlur;

    public @Nullable Double getTextHaloBlur() {
      return textHaloBlur;
    }

    public void setTextHaloBlur(@Nullable Double setterArg) {
      this.textHaloBlur = setterArg;
    }

    /** The color of the text's halo, which helps it stand out from backgrounds. */
    private @Nullable Long textHaloColor;

    public @Nullable Long getTextHaloColor() {
      return textHaloColor;
    }

    public void setTextHaloColor(@Nullable Long setterArg) {
      this.textHaloColor = setterArg;
    }

    /** Distance of halo to the font outline. Max text halo width is 1/4 of the font-size. */
    private @Nullable Double textHaloWidth;

    public @Nullable Double getTextHaloWidth() {
      return textHaloWidth;
    }

    public void setTextHaloWidth(@Nullable Double setterArg) {
      this.textHaloWidth = setterArg;
    }

    /** The opacity at which the text will be drawn. */
    private @Nullable Double textOpacity;

    public @Nullable Double getTextOpacity() {
      return textOpacity;
    }

    public void setTextOpacity(@Nullable Double setterArg) {
      this.textOpacity = setterArg;
    }

    public static final class Builder {

      private @Nullable Map<String, Object> geometry;

      public @NonNull Builder setGeometry(@Nullable Map<String, Object> setterArg) {
        this.geometry = setterArg;
        return this;
      }

      private @Nullable byte[] image;

      public @NonNull Builder setImage(@Nullable byte[] setterArg) {
        this.image = setterArg;
        return this;
      }

      private @Nullable IconAnchor iconAnchor;

      public @NonNull Builder setIconAnchor(@Nullable IconAnchor setterArg) {
        this.iconAnchor = setterArg;
        return this;
      }

      private @Nullable String iconImage;

      public @NonNull Builder setIconImage(@Nullable String setterArg) {
        this.iconImage = setterArg;
        return this;
      }

      private @Nullable List<Double> iconOffset;

      public @NonNull Builder setIconOffset(@Nullable List<Double> setterArg) {
        this.iconOffset = setterArg;
        return this;
      }

      private @Nullable Double iconRotate;

      public @NonNull Builder setIconRotate(@Nullable Double setterArg) {
        this.iconRotate = setterArg;
        return this;
      }

      private @Nullable Double iconSize;

      public @NonNull Builder setIconSize(@Nullable Double setterArg) {
        this.iconSize = setterArg;
        return this;
      }

      private @Nullable Double symbolSortKey;

      public @NonNull Builder setSymbolSortKey(@Nullable Double setterArg) {
        this.symbolSortKey = setterArg;
        return this;
      }

      private @Nullable TextAnchor textAnchor;

      public @NonNull Builder setTextAnchor(@Nullable TextAnchor setterArg) {
        this.textAnchor = setterArg;
        return this;
      }

      private @Nullable String textField;

      public @NonNull Builder setTextField(@Nullable String setterArg) {
        this.textField = setterArg;
        return this;
      }

      private @Nullable TextJustify textJustify;

      public @NonNull Builder setTextJustify(@Nullable TextJustify setterArg) {
        this.textJustify = setterArg;
        return this;
      }

      private @Nullable Double textLetterSpacing;

      public @NonNull Builder setTextLetterSpacing(@Nullable Double setterArg) {
        this.textLetterSpacing = setterArg;
        return this;
      }

      private @Nullable Double textMaxWidth;

      public @NonNull Builder setTextMaxWidth(@Nullable Double setterArg) {
        this.textMaxWidth = setterArg;
        return this;
      }

      private @Nullable List<Double> textOffset;

      public @NonNull Builder setTextOffset(@Nullable List<Double> setterArg) {
        this.textOffset = setterArg;
        return this;
      }

      private @Nullable Double textRadialOffset;

      public @NonNull Builder setTextRadialOffset(@Nullable Double setterArg) {
        this.textRadialOffset = setterArg;
        return this;
      }

      private @Nullable Double textRotate;

      public @NonNull Builder setTextRotate(@Nullable Double setterArg) {
        this.textRotate = setterArg;
        return this;
      }

      private @Nullable Double textSize;

      public @NonNull Builder setTextSize(@Nullable Double setterArg) {
        this.textSize = setterArg;
        return this;
      }

      private @Nullable TextTransform textTransform;

      public @NonNull Builder setTextTransform(@Nullable TextTransform setterArg) {
        this.textTransform = setterArg;
        return this;
      }

      private @Nullable Long iconColor;

      public @NonNull Builder setIconColor(@Nullable Long setterArg) {
        this.iconColor = setterArg;
        return this;
      }

      private @Nullable Double iconHaloBlur;

      public @NonNull Builder setIconHaloBlur(@Nullable Double setterArg) {
        this.iconHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long iconHaloColor;

      public @NonNull Builder setIconHaloColor(@Nullable Long setterArg) {
        this.iconHaloColor = setterArg;
        return this;
      }

      private @Nullable Double iconHaloWidth;

      public @NonNull Builder setIconHaloWidth(@Nullable Double setterArg) {
        this.iconHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double iconOpacity;

      public @NonNull Builder setIconOpacity(@Nullable Double setterArg) {
        this.iconOpacity = setterArg;
        return this;
      }

      private @Nullable Long textColor;

      public @NonNull Builder setTextColor(@Nullable Long setterArg) {
        this.textColor = setterArg;
        return this;
      }

      private @Nullable Double textHaloBlur;

      public @NonNull Builder setTextHaloBlur(@Nullable Double setterArg) {
        this.textHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long textHaloColor;

      public @NonNull Builder setTextHaloColor(@Nullable Long setterArg) {
        this.textHaloColor = setterArg;
        return this;
      }

      private @Nullable Double textHaloWidth;

      public @NonNull Builder setTextHaloWidth(@Nullable Double setterArg) {
        this.textHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double textOpacity;

      public @NonNull Builder setTextOpacity(@Nullable Double setterArg) {
        this.textOpacity = setterArg;
        return this;
      }

      public @NonNull PointAnnotationOptions build() {
        PointAnnotationOptions pigeonReturn = new PointAnnotationOptions();
        pigeonReturn.setGeometry(geometry);
        pigeonReturn.setImage(image);
        pigeonReturn.setIconAnchor(iconAnchor);
        pigeonReturn.setIconImage(iconImage);
        pigeonReturn.setIconOffset(iconOffset);
        pigeonReturn.setIconRotate(iconRotate);
        pigeonReturn.setIconSize(iconSize);
        pigeonReturn.setSymbolSortKey(symbolSortKey);
        pigeonReturn.setTextAnchor(textAnchor);
        pigeonReturn.setTextField(textField);
        pigeonReturn.setTextJustify(textJustify);
        pigeonReturn.setTextLetterSpacing(textLetterSpacing);
        pigeonReturn.setTextMaxWidth(textMaxWidth);
        pigeonReturn.setTextOffset(textOffset);
        pigeonReturn.setTextRadialOffset(textRadialOffset);
        pigeonReturn.setTextRotate(textRotate);
        pigeonReturn.setTextSize(textSize);
        pigeonReturn.setTextTransform(textTransform);
        pigeonReturn.setIconColor(iconColor);
        pigeonReturn.setIconHaloBlur(iconHaloBlur);
        pigeonReturn.setIconHaloColor(iconHaloColor);
        pigeonReturn.setIconHaloWidth(iconHaloWidth);
        pigeonReturn.setIconOpacity(iconOpacity);
        pigeonReturn.setTextColor(textColor);
        pigeonReturn.setTextHaloBlur(textHaloBlur);
        pigeonReturn.setTextHaloColor(textHaloColor);
        pigeonReturn.setTextHaloWidth(textHaloWidth);
        pigeonReturn.setTextOpacity(textOpacity);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(28);
      toListResult.add(geometry);
      toListResult.add(image);
      toListResult.add(iconAnchor == null ? null : iconAnchor.index);
      toListResult.add(iconImage);
      toListResult.add(iconOffset);
      toListResult.add(iconRotate);
      toListResult.add(iconSize);
      toListResult.add(symbolSortKey);
      toListResult.add(textAnchor == null ? null : textAnchor.index);
      toListResult.add(textField);
      toListResult.add(textJustify == null ? null : textJustify.index);
      toListResult.add(textLetterSpacing);
      toListResult.add(textMaxWidth);
      toListResult.add(textOffset);
      toListResult.add(textRadialOffset);
      toListResult.add(textRotate);
      toListResult.add(textSize);
      toListResult.add(textTransform == null ? null : textTransform.index);
      toListResult.add(iconColor);
      toListResult.add(iconHaloBlur);
      toListResult.add(iconHaloColor);
      toListResult.add(iconHaloWidth);
      toListResult.add(iconOpacity);
      toListResult.add(textColor);
      toListResult.add(textHaloBlur);
      toListResult.add(textHaloColor);
      toListResult.add(textHaloWidth);
      toListResult.add(textOpacity);
      return toListResult;
    }

    static @NonNull PointAnnotationOptions fromList(@NonNull ArrayList<Object> list) {
      PointAnnotationOptions pigeonResult = new PointAnnotationOptions();
      Object geometry = list.get(0);
      pigeonResult.setGeometry((Map<String, Object>) geometry);
      Object image = list.get(1);
      pigeonResult.setImage((byte[]) image);
      Object iconAnchor = list.get(2);
      pigeonResult.setIconAnchor(iconAnchor == null ? null : IconAnchor.values()[(int) iconAnchor]);
      Object iconImage = list.get(3);
      pigeonResult.setIconImage((String) iconImage);
      Object iconOffset = list.get(4);
      pigeonResult.setIconOffset((List<Double>) iconOffset);
      Object iconRotate = list.get(5);
      pigeonResult.setIconRotate((Double) iconRotate);
      Object iconSize = list.get(6);
      pigeonResult.setIconSize((Double) iconSize);
      Object symbolSortKey = list.get(7);
      pigeonResult.setSymbolSortKey((Double) symbolSortKey);
      Object textAnchor = list.get(8);
      pigeonResult.setTextAnchor(textAnchor == null ? null : TextAnchor.values()[(int) textAnchor]);
      Object textField = list.get(9);
      pigeonResult.setTextField((String) textField);
      Object textJustify = list.get(10);
      pigeonResult.setTextJustify(textJustify == null ? null : TextJustify.values()[(int) textJustify]);
      Object textLetterSpacing = list.get(11);
      pigeonResult.setTextLetterSpacing((Double) textLetterSpacing);
      Object textMaxWidth = list.get(12);
      pigeonResult.setTextMaxWidth((Double) textMaxWidth);
      Object textOffset = list.get(13);
      pigeonResult.setTextOffset((List<Double>) textOffset);
      Object textRadialOffset = list.get(14);
      pigeonResult.setTextRadialOffset((Double) textRadialOffset);
      Object textRotate = list.get(15);
      pigeonResult.setTextRotate((Double) textRotate);
      Object textSize = list.get(16);
      pigeonResult.setTextSize((Double) textSize);
      Object textTransform = list.get(17);
      pigeonResult.setTextTransform(textTransform == null ? null : TextTransform.values()[(int) textTransform]);
      Object iconColor = list.get(18);
      pigeonResult.setIconColor((iconColor == null) ? null : ((iconColor instanceof Integer) ? (Integer) iconColor : (Long) iconColor));
      Object iconHaloBlur = list.get(19);
      pigeonResult.setIconHaloBlur((Double) iconHaloBlur);
      Object iconHaloColor = list.get(20);
      pigeonResult.setIconHaloColor((iconHaloColor == null) ? null : ((iconHaloColor instanceof Integer) ? (Integer) iconHaloColor : (Long) iconHaloColor));
      Object iconHaloWidth = list.get(21);
      pigeonResult.setIconHaloWidth((Double) iconHaloWidth);
      Object iconOpacity = list.get(22);
      pigeonResult.setIconOpacity((Double) iconOpacity);
      Object textColor = list.get(23);
      pigeonResult.setTextColor((textColor == null) ? null : ((textColor instanceof Integer) ? (Integer) textColor : (Long) textColor));
      Object textHaloBlur = list.get(24);
      pigeonResult.setTextHaloBlur((Double) textHaloBlur);
      Object textHaloColor = list.get(25);
      pigeonResult.setTextHaloColor((textHaloColor == null) ? null : ((textHaloColor instanceof Integer) ? (Integer) textHaloColor : (Long) textHaloColor));
      Object textHaloWidth = list.get(26);
      pigeonResult.setTextHaloWidth((Double) textHaloWidth);
      Object textOpacity = list.get(27);
      pigeonResult.setTextOpacity((Double) textOpacity);
      return pigeonResult;
    }
  }

  public interface Result<T> {
    @SuppressWarnings("UnknownNullness")
    void success(T result);

    void error(@NonNull Throwable error);
  }

  private static class OnPointAnnotationClickListenerCodec extends StandardMessageCodec {
    public static final OnPointAnnotationClickListenerCodec INSTANCE = new OnPointAnnotationClickListenerCodec();

    private OnPointAnnotationClickListenerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PointAnnotation.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PointAnnotation) {
        stream.write(128);
        writeValue(stream, ((PointAnnotation) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated class from Pigeon that represents Flutter messages that can be called from Java. */
  public static class OnPointAnnotationClickListener {
    private final @NonNull BinaryMessenger binaryMessenger;

    public OnPointAnnotationClickListener(@NonNull BinaryMessenger argBinaryMessenger) {
      this.binaryMessenger = argBinaryMessenger;
    }

    /** Public interface for sending reply. */ 
    @SuppressWarnings("UnknownNullness")
    public interface Reply<T> {
      void reply(T reply);
    }
    /** The codec used by OnPointAnnotationClickListener. */
    static @NonNull MessageCodec<Object> getCodec() {
      return OnPointAnnotationClickListenerCodec.INSTANCE;
    }
    public void onPointAnnotationClick(@NonNull PointAnnotation annotationArg, @NonNull Reply<Void> callback) {
      BasicMessageChannel<Object> channel =
          new BasicMessageChannel<>(
              binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick", getCodec());
      channel.send(
          new ArrayList<Object>(Collections.singletonList(annotationArg)),
          channelReply -> callback.reply(null));
    }
  }

  private static class _PointAnnotationMessagerCodec extends StandardMessageCodec {
    public static final _PointAnnotationMessagerCodec INSTANCE = new _PointAnnotationMessagerCodec();

    private _PointAnnotationMessagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PointAnnotation.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return PointAnnotationOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PointAnnotation) {
        stream.write(128);
        writeValue(stream, ((PointAnnotation) value).toList());
      } else if (value instanceof PointAnnotationOptions) {
        stream.write(129);
        writeValue(stream, ((PointAnnotationOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface _PointAnnotationMessager {

    void create(@NonNull String managerId, @NonNull PointAnnotationOptions annotationOption, @NonNull Result<PointAnnotation> result);

    void createMulti(@NonNull String managerId, @NonNull List<PointAnnotationOptions> annotationOptions, @NonNull Result<List<PointAnnotation>> result);

    void update(@NonNull String managerId, @NonNull PointAnnotation annotation, @NonNull Result<Void> result);

    void delete(@NonNull String managerId, @NonNull PointAnnotation annotation, @NonNull Result<Void> result);

    void deleteAll(@NonNull String managerId, @NonNull Result<Void> result);

    void setIconAllowOverlap(@NonNull String managerId, @NonNull Boolean iconAllowOverlap, @NonNull Result<Void> result);

    void getIconAllowOverlap(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setIconIgnorePlacement(@NonNull String managerId, @NonNull Boolean iconIgnorePlacement, @NonNull Result<Void> result);

    void getIconIgnorePlacement(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setIconKeepUpright(@NonNull String managerId, @NonNull Boolean iconKeepUpright, @NonNull Result<Void> result);

    void getIconKeepUpright(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setIconOptional(@NonNull String managerId, @NonNull Boolean iconOptional, @NonNull Result<Void> result);

    void getIconOptional(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setIconPadding(@NonNull String managerId, @NonNull Double iconPadding, @NonNull Result<Void> result);

    void getIconPadding(@NonNull String managerId, @NonNull Result<Double> result);

    void setIconPitchAlignment(@NonNull String managerId, @NonNull IconPitchAlignment iconPitchAlignment, @NonNull Result<Void> result);

    void getIconPitchAlignment(@NonNull String managerId, @NonNull Result<Long> result);

    void setIconRotationAlignment(@NonNull String managerId, @NonNull IconRotationAlignment iconRotationAlignment, @NonNull Result<Void> result);

    void getIconRotationAlignment(@NonNull String managerId, @NonNull Result<Long> result);

    void setIconTextFit(@NonNull String managerId, @NonNull IconTextFit iconTextFit, @NonNull Result<Void> result);

    void getIconTextFit(@NonNull String managerId, @NonNull Result<Long> result);

    void setIconTextFitPadding(@NonNull String managerId, @NonNull List<Double> iconTextFitPadding, @NonNull Result<Void> result);

    void getIconTextFitPadding(@NonNull String managerId, @NonNull Result<List<Double>> result);

    void setSymbolAvoidEdges(@NonNull String managerId, @NonNull Boolean symbolAvoidEdges, @NonNull Result<Void> result);

    void getSymbolAvoidEdges(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setSymbolPlacement(@NonNull String managerId, @NonNull SymbolPlacement symbolPlacement, @NonNull Result<Void> result);

    void getSymbolPlacement(@NonNull String managerId, @NonNull Result<Long> result);

    void setSymbolSpacing(@NonNull String managerId, @NonNull Double symbolSpacing, @NonNull Result<Void> result);

    void getSymbolSpacing(@NonNull String managerId, @NonNull Result<Double> result);

    void setSymbolZOrder(@NonNull String managerId, @NonNull SymbolZOrder symbolZOrder, @NonNull Result<Void> result);

    void getSymbolZOrder(@NonNull String managerId, @NonNull Result<Long> result);

    void setTextAllowOverlap(@NonNull String managerId, @NonNull Boolean textAllowOverlap, @NonNull Result<Void> result);

    void getTextAllowOverlap(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setTextFont(@NonNull String managerId, @NonNull List<String> textFont, @NonNull Result<Void> result);

    void getTextFont(@NonNull String managerId, @NonNull Result<List<String>> result);

    void setTextIgnorePlacement(@NonNull String managerId, @NonNull Boolean textIgnorePlacement, @NonNull Result<Void> result);

    void getTextIgnorePlacement(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setTextKeepUpright(@NonNull String managerId, @NonNull Boolean textKeepUpright, @NonNull Result<Void> result);

    void getTextKeepUpright(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setTextLineHeight(@NonNull String managerId, @NonNull Double textLineHeight, @NonNull Result<Void> result);

    void getTextLineHeight(@NonNull String managerId, @NonNull Result<Double> result);

    void setTextMaxAngle(@NonNull String managerId, @NonNull Double textMaxAngle, @NonNull Result<Void> result);

    void getTextMaxAngle(@NonNull String managerId, @NonNull Result<Double> result);

    void setTextOptional(@NonNull String managerId, @NonNull Boolean textOptional, @NonNull Result<Void> result);

    void getTextOptional(@NonNull String managerId, @NonNull Result<Boolean> result);

    void setTextPadding(@NonNull String managerId, @NonNull Double textPadding, @NonNull Result<Void> result);

    void getTextPadding(@NonNull String managerId, @NonNull Result<Double> result);

    void setTextPitchAlignment(@NonNull String managerId, @NonNull TextPitchAlignment textPitchAlignment, @NonNull Result<Void> result);

    void getTextPitchAlignment(@NonNull String managerId, @NonNull Result<Long> result);

    void setTextRotationAlignment(@NonNull String managerId, @NonNull TextRotationAlignment textRotationAlignment, @NonNull Result<Void> result);

    void getTextRotationAlignment(@NonNull String managerId, @NonNull Result<Long> result);

    void setIconTranslate(@NonNull String managerId, @NonNull List<Double> iconTranslate, @NonNull Result<Void> result);

    void getIconTranslate(@NonNull String managerId, @NonNull Result<List<Double>> result);

    void setIconTranslateAnchor(@NonNull String managerId, @NonNull IconTranslateAnchor iconTranslateAnchor, @NonNull Result<Void> result);

    void getIconTranslateAnchor(@NonNull String managerId, @NonNull Result<Long> result);

    void setTextTranslate(@NonNull String managerId, @NonNull List<Double> textTranslate, @NonNull Result<Void> result);

    void getTextTranslate(@NonNull String managerId, @NonNull Result<List<Double>> result);

    void setTextTranslateAnchor(@NonNull String managerId, @NonNull TextTranslateAnchor textTranslateAnchor, @NonNull Result<Void> result);

    void getTextTranslateAnchor(@NonNull String managerId, @NonNull Result<Long> result);

    /** The codec used by _PointAnnotationMessager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _PointAnnotationMessagerCodec.INSTANCE;
    }
    /**Sets up an instance of `_PointAnnotationMessager` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable _PointAnnotationMessager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.create", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                PointAnnotationOptions annotationOptionArg = (PointAnnotationOptions) args.get(1);
                Result<PointAnnotation> resultCallback =
                    new Result<PointAnnotation>() {
                      public void success(PointAnnotation result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.create(managerIdArg, annotationOptionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.createMulti", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<PointAnnotationOptions> annotationOptionsArg = (List<PointAnnotationOptions>) args.get(1);
                Result<List<PointAnnotation>> resultCallback =
                    new Result<List<PointAnnotation>>() {
                      public void success(List<PointAnnotation> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.createMulti(managerIdArg, annotationOptionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.update", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                PointAnnotation annotationArg = (PointAnnotation) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.update(managerIdArg, annotationArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.delete", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                PointAnnotation annotationArg = (PointAnnotation) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.delete(managerIdArg, annotationArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.deleteAll", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.deleteAll(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconAllowOverlapArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconAllowOverlap(managerIdArg, iconAllowOverlapArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconAllowOverlap(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconIgnorePlacementArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconIgnorePlacement(managerIdArg, iconIgnorePlacementArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconIgnorePlacement(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconKeepUprightArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconKeepUpright(managerIdArg, iconKeepUprightArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconKeepUpright(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconOptionalArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconOptional(managerIdArg, iconOptionalArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconOptional(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double iconPaddingArg = (Double) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconPadding(managerIdArg, iconPaddingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Double> resultCallback =
                    new Result<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconPadding(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconPitchAlignment iconPitchAlignmentArg = IconPitchAlignment.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconPitchAlignment(managerIdArg, iconPitchAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconPitchAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconRotationAlignment iconRotationAlignmentArg = IconRotationAlignment.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconRotationAlignment(managerIdArg, iconRotationAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconRotationAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconTextFit", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconTextFit iconTextFitArg = IconTextFit.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconTextFit(managerIdArg, iconTextFitArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconTextFit", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconTextFit(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconTextFitPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<Double> iconTextFitPaddingArg = (List<Double>) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconTextFitPadding(managerIdArg, iconTextFitPaddingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconTextFitPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<List<Double>> resultCallback =
                    new Result<List<Double>>() {
                      public void success(List<Double> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconTextFitPadding(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolAvoidEdges", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean symbolAvoidEdgesArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolAvoidEdges(managerIdArg, symbolAvoidEdgesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolAvoidEdges", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolAvoidEdges(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolPlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                SymbolPlacement symbolPlacementArg = SymbolPlacement.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolPlacement(managerIdArg, symbolPlacementArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolPlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolPlacement(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolSpacing", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double symbolSpacingArg = (Double) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolSpacing(managerIdArg, symbolSpacingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolSpacing", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Double> resultCallback =
                    new Result<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolSpacing(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolZOrder", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                SymbolZOrder symbolZOrderArg = SymbolZOrder.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolZOrder(managerIdArg, symbolZOrderArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolZOrder", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolZOrder(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textAllowOverlapArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextAllowOverlap(managerIdArg, textAllowOverlapArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextAllowOverlap(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextFont", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<String> textFontArg = (List<String>) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextFont(managerIdArg, textFontArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextFont", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<List<String>> resultCallback =
                    new Result<List<String>>() {
                      public void success(List<String> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextFont(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textIgnorePlacementArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextIgnorePlacement(managerIdArg, textIgnorePlacementArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextIgnorePlacement(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textKeepUprightArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextKeepUpright(managerIdArg, textKeepUprightArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextKeepUpright(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextLineHeight", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double textLineHeightArg = (Double) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextLineHeight(managerIdArg, textLineHeightArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextLineHeight", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Double> resultCallback =
                    new Result<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextLineHeight(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextMaxAngle", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double textMaxAngleArg = (Double) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextMaxAngle(managerIdArg, textMaxAngleArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextMaxAngle", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Double> resultCallback =
                    new Result<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextMaxAngle(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textOptionalArg = (Boolean) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextOptional(managerIdArg, textOptionalArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextOptional(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double textPaddingArg = (Double) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextPadding(managerIdArg, textPaddingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Double> resultCallback =
                    new Result<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextPadding(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                TextPitchAlignment textPitchAlignmentArg = TextPitchAlignment.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextPitchAlignment(managerIdArg, textPitchAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextPitchAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                TextRotationAlignment textRotationAlignmentArg = TextRotationAlignment.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextRotationAlignment(managerIdArg, textRotationAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextRotationAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<Double> iconTranslateArg = (List<Double>) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconTranslate(managerIdArg, iconTranslateArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<List<Double>> resultCallback =
                    new Result<List<Double>>() {
                      public void success(List<Double> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconTranslate(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconTranslateAnchor iconTranslateAnchorArg = IconTranslateAnchor.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconTranslateAnchor(managerIdArg, iconTranslateAnchorArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconTranslateAnchor(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<Double> textTranslateArg = (List<Double>) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextTranslate(managerIdArg, textTranslateArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<List<Double>> resultCallback =
                    new Result<List<Double>>() {
                      public void success(List<Double> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextTranslate(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                TextTranslateAnchor textTranslateAnchorArg = TextTranslateAnchor.values()[(int) args.get(1)];
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextTranslateAnchor(managerIdArg, textTranslateAnchorArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Result<Long> resultCallback =
                    new Result<Long>() {
                      public void success(Long result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextTranslateAnchor(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
}
