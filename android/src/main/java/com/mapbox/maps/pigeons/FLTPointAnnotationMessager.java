// Autogenerated from Pigeon (v16.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.pigeons;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.CLASS;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class FLTPointAnnotationMessager {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) 
    {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
        "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  @NonNull
  protected static FlutterError createConnectionError(@NonNull String channelName) {
    return new FlutterError("channel-error",  "Unable to establish connection on channel: " + channelName + ".", "");
  }

  @Target(METHOD)
  @Retention(CLASS)
  @interface CanIgnoreReturnValue {}

  /** Part of the icon placed closest to the anchor. */
  public enum IconAnchor {
    /** The center of the icon is placed closest to the anchor. */
    CENTER(0),
    /** The left side of the icon is placed closest to the anchor. */
    LEFT(1),
    /** The right side of the icon is placed closest to the anchor. */
    RIGHT(2),
    /** The top of the icon is placed closest to the anchor. */
    TOP(3),
    /** The bottom of the icon is placed closest to the anchor. */
    BOTTOM(4),
    /** The top left corner of the icon is placed closest to the anchor. */
    TOP_LEFT(5),
    /** The top right corner of the icon is placed closest to the anchor. */
    TOP_RIGHT(6),
    /** The bottom left corner of the icon is placed closest to the anchor. */
    BOTTOM_LEFT(7),
    /** The bottom right corner of the icon is placed closest to the anchor. */
    BOTTOM_RIGHT(8);

    final int index;

    private IconAnchor(final int index) {
      this.index = index;
    }
  }

  /** Orientation of icon when map is pitched. */
  public enum IconPitchAlignment {
    /** The icon is aligned to the plane of the map. */
    MAP(0),
    /** The icon is aligned to the plane of the viewport. */
    VIEWPORT(1),
    /** Automatically matches the value of {@link ICON_ROTATION_ALIGNMENT}. */
    AUTO(2);

    final int index;

    private IconPitchAlignment(final int index) {
      this.index = index;
    }
  }

  /** In combination with `symbol-placement`, determines the rotation behavior of icons. */
  public enum IconRotationAlignment {
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns icons east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns icon x-axes with the line. */
    MAP(0),
    /** Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}. */
    VIEWPORT(1),
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_MAP}. */
    AUTO(2);

    final int index;

    private IconRotationAlignment(final int index) {
      this.index = index;
    }
  }

  /** Scales the icon to fit around the associated text. */
  public enum IconTextFit {
    /** The icon is displayed at its intrinsic aspect ratio. */
    NONE(0),
    /** The icon is scaled in the x-dimension to fit the width of the text. */
    WIDTH(1),
    /** The icon is scaled in the y-dimension to fit the height of the text. */
    HEIGHT(2),
    /** The icon is scaled in both x- and y-dimensions. */
    BOTH(3);

    final int index;

    private IconTextFit(final int index) {
      this.index = index;
    }
  }

  /** Label placement relative to its geometry. */
  public enum SymbolPlacement {
    /** The label is placed at the point where the geometry is located. */
    POINT(0),
    /** The label is placed along the line of the geometry. Can only be used on LineString and Polygon geometries. */
    LINE(1),
    /** The label is placed at the center of the line of the geometry. Can only be used on LineString and Polygon geometries. Note that a single feature in a vector tile may contain multiple line geometries. */
    LINE_CENTER(2);

    final int index;

    private SymbolPlacement(final int index) {
      this.index = index;
    }
  }

  /** Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`. */
  public enum SymbolZOrder {
    /** Sorts symbols by symbol sort key if set. Otherwise, sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}. */
    AUTO(0),
    /** Sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}. */
    VIEWPORT_Y(1),
    /** Sorts symbols by symbol sort key if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data. */
    SOURCE(2);

    final int index;

    private SymbolZOrder(final int index) {
      this.index = index;
    }
  }

  /** Part of the text placed closest to the anchor. */
  public enum TextAnchor {
    /** The center of the text is placed closest to the anchor. */
    CENTER(0),
    /** The left side of the text is placed closest to the anchor. */
    LEFT(1),
    /** The right side of the text is placed closest to the anchor. */
    RIGHT(2),
    /** The top of the text is placed closest to the anchor. */
    TOP(3),
    /** The bottom of the text is placed closest to the anchor. */
    BOTTOM(4),
    /** The top left corner of the text is placed closest to the anchor. */
    TOP_LEFT(5),
    /** The top right corner of the text is placed closest to the anchor. */
    TOP_RIGHT(6),
    /** The bottom left corner of the text is placed closest to the anchor. */
    BOTTOM_LEFT(7),
    /** The bottom right corner of the text is placed closest to the anchor. */
    BOTTOM_RIGHT(8);

    final int index;

    private TextAnchor(final int index) {
      this.index = index;
    }
  }

  /** Text justification options. */
  public enum TextJustify {
    /** The text is aligned towards the anchor position. */
    AUTO(0),
    /** The text is aligned to the left. */
    LEFT(1),
    /** The text is centered. */
    CENTER(2),
    /** The text is aligned to the right. */
    RIGHT(3);

    final int index;

    private TextJustify(final int index) {
      this.index = index;
    }
  }

  /** Orientation of text when map is pitched. */
  public enum TextPitchAlignment {
    /** The text is aligned to the plane of the map. */
    MAP(0),
    /** The text is aligned to the plane of the viewport. */
    VIEWPORT(1),
    /** Automatically matches the value of {@link TEXT_ROTATION_ALIGNMENT}. */
    AUTO(2);

    final int index;

    private TextPitchAlignment(final int index) {
      this.index = index;
    }
  }

  /** In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text. */
  public enum TextRotationAlignment {
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns text east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns text x-axes with the line. */
    MAP(0),
    /** Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}. */
    VIEWPORT(1),
    /** When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_MAP}. */
    AUTO(2);

    final int index;

    private TextRotationAlignment(final int index) {
      this.index = index;
    }
  }

  /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
  public enum TextTransform {
    /** The text is not altered. */
    NONE(0),
    /** Forces all letters to be displayed in uppercase. */
    UPPERCASE(1),
    /** Forces all letters to be displayed in lowercase. */
    LOWERCASE(2);

    final int index;

    private TextTransform(final int index) {
      this.index = index;
    }
  }

  /** To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`. */
  public enum TextVariableAnchor {
    /** The center of the text is placed closest to the anchor. */
    CENTER(0),
    /** The left side of the text is placed closest to the anchor. */
    LEFT(1),
    /** The right side of the text is placed closest to the anchor. */
    RIGHT(2),
    /** The top of the text is placed closest to the anchor. */
    TOP(3),
    /** The bottom of the text is placed closest to the anchor. */
    BOTTOM(4),
    /** The top left corner of the text is placed closest to the anchor. */
    TOP_LEFT(5),
    /** The top right corner of the text is placed closest to the anchor. */
    TOP_RIGHT(6),
    /** The bottom left corner of the text is placed closest to the anchor. */
    BOTTOM_LEFT(7),
    /** The bottom right corner of the text is placed closest to the anchor. */
    BOTTOM_RIGHT(8);

    final int index;

    private TextVariableAnchor(final int index) {
      this.index = index;
    }
  }

  /** The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnâ€™t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement. */
  public enum TextWritingMode {
    /** If a text's language supports horizontal writing mode, symbols would be laid out horizontally. */
    HORIZONTAL(0),
    /** If a text's language supports vertical writing mode, symbols would be laid out vertically. */
    VERTICAL(1);

    final int index;

    private TextWritingMode(final int index) {
      this.index = index;
    }
  }

  /** Controls the frame of reference for `icon-translate`. */
  public enum IconTranslateAnchor {
    /** Icons are translated relative to the map. */
    MAP(0),
    /** Icons are translated relative to the viewport. */
    VIEWPORT(1);

    final int index;

    private IconTranslateAnchor(final int index) {
      this.index = index;
    }
  }

  /** Controls the frame of reference for `text-translate`. */
  public enum TextTranslateAnchor {
    /** The text is translated relative to the map. */
    MAP(0),
    /** The text is translated relative to the viewport. */
    VIEWPORT(1);

    final int index;

    private TextTranslateAnchor(final int index) {
      this.index = index;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PointAnnotation {
    /** The id for annotation */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** The geometry that determines the location/shape of this annotation */
    private @Nullable Map<String, Object> geometry;

    public @Nullable Map<String, Object> getGeometry() {
      return geometry;
    }

    public void setGeometry(@Nullable Map<String, Object> setterArg) {
      this.geometry = setterArg;
    }

    /**
     * The bitmap image for this Annotation
     * Will not take effect if [iconImage] has been set.
     */
    private @Nullable byte[] image;

    public @Nullable byte[] getImage() {
      return image;
    }

    public void setImage(@Nullable byte[] setterArg) {
      this.image = setterArg;
    }

    /** Part of the icon placed closest to the anchor. */
    private @Nullable IconAnchor iconAnchor;

    public @Nullable IconAnchor getIconAnchor() {
      return iconAnchor;
    }

    public void setIconAnchor(@Nullable IconAnchor setterArg) {
      this.iconAnchor = setterArg;
    }

    /** Name of image in sprite to use for drawing an image background. */
    private @Nullable String iconImage;

    public @Nullable String getIconImage() {
      return iconImage;
    }

    public void setIconImage(@Nullable String setterArg) {
      this.iconImage = setterArg;
    }

    /** Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up. */
    private @Nullable List<Double> iconOffset;

    public @Nullable List<Double> getIconOffset() {
      return iconOffset;
    }

    public void setIconOffset(@Nullable List<Double> setterArg) {
      this.iconOffset = setterArg;
    }

    /** Rotates the icon clockwise. */
    private @Nullable Double iconRotate;

    public @Nullable Double getIconRotate() {
      return iconRotate;
    }

    public void setIconRotate(@Nullable Double setterArg) {
      this.iconRotate = setterArg;
    }

    /** Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image. */
    private @Nullable Double iconSize;

    public @Nullable Double getIconSize() {
      return iconSize;
    }

    public void setIconSize(@Nullable Double setterArg) {
      this.iconSize = setterArg;
    }

    /** Scales the icon to fit around the associated text. */
    private @Nullable IconTextFit iconTextFit;

    public @Nullable IconTextFit getIconTextFit() {
      return iconTextFit;
    }

    public void setIconTextFit(@Nullable IconTextFit setterArg) {
      this.iconTextFit = setterArg;
    }

    /** Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left. */
    private @Nullable List<Double> iconTextFitPadding;

    public @Nullable List<Double> getIconTextFitPadding() {
      return iconTextFitPadding;
    }

    public void setIconTextFitPadding(@Nullable List<Double> setterArg) {
      this.iconTextFitPadding = setterArg;
    }

    /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
    private @Nullable Double symbolSortKey;

    public @Nullable Double getSymbolSortKey() {
      return symbolSortKey;
    }

    public void setSymbolSortKey(@Nullable Double setterArg) {
      this.symbolSortKey = setterArg;
    }

    /** Part of the text placed closest to the anchor. */
    private @Nullable TextAnchor textAnchor;

    public @Nullable TextAnchor getTextAnchor() {
      return textAnchor;
    }

    public void setTextAnchor(@Nullable TextAnchor setterArg) {
      this.textAnchor = setterArg;
    }

    /** Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored. */
    private @Nullable String textField;

    public @Nullable String getTextField() {
      return textField;
    }

    public void setTextField(@Nullable String setterArg) {
      this.textField = setterArg;
    }

    /** Text justification options. */
    private @Nullable TextJustify textJustify;

    public @Nullable TextJustify getTextJustify() {
      return textJustify;
    }

    public void setTextJustify(@Nullable TextJustify setterArg) {
      this.textJustify = setterArg;
    }

    /** Text tracking amount. */
    private @Nullable Double textLetterSpacing;

    public @Nullable Double getTextLetterSpacing() {
      return textLetterSpacing;
    }

    public void setTextLetterSpacing(@Nullable Double setterArg) {
      this.textLetterSpacing = setterArg;
    }

    /** Text leading value for multi-line text. */
    private @Nullable Double textLineHeight;

    public @Nullable Double getTextLineHeight() {
      return textLineHeight;
    }

    public void setTextLineHeight(@Nullable Double setterArg) {
      this.textLineHeight = setterArg;
    }

    /** The maximum line width for text wrapping. */
    private @Nullable Double textMaxWidth;

    public @Nullable Double getTextMaxWidth() {
      return textMaxWidth;
    }

    public void setTextMaxWidth(@Nullable Double setterArg) {
      this.textMaxWidth = setterArg;
    }

    /** Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position. */
    private @Nullable List<Double> textOffset;

    public @Nullable List<Double> getTextOffset() {
      return textOffset;
    }

    public void setTextOffset(@Nullable List<Double> setterArg) {
      this.textOffset = setterArg;
    }

    /** Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present. */
    private @Nullable Double textRadialOffset;

    public @Nullable Double getTextRadialOffset() {
      return textRadialOffset;
    }

    public void setTextRadialOffset(@Nullable Double setterArg) {
      this.textRadialOffset = setterArg;
    }

    /** Rotates the text clockwise. */
    private @Nullable Double textRotate;

    public @Nullable Double getTextRotate() {
      return textRotate;
    }

    public void setTextRotate(@Nullable Double setterArg) {
      this.textRotate = setterArg;
    }

    /** Font size. */
    private @Nullable Double textSize;

    public @Nullable Double getTextSize() {
      return textSize;
    }

    public void setTextSize(@Nullable Double setterArg) {
      this.textSize = setterArg;
    }

    /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
    private @Nullable TextTransform textTransform;

    public @Nullable TextTransform getTextTransform() {
      return textTransform;
    }

    public void setTextTransform(@Nullable TextTransform setterArg) {
      this.textTransform = setterArg;
    }

    /** The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
    private @Nullable Long iconColor;

    public @Nullable Long getIconColor() {
      return iconColor;
    }

    public void setIconColor(@Nullable Long setterArg) {
      this.iconColor = setterArg;
    }

    /** Controls the intensity of light emitted on the source features. This property works only with 3D light, i.e. when `lights` root property is defined. */
    private @Nullable Double iconEmissiveStrength;

    public @Nullable Double getIconEmissiveStrength() {
      return iconEmissiveStrength;
    }

    public void setIconEmissiveStrength(@Nullable Double setterArg) {
      this.iconEmissiveStrength = setterArg;
    }

    /** Fade out the halo towards the outside. */
    private @Nullable Double iconHaloBlur;

    public @Nullable Double getIconHaloBlur() {
      return iconHaloBlur;
    }

    public void setIconHaloBlur(@Nullable Double setterArg) {
      this.iconHaloBlur = setterArg;
    }

    /** The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
    private @Nullable Long iconHaloColor;

    public @Nullable Long getIconHaloColor() {
      return iconHaloColor;
    }

    public void setIconHaloColor(@Nullable Long setterArg) {
      this.iconHaloColor = setterArg;
    }

    /** Distance of halo to the icon outline. */
    private @Nullable Double iconHaloWidth;

    public @Nullable Double getIconHaloWidth() {
      return iconHaloWidth;
    }

    public void setIconHaloWidth(@Nullable Double setterArg) {
      this.iconHaloWidth = setterArg;
    }

    /** Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together. */
    private @Nullable Double iconImageCrossFade;

    public @Nullable Double getIconImageCrossFade() {
      return iconImageCrossFade;
    }

    public void setIconImageCrossFade(@Nullable Double setterArg) {
      this.iconImageCrossFade = setterArg;
    }

    /** The opacity at which the icon will be drawn. */
    private @Nullable Double iconOpacity;

    public @Nullable Double getIconOpacity() {
      return iconOpacity;
    }

    public void setIconOpacity(@Nullable Double setterArg) {
      this.iconOpacity = setterArg;
    }

    /** The color with which the text will be drawn. */
    private @Nullable Long textColor;

    public @Nullable Long getTextColor() {
      return textColor;
    }

    public void setTextColor(@Nullable Long setterArg) {
      this.textColor = setterArg;
    }

    /** Controls the intensity of light emitted on the source features. This property works only with 3D light, i.e. when `lights` root property is defined. */
    private @Nullable Double textEmissiveStrength;

    public @Nullable Double getTextEmissiveStrength() {
      return textEmissiveStrength;
    }

    public void setTextEmissiveStrength(@Nullable Double setterArg) {
      this.textEmissiveStrength = setterArg;
    }

    /** The halo's fadeout distance towards the outside. */
    private @Nullable Double textHaloBlur;

    public @Nullable Double getTextHaloBlur() {
      return textHaloBlur;
    }

    public void setTextHaloBlur(@Nullable Double setterArg) {
      this.textHaloBlur = setterArg;
    }

    /** The color of the text's halo, which helps it stand out from backgrounds. */
    private @Nullable Long textHaloColor;

    public @Nullable Long getTextHaloColor() {
      return textHaloColor;
    }

    public void setTextHaloColor(@Nullable Long setterArg) {
      this.textHaloColor = setterArg;
    }

    /** Distance of halo to the font outline. Max text halo width is 1/4 of the font-size. */
    private @Nullable Double textHaloWidth;

    public @Nullable Double getTextHaloWidth() {
      return textHaloWidth;
    }

    public void setTextHaloWidth(@Nullable Double setterArg) {
      this.textHaloWidth = setterArg;
    }

    /** The opacity at which the text will be drawn. */
    private @Nullable Double textOpacity;

    public @Nullable Double getTextOpacity() {
      return textOpacity;
    }

    public void setTextOpacity(@Nullable Double setterArg) {
      this.textOpacity = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    PointAnnotation() {}

    public static final class Builder {

      private @Nullable String id;

      @CanIgnoreReturnValue
      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> geometry;

      @CanIgnoreReturnValue
      public @NonNull Builder setGeometry(@Nullable Map<String, Object> setterArg) {
        this.geometry = setterArg;
        return this;
      }

      private @Nullable byte[] image;

      @CanIgnoreReturnValue
      public @NonNull Builder setImage(@Nullable byte[] setterArg) {
        this.image = setterArg;
        return this;
      }

      private @Nullable IconAnchor iconAnchor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconAnchor(@Nullable IconAnchor setterArg) {
        this.iconAnchor = setterArg;
        return this;
      }

      private @Nullable String iconImage;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconImage(@Nullable String setterArg) {
        this.iconImage = setterArg;
        return this;
      }

      private @Nullable List<Double> iconOffset;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconOffset(@Nullable List<Double> setterArg) {
        this.iconOffset = setterArg;
        return this;
      }

      private @Nullable Double iconRotate;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconRotate(@Nullable Double setterArg) {
        this.iconRotate = setterArg;
        return this;
      }

      private @Nullable Double iconSize;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconSize(@Nullable Double setterArg) {
        this.iconSize = setterArg;
        return this;
      }

      private @Nullable IconTextFit iconTextFit;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconTextFit(@Nullable IconTextFit setterArg) {
        this.iconTextFit = setterArg;
        return this;
      }

      private @Nullable List<Double> iconTextFitPadding;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconTextFitPadding(@Nullable List<Double> setterArg) {
        this.iconTextFitPadding = setterArg;
        return this;
      }

      private @Nullable Double symbolSortKey;

      @CanIgnoreReturnValue
      public @NonNull Builder setSymbolSortKey(@Nullable Double setterArg) {
        this.symbolSortKey = setterArg;
        return this;
      }

      private @Nullable TextAnchor textAnchor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextAnchor(@Nullable TextAnchor setterArg) {
        this.textAnchor = setterArg;
        return this;
      }

      private @Nullable String textField;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextField(@Nullable String setterArg) {
        this.textField = setterArg;
        return this;
      }

      private @Nullable TextJustify textJustify;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextJustify(@Nullable TextJustify setterArg) {
        this.textJustify = setterArg;
        return this;
      }

      private @Nullable Double textLetterSpacing;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextLetterSpacing(@Nullable Double setterArg) {
        this.textLetterSpacing = setterArg;
        return this;
      }

      private @Nullable Double textLineHeight;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextLineHeight(@Nullable Double setterArg) {
        this.textLineHeight = setterArg;
        return this;
      }

      private @Nullable Double textMaxWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextMaxWidth(@Nullable Double setterArg) {
        this.textMaxWidth = setterArg;
        return this;
      }

      private @Nullable List<Double> textOffset;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextOffset(@Nullable List<Double> setterArg) {
        this.textOffset = setterArg;
        return this;
      }

      private @Nullable Double textRadialOffset;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextRadialOffset(@Nullable Double setterArg) {
        this.textRadialOffset = setterArg;
        return this;
      }

      private @Nullable Double textRotate;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextRotate(@Nullable Double setterArg) {
        this.textRotate = setterArg;
        return this;
      }

      private @Nullable Double textSize;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextSize(@Nullable Double setterArg) {
        this.textSize = setterArg;
        return this;
      }

      private @Nullable TextTransform textTransform;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextTransform(@Nullable TextTransform setterArg) {
        this.textTransform = setterArg;
        return this;
      }

      private @Nullable Long iconColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconColor(@Nullable Long setterArg) {
        this.iconColor = setterArg;
        return this;
      }

      private @Nullable Double iconEmissiveStrength;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconEmissiveStrength(@Nullable Double setterArg) {
        this.iconEmissiveStrength = setterArg;
        return this;
      }

      private @Nullable Double iconHaloBlur;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconHaloBlur(@Nullable Double setterArg) {
        this.iconHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long iconHaloColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconHaloColor(@Nullable Long setterArg) {
        this.iconHaloColor = setterArg;
        return this;
      }

      private @Nullable Double iconHaloWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconHaloWidth(@Nullable Double setterArg) {
        this.iconHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double iconImageCrossFade;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconImageCrossFade(@Nullable Double setterArg) {
        this.iconImageCrossFade = setterArg;
        return this;
      }

      private @Nullable Double iconOpacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconOpacity(@Nullable Double setterArg) {
        this.iconOpacity = setterArg;
        return this;
      }

      private @Nullable Long textColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextColor(@Nullable Long setterArg) {
        this.textColor = setterArg;
        return this;
      }

      private @Nullable Double textEmissiveStrength;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextEmissiveStrength(@Nullable Double setterArg) {
        this.textEmissiveStrength = setterArg;
        return this;
      }

      private @Nullable Double textHaloBlur;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextHaloBlur(@Nullable Double setterArg) {
        this.textHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long textHaloColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextHaloColor(@Nullable Long setterArg) {
        this.textHaloColor = setterArg;
        return this;
      }

      private @Nullable Double textHaloWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextHaloWidth(@Nullable Double setterArg) {
        this.textHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double textOpacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextOpacity(@Nullable Double setterArg) {
        this.textOpacity = setterArg;
        return this;
      }

      public @NonNull PointAnnotation build() {
        PointAnnotation pigeonReturn = new PointAnnotation();
        pigeonReturn.setId(id);
        pigeonReturn.setGeometry(geometry);
        pigeonReturn.setImage(image);
        pigeonReturn.setIconAnchor(iconAnchor);
        pigeonReturn.setIconImage(iconImage);
        pigeonReturn.setIconOffset(iconOffset);
        pigeonReturn.setIconRotate(iconRotate);
        pigeonReturn.setIconSize(iconSize);
        pigeonReturn.setIconTextFit(iconTextFit);
        pigeonReturn.setIconTextFitPadding(iconTextFitPadding);
        pigeonReturn.setSymbolSortKey(symbolSortKey);
        pigeonReturn.setTextAnchor(textAnchor);
        pigeonReturn.setTextField(textField);
        pigeonReturn.setTextJustify(textJustify);
        pigeonReturn.setTextLetterSpacing(textLetterSpacing);
        pigeonReturn.setTextLineHeight(textLineHeight);
        pigeonReturn.setTextMaxWidth(textMaxWidth);
        pigeonReturn.setTextOffset(textOffset);
        pigeonReturn.setTextRadialOffset(textRadialOffset);
        pigeonReturn.setTextRotate(textRotate);
        pigeonReturn.setTextSize(textSize);
        pigeonReturn.setTextTransform(textTransform);
        pigeonReturn.setIconColor(iconColor);
        pigeonReturn.setIconEmissiveStrength(iconEmissiveStrength);
        pigeonReturn.setIconHaloBlur(iconHaloBlur);
        pigeonReturn.setIconHaloColor(iconHaloColor);
        pigeonReturn.setIconHaloWidth(iconHaloWidth);
        pigeonReturn.setIconImageCrossFade(iconImageCrossFade);
        pigeonReturn.setIconOpacity(iconOpacity);
        pigeonReturn.setTextColor(textColor);
        pigeonReturn.setTextEmissiveStrength(textEmissiveStrength);
        pigeonReturn.setTextHaloBlur(textHaloBlur);
        pigeonReturn.setTextHaloColor(textHaloColor);
        pigeonReturn.setTextHaloWidth(textHaloWidth);
        pigeonReturn.setTextOpacity(textOpacity);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(35);
      toListResult.add(id);
      toListResult.add(geometry);
      toListResult.add(image);
      toListResult.add(iconAnchor == null ? null : iconAnchor.index);
      toListResult.add(iconImage);
      toListResult.add(iconOffset);
      toListResult.add(iconRotate);
      toListResult.add(iconSize);
      toListResult.add(iconTextFit == null ? null : iconTextFit.index);
      toListResult.add(iconTextFitPadding);
      toListResult.add(symbolSortKey);
      toListResult.add(textAnchor == null ? null : textAnchor.index);
      toListResult.add(textField);
      toListResult.add(textJustify == null ? null : textJustify.index);
      toListResult.add(textLetterSpacing);
      toListResult.add(textLineHeight);
      toListResult.add(textMaxWidth);
      toListResult.add(textOffset);
      toListResult.add(textRadialOffset);
      toListResult.add(textRotate);
      toListResult.add(textSize);
      toListResult.add(textTransform == null ? null : textTransform.index);
      toListResult.add(iconColor);
      toListResult.add(iconEmissiveStrength);
      toListResult.add(iconHaloBlur);
      toListResult.add(iconHaloColor);
      toListResult.add(iconHaloWidth);
      toListResult.add(iconImageCrossFade);
      toListResult.add(iconOpacity);
      toListResult.add(textColor);
      toListResult.add(textEmissiveStrength);
      toListResult.add(textHaloBlur);
      toListResult.add(textHaloColor);
      toListResult.add(textHaloWidth);
      toListResult.add(textOpacity);
      return toListResult;
    }

    static @NonNull PointAnnotation fromList(@NonNull ArrayList<Object> list) {
      PointAnnotation pigeonResult = new PointAnnotation();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object geometry = list.get(1);
      pigeonResult.setGeometry((Map<String, Object>) geometry);
      Object image = list.get(2);
      pigeonResult.setImage((byte[]) image);
      Object iconAnchor = list.get(3);
      pigeonResult.setIconAnchor(iconAnchor == null ? null : IconAnchor.values()[(int) iconAnchor]);
      Object iconImage = list.get(4);
      pigeonResult.setIconImage((String) iconImage);
      Object iconOffset = list.get(5);
      pigeonResult.setIconOffset((List<Double>) iconOffset);
      Object iconRotate = list.get(6);
      pigeonResult.setIconRotate((Double) iconRotate);
      Object iconSize = list.get(7);
      pigeonResult.setIconSize((Double) iconSize);
      Object iconTextFit = list.get(8);
      pigeonResult.setIconTextFit(iconTextFit == null ? null : IconTextFit.values()[(int) iconTextFit]);
      Object iconTextFitPadding = list.get(9);
      pigeonResult.setIconTextFitPadding((List<Double>) iconTextFitPadding);
      Object symbolSortKey = list.get(10);
      pigeonResult.setSymbolSortKey((Double) symbolSortKey);
      Object textAnchor = list.get(11);
      pigeonResult.setTextAnchor(textAnchor == null ? null : TextAnchor.values()[(int) textAnchor]);
      Object textField = list.get(12);
      pigeonResult.setTextField((String) textField);
      Object textJustify = list.get(13);
      pigeonResult.setTextJustify(textJustify == null ? null : TextJustify.values()[(int) textJustify]);
      Object textLetterSpacing = list.get(14);
      pigeonResult.setTextLetterSpacing((Double) textLetterSpacing);
      Object textLineHeight = list.get(15);
      pigeonResult.setTextLineHeight((Double) textLineHeight);
      Object textMaxWidth = list.get(16);
      pigeonResult.setTextMaxWidth((Double) textMaxWidth);
      Object textOffset = list.get(17);
      pigeonResult.setTextOffset((List<Double>) textOffset);
      Object textRadialOffset = list.get(18);
      pigeonResult.setTextRadialOffset((Double) textRadialOffset);
      Object textRotate = list.get(19);
      pigeonResult.setTextRotate((Double) textRotate);
      Object textSize = list.get(20);
      pigeonResult.setTextSize((Double) textSize);
      Object textTransform = list.get(21);
      pigeonResult.setTextTransform(textTransform == null ? null : TextTransform.values()[(int) textTransform]);
      Object iconColor = list.get(22);
      pigeonResult.setIconColor((iconColor == null) ? null : ((iconColor instanceof Integer) ? (Integer) iconColor : (Long) iconColor));
      Object iconEmissiveStrength = list.get(23);
      pigeonResult.setIconEmissiveStrength((Double) iconEmissiveStrength);
      Object iconHaloBlur = list.get(24);
      pigeonResult.setIconHaloBlur((Double) iconHaloBlur);
      Object iconHaloColor = list.get(25);
      pigeonResult.setIconHaloColor((iconHaloColor == null) ? null : ((iconHaloColor instanceof Integer) ? (Integer) iconHaloColor : (Long) iconHaloColor));
      Object iconHaloWidth = list.get(26);
      pigeonResult.setIconHaloWidth((Double) iconHaloWidth);
      Object iconImageCrossFade = list.get(27);
      pigeonResult.setIconImageCrossFade((Double) iconImageCrossFade);
      Object iconOpacity = list.get(28);
      pigeonResult.setIconOpacity((Double) iconOpacity);
      Object textColor = list.get(29);
      pigeonResult.setTextColor((textColor == null) ? null : ((textColor instanceof Integer) ? (Integer) textColor : (Long) textColor));
      Object textEmissiveStrength = list.get(30);
      pigeonResult.setTextEmissiveStrength((Double) textEmissiveStrength);
      Object textHaloBlur = list.get(31);
      pigeonResult.setTextHaloBlur((Double) textHaloBlur);
      Object textHaloColor = list.get(32);
      pigeonResult.setTextHaloColor((textHaloColor == null) ? null : ((textHaloColor instanceof Integer) ? (Integer) textHaloColor : (Long) textHaloColor));
      Object textHaloWidth = list.get(33);
      pigeonResult.setTextHaloWidth((Double) textHaloWidth);
      Object textOpacity = list.get(34);
      pigeonResult.setTextOpacity((Double) textOpacity);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class PointAnnotationOptions {
    /** The geometry that determines the location/shape of this annotation */
    private @Nullable Map<String, Object> geometry;

    public @Nullable Map<String, Object> getGeometry() {
      return geometry;
    }

    public void setGeometry(@Nullable Map<String, Object> setterArg) {
      this.geometry = setterArg;
    }

    /**
     * The bitmap image for this Annotation
     * Will not take effect if [iconImage] has been set.
     */
    private @Nullable byte[] image;

    public @Nullable byte[] getImage() {
      return image;
    }

    public void setImage(@Nullable byte[] setterArg) {
      this.image = setterArg;
    }

    /** Part of the icon placed closest to the anchor. */
    private @Nullable IconAnchor iconAnchor;

    public @Nullable IconAnchor getIconAnchor() {
      return iconAnchor;
    }

    public void setIconAnchor(@Nullable IconAnchor setterArg) {
      this.iconAnchor = setterArg;
    }

    /** Name of image in sprite to use for drawing an image background. */
    private @Nullable String iconImage;

    public @Nullable String getIconImage() {
      return iconImage;
    }

    public void setIconImage(@Nullable String setterArg) {
      this.iconImage = setterArg;
    }

    /** Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up. */
    private @Nullable List<Double> iconOffset;

    public @Nullable List<Double> getIconOffset() {
      return iconOffset;
    }

    public void setIconOffset(@Nullable List<Double> setterArg) {
      this.iconOffset = setterArg;
    }

    /** Rotates the icon clockwise. */
    private @Nullable Double iconRotate;

    public @Nullable Double getIconRotate() {
      return iconRotate;
    }

    public void setIconRotate(@Nullable Double setterArg) {
      this.iconRotate = setterArg;
    }

    /** Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image. */
    private @Nullable Double iconSize;

    public @Nullable Double getIconSize() {
      return iconSize;
    }

    public void setIconSize(@Nullable Double setterArg) {
      this.iconSize = setterArg;
    }

    /** Scales the icon to fit around the associated text. */
    private @Nullable IconTextFit iconTextFit;

    public @Nullable IconTextFit getIconTextFit() {
      return iconTextFit;
    }

    public void setIconTextFit(@Nullable IconTextFit setterArg) {
      this.iconTextFit = setterArg;
    }

    /** Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left. */
    private @Nullable List<Double> iconTextFitPadding;

    public @Nullable List<Double> getIconTextFitPadding() {
      return iconTextFitPadding;
    }

    public void setIconTextFitPadding(@Nullable List<Double> setterArg) {
      this.iconTextFitPadding = setterArg;
    }

    /** Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key. */
    private @Nullable Double symbolSortKey;

    public @Nullable Double getSymbolSortKey() {
      return symbolSortKey;
    }

    public void setSymbolSortKey(@Nullable Double setterArg) {
      this.symbolSortKey = setterArg;
    }

    /** Part of the text placed closest to the anchor. */
    private @Nullable TextAnchor textAnchor;

    public @Nullable TextAnchor getTextAnchor() {
      return textAnchor;
    }

    public void setTextAnchor(@Nullable TextAnchor setterArg) {
      this.textAnchor = setterArg;
    }

    /** Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored. */
    private @Nullable String textField;

    public @Nullable String getTextField() {
      return textField;
    }

    public void setTextField(@Nullable String setterArg) {
      this.textField = setterArg;
    }

    /** Text justification options. */
    private @Nullable TextJustify textJustify;

    public @Nullable TextJustify getTextJustify() {
      return textJustify;
    }

    public void setTextJustify(@Nullable TextJustify setterArg) {
      this.textJustify = setterArg;
    }

    /** Text tracking amount. */
    private @Nullable Double textLetterSpacing;

    public @Nullable Double getTextLetterSpacing() {
      return textLetterSpacing;
    }

    public void setTextLetterSpacing(@Nullable Double setterArg) {
      this.textLetterSpacing = setterArg;
    }

    /** Text leading value for multi-line text. */
    private @Nullable Double textLineHeight;

    public @Nullable Double getTextLineHeight() {
      return textLineHeight;
    }

    public void setTextLineHeight(@Nullable Double setterArg) {
      this.textLineHeight = setterArg;
    }

    /** The maximum line width for text wrapping. */
    private @Nullable Double textMaxWidth;

    public @Nullable Double getTextMaxWidth() {
      return textMaxWidth;
    }

    public void setTextMaxWidth(@Nullable Double setterArg) {
      this.textMaxWidth = setterArg;
    }

    /** Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position. */
    private @Nullable List<Double> textOffset;

    public @Nullable List<Double> getTextOffset() {
      return textOffset;
    }

    public void setTextOffset(@Nullable List<Double> setterArg) {
      this.textOffset = setterArg;
    }

    /** Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present. */
    private @Nullable Double textRadialOffset;

    public @Nullable Double getTextRadialOffset() {
      return textRadialOffset;
    }

    public void setTextRadialOffset(@Nullable Double setterArg) {
      this.textRadialOffset = setterArg;
    }

    /** Rotates the text clockwise. */
    private @Nullable Double textRotate;

    public @Nullable Double getTextRotate() {
      return textRotate;
    }

    public void setTextRotate(@Nullable Double setterArg) {
      this.textRotate = setterArg;
    }

    /** Font size. */
    private @Nullable Double textSize;

    public @Nullable Double getTextSize() {
      return textSize;
    }

    public void setTextSize(@Nullable Double setterArg) {
      this.textSize = setterArg;
    }

    /** Specifies how to capitalize text, similar to the CSS `text-transform` property. */
    private @Nullable TextTransform textTransform;

    public @Nullable TextTransform getTextTransform() {
      return textTransform;
    }

    public void setTextTransform(@Nullable TextTransform setterArg) {
      this.textTransform = setterArg;
    }

    /** The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
    private @Nullable Long iconColor;

    public @Nullable Long getIconColor() {
      return iconColor;
    }

    public void setIconColor(@Nullable Long setterArg) {
      this.iconColor = setterArg;
    }

    /** Controls the intensity of light emitted on the source features. This property works only with 3D light, i.e. when `lights` root property is defined. */
    private @Nullable Double iconEmissiveStrength;

    public @Nullable Double getIconEmissiveStrength() {
      return iconEmissiveStrength;
    }

    public void setIconEmissiveStrength(@Nullable Double setterArg) {
      this.iconEmissiveStrength = setterArg;
    }

    /** Fade out the halo towards the outside. */
    private @Nullable Double iconHaloBlur;

    public @Nullable Double getIconHaloBlur() {
      return iconHaloBlur;
    }

    public void setIconHaloBlur(@Nullable Double setterArg) {
      this.iconHaloBlur = setterArg;
    }

    /** The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/). */
    private @Nullable Long iconHaloColor;

    public @Nullable Long getIconHaloColor() {
      return iconHaloColor;
    }

    public void setIconHaloColor(@Nullable Long setterArg) {
      this.iconHaloColor = setterArg;
    }

    /** Distance of halo to the icon outline. */
    private @Nullable Double iconHaloWidth;

    public @Nullable Double getIconHaloWidth() {
      return iconHaloWidth;
    }

    public void setIconHaloWidth(@Nullable Double setterArg) {
      this.iconHaloWidth = setterArg;
    }

    /** Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together. */
    private @Nullable Double iconImageCrossFade;

    public @Nullable Double getIconImageCrossFade() {
      return iconImageCrossFade;
    }

    public void setIconImageCrossFade(@Nullable Double setterArg) {
      this.iconImageCrossFade = setterArg;
    }

    /** The opacity at which the icon will be drawn. */
    private @Nullable Double iconOpacity;

    public @Nullable Double getIconOpacity() {
      return iconOpacity;
    }

    public void setIconOpacity(@Nullable Double setterArg) {
      this.iconOpacity = setterArg;
    }

    /** The color with which the text will be drawn. */
    private @Nullable Long textColor;

    public @Nullable Long getTextColor() {
      return textColor;
    }

    public void setTextColor(@Nullable Long setterArg) {
      this.textColor = setterArg;
    }

    /** Controls the intensity of light emitted on the source features. This property works only with 3D light, i.e. when `lights` root property is defined. */
    private @Nullable Double textEmissiveStrength;

    public @Nullable Double getTextEmissiveStrength() {
      return textEmissiveStrength;
    }

    public void setTextEmissiveStrength(@Nullable Double setterArg) {
      this.textEmissiveStrength = setterArg;
    }

    /** The halo's fadeout distance towards the outside. */
    private @Nullable Double textHaloBlur;

    public @Nullable Double getTextHaloBlur() {
      return textHaloBlur;
    }

    public void setTextHaloBlur(@Nullable Double setterArg) {
      this.textHaloBlur = setterArg;
    }

    /** The color of the text's halo, which helps it stand out from backgrounds. */
    private @Nullable Long textHaloColor;

    public @Nullable Long getTextHaloColor() {
      return textHaloColor;
    }

    public void setTextHaloColor(@Nullable Long setterArg) {
      this.textHaloColor = setterArg;
    }

    /** Distance of halo to the font outline. Max text halo width is 1/4 of the font-size. */
    private @Nullable Double textHaloWidth;

    public @Nullable Double getTextHaloWidth() {
      return textHaloWidth;
    }

    public void setTextHaloWidth(@Nullable Double setterArg) {
      this.textHaloWidth = setterArg;
    }

    /** The opacity at which the text will be drawn. */
    private @Nullable Double textOpacity;

    public @Nullable Double getTextOpacity() {
      return textOpacity;
    }

    public void setTextOpacity(@Nullable Double setterArg) {
      this.textOpacity = setterArg;
    }

    public static final class Builder {

      private @Nullable Map<String, Object> geometry;

      @CanIgnoreReturnValue
      public @NonNull Builder setGeometry(@Nullable Map<String, Object> setterArg) {
        this.geometry = setterArg;
        return this;
      }

      private @Nullable byte[] image;

      @CanIgnoreReturnValue
      public @NonNull Builder setImage(@Nullable byte[] setterArg) {
        this.image = setterArg;
        return this;
      }

      private @Nullable IconAnchor iconAnchor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconAnchor(@Nullable IconAnchor setterArg) {
        this.iconAnchor = setterArg;
        return this;
      }

      private @Nullable String iconImage;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconImage(@Nullable String setterArg) {
        this.iconImage = setterArg;
        return this;
      }

      private @Nullable List<Double> iconOffset;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconOffset(@Nullable List<Double> setterArg) {
        this.iconOffset = setterArg;
        return this;
      }

      private @Nullable Double iconRotate;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconRotate(@Nullable Double setterArg) {
        this.iconRotate = setterArg;
        return this;
      }

      private @Nullable Double iconSize;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconSize(@Nullable Double setterArg) {
        this.iconSize = setterArg;
        return this;
      }

      private @Nullable IconTextFit iconTextFit;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconTextFit(@Nullable IconTextFit setterArg) {
        this.iconTextFit = setterArg;
        return this;
      }

      private @Nullable List<Double> iconTextFitPadding;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconTextFitPadding(@Nullable List<Double> setterArg) {
        this.iconTextFitPadding = setterArg;
        return this;
      }

      private @Nullable Double symbolSortKey;

      @CanIgnoreReturnValue
      public @NonNull Builder setSymbolSortKey(@Nullable Double setterArg) {
        this.symbolSortKey = setterArg;
        return this;
      }

      private @Nullable TextAnchor textAnchor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextAnchor(@Nullable TextAnchor setterArg) {
        this.textAnchor = setterArg;
        return this;
      }

      private @Nullable String textField;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextField(@Nullable String setterArg) {
        this.textField = setterArg;
        return this;
      }

      private @Nullable TextJustify textJustify;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextJustify(@Nullable TextJustify setterArg) {
        this.textJustify = setterArg;
        return this;
      }

      private @Nullable Double textLetterSpacing;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextLetterSpacing(@Nullable Double setterArg) {
        this.textLetterSpacing = setterArg;
        return this;
      }

      private @Nullable Double textLineHeight;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextLineHeight(@Nullable Double setterArg) {
        this.textLineHeight = setterArg;
        return this;
      }

      private @Nullable Double textMaxWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextMaxWidth(@Nullable Double setterArg) {
        this.textMaxWidth = setterArg;
        return this;
      }

      private @Nullable List<Double> textOffset;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextOffset(@Nullable List<Double> setterArg) {
        this.textOffset = setterArg;
        return this;
      }

      private @Nullable Double textRadialOffset;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextRadialOffset(@Nullable Double setterArg) {
        this.textRadialOffset = setterArg;
        return this;
      }

      private @Nullable Double textRotate;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextRotate(@Nullable Double setterArg) {
        this.textRotate = setterArg;
        return this;
      }

      private @Nullable Double textSize;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextSize(@Nullable Double setterArg) {
        this.textSize = setterArg;
        return this;
      }

      private @Nullable TextTransform textTransform;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextTransform(@Nullable TextTransform setterArg) {
        this.textTransform = setterArg;
        return this;
      }

      private @Nullable Long iconColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconColor(@Nullable Long setterArg) {
        this.iconColor = setterArg;
        return this;
      }

      private @Nullable Double iconEmissiveStrength;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconEmissiveStrength(@Nullable Double setterArg) {
        this.iconEmissiveStrength = setterArg;
        return this;
      }

      private @Nullable Double iconHaloBlur;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconHaloBlur(@Nullable Double setterArg) {
        this.iconHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long iconHaloColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconHaloColor(@Nullable Long setterArg) {
        this.iconHaloColor = setterArg;
        return this;
      }

      private @Nullable Double iconHaloWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconHaloWidth(@Nullable Double setterArg) {
        this.iconHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double iconImageCrossFade;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconImageCrossFade(@Nullable Double setterArg) {
        this.iconImageCrossFade = setterArg;
        return this;
      }

      private @Nullable Double iconOpacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setIconOpacity(@Nullable Double setterArg) {
        this.iconOpacity = setterArg;
        return this;
      }

      private @Nullable Long textColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextColor(@Nullable Long setterArg) {
        this.textColor = setterArg;
        return this;
      }

      private @Nullable Double textEmissiveStrength;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextEmissiveStrength(@Nullable Double setterArg) {
        this.textEmissiveStrength = setterArg;
        return this;
      }

      private @Nullable Double textHaloBlur;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextHaloBlur(@Nullable Double setterArg) {
        this.textHaloBlur = setterArg;
        return this;
      }

      private @Nullable Long textHaloColor;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextHaloColor(@Nullable Long setterArg) {
        this.textHaloColor = setterArg;
        return this;
      }

      private @Nullable Double textHaloWidth;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextHaloWidth(@Nullable Double setterArg) {
        this.textHaloWidth = setterArg;
        return this;
      }

      private @Nullable Double textOpacity;

      @CanIgnoreReturnValue
      public @NonNull Builder setTextOpacity(@Nullable Double setterArg) {
        this.textOpacity = setterArg;
        return this;
      }

      public @NonNull PointAnnotationOptions build() {
        PointAnnotationOptions pigeonReturn = new PointAnnotationOptions();
        pigeonReturn.setGeometry(geometry);
        pigeonReturn.setImage(image);
        pigeonReturn.setIconAnchor(iconAnchor);
        pigeonReturn.setIconImage(iconImage);
        pigeonReturn.setIconOffset(iconOffset);
        pigeonReturn.setIconRotate(iconRotate);
        pigeonReturn.setIconSize(iconSize);
        pigeonReturn.setIconTextFit(iconTextFit);
        pigeonReturn.setIconTextFitPadding(iconTextFitPadding);
        pigeonReturn.setSymbolSortKey(symbolSortKey);
        pigeonReturn.setTextAnchor(textAnchor);
        pigeonReturn.setTextField(textField);
        pigeonReturn.setTextJustify(textJustify);
        pigeonReturn.setTextLetterSpacing(textLetterSpacing);
        pigeonReturn.setTextLineHeight(textLineHeight);
        pigeonReturn.setTextMaxWidth(textMaxWidth);
        pigeonReturn.setTextOffset(textOffset);
        pigeonReturn.setTextRadialOffset(textRadialOffset);
        pigeonReturn.setTextRotate(textRotate);
        pigeonReturn.setTextSize(textSize);
        pigeonReturn.setTextTransform(textTransform);
        pigeonReturn.setIconColor(iconColor);
        pigeonReturn.setIconEmissiveStrength(iconEmissiveStrength);
        pigeonReturn.setIconHaloBlur(iconHaloBlur);
        pigeonReturn.setIconHaloColor(iconHaloColor);
        pigeonReturn.setIconHaloWidth(iconHaloWidth);
        pigeonReturn.setIconImageCrossFade(iconImageCrossFade);
        pigeonReturn.setIconOpacity(iconOpacity);
        pigeonReturn.setTextColor(textColor);
        pigeonReturn.setTextEmissiveStrength(textEmissiveStrength);
        pigeonReturn.setTextHaloBlur(textHaloBlur);
        pigeonReturn.setTextHaloColor(textHaloColor);
        pigeonReturn.setTextHaloWidth(textHaloWidth);
        pigeonReturn.setTextOpacity(textOpacity);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(34);
      toListResult.add(geometry);
      toListResult.add(image);
      toListResult.add(iconAnchor == null ? null : iconAnchor.index);
      toListResult.add(iconImage);
      toListResult.add(iconOffset);
      toListResult.add(iconRotate);
      toListResult.add(iconSize);
      toListResult.add(iconTextFit == null ? null : iconTextFit.index);
      toListResult.add(iconTextFitPadding);
      toListResult.add(symbolSortKey);
      toListResult.add(textAnchor == null ? null : textAnchor.index);
      toListResult.add(textField);
      toListResult.add(textJustify == null ? null : textJustify.index);
      toListResult.add(textLetterSpacing);
      toListResult.add(textLineHeight);
      toListResult.add(textMaxWidth);
      toListResult.add(textOffset);
      toListResult.add(textRadialOffset);
      toListResult.add(textRotate);
      toListResult.add(textSize);
      toListResult.add(textTransform == null ? null : textTransform.index);
      toListResult.add(iconColor);
      toListResult.add(iconEmissiveStrength);
      toListResult.add(iconHaloBlur);
      toListResult.add(iconHaloColor);
      toListResult.add(iconHaloWidth);
      toListResult.add(iconImageCrossFade);
      toListResult.add(iconOpacity);
      toListResult.add(textColor);
      toListResult.add(textEmissiveStrength);
      toListResult.add(textHaloBlur);
      toListResult.add(textHaloColor);
      toListResult.add(textHaloWidth);
      toListResult.add(textOpacity);
      return toListResult;
    }

    static @NonNull PointAnnotationOptions fromList(@NonNull ArrayList<Object> list) {
      PointAnnotationOptions pigeonResult = new PointAnnotationOptions();
      Object geometry = list.get(0);
      pigeonResult.setGeometry((Map<String, Object>) geometry);
      Object image = list.get(1);
      pigeonResult.setImage((byte[]) image);
      Object iconAnchor = list.get(2);
      pigeonResult.setIconAnchor(iconAnchor == null ? null : IconAnchor.values()[(int) iconAnchor]);
      Object iconImage = list.get(3);
      pigeonResult.setIconImage((String) iconImage);
      Object iconOffset = list.get(4);
      pigeonResult.setIconOffset((List<Double>) iconOffset);
      Object iconRotate = list.get(5);
      pigeonResult.setIconRotate((Double) iconRotate);
      Object iconSize = list.get(6);
      pigeonResult.setIconSize((Double) iconSize);
      Object iconTextFit = list.get(7);
      pigeonResult.setIconTextFit(iconTextFit == null ? null : IconTextFit.values()[(int) iconTextFit]);
      Object iconTextFitPadding = list.get(8);
      pigeonResult.setIconTextFitPadding((List<Double>) iconTextFitPadding);
      Object symbolSortKey = list.get(9);
      pigeonResult.setSymbolSortKey((Double) symbolSortKey);
      Object textAnchor = list.get(10);
      pigeonResult.setTextAnchor(textAnchor == null ? null : TextAnchor.values()[(int) textAnchor]);
      Object textField = list.get(11);
      pigeonResult.setTextField((String) textField);
      Object textJustify = list.get(12);
      pigeonResult.setTextJustify(textJustify == null ? null : TextJustify.values()[(int) textJustify]);
      Object textLetterSpacing = list.get(13);
      pigeonResult.setTextLetterSpacing((Double) textLetterSpacing);
      Object textLineHeight = list.get(14);
      pigeonResult.setTextLineHeight((Double) textLineHeight);
      Object textMaxWidth = list.get(15);
      pigeonResult.setTextMaxWidth((Double) textMaxWidth);
      Object textOffset = list.get(16);
      pigeonResult.setTextOffset((List<Double>) textOffset);
      Object textRadialOffset = list.get(17);
      pigeonResult.setTextRadialOffset((Double) textRadialOffset);
      Object textRotate = list.get(18);
      pigeonResult.setTextRotate((Double) textRotate);
      Object textSize = list.get(19);
      pigeonResult.setTextSize((Double) textSize);
      Object textTransform = list.get(20);
      pigeonResult.setTextTransform(textTransform == null ? null : TextTransform.values()[(int) textTransform]);
      Object iconColor = list.get(21);
      pigeonResult.setIconColor((iconColor == null) ? null : ((iconColor instanceof Integer) ? (Integer) iconColor : (Long) iconColor));
      Object iconEmissiveStrength = list.get(22);
      pigeonResult.setIconEmissiveStrength((Double) iconEmissiveStrength);
      Object iconHaloBlur = list.get(23);
      pigeonResult.setIconHaloBlur((Double) iconHaloBlur);
      Object iconHaloColor = list.get(24);
      pigeonResult.setIconHaloColor((iconHaloColor == null) ? null : ((iconHaloColor instanceof Integer) ? (Integer) iconHaloColor : (Long) iconHaloColor));
      Object iconHaloWidth = list.get(25);
      pigeonResult.setIconHaloWidth((Double) iconHaloWidth);
      Object iconImageCrossFade = list.get(26);
      pigeonResult.setIconImageCrossFade((Double) iconImageCrossFade);
      Object iconOpacity = list.get(27);
      pigeonResult.setIconOpacity((Double) iconOpacity);
      Object textColor = list.get(28);
      pigeonResult.setTextColor((textColor == null) ? null : ((textColor instanceof Integer) ? (Integer) textColor : (Long) textColor));
      Object textEmissiveStrength = list.get(29);
      pigeonResult.setTextEmissiveStrength((Double) textEmissiveStrength);
      Object textHaloBlur = list.get(30);
      pigeonResult.setTextHaloBlur((Double) textHaloBlur);
      Object textHaloColor = list.get(31);
      pigeonResult.setTextHaloColor((textHaloColor == null) ? null : ((textHaloColor instanceof Integer) ? (Integer) textHaloColor : (Long) textHaloColor));
      Object textHaloWidth = list.get(32);
      pigeonResult.setTextHaloWidth((Double) textHaloWidth);
      Object textOpacity = list.get(33);
      pigeonResult.setTextOpacity((Double) textOpacity);
      return pigeonResult;
    }
  }

  /** Asynchronous error handling return type for non-nullable API method returns. */
  public interface Result<T> {
    /** Success case callback method for handling returns. */
    void success(@NonNull T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for nullable API method returns. */
  public interface NullableResult<T> {
    /** Success case callback method for handling returns. */
    void success(@Nullable T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for void API method returns. */
  public interface VoidResult {
    /** Success case callback method for handling returns. */
    void success();

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }

  private static class OnPointAnnotationClickListenerCodec extends StandardMessageCodec {
    public static final OnPointAnnotationClickListenerCodec INSTANCE = new OnPointAnnotationClickListenerCodec();

    private OnPointAnnotationClickListenerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PointAnnotation.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PointAnnotation) {
        stream.write(128);
        writeValue(stream, ((PointAnnotation) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated class from Pigeon that represents Flutter messages that can be called from Java. */
  public static class OnPointAnnotationClickListener {
    private final @NonNull BinaryMessenger binaryMessenger;

    public OnPointAnnotationClickListener(@NonNull BinaryMessenger argBinaryMessenger) {
      this.binaryMessenger = argBinaryMessenger;
    }

    /** Public interface for sending reply. */ 
    /** The codec used by OnPointAnnotationClickListener. */
    static @NonNull MessageCodec<Object> getCodec() {
      return OnPointAnnotationClickListenerCodec.INSTANCE;
    }
    public void onPointAnnotationClick(@NonNull PointAnnotation annotationArg, @NonNull VoidResult result) {
      final String channelName = "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick";
      BasicMessageChannel<Object> channel =
          new BasicMessageChannel<>(
              binaryMessenger, channelName, getCodec());
      channel.send(
          new ArrayList<Object>(Collections.singletonList(annotationArg)),
          channelReply -> {
            if (channelReply instanceof List) {
              List<Object> listReply = (List<Object>) channelReply;
              if (listReply.size() > 1) {
                result.error(new FlutterError((String) listReply.get(0), (String) listReply.get(1), (String) listReply.get(2)));
              } else {
                result.success();
              }
            }  else {
              result.error(createConnectionError(channelName));
            } 
          });
    }
  }

  private static class _PointAnnotationMessagerCodec extends StandardMessageCodec {
    public static final _PointAnnotationMessagerCodec INSTANCE = new _PointAnnotationMessagerCodec();

    private _PointAnnotationMessagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return PointAnnotation.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return PointAnnotation.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return PointAnnotationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return PointAnnotationOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof PointAnnotation) {
        stream.write(128);
        writeValue(stream, ((PointAnnotation) value).toList());
      } else if (value instanceof PointAnnotation) {
        stream.write(129);
        writeValue(stream, ((PointAnnotation) value).toList());
      } else if (value instanceof PointAnnotationOptions) {
        stream.write(130);
        writeValue(stream, ((PointAnnotationOptions) value).toList());
      } else if (value instanceof PointAnnotationOptions) {
        stream.write(131);
        writeValue(stream, ((PointAnnotationOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface _PointAnnotationMessager {

    void create(@NonNull String managerId, @NonNull PointAnnotationOptions annotationOption, @NonNull Result<PointAnnotation> result);

    void createMulti(@NonNull String managerId, @NonNull List<PointAnnotationOptions> annotationOptions, @NonNull Result<List<PointAnnotation>> result);

    void update(@NonNull String managerId, @NonNull PointAnnotation annotation, @NonNull VoidResult result);

    void delete(@NonNull String managerId, @NonNull PointAnnotation annotation, @NonNull VoidResult result);

    void deleteAll(@NonNull String managerId, @NonNull VoidResult result);

    void setIconAllowOverlap(@NonNull String managerId, @NonNull Boolean iconAllowOverlap, @NonNull VoidResult result);

    void getIconAllowOverlap(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setIconIgnorePlacement(@NonNull String managerId, @NonNull Boolean iconIgnorePlacement, @NonNull VoidResult result);

    void getIconIgnorePlacement(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setIconKeepUpright(@NonNull String managerId, @NonNull Boolean iconKeepUpright, @NonNull VoidResult result);

    void getIconKeepUpright(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setIconOptional(@NonNull String managerId, @NonNull Boolean iconOptional, @NonNull VoidResult result);

    void getIconOptional(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setIconPadding(@NonNull String managerId, @NonNull Double iconPadding, @NonNull VoidResult result);

    void getIconPadding(@NonNull String managerId, @NonNull NullableResult<Double> result);

    void setIconPitchAlignment(@NonNull String managerId, @NonNull IconPitchAlignment iconPitchAlignment, @NonNull VoidResult result);

    void getIconPitchAlignment(@NonNull String managerId, @NonNull NullableResult<IconPitchAlignment> result);

    void setIconRotationAlignment(@NonNull String managerId, @NonNull IconRotationAlignment iconRotationAlignment, @NonNull VoidResult result);

    void getIconRotationAlignment(@NonNull String managerId, @NonNull NullableResult<IconRotationAlignment> result);

    void setSymbolAvoidEdges(@NonNull String managerId, @NonNull Boolean symbolAvoidEdges, @NonNull VoidResult result);

    void getSymbolAvoidEdges(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setSymbolPlacement(@NonNull String managerId, @NonNull SymbolPlacement symbolPlacement, @NonNull VoidResult result);

    void getSymbolPlacement(@NonNull String managerId, @NonNull NullableResult<SymbolPlacement> result);

    void setSymbolSpacing(@NonNull String managerId, @NonNull Double symbolSpacing, @NonNull VoidResult result);

    void getSymbolSpacing(@NonNull String managerId, @NonNull NullableResult<Double> result);

    void setSymbolZElevate(@NonNull String managerId, @NonNull Boolean symbolZElevate, @NonNull VoidResult result);

    void getSymbolZElevate(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setSymbolZOrder(@NonNull String managerId, @NonNull SymbolZOrder symbolZOrder, @NonNull VoidResult result);

    void getSymbolZOrder(@NonNull String managerId, @NonNull NullableResult<SymbolZOrder> result);

    void setTextAllowOverlap(@NonNull String managerId, @NonNull Boolean textAllowOverlap, @NonNull VoidResult result);

    void getTextAllowOverlap(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setTextFont(@NonNull String managerId, @NonNull List<String> textFont, @NonNull VoidResult result);

    void getTextFont(@NonNull String managerId, @NonNull NullableResult<List<String>> result);

    void setTextIgnorePlacement(@NonNull String managerId, @NonNull Boolean textIgnorePlacement, @NonNull VoidResult result);

    void getTextIgnorePlacement(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setTextKeepUpright(@NonNull String managerId, @NonNull Boolean textKeepUpright, @NonNull VoidResult result);

    void getTextKeepUpright(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setTextMaxAngle(@NonNull String managerId, @NonNull Double textMaxAngle, @NonNull VoidResult result);

    void getTextMaxAngle(@NonNull String managerId, @NonNull NullableResult<Double> result);

    void setTextOptional(@NonNull String managerId, @NonNull Boolean textOptional, @NonNull VoidResult result);

    void getTextOptional(@NonNull String managerId, @NonNull NullableResult<Boolean> result);

    void setTextPadding(@NonNull String managerId, @NonNull Double textPadding, @NonNull VoidResult result);

    void getTextPadding(@NonNull String managerId, @NonNull NullableResult<Double> result);

    void setTextPitchAlignment(@NonNull String managerId, @NonNull TextPitchAlignment textPitchAlignment, @NonNull VoidResult result);

    void getTextPitchAlignment(@NonNull String managerId, @NonNull NullableResult<TextPitchAlignment> result);

    void setTextRotationAlignment(@NonNull String managerId, @NonNull TextRotationAlignment textRotationAlignment, @NonNull VoidResult result);

    void getTextRotationAlignment(@NonNull String managerId, @NonNull NullableResult<TextRotationAlignment> result);

    void setIconTranslate(@NonNull String managerId, @NonNull List<Double> iconTranslate, @NonNull VoidResult result);

    void getIconTranslate(@NonNull String managerId, @NonNull NullableResult<List<Double>> result);

    void setIconTranslateAnchor(@NonNull String managerId, @NonNull IconTranslateAnchor iconTranslateAnchor, @NonNull VoidResult result);

    void getIconTranslateAnchor(@NonNull String managerId, @NonNull NullableResult<IconTranslateAnchor> result);

    void setTextTranslate(@NonNull String managerId, @NonNull List<Double> textTranslate, @NonNull VoidResult result);

    void getTextTranslate(@NonNull String managerId, @NonNull NullableResult<List<Double>> result);

    void setTextTranslateAnchor(@NonNull String managerId, @NonNull TextTranslateAnchor textTranslateAnchor, @NonNull VoidResult result);

    void getTextTranslateAnchor(@NonNull String managerId, @NonNull NullableResult<TextTranslateAnchor> result);

    /** The codec used by _PointAnnotationMessager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _PointAnnotationMessagerCodec.INSTANCE;
    }
    /**Sets up an instance of `_PointAnnotationMessager` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _PointAnnotationMessager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.create", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                PointAnnotationOptions annotationOptionArg = (PointAnnotationOptions) args.get(1);
                Result<PointAnnotation> resultCallback =
                    new Result<PointAnnotation>() {
                      public void success(PointAnnotation result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.create(managerIdArg, annotationOptionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.createMulti", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<PointAnnotationOptions> annotationOptionsArg = (List<PointAnnotationOptions>) args.get(1);
                Result<List<PointAnnotation>> resultCallback =
                    new Result<List<PointAnnotation>>() {
                      public void success(List<PointAnnotation> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.createMulti(managerIdArg, annotationOptionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.update", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                PointAnnotation annotationArg = (PointAnnotation) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.update(managerIdArg, annotationArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.delete", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                PointAnnotation annotationArg = (PointAnnotation) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.delete(managerIdArg, annotationArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.deleteAll", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.deleteAll(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconAllowOverlapArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconAllowOverlap(managerIdArg, iconAllowOverlapArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconAllowOverlap(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconIgnorePlacementArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconIgnorePlacement(managerIdArg, iconIgnorePlacementArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconIgnorePlacement(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconKeepUprightArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconKeepUpright(managerIdArg, iconKeepUprightArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconKeepUpright(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean iconOptionalArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconOptional(managerIdArg, iconOptionalArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconOptional(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double iconPaddingArg = (Double) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconPadding(managerIdArg, iconPaddingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Double> resultCallback =
                    new NullableResult<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconPadding(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconPitchAlignment iconPitchAlignmentArg = IconPitchAlignment.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconPitchAlignment(managerIdArg, iconPitchAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<IconPitchAlignment> resultCallback =
                    new NullableResult<IconPitchAlignment>() {
                      public void success(IconPitchAlignment result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconPitchAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconRotationAlignment iconRotationAlignmentArg = IconRotationAlignment.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconRotationAlignment(managerIdArg, iconRotationAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<IconRotationAlignment> resultCallback =
                    new NullableResult<IconRotationAlignment>() {
                      public void success(IconRotationAlignment result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconRotationAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolAvoidEdges", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean symbolAvoidEdgesArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolAvoidEdges(managerIdArg, symbolAvoidEdgesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolAvoidEdges", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolAvoidEdges(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolPlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                SymbolPlacement symbolPlacementArg = SymbolPlacement.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolPlacement(managerIdArg, symbolPlacementArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolPlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<SymbolPlacement> resultCallback =
                    new NullableResult<SymbolPlacement>() {
                      public void success(SymbolPlacement result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolPlacement(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolSpacing", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double symbolSpacingArg = (Double) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolSpacing(managerIdArg, symbolSpacingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolSpacing", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Double> resultCallback =
                    new NullableResult<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolSpacing(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolZElevate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean symbolZElevateArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolZElevate(managerIdArg, symbolZElevateArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolZElevate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolZElevate(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setSymbolZOrder", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                SymbolZOrder symbolZOrderArg = SymbolZOrder.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setSymbolZOrder(managerIdArg, symbolZOrderArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getSymbolZOrder", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<SymbolZOrder> resultCallback =
                    new NullableResult<SymbolZOrder>() {
                      public void success(SymbolZOrder result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getSymbolZOrder(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textAllowOverlapArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextAllowOverlap(managerIdArg, textAllowOverlapArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextAllowOverlap", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextAllowOverlap(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextFont", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<String> textFontArg = (List<String>) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextFont(managerIdArg, textFontArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextFont", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<List<String>> resultCallback =
                    new NullableResult<List<String>>() {
                      public void success(List<String> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextFont(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textIgnorePlacementArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextIgnorePlacement(managerIdArg, textIgnorePlacementArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextIgnorePlacement", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextIgnorePlacement(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textKeepUprightArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextKeepUpright(managerIdArg, textKeepUprightArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextKeepUpright", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextKeepUpright(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextMaxAngle", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double textMaxAngleArg = (Double) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextMaxAngle(managerIdArg, textMaxAngleArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextMaxAngle", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Double> resultCallback =
                    new NullableResult<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextMaxAngle(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Boolean textOptionalArg = (Boolean) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextOptional(managerIdArg, textOptionalArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextOptional", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Boolean> resultCallback =
                    new NullableResult<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextOptional(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                Double textPaddingArg = (Double) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextPadding(managerIdArg, textPaddingArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<Double> resultCallback =
                    new NullableResult<Double>() {
                      public void success(Double result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextPadding(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                TextPitchAlignment textPitchAlignmentArg = TextPitchAlignment.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextPitchAlignment(managerIdArg, textPitchAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextPitchAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<TextPitchAlignment> resultCallback =
                    new NullableResult<TextPitchAlignment>() {
                      public void success(TextPitchAlignment result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextPitchAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                TextRotationAlignment textRotationAlignmentArg = TextRotationAlignment.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextRotationAlignment(managerIdArg, textRotationAlignmentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextRotationAlignment", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<TextRotationAlignment> resultCallback =
                    new NullableResult<TextRotationAlignment>() {
                      public void success(TextRotationAlignment result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextRotationAlignment(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<Double> iconTranslateArg = (List<Double>) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconTranslate(managerIdArg, iconTranslateArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<List<Double>> resultCallback =
                    new NullableResult<List<Double>>() {
                      public void success(List<Double> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconTranslate(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setIconTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                IconTranslateAnchor iconTranslateAnchorArg = IconTranslateAnchor.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setIconTranslateAnchor(managerIdArg, iconTranslateAnchorArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getIconTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<IconTranslateAnchor> resultCallback =
                    new NullableResult<IconTranslateAnchor>() {
                      public void success(IconTranslateAnchor result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getIconTranslateAnchor(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                List<Double> textTranslateArg = (List<Double>) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextTranslate(managerIdArg, textTranslateArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextTranslate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<List<Double>> resultCallback =
                    new NullableResult<List<Double>>() {
                      public void success(List<Double> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextTranslate(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.setTextTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                TextTranslateAnchor textTranslateAnchorArg = TextTranslateAnchor.values()[(int) args.get(1)];
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setTextTranslateAnchor(managerIdArg, textTranslateAnchorArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessager.getTextTranslateAnchor", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String managerIdArg = (String) args.get(0);
                NullableResult<TextTranslateAnchor> resultCallback =
                    new NullableResult<TextTranslateAnchor>() {
                      public void success(TextTranslateAnchor result) {
                        wrapped.add(0, result == null ? null : result.index);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getTextTranslateAnchor(managerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
}
