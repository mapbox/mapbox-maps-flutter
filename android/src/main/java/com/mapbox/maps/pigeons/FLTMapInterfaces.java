// Autogenerated from Pigeon (v16.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.pigeons;

import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.RetentionPolicy.CLASS;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class FLTMapInterfaces {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) 
    {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
        "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  @Target(METHOD)
  @Retention(CLASS)
  @interface CanIgnoreReturnValue {}

  /** Describes glyphs rasterization modes. */
  public enum GlyphsRasterizationMode {
    /** No glyphs are rasterized locally. All glyphs are loaded from the server. */
    NO_GLYPHS_RASTERIZED_LOCALLY(0),
    /** Ideographs are rasterized locally, and they are not loaded from the server. */
    IDEOGRAPHS_RASTERIZED_LOCALLY(1),
    /** All glyphs are rasterized locally. No glyphs are loaded from the server. */
    ALL_GLYPHS_RASTERIZED_LOCALLY(2);

    final int index;

    private GlyphsRasterizationMode(final int index) {
      this.index = index;
    }
  }

  /**
   * Describes the map context mode.
   * We can make some optimizations if we know that the drawing context is not shared with other code.
   */
  public enum ContextMode {
    /**
     * Unique context mode: in OpenGL, the GL context is not shared, thus we can retain knowledge about the GL state
     * from a previous render pass. It also enables clearing the screen using glClear for the bottommost background
     * layer when no pattern is applied to that layer.
     */
    UNIQUE(0),
    /**
     * Shared context mode: in OpenGL, the GL context is shared with other renderers, thus we cannot rely on the GL
     * state set from a previous render pass.
     */
    SHARED(1);

    final int index;

    private ContextMode(final int index) {
      this.index = index;
    }
  }

  /** Describes whether to constrain the map in both axes or only vertically e.g. while panning. */
  public enum ConstrainMode {
    /** No constrains. */
    NONE(0),
    /** Constrain to height only */
    HEIGHT_ONLY(1),
    /** Constrain both width and height axes. */
    WIDTH_AND_HEIGHT(2);

    final int index;

    private ConstrainMode(final int index) {
      this.index = index;
    }
  }

  /** Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards. */
  public enum ViewportMode {
    /** Default viewport */
    DEFAULT(0),
    /** Viewport flipped on the y-axis. */
    FLIPPED_Y(1);

    final int index;

    private ViewportMode(final int index) {
      this.index = index;
    }
  }

  /** Describes the map orientation. */
  public enum NorthOrientation {
    /** Default, map oriented upwards */
    UPWARDS(0),
    /** Map oriented righwards */
    RIGHTWARDS(1),
    /** Map oriented downwards */
    DOWNWARDS(2),
    /** Map oriented leftwards */
    LEFTWARDS(3);

    final int index;

    private NorthOrientation(final int index) {
      this.index = index;
    }
  }

  /** Options for enabling debugging features in a map. */
  public enum MapDebugOptionsData {
    /**
     * Edges of tile boundaries are shown as thick, red lines to help diagnose
     * tile clipping issues.
     */
    TILE_BORDERS(0),
    /** Each tile shows its tile coordinate (x/y/z) in the upper-left corner. */
    PARSE_STATUS(1),
    /** Each tile shows a timestamp indicating when it was loaded. */
    TIMESTAMPS(2),
    /**
     * Edges of glyphs and symbols are shown as faint, green lines to help
     * diagnose collision and label placement issues.
     */
    COLLISION(3),
    /**
     * Each drawing operation is replaced by a translucent fill. Overlapping
     * drawing operations appear more prominent to help diagnose overdrawing.
     */
    OVERDRAW(4),
    /** The stencil buffer is shown instead of the color buffer. */
    STENCIL_CLIP(5),
    /** The depth buffer is shown instead of the color buffer. */
    DEPTH_BUFFER(6),
    /**
     * Visualize residency of tiles in the render cache. Tile boundaries of cached tiles
     * are rendered with green, tiles waiting for an update with yellow and tiles not in the cache
     * with red.
     */
    RENDER_CACHE(7),
    /** Show 3D model bounding boxes. */
    MODEL_BOUNDS(8),
    /** Show a wireframe for terrain. */
    TERRAIN_WIREFRAME(9);

    final int index;

    private MapDebugOptionsData(final int index) {
      this.index = index;
    }
  }

  /** Enum describing how to place view annotation relatively to geometry. */
  public enum ViewAnnotationAnchor {
    /** The top of the view annotation is placed closest to the geometry. */
    TOP(0),
    /** The left side of the view annotation is placed closest to the geometry. */
    LEFT(1),
    /** The bottom of the view annotation is placed closest to the geometry. */
    BOTTOM(2),
    /** The right side of the view annotation is placed closest to the geometry. */
    RIGHT(3),
    /** The top-left corner of the view annotation is placed closest to the geometry. */
    TOP_LEFT(4),
    /** The bottom-right corner of the view annotation is placed closest to the geometry. */
    BOTTOM_RIGHT(5),
    /** The top-right corner of the view annotation is placed closest to the geometry. */
    TOP_RIGHT(6),
    /** The bottom-left corner of the view annotation is placed closest to the geometry. */
    BOTTOM_LEFT(7),
    /** The center of the view annotation is placed closest to the geometry. */
    CENTER(8);

    final int index;

    private ViewAnnotationAnchor(final int index) {
      this.index = index;
    }
  }

  /** Type information of the variant's content */
  public enum Type {
    SCREEN_BOX(0),
    SCREEN_COORDINATE(1),
    LIST(2);

    final int index;

    private Type(final int index) {
      this.index = index;
    }
  }

  /** Describes the reason for a style package download request failure. */
  public enum StylePackErrorType {
    /** The operation was canceled. */
    CANCELED(0),
    /** The style package does not exist. */
    DOES_NOT_EXIST(1),
    /** There is no available space to store the resources. */
    DISK_FULL(2),
    /** Other reason. */
    OTHER(3);

    final int index;

    private StylePackErrorType(final int index) {
      this.index = index;
    }
  }

  /** Describes the reason for an offline request response error. */
  public enum ResponseErrorReason {
    /** No error occurred during the resource request. */
    SUCCESS(0),
    /** The resource is not found. */
    NOT_FOUND(1),
    /** The server error. */
    SERVER(2),
    /** The connection error. */
    CONNECTION(3),
    /** The error happened because of a rate limit. */
    RATE_LIMIT(4),
    /** The resource cannot be loaded because the device is in offline mode. */
    IN_OFFLINE_MODE(5),
    /** Other reason. */
    OTHER(6);

    final int index;

    private ResponseErrorReason(final int index) {
      this.index = index;
    }
  }

  /** Describes the download state of a region. */
  public enum OfflineRegionDownloadState {
    /** Indicates downloading is inactive. */
    INACTIVE(0),
    /** Indicates downloading is active. */
    ACTIVE(1);

    final int index;

    private OfflineRegionDownloadState(final int index) {
      this.index = index;
    }
  }

  /** Describes tile store usage modes. */
  public enum TileStoreUsageMode {
    /**
     * Tile store usage is disabled.
     *
     * The implementation skips checking tile store when requesting a tile.
     */
    DISABLED(0),
    /**
     * Tile store enabled for accessing loaded tile packs.
     *
     * The implementation first checks tile store when requesting a tile.
     * If a tile pack is already loaded, the tile will be extracted and returned. Otherwise, the implementation
     * falls back to requesting the individual tile and storing it in the disk cache.
     */
    READ_ONLY(1),
    /**
     * Tile store enabled for accessing local tile packs and for loading new tile packs from server.
     *
     * All tile requests are converted to tile pack requests, i.e.
     * the tile pack that includes the request tile will be loaded, and the tile extracted
     * from it. In this mode, no individual tile requests will be made.
     *
     * This mode can be useful if the map trajectory is predefined and the user cannot pan
     * freely (e.g. navigation use cases), so that there is a good chance tile packs are already loaded
     * in the vicinity of the user.
     *
     * If users can pan freely, this mode is not recommended. Otherwise, panning
     * will download tile packs instead of using individual tiles. Note that this means that we could first
     * download an individual tile, and then a tile pack that also includes this tile. The individual tile in
     * the disk cache wonâ€™t be used as long as the up-to-date tile pack exists in the cache.
     */
    READ_AND_UPDATE(2);

    final int index;

    private TileStoreUsageMode(final int index) {
      this.index = index;
    }
  }

  /** Describes the kind of a style property value. */
  public enum StylePropertyValueKind {
    /** The property value is not defined. */
    UNDEFINED(0),
    /** The property value is a constant. */
    CONSTANT(1),
    /** The property value is a style [expression](https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions). */
    EXPRESSION(2),
    /** Property value is a style [transition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#transition). */
    TRANSITION(3);

    final int index;

    private StylePropertyValueKind(final int index) {
      this.index = index;
    }
  }

  public enum StyleProjectionName {
    MERCATOR(0),
    GLOBE(1);

    final int index;

    private StyleProjectionName(final int index) {
      this.index = index;
    }
  }

  /** Whether extruded geometries are lit relative to the map or viewport. */
  public enum Anchor {
    /** The position of the light source is aligned to the rotation of the map. */
    MAP(0),
    /** The position of the light source is aligned to the rotation of the viewport. */
    VIEWPORT(1);

    final int index;

    private Anchor(final int index) {
      this.index = index;
    }
  }

  /** HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. */
  public enum HttpMethod {
    /** The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. */
    GET(0),
    /** The HEAD method asks for a response identical to that of a GET request, but without the response body. */
    HEAD(1),
    /** The POST method sends data (stored in the request body) to a server to create or update a given resource. */
    POST(2);

    final int index;

    private HttpMethod(final int index) {
      this.index = index;
    }
  }

  /** Classify network types based on cost. */
  public enum NetworkRestriction {
    /** Allow access to all network types. */
    NONE(0),
    /** Forbid network access to expensive networks, such as cellular. */
    DISALLOW_EXPENSIVE(1),
    /** Forbid access to all network types. */
    DISALLOW_ALL(2);

    final int index;

    private NetworkRestriction(final int index) {
      this.index = index;
    }
  }

  /** Enum which describes possible error types which could happen during HTTP request/download calls. */
  public enum HttpRequestErrorType {
    /** Establishing connection related error. */
    CONNECTION_ERROR(0),
    /** SSL related error. */
    SSLERROR(1),
    /** Request was cancelled by the user. */
    REQUEST_CANCELLED(2),
    /** Timeout error. */
    REQUEST_TIMED_OUT(3),
    /** Range request failed. */
    RANGE_ERROR(4),
    /** Other than above error. */
    OTHER_ERROR(5);

    final int index;

    private HttpRequestErrorType(final int index) {
      this.index = index;
    }
  }

  /** Enum which represents different error cases which could happen during download session. */
  public enum DownloadErrorCode {
    /** General filesystem related error code. For cases like: write error, no such file or directory, not enough space and etc. */
    FILE_SYSTEM_ERROR(0),
    /** General network related error. Should be probably representation of HttpRequestError. */
    NETWORK_ERROR(1);

    final int index;

    private DownloadErrorCode(final int index) {
      this.index = index;
    }
  }

  /** Enum representing state of download session. */
  public enum DownloadState {
    /** Download session initiated but not started yet. */
    PENDING(0),
    /** Download session is in progress. */
    DOWNLOADING(1),
    /** Download session failed. */
    FAILED(2),
    /** Download session successfully finished. */
    FINISHED(3);

    final int index;

    private DownloadState(final int index) {
      this.index = index;
    }
  }

  /** Describes the tiles data domain. */
  public enum TileDataDomain {
    /** Data for Maps. */
    MAPS(0),
    /** Data for Navigation. */
    NAVIGATION(1),
    /** Data for Search. */
    SEARCH(2),
    /** Data for ADAS */
    ADAS(3);

    final int index;

    private TileDataDomain(final int index) {
      this.index = index;
    }
  }

  /** Describes the reason for a tile region download request failure. */
  public enum TileRegionErrorType {
    /** The operation was canceled. */
    CANCELED(0),
    /** tile region does not exist. */
    DOES_NOT_EXIST(1),
    /** Tileset descriptors resolving failed. */
    TILESET_DESCRIPTOR(2),
    /** There is no available space to store the resources */
    DISK_FULL(3),
    /** Other reason. */
    OTHER(4),
    /** The region contains more tiles than allowed. */
    TILE_COUNT_EXCEEDED(5);

    final int index;

    private TileRegionErrorType(final int index) {
      this.index = index;
    }
  }

  public enum _MapEvent {
    MAP_LOADED(0),
    MAP_LOADING_ERROR(1),
    STYLE_LOADED(2),
    STYLE_DATA_LOADED(3),
    CAMERA_CHANGED(4),
    MAP_IDLE(5),
    SOURCE_ADDED(6),
    SOURCE_REMOVED(7),
    SOURCE_DATA_LOADED(8),
    STYLE_IMAGE_MISSING(9),
    STYLE_IMAGE_REMOVE_UNUSED(10),
    RENDER_FRAME_STARTED(11),
    RENDER_FRAME_FINISHED(12),
    RESOURCE_REQUEST(13);

    final int index;

    private _MapEvent(final int index) {
      this.index = index;
    }
  }

  /**
   * The distance on each side between rectangles, when one is contained into other.
   *
   * All fields' values are in `logical pixel` units.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MbxEdgeInsets {
    /** Padding from the top. */
    private @NonNull Double top;

    public @NonNull Double getTop() {
      return top;
    }

    public void setTop(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"top\" is null.");
      }
      this.top = setterArg;
    }

    /** Padding from the left. */
    private @NonNull Double left;

    public @NonNull Double getLeft() {
      return left;
    }

    public void setLeft(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"left\" is null.");
      }
      this.left = setterArg;
    }

    /** Padding from the bottom. */
    private @NonNull Double bottom;

    public @NonNull Double getBottom() {
      return bottom;
    }

    public void setBottom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bottom\" is null.");
      }
      this.bottom = setterArg;
    }

    /** Padding from the right. */
    private @NonNull Double right;

    public @NonNull Double getRight() {
      return right;
    }

    public void setRight(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"right\" is null.");
      }
      this.right = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MbxEdgeInsets() {}

    public static final class Builder {

      private @Nullable Double top;

      @CanIgnoreReturnValue
      public @NonNull Builder setTop(@NonNull Double setterArg) {
        this.top = setterArg;
        return this;
      }

      private @Nullable Double left;

      @CanIgnoreReturnValue
      public @NonNull Builder setLeft(@NonNull Double setterArg) {
        this.left = setterArg;
        return this;
      }

      private @Nullable Double bottom;

      @CanIgnoreReturnValue
      public @NonNull Builder setBottom(@NonNull Double setterArg) {
        this.bottom = setterArg;
        return this;
      }

      private @Nullable Double right;

      @CanIgnoreReturnValue
      public @NonNull Builder setRight(@NonNull Double setterArg) {
        this.right = setterArg;
        return this;
      }

      public @NonNull MbxEdgeInsets build() {
        MbxEdgeInsets pigeonReturn = new MbxEdgeInsets();
        pigeonReturn.setTop(top);
        pigeonReturn.setLeft(left);
        pigeonReturn.setBottom(bottom);
        pigeonReturn.setRight(right);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(top);
      toListResult.add(left);
      toListResult.add(bottom);
      toListResult.add(right);
      return toListResult;
    }

    static @NonNull MbxEdgeInsets fromList(@NonNull ArrayList<Object> list) {
      MbxEdgeInsets pigeonResult = new MbxEdgeInsets();
      Object top = list.get(0);
      pigeonResult.setTop((Double) top);
      Object left = list.get(1);
      pigeonResult.setLeft((Double) left);
      Object bottom = list.get(2);
      pigeonResult.setBottom((Double) bottom);
      Object right = list.get(3);
      pigeonResult.setRight((Double) right);
      return pigeonResult;
    }
  }

  /**
   * Various options for describing the viewpoint of a camera. All fields are
   * optional.
   *
   * Anchor and center points are mutually exclusive, with preference for the
   * center point when both are set.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraOptions {
    /** Coordinate at the center of the camera. */
    private @Nullable Map<String, Object> center;

    public @Nullable Map<String, Object> getCenter() {
      return center;
    }

    public void setCenter(@Nullable Map<String, Object> setterArg) {
      this.center = setterArg;
    }

    /**
     * Padding around the interior of the view that affects the frame of
     * reference for `center`.
     */
    private @Nullable MbxEdgeInsets padding;

    public @Nullable MbxEdgeInsets getPadding() {
      return padding;
    }

    public void setPadding(@Nullable MbxEdgeInsets setterArg) {
      this.padding = setterArg;
    }

    /**
     * Point of reference for `zoom` and `angle`, assuming an origin at the
     * top-left corner of the view.
     */
    private @Nullable ScreenCoordinate anchor;

    public @Nullable ScreenCoordinate getAnchor() {
      return anchor;
    }

    public void setAnchor(@Nullable ScreenCoordinate setterArg) {
      this.anchor = setterArg;
    }

    /**
     * Zero-based zoom level. Constrained to the minimum and maximum zoom
     * levels.
     */
    private @Nullable Double zoom;

    public @Nullable Double getZoom() {
      return zoom;
    }

    public void setZoom(@Nullable Double setterArg) {
      this.zoom = setterArg;
    }

    /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
    private @Nullable Double bearing;

    public @Nullable Double getBearing() {
      return bearing;
    }

    public void setBearing(@Nullable Double setterArg) {
      this.bearing = setterArg;
    }

    /** Pitch toward the horizon measured in degrees. */
    private @Nullable Double pitch;

    public @Nullable Double getPitch() {
      return pitch;
    }

    public void setPitch(@Nullable Double setterArg) {
      this.pitch = setterArg;
    }

    public static final class Builder {

      private @Nullable Map<String, Object> center;

      @CanIgnoreReturnValue
      public @NonNull Builder setCenter(@Nullable Map<String, Object> setterArg) {
        this.center = setterArg;
        return this;
      }

      private @Nullable MbxEdgeInsets padding;

      @CanIgnoreReturnValue
      public @NonNull Builder setPadding(@Nullable MbxEdgeInsets setterArg) {
        this.padding = setterArg;
        return this;
      }

      private @Nullable ScreenCoordinate anchor;

      @CanIgnoreReturnValue
      public @NonNull Builder setAnchor(@Nullable ScreenCoordinate setterArg) {
        this.anchor = setterArg;
        return this;
      }

      private @Nullable Double zoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setZoom(@Nullable Double setterArg) {
        this.zoom = setterArg;
        return this;
      }

      private @Nullable Double bearing;

      @CanIgnoreReturnValue
      public @NonNull Builder setBearing(@Nullable Double setterArg) {
        this.bearing = setterArg;
        return this;
      }

      private @Nullable Double pitch;

      @CanIgnoreReturnValue
      public @NonNull Builder setPitch(@Nullable Double setterArg) {
        this.pitch = setterArg;
        return this;
      }

      public @NonNull CameraOptions build() {
        CameraOptions pigeonReturn = new CameraOptions();
        pigeonReturn.setCenter(center);
        pigeonReturn.setPadding(padding);
        pigeonReturn.setAnchor(anchor);
        pigeonReturn.setZoom(zoom);
        pigeonReturn.setBearing(bearing);
        pigeonReturn.setPitch(pitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(center);
      toListResult.add((padding == null) ? null : padding.toList());
      toListResult.add((anchor == null) ? null : anchor.toList());
      toListResult.add(zoom);
      toListResult.add(bearing);
      toListResult.add(pitch);
      return toListResult;
    }

    static @NonNull CameraOptions fromList(@NonNull ArrayList<Object> list) {
      CameraOptions pigeonResult = new CameraOptions();
      Object center = list.get(0);
      pigeonResult.setCenter((Map<String, Object>) center);
      Object padding = list.get(1);
      pigeonResult.setPadding((padding == null) ? null : MbxEdgeInsets.fromList((ArrayList<Object>) padding));
      Object anchor = list.get(2);
      pigeonResult.setAnchor((anchor == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) anchor));
      Object zoom = list.get(3);
      pigeonResult.setZoom((Double) zoom);
      Object bearing = list.get(4);
      pigeonResult.setBearing((Double) bearing);
      Object pitch = list.get(5);
      pigeonResult.setPitch((Double) pitch);
      return pigeonResult;
    }
  }

  /**
   * Describes the viewpoint of a camera.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraState {
    /** Coordinate at the center of the camera. */
    private @NonNull Map<String, Object> center;

    public @NonNull Map<String, Object> getCenter() {
      return center;
    }

    public void setCenter(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"center\" is null.");
      }
      this.center = setterArg;
    }

    /**
     * Padding around the interior of the view that affects the frame of
     * reference for `center`.
     */
    private @NonNull MbxEdgeInsets padding;

    public @NonNull MbxEdgeInsets getPadding() {
      return padding;
    }

    public void setPadding(@NonNull MbxEdgeInsets setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"padding\" is null.");
      }
      this.padding = setterArg;
    }

    /**
     * Zero-based zoom level. Constrained to the minimum and maximum zoom
     * levels.
     */
    private @NonNull Double zoom;

    public @NonNull Double getZoom() {
      return zoom;
    }

    public void setZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"zoom\" is null.");
      }
      this.zoom = setterArg;
    }

    /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
    private @NonNull Double bearing;

    public @NonNull Double getBearing() {
      return bearing;
    }

    public void setBearing(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bearing\" is null.");
      }
      this.bearing = setterArg;
    }

    /** Pitch toward the horizon measured in degrees. */
    private @NonNull Double pitch;

    public @NonNull Double getPitch() {
      return pitch;
    }

    public void setPitch(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pitch\" is null.");
      }
      this.pitch = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CameraState() {}

    public static final class Builder {

      private @Nullable Map<String, Object> center;

      @CanIgnoreReturnValue
      public @NonNull Builder setCenter(@NonNull Map<String, Object> setterArg) {
        this.center = setterArg;
        return this;
      }

      private @Nullable MbxEdgeInsets padding;

      @CanIgnoreReturnValue
      public @NonNull Builder setPadding(@NonNull MbxEdgeInsets setterArg) {
        this.padding = setterArg;
        return this;
      }

      private @Nullable Double zoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setZoom(@NonNull Double setterArg) {
        this.zoom = setterArg;
        return this;
      }

      private @Nullable Double bearing;

      @CanIgnoreReturnValue
      public @NonNull Builder setBearing(@NonNull Double setterArg) {
        this.bearing = setterArg;
        return this;
      }

      private @Nullable Double pitch;

      @CanIgnoreReturnValue
      public @NonNull Builder setPitch(@NonNull Double setterArg) {
        this.pitch = setterArg;
        return this;
      }

      public @NonNull CameraState build() {
        CameraState pigeonReturn = new CameraState();
        pigeonReturn.setCenter(center);
        pigeonReturn.setPadding(padding);
        pigeonReturn.setZoom(zoom);
        pigeonReturn.setBearing(bearing);
        pigeonReturn.setPitch(pitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(center);
      toListResult.add((padding == null) ? null : padding.toList());
      toListResult.add(zoom);
      toListResult.add(bearing);
      toListResult.add(pitch);
      return toListResult;
    }

    static @NonNull CameraState fromList(@NonNull ArrayList<Object> list) {
      CameraState pigeonResult = new CameraState();
      Object center = list.get(0);
      pigeonResult.setCenter((Map<String, Object>) center);
      Object padding = list.get(1);
      pigeonResult.setPadding((padding == null) ? null : MbxEdgeInsets.fromList((ArrayList<Object>) padding));
      Object zoom = list.get(2);
      pigeonResult.setZoom((Double) zoom);
      Object bearing = list.get(3);
      pigeonResult.setBearing((Double) bearing);
      Object pitch = list.get(4);
      pigeonResult.setPitch((Double) pitch);
      return pigeonResult;
    }
  }

  /**
   * Holds options to be used for setting `camera bounds`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraBoundsOptions {
    /** The latitude and longitude bounds to which the camera center are constrained. */
    private @Nullable CoordinateBounds bounds;

    public @Nullable CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@Nullable CoordinateBounds setterArg) {
      this.bounds = setterArg;
    }

    /** The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area. */
    private @Nullable Double maxZoom;

    public @Nullable Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@Nullable Double setterArg) {
      this.maxZoom = setterArg;
    }

    /** The minimum zoom level, in Mapbox zoom levels 0-25.5. */
    private @Nullable Double minZoom;

    public @Nullable Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@Nullable Double setterArg) {
      this.minZoom = setterArg;
    }

    /** The maximum allowed pitch value in degrees. */
    private @Nullable Double maxPitch;

    public @Nullable Double getMaxPitch() {
      return maxPitch;
    }

    public void setMaxPitch(@Nullable Double setterArg) {
      this.maxPitch = setterArg;
    }

    /** The minimum allowed pitch value in degrees. */
    private @Nullable Double minPitch;

    public @Nullable Double getMinPitch() {
      return minPitch;
    }

    public void setMinPitch(@Nullable Double setterArg) {
      this.minPitch = setterArg;
    }

    public static final class Builder {

      private @Nullable CoordinateBounds bounds;

      @CanIgnoreReturnValue
      public @NonNull Builder setBounds(@Nullable CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMaxZoom(@Nullable Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMinZoom(@Nullable Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxPitch;

      @CanIgnoreReturnValue
      public @NonNull Builder setMaxPitch(@Nullable Double setterArg) {
        this.maxPitch = setterArg;
        return this;
      }

      private @Nullable Double minPitch;

      @CanIgnoreReturnValue
      public @NonNull Builder setMinPitch(@Nullable Double setterArg) {
        this.minPitch = setterArg;
        return this;
      }

      public @NonNull CameraBoundsOptions build() {
        CameraBoundsOptions pigeonReturn = new CameraBoundsOptions();
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxPitch(maxPitch);
        pigeonReturn.setMinPitch(minPitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(maxZoom);
      toListResult.add(minZoom);
      toListResult.add(maxPitch);
      toListResult.add(minPitch);
      return toListResult;
    }

    static @NonNull CameraBoundsOptions fromList(@NonNull ArrayList<Object> list) {
      CameraBoundsOptions pigeonResult = new CameraBoundsOptions();
      Object bounds = list.get(0);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object maxZoom = list.get(1);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxPitch = list.get(3);
      pigeonResult.setMaxPitch((Double) maxPitch);
      Object minPitch = list.get(4);
      pigeonResult.setMinPitch((Double) minPitch);
      return pigeonResult;
    }
  }

  /**
   * Holds information about `camera bounds`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraBounds {
    /** The latitude and longitude bounds to which the camera center are constrained. */
    private @NonNull CoordinateBounds bounds;

    public @NonNull CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@NonNull CoordinateBounds setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bounds\" is null.");
      }
      this.bounds = setterArg;
    }

    /** The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area. */
    private @NonNull Double maxZoom;

    public @NonNull Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxZoom\" is null.");
      }
      this.maxZoom = setterArg;
    }

    /** The minimum zoom level, in Mapbox zoom levels 0-25.5. */
    private @NonNull Double minZoom;

    public @NonNull Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minZoom\" is null.");
      }
      this.minZoom = setterArg;
    }

    /** The maximum allowed pitch value in degrees. */
    private @NonNull Double maxPitch;

    public @NonNull Double getMaxPitch() {
      return maxPitch;
    }

    public void setMaxPitch(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxPitch\" is null.");
      }
      this.maxPitch = setterArg;
    }

    /** The minimum allowed pitch value in degrees. */
    private @NonNull Double minPitch;

    public @NonNull Double getMinPitch() {
      return minPitch;
    }

    public void setMinPitch(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minPitch\" is null.");
      }
      this.minPitch = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CameraBounds() {}

    public static final class Builder {

      private @Nullable CoordinateBounds bounds;

      @CanIgnoreReturnValue
      public @NonNull Builder setBounds(@NonNull CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMaxZoom(@NonNull Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMinZoom(@NonNull Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxPitch;

      @CanIgnoreReturnValue
      public @NonNull Builder setMaxPitch(@NonNull Double setterArg) {
        this.maxPitch = setterArg;
        return this;
      }

      private @Nullable Double minPitch;

      @CanIgnoreReturnValue
      public @NonNull Builder setMinPitch(@NonNull Double setterArg) {
        this.minPitch = setterArg;
        return this;
      }

      public @NonNull CameraBounds build() {
        CameraBounds pigeonReturn = new CameraBounds();
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxPitch(maxPitch);
        pigeonReturn.setMinPitch(minPitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(maxZoom);
      toListResult.add(minZoom);
      toListResult.add(maxPitch);
      toListResult.add(minPitch);
      return toListResult;
    }

    static @NonNull CameraBounds fromList(@NonNull ArrayList<Object> list) {
      CameraBounds pigeonResult = new CameraBounds();
      Object bounds = list.get(0);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object maxZoom = list.get(1);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxPitch = list.get(3);
      pigeonResult.setMaxPitch((Double) maxPitch);
      Object minPitch = list.get(4);
      pigeonResult.setMinPitch((Double) minPitch);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class MapAnimationOptions {
    /**
     * The duration of the animation in milliseconds.
     * If not set explicitly default duration will be taken 300ms
     */
    private @Nullable Long duration;

    public @Nullable Long getDuration() {
      return duration;
    }

    public void setDuration(@Nullable Long setterArg) {
      this.duration = setterArg;
    }

    /**
     * The amount of time, in milliseconds, to delay starting the animation after animation start.
     * If not set explicitly default startDelay will be taken 0ms. This only works for Android.
     */
    private @Nullable Long startDelay;

    public @Nullable Long getStartDelay() {
      return startDelay;
    }

    public void setStartDelay(@Nullable Long setterArg) {
      this.startDelay = setterArg;
    }

    public static final class Builder {

      private @Nullable Long duration;

      @CanIgnoreReturnValue
      public @NonNull Builder setDuration(@Nullable Long setterArg) {
        this.duration = setterArg;
        return this;
      }

      private @Nullable Long startDelay;

      @CanIgnoreReturnValue
      public @NonNull Builder setStartDelay(@Nullable Long setterArg) {
        this.startDelay = setterArg;
        return this;
      }

      public @NonNull MapAnimationOptions build() {
        MapAnimationOptions pigeonReturn = new MapAnimationOptions();
        pigeonReturn.setDuration(duration);
        pigeonReturn.setStartDelay(startDelay);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(duration);
      toListResult.add(startDelay);
      return toListResult;
    }

    static @NonNull MapAnimationOptions fromList(@NonNull ArrayList<Object> list) {
      MapAnimationOptions pigeonResult = new MapAnimationOptions();
      Object duration = list.get(0);
      pigeonResult.setDuration((duration == null) ? null : ((duration instanceof Integer) ? (Integer) duration : (Long) duration));
      Object startDelay = list.get(1);
      pigeonResult.setStartDelay((startDelay == null) ? null : ((startDelay instanceof Integer) ? (Integer) startDelay : (Long) startDelay));
      return pigeonResult;
    }
  }

  /**
   * A rectangular area as measured on a two-dimensional map projection.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CoordinateBounds {
    /**
     * Coordinate at the southwest corner.
     * Note: setting this field with invalid values (infinite, NaN) will crash the application.
     */
    private @NonNull Map<String, Object> southwest;

    public @NonNull Map<String, Object> getSouthwest() {
      return southwest;
    }

    public void setSouthwest(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"southwest\" is null.");
      }
      this.southwest = setterArg;
    }

    /**
     * Coordinate at the northeast corner.
     * Note: setting this field with invalid values (infinite, NaN) will crash the application.
     */
    private @NonNull Map<String, Object> northeast;

    public @NonNull Map<String, Object> getNortheast() {
      return northeast;
    }

    public void setNortheast(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"northeast\" is null.");
      }
      this.northeast = setterArg;
    }

    /**
     * If set to `true`, an infinite (unconstrained) bounds covering the world coordinates would be used.
     * Coordinates provided in `southwest` and `northeast` fields would be omitted and have no effect.
     */
    private @NonNull Boolean infiniteBounds;

    public @NonNull Boolean getInfiniteBounds() {
      return infiniteBounds;
    }

    public void setInfiniteBounds(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"infiniteBounds\" is null.");
      }
      this.infiniteBounds = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CoordinateBounds() {}

    public static final class Builder {

      private @Nullable Map<String, Object> southwest;

      @CanIgnoreReturnValue
      public @NonNull Builder setSouthwest(@NonNull Map<String, Object> setterArg) {
        this.southwest = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> northeast;

      @CanIgnoreReturnValue
      public @NonNull Builder setNortheast(@NonNull Map<String, Object> setterArg) {
        this.northeast = setterArg;
        return this;
      }

      private @Nullable Boolean infiniteBounds;

      @CanIgnoreReturnValue
      public @NonNull Builder setInfiniteBounds(@NonNull Boolean setterArg) {
        this.infiniteBounds = setterArg;
        return this;
      }

      public @NonNull CoordinateBounds build() {
        CoordinateBounds pigeonReturn = new CoordinateBounds();
        pigeonReturn.setSouthwest(southwest);
        pigeonReturn.setNortheast(northeast);
        pigeonReturn.setInfiniteBounds(infiniteBounds);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(southwest);
      toListResult.add(northeast);
      toListResult.add(infiniteBounds);
      return toListResult;
    }

    static @NonNull CoordinateBounds fromList(@NonNull ArrayList<Object> list) {
      CoordinateBounds pigeonResult = new CoordinateBounds();
      Object southwest = list.get(0);
      pigeonResult.setSouthwest((Map<String, Object>) southwest);
      Object northeast = list.get(1);
      pigeonResult.setNortheast((Map<String, Object>) northeast);
      Object infiniteBounds = list.get(2);
      pigeonResult.setInfiniteBounds((Boolean) infiniteBounds);
      return pigeonResult;
    }
  }

  /**
   * Options for enabling debugging features in a map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MapDebugOptions {
    private @NonNull MapDebugOptionsData data;

    public @NonNull MapDebugOptionsData getData() {
      return data;
    }

    public void setData(@NonNull MapDebugOptionsData setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"data\" is null.");
      }
      this.data = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MapDebugOptions() {}

    public static final class Builder {

      private @Nullable MapDebugOptionsData data;

      @CanIgnoreReturnValue
      public @NonNull Builder setData(@NonNull MapDebugOptionsData setterArg) {
        this.data = setterArg;
        return this;
      }

      public @NonNull MapDebugOptions build() {
        MapDebugOptions pigeonReturn = new MapDebugOptions();
        pigeonReturn.setData(data);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(data == null ? null : data.index);
      return toListResult;
    }

    static @NonNull MapDebugOptions fromList(@NonNull ArrayList<Object> list) {
      MapDebugOptions pigeonResult = new MapDebugOptions();
      Object data = list.get(0);
      pigeonResult.setData(MapDebugOptionsData.values()[(int) data]);
      return pigeonResult;
    }
  }

  /**
   * Describes the glyphs rasterization option values.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class GlyphsRasterizationOptions {
    /** Glyphs rasterization mode for client-side text rendering. */
    private @NonNull GlyphsRasterizationMode rasterizationMode;

    public @NonNull GlyphsRasterizationMode getRasterizationMode() {
      return rasterizationMode;
    }

    public void setRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"rasterizationMode\" is null.");
      }
      this.rasterizationMode = setterArg;
    }

    /**
     * Font family to use as font fallback for client-side text renderings.
     *
     * Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
     * or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
     * font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
     * default font are varied in platforms:
     * - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
     *   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
     * - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
     *
     * Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
     *
     */
    private @Nullable String fontFamily;

    public @Nullable String getFontFamily() {
      return fontFamily;
    }

    public void setFontFamily(@Nullable String setterArg) {
      this.fontFamily = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    GlyphsRasterizationOptions() {}

    public static final class Builder {

      private @Nullable GlyphsRasterizationMode rasterizationMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
        this.rasterizationMode = setterArg;
        return this;
      }

      private @Nullable String fontFamily;

      @CanIgnoreReturnValue
      public @NonNull Builder setFontFamily(@Nullable String setterArg) {
        this.fontFamily = setterArg;
        return this;
      }

      public @NonNull GlyphsRasterizationOptions build() {
        GlyphsRasterizationOptions pigeonReturn = new GlyphsRasterizationOptions();
        pigeonReturn.setRasterizationMode(rasterizationMode);
        pigeonReturn.setFontFamily(fontFamily);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(rasterizationMode == null ? null : rasterizationMode.index);
      toListResult.add(fontFamily);
      return toListResult;
    }

    static @NonNull GlyphsRasterizationOptions fromList(@NonNull ArrayList<Object> list) {
      GlyphsRasterizationOptions pigeonResult = new GlyphsRasterizationOptions();
      Object rasterizationMode = list.get(0);
      pigeonResult.setRasterizationMode(GlyphsRasterizationMode.values()[(int) rasterizationMode]);
      Object fontFamily = list.get(1);
      pigeonResult.setFontFamily((String) fontFamily);
      return pigeonResult;
    }
  }

  /**
   * Map memory budget in megabytes.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class TileCacheBudgetInMegabytes {
    private @NonNull Long size;

    public @NonNull Long getSize() {
      return size;
    }

    public void setSize(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"size\" is null.");
      }
      this.size = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    TileCacheBudgetInMegabytes() {}

    public static final class Builder {

      private @Nullable Long size;

      @CanIgnoreReturnValue
      public @NonNull Builder setSize(@NonNull Long setterArg) {
        this.size = setterArg;
        return this;
      }

      public @NonNull TileCacheBudgetInMegabytes build() {
        TileCacheBudgetInMegabytes pigeonReturn = new TileCacheBudgetInMegabytes();
        pigeonReturn.setSize(size);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(size);
      return toListResult;
    }

    static @NonNull TileCacheBudgetInMegabytes fromList(@NonNull ArrayList<Object> list) {
      TileCacheBudgetInMegabytes pigeonResult = new TileCacheBudgetInMegabytes();
      Object size = list.get(0);
      pigeonResult.setSize((size == null) ? null : ((size instanceof Integer) ? (Integer) size : (Long) size));
      return pigeonResult;
    }
  }

  /**
   * Map memory budget in tiles.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class TileCacheBudgetInTiles {
    private @NonNull Long size;

    public @NonNull Long getSize() {
      return size;
    }

    public void setSize(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"size\" is null.");
      }
      this.size = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    TileCacheBudgetInTiles() {}

    public static final class Builder {

      private @Nullable Long size;

      @CanIgnoreReturnValue
      public @NonNull Builder setSize(@NonNull Long setterArg) {
        this.size = setterArg;
        return this;
      }

      public @NonNull TileCacheBudgetInTiles build() {
        TileCacheBudgetInTiles pigeonReturn = new TileCacheBudgetInTiles();
        pigeonReturn.setSize(size);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(size);
      return toListResult;
    }

    static @NonNull TileCacheBudgetInTiles fromList(@NonNull ArrayList<Object> list) {
      TileCacheBudgetInTiles pigeonResult = new TileCacheBudgetInTiles();
      Object size = list.get(0);
      pigeonResult.setSize((size == null) ? null : ((size instanceof Integer) ? (Integer) size : (Long) size));
      return pigeonResult;
    }
  }

  /**
   * Describes the map option values.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MapOptions {
    /**
     * The map context mode. This can be used to optimizations
     * if we know that the drawing context is not shared with other code.
     */
    private @Nullable ContextMode contextMode;

    public @Nullable ContextMode getContextMode() {
      return contextMode;
    }

    public void setContextMode(@Nullable ContextMode setterArg) {
      this.contextMode = setterArg;
    }

    /**
     * The map constrain mode. This can be used to limit the map
     * to wrap around the globe horizontally. By default, it is set to
     * `HeightOnly`.
     */
    private @Nullable ConstrainMode constrainMode;

    public @Nullable ConstrainMode getConstrainMode() {
      return constrainMode;
    }

    public void setConstrainMode(@Nullable ConstrainMode setterArg) {
      this.constrainMode = setterArg;
    }

    /**
     * The viewport mode. This can be used to flip the vertical
     * orientation of the map as some devices may use inverted orientation.
     */
    private @Nullable ViewportMode viewportMode;

    public @Nullable ViewportMode getViewportMode() {
      return viewportMode;
    }

    public void setViewportMode(@Nullable ViewportMode setterArg) {
      this.viewportMode = setterArg;
    }

    /**
     * The orientation of the Map. By default, it is set to
     * `Upwards`.
     */
    private @Nullable NorthOrientation orientation;

    public @Nullable NorthOrientation getOrientation() {
      return orientation;
    }

    public void setOrientation(@Nullable NorthOrientation setterArg) {
      this.orientation = setterArg;
    }

    /**
     * Specify whether to enable cross-source symbol collision detection
     * or not. By default, it is set to `true`.
     */
    private @Nullable Boolean crossSourceCollisions;

    public @Nullable Boolean getCrossSourceCollisions() {
      return crossSourceCollisions;
    }

    public void setCrossSourceCollisions(@Nullable Boolean setterArg) {
      this.crossSourceCollisions = setterArg;
    }

    /**
     * The size to resize the map object and renderer backend.
     * The size is given in `logical pixel` units. macOS and iOS platforms use
     * device-independent pixel units, while other platforms, such as Android,
     * use screen pixel units.
     */
    private @Nullable Size size;

    public @Nullable Size getSize() {
      return size;
    }

    public void setSize(@Nullable Size setterArg) {
      this.size = setterArg;
    }

    /** The custom pixel ratio. By default, it is set to 1.0 */
    private @NonNull Double pixelRatio;

    public @NonNull Double getPixelRatio() {
      return pixelRatio;
    }

    public void setPixelRatio(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pixelRatio\" is null.");
      }
      this.pixelRatio = setterArg;
    }

    /** Glyphs rasterization options to use for client-side text rendering. */
    private @Nullable GlyphsRasterizationOptions glyphsRasterizationOptions;

    public @Nullable GlyphsRasterizationOptions getGlyphsRasterizationOptions() {
      return glyphsRasterizationOptions;
    }

    public void setGlyphsRasterizationOptions(@Nullable GlyphsRasterizationOptions setterArg) {
      this.glyphsRasterizationOptions = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MapOptions() {}

    public static final class Builder {

      private @Nullable ContextMode contextMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setContextMode(@Nullable ContextMode setterArg) {
        this.contextMode = setterArg;
        return this;
      }

      private @Nullable ConstrainMode constrainMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setConstrainMode(@Nullable ConstrainMode setterArg) {
        this.constrainMode = setterArg;
        return this;
      }

      private @Nullable ViewportMode viewportMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setViewportMode(@Nullable ViewportMode setterArg) {
        this.viewportMode = setterArg;
        return this;
      }

      private @Nullable NorthOrientation orientation;

      @CanIgnoreReturnValue
      public @NonNull Builder setOrientation(@Nullable NorthOrientation setterArg) {
        this.orientation = setterArg;
        return this;
      }

      private @Nullable Boolean crossSourceCollisions;

      @CanIgnoreReturnValue
      public @NonNull Builder setCrossSourceCollisions(@Nullable Boolean setterArg) {
        this.crossSourceCollisions = setterArg;
        return this;
      }

      private @Nullable Size size;

      @CanIgnoreReturnValue
      public @NonNull Builder setSize(@Nullable Size setterArg) {
        this.size = setterArg;
        return this;
      }

      private @Nullable Double pixelRatio;

      @CanIgnoreReturnValue
      public @NonNull Builder setPixelRatio(@NonNull Double setterArg) {
        this.pixelRatio = setterArg;
        return this;
      }

      private @Nullable GlyphsRasterizationOptions glyphsRasterizationOptions;

      @CanIgnoreReturnValue
      public @NonNull Builder setGlyphsRasterizationOptions(@Nullable GlyphsRasterizationOptions setterArg) {
        this.glyphsRasterizationOptions = setterArg;
        return this;
      }

      public @NonNull MapOptions build() {
        MapOptions pigeonReturn = new MapOptions();
        pigeonReturn.setContextMode(contextMode);
        pigeonReturn.setConstrainMode(constrainMode);
        pigeonReturn.setViewportMode(viewportMode);
        pigeonReturn.setOrientation(orientation);
        pigeonReturn.setCrossSourceCollisions(crossSourceCollisions);
        pigeonReturn.setSize(size);
        pigeonReturn.setPixelRatio(pixelRatio);
        pigeonReturn.setGlyphsRasterizationOptions(glyphsRasterizationOptions);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(8);
      toListResult.add(contextMode == null ? null : contextMode.index);
      toListResult.add(constrainMode == null ? null : constrainMode.index);
      toListResult.add(viewportMode == null ? null : viewportMode.index);
      toListResult.add(orientation == null ? null : orientation.index);
      toListResult.add(crossSourceCollisions);
      toListResult.add((size == null) ? null : size.toList());
      toListResult.add(pixelRatio);
      toListResult.add((glyphsRasterizationOptions == null) ? null : glyphsRasterizationOptions.toList());
      return toListResult;
    }

    static @NonNull MapOptions fromList(@NonNull ArrayList<Object> list) {
      MapOptions pigeonResult = new MapOptions();
      Object contextMode = list.get(0);
      pigeonResult.setContextMode(contextMode == null ? null : ContextMode.values()[(int) contextMode]);
      Object constrainMode = list.get(1);
      pigeonResult.setConstrainMode(constrainMode == null ? null : ConstrainMode.values()[(int) constrainMode]);
      Object viewportMode = list.get(2);
      pigeonResult.setViewportMode(viewportMode == null ? null : ViewportMode.values()[(int) viewportMode]);
      Object orientation = list.get(3);
      pigeonResult.setOrientation(orientation == null ? null : NorthOrientation.values()[(int) orientation]);
      Object crossSourceCollisions = list.get(4);
      pigeonResult.setCrossSourceCollisions((Boolean) crossSourceCollisions);
      Object size = list.get(5);
      pigeonResult.setSize((size == null) ? null : Size.fromList((ArrayList<Object>) size));
      Object pixelRatio = list.get(6);
      pigeonResult.setPixelRatio((Double) pixelRatio);
      Object glyphsRasterizationOptions = list.get(7);
      pigeonResult.setGlyphsRasterizationOptions((glyphsRasterizationOptions == null) ? null : GlyphsRasterizationOptions.fromList((ArrayList<Object>) glyphsRasterizationOptions));
      return pigeonResult;
    }
  }

  /**
   * Describes the coordinate on the screen, measured from top to bottom and from left to right.
   * Note: the `map` uses screen coordinate units measured in `logical pixels`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ScreenCoordinate {
    /** A value representing the x position of this coordinate. */
    private @NonNull Double x;

    public @NonNull Double getX() {
      return x;
    }

    public void setX(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** A value representing the y position of this coordinate. */
    private @NonNull Double y;

    public @NonNull Double getY() {
      return y;
    }

    public void setY(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ScreenCoordinate() {}

    public static final class Builder {

      private @Nullable Double x;

      @CanIgnoreReturnValue
      public @NonNull Builder setX(@NonNull Double setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Double y;

      @CanIgnoreReturnValue
      public @NonNull Builder setY(@NonNull Double setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull ScreenCoordinate build() {
        ScreenCoordinate pigeonReturn = new ScreenCoordinate();
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull ScreenCoordinate fromList(@NonNull ArrayList<Object> list) {
      ScreenCoordinate pigeonResult = new ScreenCoordinate();
      Object x = list.get(0);
      pigeonResult.setX((Double) x);
      Object y = list.get(1);
      pigeonResult.setY((Double) y);
      return pigeonResult;
    }
  }

  /**
   * Describes the coordinate box on the screen, measured in `logical pixels`
   * from top to bottom and from left to right.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ScreenBox {
    /** The screen coordinate close to the top left corner of the screen. */
    private @NonNull ScreenCoordinate min;

    public @NonNull ScreenCoordinate getMin() {
      return min;
    }

    public void setMin(@NonNull ScreenCoordinate setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"min\" is null.");
      }
      this.min = setterArg;
    }

    /** The screen coordinate close to the bottom right corner of the screen. */
    private @NonNull ScreenCoordinate max;

    public @NonNull ScreenCoordinate getMax() {
      return max;
    }

    public void setMax(@NonNull ScreenCoordinate setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"max\" is null.");
      }
      this.max = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ScreenBox() {}

    public static final class Builder {

      private @Nullable ScreenCoordinate min;

      @CanIgnoreReturnValue
      public @NonNull Builder setMin(@NonNull ScreenCoordinate setterArg) {
        this.min = setterArg;
        return this;
      }

      private @Nullable ScreenCoordinate max;

      @CanIgnoreReturnValue
      public @NonNull Builder setMax(@NonNull ScreenCoordinate setterArg) {
        this.max = setterArg;
        return this;
      }

      public @NonNull ScreenBox build() {
        ScreenBox pigeonReturn = new ScreenBox();
        pigeonReturn.setMin(min);
        pigeonReturn.setMax(max);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add((min == null) ? null : min.toList());
      toListResult.add((max == null) ? null : max.toList());
      return toListResult;
    }

    static @NonNull ScreenBox fromList(@NonNull ArrayList<Object> list) {
      ScreenBox pigeonResult = new ScreenBox();
      Object min = list.get(0);
      pigeonResult.setMin((min == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) min));
      Object max = list.get(1);
      pigeonResult.setMax((max == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) max));
      return pigeonResult;
    }
  }

  /**
   * A coordinate bounds and zoom.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CoordinateBoundsZoom {
    /** The latitude and longitude bounds. */
    private @NonNull CoordinateBounds bounds;

    public @NonNull CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@NonNull CoordinateBounds setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bounds\" is null.");
      }
      this.bounds = setterArg;
    }

    /** Zoom. */
    private @NonNull Double zoom;

    public @NonNull Double getZoom() {
      return zoom;
    }

    public void setZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"zoom\" is null.");
      }
      this.zoom = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CoordinateBoundsZoom() {}

    public static final class Builder {

      private @Nullable CoordinateBounds bounds;

      @CanIgnoreReturnValue
      public @NonNull Builder setBounds(@NonNull CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double zoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setZoom(@NonNull Double setterArg) {
        this.zoom = setterArg;
        return this;
      }

      public @NonNull CoordinateBoundsZoom build() {
        CoordinateBoundsZoom pigeonReturn = new CoordinateBoundsZoom();
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setZoom(zoom);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(zoom);
      return toListResult;
    }

    static @NonNull CoordinateBoundsZoom fromList(@NonNull ArrayList<Object> list) {
      CoordinateBoundsZoom pigeonResult = new CoordinateBoundsZoom();
      Object bounds = list.get(0);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object zoom = list.get(1);
      pigeonResult.setZoom((Double) zoom);
      return pigeonResult;
    }
  }

  /**
   * Size type.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class Size {
    /** Width of the size. */
    private @NonNull Double width;

    public @NonNull Double getWidth() {
      return width;
    }

    public void setWidth(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"width\" is null.");
      }
      this.width = setterArg;
    }

    /** Height of the size. */
    private @NonNull Double height;

    public @NonNull Double getHeight() {
      return height;
    }

    public void setHeight(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"height\" is null.");
      }
      this.height = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    Size() {}

    public static final class Builder {

      private @Nullable Double width;

      @CanIgnoreReturnValue
      public @NonNull Builder setWidth(@NonNull Double setterArg) {
        this.width = setterArg;
        return this;
      }

      private @Nullable Double height;

      @CanIgnoreReturnValue
      public @NonNull Builder setHeight(@NonNull Double setterArg) {
        this.height = setterArg;
        return this;
      }

      public @NonNull Size build() {
        Size pigeonReturn = new Size();
        pigeonReturn.setWidth(width);
        pigeonReturn.setHeight(height);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(width);
      toListResult.add(height);
      return toListResult;
    }

    static @NonNull Size fromList(@NonNull ArrayList<Object> list) {
      Size pigeonResult = new Size();
      Object width = list.get(0);
      pigeonResult.setWidth((Double) width);
      Object height = list.get(1);
      pigeonResult.setHeight((Double) height);
      return pigeonResult;
    }
  }

  /**
   * Options for querying rendered features.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class RenderedQueryOptions {
    /** Layer IDs to include in the query. */
    private @Nullable List<String> layerIds;

    public @Nullable List<String> getLayerIds() {
      return layerIds;
    }

    public void setLayerIds(@Nullable List<String> setterArg) {
      this.layerIds = setterArg;
    }

    /** Filters the returned features with an expression */
    private @Nullable String filter;

    public @Nullable String getFilter() {
      return filter;
    }

    public void setFilter(@Nullable String setterArg) {
      this.filter = setterArg;
    }

    public static final class Builder {

      private @Nullable List<String> layerIds;

      @CanIgnoreReturnValue
      public @NonNull Builder setLayerIds(@Nullable List<String> setterArg) {
        this.layerIds = setterArg;
        return this;
      }

      private @Nullable String filter;

      @CanIgnoreReturnValue
      public @NonNull Builder setFilter(@Nullable String setterArg) {
        this.filter = setterArg;
        return this;
      }

      public @NonNull RenderedQueryOptions build() {
        RenderedQueryOptions pigeonReturn = new RenderedQueryOptions();
        pigeonReturn.setLayerIds(layerIds);
        pigeonReturn.setFilter(filter);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(layerIds);
      toListResult.add(filter);
      return toListResult;
    }

    static @NonNull RenderedQueryOptions fromList(@NonNull ArrayList<Object> list) {
      RenderedQueryOptions pigeonResult = new RenderedQueryOptions();
      Object layerIds = list.get(0);
      pigeonResult.setLayerIds((List<String>) layerIds);
      Object filter = list.get(1);
      pigeonResult.setFilter((String) filter);
      return pigeonResult;
    }
  }

  /**
   * Options for querying source features.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class SourceQueryOptions {
    /** Source layer IDs to include in the query. */
    private @Nullable List<String> sourceLayerIds;

    public @Nullable List<String> getSourceLayerIds() {
      return sourceLayerIds;
    }

    public void setSourceLayerIds(@Nullable List<String> setterArg) {
      this.sourceLayerIds = setterArg;
    }

    /** Filters the returned features with an expression */
    private @NonNull String filter;

    public @NonNull String getFilter() {
      return filter;
    }

    public void setFilter(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"filter\" is null.");
      }
      this.filter = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    SourceQueryOptions() {}

    public static final class Builder {

      private @Nullable List<String> sourceLayerIds;

      @CanIgnoreReturnValue
      public @NonNull Builder setSourceLayerIds(@Nullable List<String> setterArg) {
        this.sourceLayerIds = setterArg;
        return this;
      }

      private @Nullable String filter;

      @CanIgnoreReturnValue
      public @NonNull Builder setFilter(@NonNull String setterArg) {
        this.filter = setterArg;
        return this;
      }

      public @NonNull SourceQueryOptions build() {
        SourceQueryOptions pigeonReturn = new SourceQueryOptions();
        pigeonReturn.setSourceLayerIds(sourceLayerIds);
        pigeonReturn.setFilter(filter);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(sourceLayerIds);
      toListResult.add(filter);
      return toListResult;
    }

    static @NonNull SourceQueryOptions fromList(@NonNull ArrayList<Object> list) {
      SourceQueryOptions pigeonResult = new SourceQueryOptions();
      Object sourceLayerIds = list.get(0);
      pigeonResult.setSourceLayerIds((List<String>) sourceLayerIds);
      Object filter = list.get(1);
      pigeonResult.setFilter((String) filter);
      return pigeonResult;
    }
  }

  /**
   * A value or a collection of a feature extension.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class FeatureExtensionValue {
    /** An optional value of a feature extension */
    private @Nullable String value;

    public @Nullable String getValue() {
      return value;
    }

    public void setValue(@Nullable String setterArg) {
      this.value = setterArg;
    }

    /** An optional array of features from a feature extension. */
    private @Nullable List<Map<String, Object>> featureCollection;

    public @Nullable List<Map<String, Object>> getFeatureCollection() {
      return featureCollection;
    }

    public void setFeatureCollection(@Nullable List<Map<String, Object>> setterArg) {
      this.featureCollection = setterArg;
    }

    public static final class Builder {

      private @Nullable String value;

      @CanIgnoreReturnValue
      public @NonNull Builder setValue(@Nullable String setterArg) {
        this.value = setterArg;
        return this;
      }

      private @Nullable List<Map<String, Object>> featureCollection;

      @CanIgnoreReturnValue
      public @NonNull Builder setFeatureCollection(@Nullable List<Map<String, Object>> setterArg) {
        this.featureCollection = setterArg;
        return this;
      }

      public @NonNull FeatureExtensionValue build() {
        FeatureExtensionValue pigeonReturn = new FeatureExtensionValue();
        pigeonReturn.setValue(value);
        pigeonReturn.setFeatureCollection(featureCollection);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(value);
      toListResult.add(featureCollection);
      return toListResult;
    }

    static @NonNull FeatureExtensionValue fromList(@NonNull ArrayList<Object> list) {
      FeatureExtensionValue pigeonResult = new FeatureExtensionValue();
      Object value = list.get(0);
      pigeonResult.setValue((String) value);
      Object featureCollection = list.get(1);
      pigeonResult.setFeatureCollection((List<Map<String, Object>>) featureCollection);
      return pigeonResult;
    }
  }

  /**
   * Specifies position of a layer that is added via addStyleLayer method.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class LayerPosition {
    /** Layer should be positioned above specified layer id. */
    private @Nullable String above;

    public @Nullable String getAbove() {
      return above;
    }

    public void setAbove(@Nullable String setterArg) {
      this.above = setterArg;
    }

    /** Layer should be positioned below specified layer id. */
    private @Nullable String below;

    public @Nullable String getBelow() {
      return below;
    }

    public void setBelow(@Nullable String setterArg) {
      this.below = setterArg;
    }

    /** Layer should be positioned at specified index in a layers stack. */
    private @Nullable Long at;

    public @Nullable Long getAt() {
      return at;
    }

    public void setAt(@Nullable Long setterArg) {
      this.at = setterArg;
    }

    public static final class Builder {

      private @Nullable String above;

      @CanIgnoreReturnValue
      public @NonNull Builder setAbove(@Nullable String setterArg) {
        this.above = setterArg;
        return this;
      }

      private @Nullable String below;

      @CanIgnoreReturnValue
      public @NonNull Builder setBelow(@Nullable String setterArg) {
        this.below = setterArg;
        return this;
      }

      private @Nullable Long at;

      @CanIgnoreReturnValue
      public @NonNull Builder setAt(@Nullable Long setterArg) {
        this.at = setterArg;
        return this;
      }

      public @NonNull LayerPosition build() {
        LayerPosition pigeonReturn = new LayerPosition();
        pigeonReturn.setAbove(above);
        pigeonReturn.setBelow(below);
        pigeonReturn.setAt(at);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(above);
      toListResult.add(below);
      toListResult.add(at);
      return toListResult;
    }

    static @NonNull LayerPosition fromList(@NonNull ArrayList<Object> list) {
      LayerPosition pigeonResult = new LayerPosition();
      Object above = list.get(0);
      pigeonResult.setAbove((String) above);
      Object below = list.get(1);
      pigeonResult.setBelow((String) below);
      Object at = list.get(2);
      pigeonResult.setAt((at == null) ? null : ((at instanceof Integer) ? (Integer) at : (Long) at));
      return pigeonResult;
    }
  }

  /**
   * Represents query result that is returned in QueryRenderedFeaturesCallback.
   * @see `queryRenderedFeatures`
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class QueriedRenderedFeature {
    /** Feature returned by the query. */
    private @NonNull QueriedFeature queriedFeature;

    public @NonNull QueriedFeature getQueriedFeature() {
      return queriedFeature;
    }

    public void setQueriedFeature(@NonNull QueriedFeature setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"queriedFeature\" is null.");
      }
      this.queriedFeature = setterArg;
    }

    /**
     * An array of layer Ids for the queried feature.
     * If the feature has been rendered in multiple layers, multiple Ids will be provided.
     * If the feature is only rendered in one layer, a single Id will be provided.
     */
    private @NonNull List<String> layers;

    public @NonNull List<String> getLayers() {
      return layers;
    }

    public void setLayers(@NonNull List<String> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"layers\" is null.");
      }
      this.layers = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    QueriedRenderedFeature() {}

    public static final class Builder {

      private @Nullable QueriedFeature queriedFeature;

      @CanIgnoreReturnValue
      public @NonNull Builder setQueriedFeature(@NonNull QueriedFeature setterArg) {
        this.queriedFeature = setterArg;
        return this;
      }

      private @Nullable List<String> layers;

      @CanIgnoreReturnValue
      public @NonNull Builder setLayers(@NonNull List<String> setterArg) {
        this.layers = setterArg;
        return this;
      }

      public @NonNull QueriedRenderedFeature build() {
        QueriedRenderedFeature pigeonReturn = new QueriedRenderedFeature();
        pigeonReturn.setQueriedFeature(queriedFeature);
        pigeonReturn.setLayers(layers);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add((queriedFeature == null) ? null : queriedFeature.toList());
      toListResult.add(layers);
      return toListResult;
    }

    static @NonNull QueriedRenderedFeature fromList(@NonNull ArrayList<Object> list) {
      QueriedRenderedFeature pigeonResult = new QueriedRenderedFeature();
      Object queriedFeature = list.get(0);
      pigeonResult.setQueriedFeature((queriedFeature == null) ? null : QueriedFeature.fromList((ArrayList<Object>) queriedFeature));
      Object layers = list.get(1);
      pigeonResult.setLayers((List<String>) layers);
      return pigeonResult;
    }
  }

  /**
   * Represents query result that is returned in QuerySourceFeaturesCallback.
   * @see `querySourceFeatures`
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class QueriedSourceFeature {
    /** Feature returned by the query. */
    private @NonNull QueriedFeature queriedFeature;

    public @NonNull QueriedFeature getQueriedFeature() {
      return queriedFeature;
    }

    public void setQueriedFeature(@NonNull QueriedFeature setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"queriedFeature\" is null.");
      }
      this.queriedFeature = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    QueriedSourceFeature() {}

    public static final class Builder {

      private @Nullable QueriedFeature queriedFeature;

      @CanIgnoreReturnValue
      public @NonNull Builder setQueriedFeature(@NonNull QueriedFeature setterArg) {
        this.queriedFeature = setterArg;
        return this;
      }

      public @NonNull QueriedSourceFeature build() {
        QueriedSourceFeature pigeonReturn = new QueriedSourceFeature();
        pigeonReturn.setQueriedFeature(queriedFeature);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add((queriedFeature == null) ? null : queriedFeature.toList());
      return toListResult;
    }

    static @NonNull QueriedSourceFeature fromList(@NonNull ArrayList<Object> list) {
      QueriedSourceFeature pigeonResult = new QueriedSourceFeature();
      Object queriedFeature = list.get(0);
      pigeonResult.setQueriedFeature((queriedFeature == null) ? null : QueriedFeature.fromList((ArrayList<Object>) queriedFeature));
      return pigeonResult;
    }
  }

  /**
   * Represents query result that is returned in QueryFeaturesCallback.
   * @see `queryRenderedFeatures` or `querySourceFeatures`
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class QueriedFeature {
    /** Feature returned by the query. */
    private @NonNull Map<String, Object> feature;

    public @NonNull Map<String, Object> getFeature() {
      return feature;
    }

    public void setFeature(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"feature\" is null.");
      }
      this.feature = setterArg;
    }

    /** Source id for a queried feature. */
    private @NonNull String source;

    public @NonNull String getSource() {
      return source;
    }

    public void setSource(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"source\" is null.");
      }
      this.source = setterArg;
    }

    /**
     * Source layer id for a queried feature. May be null if source does not support layers, e.g., 'geojson' source,
     * or when data provided by the source is not layered.
     */
    private @Nullable String sourceLayer;

    public @Nullable String getSourceLayer() {
      return sourceLayer;
    }

    public void setSourceLayer(@Nullable String setterArg) {
      this.sourceLayer = setterArg;
    }

    /**
     * Feature state for a queried feature. Type of the value is an Object.
     * @see `setFeatureState` and `getFeatureState`
     */
    private @NonNull String state;

    public @NonNull String getState() {
      return state;
    }

    public void setState(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"state\" is null.");
      }
      this.state = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    QueriedFeature() {}

    public static final class Builder {

      private @Nullable Map<String, Object> feature;

      @CanIgnoreReturnValue
      public @NonNull Builder setFeature(@NonNull Map<String, Object> setterArg) {
        this.feature = setterArg;
        return this;
      }

      private @Nullable String source;

      @CanIgnoreReturnValue
      public @NonNull Builder setSource(@NonNull String setterArg) {
        this.source = setterArg;
        return this;
      }

      private @Nullable String sourceLayer;

      @CanIgnoreReturnValue
      public @NonNull Builder setSourceLayer(@Nullable String setterArg) {
        this.sourceLayer = setterArg;
        return this;
      }

      private @Nullable String state;

      @CanIgnoreReturnValue
      public @NonNull Builder setState(@NonNull String setterArg) {
        this.state = setterArg;
        return this;
      }

      public @NonNull QueriedFeature build() {
        QueriedFeature pigeonReturn = new QueriedFeature();
        pigeonReturn.setFeature(feature);
        pigeonReturn.setSource(source);
        pigeonReturn.setSourceLayer(sourceLayer);
        pigeonReturn.setState(state);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(feature);
      toListResult.add(source);
      toListResult.add(sourceLayer);
      toListResult.add(state);
      return toListResult;
    }

    static @NonNull QueriedFeature fromList(@NonNull ArrayList<Object> list) {
      QueriedFeature pigeonResult = new QueriedFeature();
      Object feature = list.get(0);
      pigeonResult.setFeature((Map<String, Object>) feature);
      Object source = list.get(1);
      pigeonResult.setSource((String) source);
      Object sourceLayer = list.get(2);
      pigeonResult.setSourceLayer((String) sourceLayer);
      Object state = list.get(3);
      pigeonResult.setState((String) state);
      return pigeonResult;
    }
  }

  /**
   * Geometry for querying rendered features.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class RenderedQueryGeometry {
    /** ScreenCoordinate/List<ScreenCoordinate>/ScreenBox in Json mode. */
    private @NonNull String value;

    public @NonNull String getValue() {
      return value;
    }

    public void setValue(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"value\" is null.");
      }
      this.value = setterArg;
    }

    private @NonNull Type type;

    public @NonNull Type getType() {
      return type;
    }

    public void setType(@NonNull Type setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    RenderedQueryGeometry() {}

    public static final class Builder {

      private @Nullable String value;

      @CanIgnoreReturnValue
      public @NonNull Builder setValue(@NonNull String setterArg) {
        this.value = setterArg;
        return this;
      }

      private @Nullable Type type;

      @CanIgnoreReturnValue
      public @NonNull Builder setType(@NonNull Type setterArg) {
        this.type = setterArg;
        return this;
      }

      public @NonNull RenderedQueryGeometry build() {
        RenderedQueryGeometry pigeonReturn = new RenderedQueryGeometry();
        pigeonReturn.setValue(value);
        pigeonReturn.setType(type);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(value);
      toListResult.add(type == null ? null : type.index);
      return toListResult;
    }

    static @NonNull RenderedQueryGeometry fromList(@NonNull ArrayList<Object> list) {
      RenderedQueryGeometry pigeonResult = new RenderedQueryGeometry();
      Object value = list.get(0);
      pigeonResult.setValue((String) value);
      Object type = list.get(1);
      pigeonResult.setType(Type.values()[(int) type]);
      return pigeonResult;
    }
  }

  /**
   * An offline region definition is a geographic region defined by a style URL,
   * a geometry, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be â‰¥ 0,
   * and `maxZoom` must be â‰¥ `minZoom`. The `maxZoom` may be âˆž, in which case for each tile source,
   * the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
   * The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class OfflineRegionGeometryDefinition {
    /** The style associated with the offline region */
    private @NonNull String styleURL;

    public @NonNull String getStyleURL() {
      return styleURL;
    }

    public void setStyleURL(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"styleURL\" is null.");
      }
      this.styleURL = setterArg;
    }

    /** The geometry that defines the boundary of the offline region */
    private @NonNull Map<String, Object> geometry;

    public @NonNull Map<String, Object> getGeometry() {
      return geometry;
    }

    public void setGeometry(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"geometry\" is null.");
      }
      this.geometry = setterArg;
    }

    /** Minimum zoom level for the offline region */
    private @NonNull Double minZoom;

    public @NonNull Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minZoom\" is null.");
      }
      this.minZoom = setterArg;
    }

    /** Maximum zoom level for the offline region */
    private @NonNull Double maxZoom;

    public @NonNull Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxZoom\" is null.");
      }
      this.maxZoom = setterArg;
    }

    /** Pixel ratio to be accounted for when downloading assets */
    private @NonNull Double pixelRatio;

    public @NonNull Double getPixelRatio() {
      return pixelRatio;
    }

    public void setPixelRatio(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pixelRatio\" is null.");
      }
      this.pixelRatio = setterArg;
    }

    /** Specifies glyphs rasterization mode. It defines which glyphs will be loaded from the server */
    private @NonNull GlyphsRasterizationMode glyphsRasterizationMode;

    public @NonNull GlyphsRasterizationMode getGlyphsRasterizationMode() {
      return glyphsRasterizationMode;
    }

    public void setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"glyphsRasterizationMode\" is null.");
      }
      this.glyphsRasterizationMode = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    OfflineRegionGeometryDefinition() {}

    public static final class Builder {

      private @Nullable String styleURL;

      @CanIgnoreReturnValue
      public @NonNull Builder setStyleURL(@NonNull String setterArg) {
        this.styleURL = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> geometry;

      @CanIgnoreReturnValue
      public @NonNull Builder setGeometry(@NonNull Map<String, Object> setterArg) {
        this.geometry = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMinZoom(@NonNull Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMaxZoom(@NonNull Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double pixelRatio;

      @CanIgnoreReturnValue
      public @NonNull Builder setPixelRatio(@NonNull Double setterArg) {
        this.pixelRatio = setterArg;
        return this;
      }

      private @Nullable GlyphsRasterizationMode glyphsRasterizationMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
        this.glyphsRasterizationMode = setterArg;
        return this;
      }

      public @NonNull OfflineRegionGeometryDefinition build() {
        OfflineRegionGeometryDefinition pigeonReturn = new OfflineRegionGeometryDefinition();
        pigeonReturn.setStyleURL(styleURL);
        pigeonReturn.setGeometry(geometry);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setPixelRatio(pixelRatio);
        pigeonReturn.setGlyphsRasterizationMode(glyphsRasterizationMode);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(styleURL);
      toListResult.add(geometry);
      toListResult.add(minZoom);
      toListResult.add(maxZoom);
      toListResult.add(pixelRatio);
      toListResult.add(glyphsRasterizationMode == null ? null : glyphsRasterizationMode.index);
      return toListResult;
    }

    static @NonNull OfflineRegionGeometryDefinition fromList(@NonNull ArrayList<Object> list) {
      OfflineRegionGeometryDefinition pigeonResult = new OfflineRegionGeometryDefinition();
      Object styleURL = list.get(0);
      pigeonResult.setStyleURL((String) styleURL);
      Object geometry = list.get(1);
      pigeonResult.setGeometry((Map<String, Object>) geometry);
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxZoom = list.get(3);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object pixelRatio = list.get(4);
      pigeonResult.setPixelRatio((Double) pixelRatio);
      Object glyphsRasterizationMode = list.get(5);
      pigeonResult.setGlyphsRasterizationMode(GlyphsRasterizationMode.values()[(int) glyphsRasterizationMode]);
      return pigeonResult;
    }
  }

  /**
   * An offline region definition is a geographic region defined by a style URL,
   * geographic bounding box, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be â‰¥ 0,
   * and `maxZoom` must be â‰¥ `minZoom`. The `maxZoom` may be âˆž, in which case for each tile source,
   * the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
   * The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class OfflineRegionTilePyramidDefinition {
    /** The style associated with the offline region. */
    private @NonNull String styleURL;

    public @NonNull String getStyleURL() {
      return styleURL;
    }

    public void setStyleURL(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"styleURL\" is null.");
      }
      this.styleURL = setterArg;
    }

    /** The bounds covering the region. */
    private @NonNull CoordinateBounds bounds;

    public @NonNull CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@NonNull CoordinateBounds setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bounds\" is null.");
      }
      this.bounds = setterArg;
    }

    /** Minimum zoom level for the offline region. */
    private @NonNull Double minZoom;

    public @NonNull Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minZoom\" is null.");
      }
      this.minZoom = setterArg;
    }

    /** Maximum zoom level for the offline region. */
    private @NonNull Double maxZoom;

    public @NonNull Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxZoom\" is null.");
      }
      this.maxZoom = setterArg;
    }

    /** Pixel ratio to be accounted for when downloading assets. */
    private @NonNull Double pixelRatio;

    public @NonNull Double getPixelRatio() {
      return pixelRatio;
    }

    public void setPixelRatio(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pixelRatio\" is null.");
      }
      this.pixelRatio = setterArg;
    }

    /** Specifies glyphs download mode. */
    private @NonNull GlyphsRasterizationMode glyphsRasterizationMode;

    public @NonNull GlyphsRasterizationMode getGlyphsRasterizationMode() {
      return glyphsRasterizationMode;
    }

    public void setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"glyphsRasterizationMode\" is null.");
      }
      this.glyphsRasterizationMode = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    OfflineRegionTilePyramidDefinition() {}

    public static final class Builder {

      private @Nullable String styleURL;

      @CanIgnoreReturnValue
      public @NonNull Builder setStyleURL(@NonNull String setterArg) {
        this.styleURL = setterArg;
        return this;
      }

      private @Nullable CoordinateBounds bounds;

      @CanIgnoreReturnValue
      public @NonNull Builder setBounds(@NonNull CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMinZoom(@NonNull Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      @CanIgnoreReturnValue
      public @NonNull Builder setMaxZoom(@NonNull Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double pixelRatio;

      @CanIgnoreReturnValue
      public @NonNull Builder setPixelRatio(@NonNull Double setterArg) {
        this.pixelRatio = setterArg;
        return this;
      }

      private @Nullable GlyphsRasterizationMode glyphsRasterizationMode;

      @CanIgnoreReturnValue
      public @NonNull Builder setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
        this.glyphsRasterizationMode = setterArg;
        return this;
      }

      public @NonNull OfflineRegionTilePyramidDefinition build() {
        OfflineRegionTilePyramidDefinition pigeonReturn = new OfflineRegionTilePyramidDefinition();
        pigeonReturn.setStyleURL(styleURL);
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setPixelRatio(pixelRatio);
        pigeonReturn.setGlyphsRasterizationMode(glyphsRasterizationMode);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(styleURL);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(minZoom);
      toListResult.add(maxZoom);
      toListResult.add(pixelRatio);
      toListResult.add(glyphsRasterizationMode == null ? null : glyphsRasterizationMode.index);
      return toListResult;
    }

    static @NonNull OfflineRegionTilePyramidDefinition fromList(@NonNull ArrayList<Object> list) {
      OfflineRegionTilePyramidDefinition pigeonResult = new OfflineRegionTilePyramidDefinition();
      Object styleURL = list.get(0);
      pigeonResult.setStyleURL((String) styleURL);
      Object bounds = list.get(1);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxZoom = list.get(3);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object pixelRatio = list.get(4);
      pigeonResult.setPixelRatio((Double) pixelRatio);
      Object glyphsRasterizationMode = list.get(5);
      pigeonResult.setGlyphsRasterizationMode(GlyphsRasterizationMode.values()[(int) glyphsRasterizationMode]);
      return pigeonResult;
    }
  }

  /**
   * ProjectedMeters is a coordinate in a specific
   * [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection.
   *
   * This specific Spherical Mercator projection assumes the Earth is a sphere with a radius
   * of 6,378,137 meters. Coordinates are determined as distances, in meters, on the surface
   * of that sphere.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ProjectedMeters {
    /** Projected meters in north direction. */
    private @NonNull Double northing;

    public @NonNull Double getNorthing() {
      return northing;
    }

    public void setNorthing(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"northing\" is null.");
      }
      this.northing = setterArg;
    }

    /** Projected meters in east direction. */
    private @NonNull Double easting;

    public @NonNull Double getEasting() {
      return easting;
    }

    public void setEasting(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"easting\" is null.");
      }
      this.easting = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ProjectedMeters() {}

    public static final class Builder {

      private @Nullable Double northing;

      @CanIgnoreReturnValue
      public @NonNull Builder setNorthing(@NonNull Double setterArg) {
        this.northing = setterArg;
        return this;
      }

      private @Nullable Double easting;

      @CanIgnoreReturnValue
      public @NonNull Builder setEasting(@NonNull Double setterArg) {
        this.easting = setterArg;
        return this;
      }

      public @NonNull ProjectedMeters build() {
        ProjectedMeters pigeonReturn = new ProjectedMeters();
        pigeonReturn.setNorthing(northing);
        pigeonReturn.setEasting(easting);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(northing);
      toListResult.add(easting);
      return toListResult;
    }

    static @NonNull ProjectedMeters fromList(@NonNull ArrayList<Object> list) {
      ProjectedMeters pigeonResult = new ProjectedMeters();
      Object northing = list.get(0);
      pigeonResult.setNorthing((Double) northing);
      Object easting = list.get(1);
      pigeonResult.setEasting((Double) easting);
      return pigeonResult;
    }
  }

  /**
   * Describes a point on the map in Mercator projection.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MercatorCoordinate {
    /** A value representing the x position of this coordinate. */
    private @NonNull Double x;

    public @NonNull Double getX() {
      return x;
    }

    public void setX(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** A value representing the y position of this coordinate. */
    private @NonNull Double y;

    public @NonNull Double getY() {
      return y;
    }

    public void setY(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MercatorCoordinate() {}

    public static final class Builder {

      private @Nullable Double x;

      @CanIgnoreReturnValue
      public @NonNull Builder setX(@NonNull Double setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Double y;

      @CanIgnoreReturnValue
      public @NonNull Builder setY(@NonNull Double setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull MercatorCoordinate build() {
        MercatorCoordinate pigeonReturn = new MercatorCoordinate();
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull MercatorCoordinate fromList(@NonNull ArrayList<Object> list) {
      MercatorCoordinate pigeonResult = new MercatorCoordinate();
      Object x = list.get(0);
      pigeonResult.setX((Double) x);
      Object y = list.get(1);
      pigeonResult.setY((Double) y);
      return pigeonResult;
    }
  }

  /**
   * The information about style object (source or layer).
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class StyleObjectInfo {
    /** The object's identifier. */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** The object's type. */
    private @NonNull String type;

    public @NonNull String getType() {
      return type;
    }

    public void setType(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    StyleObjectInfo() {}

    public static final class Builder {

      private @Nullable String id;

      @CanIgnoreReturnValue
      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable String type;

      @CanIgnoreReturnValue
      public @NonNull Builder setType(@NonNull String setterArg) {
        this.type = setterArg;
        return this;
      }

      public @NonNull StyleObjectInfo build() {
        StyleObjectInfo pigeonReturn = new StyleObjectInfo();
        pigeonReturn.setId(id);
        pigeonReturn.setType(type);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(id);
      toListResult.add(type);
      return toListResult;
    }

    static @NonNull StyleObjectInfo fromList(@NonNull ArrayList<Object> list) {
      StyleObjectInfo pigeonResult = new StyleObjectInfo();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object type = list.get(1);
      pigeonResult.setType((String) type);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class StyleProjection {
    private @NonNull StyleProjectionName name;

    public @NonNull StyleProjectionName getName() {
      return name;
    }

    public void setName(@NonNull StyleProjectionName setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"name\" is null.");
      }
      this.name = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    StyleProjection() {}

    public static final class Builder {

      private @Nullable StyleProjectionName name;

      @CanIgnoreReturnValue
      public @NonNull Builder setName(@NonNull StyleProjectionName setterArg) {
        this.name = setterArg;
        return this;
      }

      public @NonNull StyleProjection build() {
        StyleProjection pigeonReturn = new StyleProjection();
        pigeonReturn.setName(name);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(name == null ? null : name.index);
      return toListResult;
    }

    static @NonNull StyleProjection fromList(@NonNull ArrayList<Object> list) {
      StyleProjection pigeonResult = new StyleProjection();
      Object name = list.get(0);
      pigeonResult.setName(StyleProjectionName.values()[(int) name]);
      return pigeonResult;
    }
  }

  /**
   * A global directional light source which is only applied on 3D layers and hillshade layers. Using this type disables other light sources.
   *
   * - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class FlatLight {
    /** Unique light name */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** Whether extruded geometries are lit relative to the map or viewport. */
    private @Nullable Anchor anchor;

    public @Nullable Anchor getAnchor() {
      return anchor;
    }

    public void setAnchor(@Nullable Anchor setterArg) {
      this.anchor = setterArg;
    }

    /** Color tint for lighting extruded geometries. */
    private @Nullable Long color;

    public @Nullable Long getColor() {
      return color;
    }

    public void setColor(@Nullable Long setterArg) {
      this.color = setterArg;
    }

    /** Transition property for `color` */
    private @Nullable TransitionOptions colorTransition;

    public @Nullable TransitionOptions getColorTransition() {
      return colorTransition;
    }

    public void setColorTransition(@Nullable TransitionOptions setterArg) {
      this.colorTransition = setterArg;
    }

    /** Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast. */
    private @Nullable Double intensity;

    public @Nullable Double getIntensity() {
      return intensity;
    }

    public void setIntensity(@Nullable Double setterArg) {
      this.intensity = setterArg;
    }

    /** Transition property for `intensity` */
    private @Nullable TransitionOptions intensityTransition;

    public @Nullable TransitionOptions getIntensityTransition() {
      return intensityTransition;
    }

    public void setIntensityTransition(@Nullable TransitionOptions setterArg) {
      this.intensityTransition = setterArg;
    }

    /** Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0 degree (0 degree when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0 degree when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0 degree, directly above, to 180 degree, directly below). */
    private @Nullable List<Double> position;

    public @Nullable List<Double> getPosition() {
      return position;
    }

    public void setPosition(@Nullable List<Double> setterArg) {
      this.position = setterArg;
    }

    /** Transition property for `position` */
    private @Nullable TransitionOptions positionTransition;

    public @Nullable TransitionOptions getPositionTransition() {
      return positionTransition;
    }

    public void setPositionTransition(@Nullable TransitionOptions setterArg) {
      this.positionTransition = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    FlatLight() {}

    public static final class Builder {

      private @Nullable String id;

      @CanIgnoreReturnValue
      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable Anchor anchor;

      @CanIgnoreReturnValue
      public @NonNull Builder setAnchor(@Nullable Anchor setterArg) {
        this.anchor = setterArg;
        return this;
      }

      private @Nullable Long color;

      @CanIgnoreReturnValue
      public @NonNull Builder setColor(@Nullable Long setterArg) {
        this.color = setterArg;
        return this;
      }

      private @Nullable TransitionOptions colorTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setColorTransition(@Nullable TransitionOptions setterArg) {
        this.colorTransition = setterArg;
        return this;
      }

      private @Nullable Double intensity;

      @CanIgnoreReturnValue
      public @NonNull Builder setIntensity(@Nullable Double setterArg) {
        this.intensity = setterArg;
        return this;
      }

      private @Nullable TransitionOptions intensityTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setIntensityTransition(@Nullable TransitionOptions setterArg) {
        this.intensityTransition = setterArg;
        return this;
      }

      private @Nullable List<Double> position;

      @CanIgnoreReturnValue
      public @NonNull Builder setPosition(@Nullable List<Double> setterArg) {
        this.position = setterArg;
        return this;
      }

      private @Nullable TransitionOptions positionTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setPositionTransition(@Nullable TransitionOptions setterArg) {
        this.positionTransition = setterArg;
        return this;
      }

      public @NonNull FlatLight build() {
        FlatLight pigeonReturn = new FlatLight();
        pigeonReturn.setId(id);
        pigeonReturn.setAnchor(anchor);
        pigeonReturn.setColor(color);
        pigeonReturn.setColorTransition(colorTransition);
        pigeonReturn.setIntensity(intensity);
        pigeonReturn.setIntensityTransition(intensityTransition);
        pigeonReturn.setPosition(position);
        pigeonReturn.setPositionTransition(positionTransition);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(8);
      toListResult.add(id);
      toListResult.add(anchor == null ? null : anchor.index);
      toListResult.add(color);
      toListResult.add((colorTransition == null) ? null : colorTransition.toList());
      toListResult.add(intensity);
      toListResult.add((intensityTransition == null) ? null : intensityTransition.toList());
      toListResult.add(position);
      toListResult.add((positionTransition == null) ? null : positionTransition.toList());
      return toListResult;
    }

    static @NonNull FlatLight fromList(@NonNull ArrayList<Object> list) {
      FlatLight pigeonResult = new FlatLight();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object anchor = list.get(1);
      pigeonResult.setAnchor(anchor == null ? null : Anchor.values()[(int) anchor]);
      Object color = list.get(2);
      pigeonResult.setColor((color == null) ? null : ((color instanceof Integer) ? (Integer) color : (Long) color));
      Object colorTransition = list.get(3);
      pigeonResult.setColorTransition((colorTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) colorTransition));
      Object intensity = list.get(4);
      pigeonResult.setIntensity((Double) intensity);
      Object intensityTransition = list.get(5);
      pigeonResult.setIntensityTransition((intensityTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) intensityTransition));
      Object position = list.get(6);
      pigeonResult.setPosition((List<Double>) position);
      Object positionTransition = list.get(7);
      pigeonResult.setPositionTransition((positionTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) positionTransition));
      return pigeonResult;
    }
  }

  /**
   * A light that has a direction and is located at infinite, so its rays are parallel. Simulates the sun light and it can cast shadows
   *
   * - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class DirectionalLight {
    /** Unique light name */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** Enable/Disable shadow casting for this light */
    private @Nullable Boolean castShadows;

    public @Nullable Boolean getCastShadows() {
      return castShadows;
    }

    public void setCastShadows(@Nullable Boolean setterArg) {
      this.castShadows = setterArg;
    }

    /** Color of the directional light. */
    private @Nullable Long color;

    public @Nullable Long getColor() {
      return color;
    }

    public void setColor(@Nullable Long setterArg) {
      this.color = setterArg;
    }

    /** Transition property for `color` */
    private @Nullable TransitionOptions colorTransition;

    public @Nullable TransitionOptions getColorTransition() {
      return colorTransition;
    }

    public void setColorTransition(@Nullable TransitionOptions setterArg) {
      this.colorTransition = setterArg;
    }

    /** Direction of the light source specified as [a azimuthal angle, p polar angle] where a indicates the azimuthal angle of the light relative to north (in degrees and proceeding clockwise), and p indicates polar angle of the light (from 0 degree, directly above, to 180 degree, directly below). */
    private @Nullable List<Double> direction;

    public @Nullable List<Double> getDirection() {
      return direction;
    }

    public void setDirection(@Nullable List<Double> setterArg) {
      this.direction = setterArg;
    }

    /** Transition property for `direction` */
    private @Nullable TransitionOptions directionTransition;

    public @Nullable TransitionOptions getDirectionTransition() {
      return directionTransition;
    }

    public void setDirectionTransition(@Nullable TransitionOptions setterArg) {
      this.directionTransition = setterArg;
    }

    /** A multiplier for the color of the directional light. */
    private @Nullable Double intensity;

    public @Nullable Double getIntensity() {
      return intensity;
    }

    public void setIntensity(@Nullable Double setterArg) {
      this.intensity = setterArg;
    }

    /** Transition property for `intensity` */
    private @Nullable TransitionOptions intensityTransition;

    public @Nullable TransitionOptions getIntensityTransition() {
      return intensityTransition;
    }

    public void setIntensityTransition(@Nullable TransitionOptions setterArg) {
      this.intensityTransition = setterArg;
    }

    /** Determines the shadow strength, affecting the shadow receiver surfaces final color. Values near 0.0 reduce the shadow contribution to the final color. Values near to 1.0 make occluded surfaces receive almost no directional light. Designed to be used mostly for transitioning between values 0 and 1. */
    private @Nullable Double shadowIntensity;

    public @Nullable Double getShadowIntensity() {
      return shadowIntensity;
    }

    public void setShadowIntensity(@Nullable Double setterArg) {
      this.shadowIntensity = setterArg;
    }

    /** Transition property for `shadowIntensity` */
    private @Nullable TransitionOptions shadowIntensityTransition;

    public @Nullable TransitionOptions getShadowIntensityTransition() {
      return shadowIntensityTransition;
    }

    public void setShadowIntensityTransition(@Nullable TransitionOptions setterArg) {
      this.shadowIntensityTransition = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    DirectionalLight() {}

    public static final class Builder {

      private @Nullable String id;

      @CanIgnoreReturnValue
      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable Boolean castShadows;

      @CanIgnoreReturnValue
      public @NonNull Builder setCastShadows(@Nullable Boolean setterArg) {
        this.castShadows = setterArg;
        return this;
      }

      private @Nullable Long color;

      @CanIgnoreReturnValue
      public @NonNull Builder setColor(@Nullable Long setterArg) {
        this.color = setterArg;
        return this;
      }

      private @Nullable TransitionOptions colorTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setColorTransition(@Nullable TransitionOptions setterArg) {
        this.colorTransition = setterArg;
        return this;
      }

      private @Nullable List<Double> direction;

      @CanIgnoreReturnValue
      public @NonNull Builder setDirection(@Nullable List<Double> setterArg) {
        this.direction = setterArg;
        return this;
      }

      private @Nullable TransitionOptions directionTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setDirectionTransition(@Nullable TransitionOptions setterArg) {
        this.directionTransition = setterArg;
        return this;
      }

      private @Nullable Double intensity;

      @CanIgnoreReturnValue
      public @NonNull Builder setIntensity(@Nullable Double setterArg) {
        this.intensity = setterArg;
        return this;
      }

      private @Nullable TransitionOptions intensityTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setIntensityTransition(@Nullable TransitionOptions setterArg) {
        this.intensityTransition = setterArg;
        return this;
      }

      private @Nullable Double shadowIntensity;

      @CanIgnoreReturnValue
      public @NonNull Builder setShadowIntensity(@Nullable Double setterArg) {
        this.shadowIntensity = setterArg;
        return this;
      }

      private @Nullable TransitionOptions shadowIntensityTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setShadowIntensityTransition(@Nullable TransitionOptions setterArg) {
        this.shadowIntensityTransition = setterArg;
        return this;
      }

      public @NonNull DirectionalLight build() {
        DirectionalLight pigeonReturn = new DirectionalLight();
        pigeonReturn.setId(id);
        pigeonReturn.setCastShadows(castShadows);
        pigeonReturn.setColor(color);
        pigeonReturn.setColorTransition(colorTransition);
        pigeonReturn.setDirection(direction);
        pigeonReturn.setDirectionTransition(directionTransition);
        pigeonReturn.setIntensity(intensity);
        pigeonReturn.setIntensityTransition(intensityTransition);
        pigeonReturn.setShadowIntensity(shadowIntensity);
        pigeonReturn.setShadowIntensityTransition(shadowIntensityTransition);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(10);
      toListResult.add(id);
      toListResult.add(castShadows);
      toListResult.add(color);
      toListResult.add((colorTransition == null) ? null : colorTransition.toList());
      toListResult.add(direction);
      toListResult.add((directionTransition == null) ? null : directionTransition.toList());
      toListResult.add(intensity);
      toListResult.add((intensityTransition == null) ? null : intensityTransition.toList());
      toListResult.add(shadowIntensity);
      toListResult.add((shadowIntensityTransition == null) ? null : shadowIntensityTransition.toList());
      return toListResult;
    }

    static @NonNull DirectionalLight fromList(@NonNull ArrayList<Object> list) {
      DirectionalLight pigeonResult = new DirectionalLight();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object castShadows = list.get(1);
      pigeonResult.setCastShadows((Boolean) castShadows);
      Object color = list.get(2);
      pigeonResult.setColor((color == null) ? null : ((color instanceof Integer) ? (Integer) color : (Long) color));
      Object colorTransition = list.get(3);
      pigeonResult.setColorTransition((colorTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) colorTransition));
      Object direction = list.get(4);
      pigeonResult.setDirection((List<Double>) direction);
      Object directionTransition = list.get(5);
      pigeonResult.setDirectionTransition((directionTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) directionTransition));
      Object intensity = list.get(6);
      pigeonResult.setIntensity((Double) intensity);
      Object intensityTransition = list.get(7);
      pigeonResult.setIntensityTransition((intensityTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) intensityTransition));
      Object shadowIntensity = list.get(8);
      pigeonResult.setShadowIntensity((Double) shadowIntensity);
      Object shadowIntensityTransition = list.get(9);
      pigeonResult.setShadowIntensityTransition((shadowIntensityTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) shadowIntensityTransition));
      return pigeonResult;
    }
  }

  /**
   * An indirect light affecting all objects in the map adding a constant amount of light on them. It has no explicit direction and cannot cast shadows.
   *
   * - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class AmbientLight {
    /** Unique light name */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** Color of the ambient light. */
    private @Nullable Long color;

    public @Nullable Long getColor() {
      return color;
    }

    public void setColor(@Nullable Long setterArg) {
      this.color = setterArg;
    }

    /** Transition property for `color` */
    private @Nullable TransitionOptions colorTransition;

    public @Nullable TransitionOptions getColorTransition() {
      return colorTransition;
    }

    public void setColorTransition(@Nullable TransitionOptions setterArg) {
      this.colorTransition = setterArg;
    }

    /** A multiplier for the color of the ambient light. */
    private @Nullable Double intensity;

    public @Nullable Double getIntensity() {
      return intensity;
    }

    public void setIntensity(@Nullable Double setterArg) {
      this.intensity = setterArg;
    }

    /** Transition property for `intensity` */
    private @Nullable TransitionOptions intensityTransition;

    public @Nullable TransitionOptions getIntensityTransition() {
      return intensityTransition;
    }

    public void setIntensityTransition(@Nullable TransitionOptions setterArg) {
      this.intensityTransition = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    AmbientLight() {}

    public static final class Builder {

      private @Nullable String id;

      @CanIgnoreReturnValue
      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable Long color;

      @CanIgnoreReturnValue
      public @NonNull Builder setColor(@Nullable Long setterArg) {
        this.color = setterArg;
        return this;
      }

      private @Nullable TransitionOptions colorTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setColorTransition(@Nullable TransitionOptions setterArg) {
        this.colorTransition = setterArg;
        return this;
      }

      private @Nullable Double intensity;

      @CanIgnoreReturnValue
      public @NonNull Builder setIntensity(@Nullable Double setterArg) {
        this.intensity = setterArg;
        return this;
      }

      private @Nullable TransitionOptions intensityTransition;

      @CanIgnoreReturnValue
      public @NonNull Builder setIntensityTransition(@Nullable TransitionOptions setterArg) {
        this.intensityTransition = setterArg;
        return this;
      }

      public @NonNull AmbientLight build() {
        AmbientLight pigeonReturn = new AmbientLight();
        pigeonReturn.setId(id);
        pigeonReturn.setColor(color);
        pigeonReturn.setColorTransition(colorTransition);
        pigeonReturn.setIntensity(intensity);
        pigeonReturn.setIntensityTransition(intensityTransition);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(id);
      toListResult.add(color);
      toListResult.add((colorTransition == null) ? null : colorTransition.toList());
      toListResult.add(intensity);
      toListResult.add((intensityTransition == null) ? null : intensityTransition.toList());
      return toListResult;
    }

    static @NonNull AmbientLight fromList(@NonNull ArrayList<Object> list) {
      AmbientLight pigeonResult = new AmbientLight();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object color = list.get(1);
      pigeonResult.setColor((color == null) ? null : ((color instanceof Integer) ? (Integer) color : (Long) color));
      Object colorTransition = list.get(2);
      pigeonResult.setColorTransition((colorTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) colorTransition));
      Object intensity = list.get(3);
      pigeonResult.setIntensity((Double) intensity);
      Object intensityTransition = list.get(4);
      pigeonResult.setIntensityTransition((intensityTransition == null) ? null : TransitionOptions.fromList((ArrayList<Object>) intensityTransition));
      return pigeonResult;
    }
  }

  /**
   * Image type.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MbxImage {
    /** The width of the image, in screen pixels. */
    private @NonNull Long width;

    public @NonNull Long getWidth() {
      return width;
    }

    public void setWidth(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"width\" is null.");
      }
      this.width = setterArg;
    }

    /** The height of the image, in screen pixels. */
    private @NonNull Long height;

    public @NonNull Long getHeight() {
      return height;
    }

    public void setHeight(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"height\" is null.");
      }
      this.height = setterArg;
    }

    /**
     * 32-bit premultiplied RGBA image data.
     *
     * An uncompressed image data encoded in 32-bit RGBA format with premultiplied
     * alpha channel. This field should contain exactly `4 * width * height` bytes. It
     * should consist of a sequence of scanlines.
     */
    private @NonNull byte[] data;

    public @NonNull byte[] getData() {
      return data;
    }

    public void setData(@NonNull byte[] setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"data\" is null.");
      }
      this.data = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MbxImage() {}

    public static final class Builder {

      private @Nullable Long width;

      @CanIgnoreReturnValue
      public @NonNull Builder setWidth(@NonNull Long setterArg) {
        this.width = setterArg;
        return this;
      }

      private @Nullable Long height;

      @CanIgnoreReturnValue
      public @NonNull Builder setHeight(@NonNull Long setterArg) {
        this.height = setterArg;
        return this;
      }

      private @Nullable byte[] data;

      @CanIgnoreReturnValue
      public @NonNull Builder setData(@NonNull byte[] setterArg) {
        this.data = setterArg;
        return this;
      }

      public @NonNull MbxImage build() {
        MbxImage pigeonReturn = new MbxImage();
        pigeonReturn.setWidth(width);
        pigeonReturn.setHeight(height);
        pigeonReturn.setData(data);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(width);
      toListResult.add(height);
      toListResult.add(data);
      return toListResult;
    }

    static @NonNull MbxImage fromList(@NonNull ArrayList<Object> list) {
      MbxImage pigeonResult = new MbxImage();
      Object width = list.get(0);
      pigeonResult.setWidth((width == null) ? null : ((width instanceof Integer) ? (Integer) width : (Long) width));
      Object height = list.get(1);
      pigeonResult.setHeight((height == null) ? null : ((height instanceof Integer) ? (Integer) height : (Long) height));
      Object data = list.get(2);
      pigeonResult.setData((byte[]) data);
      return pigeonResult;
    }
  }

  /**
   * Describes the image stretch areas.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ImageStretches {
    /** The first stretchable part in screen pixel units. */
    private @NonNull Double first;

    public @NonNull Double getFirst() {
      return first;
    }

    public void setFirst(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"first\" is null.");
      }
      this.first = setterArg;
    }

    /** The second stretchable part in screen pixel units. */
    private @NonNull Double second;

    public @NonNull Double getSecond() {
      return second;
    }

    public void setSecond(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"second\" is null.");
      }
      this.second = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ImageStretches() {}

    public static final class Builder {

      private @Nullable Double first;

      @CanIgnoreReturnValue
      public @NonNull Builder setFirst(@NonNull Double setterArg) {
        this.first = setterArg;
        return this;
      }

      private @Nullable Double second;

      @CanIgnoreReturnValue
      public @NonNull Builder setSecond(@NonNull Double setterArg) {
        this.second = setterArg;
        return this;
      }

      public @NonNull ImageStretches build() {
        ImageStretches pigeonReturn = new ImageStretches();
        pigeonReturn.setFirst(first);
        pigeonReturn.setSecond(second);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(first);
      toListResult.add(second);
      return toListResult;
    }

    static @NonNull ImageStretches fromList(@NonNull ArrayList<Object> list) {
      ImageStretches pigeonResult = new ImageStretches();
      Object first = list.get(0);
      pigeonResult.setFirst((Double) first);
      Object second = list.get(1);
      pigeonResult.setSecond((Double) second);
      return pigeonResult;
    }
  }

  /**
   * Describes the image content, e.g. where text can be fit into an image.
   *
   * When sizing icons with `icon-text-fit`, the icon size will be adjusted so that the this content box fits exactly around the text.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ImageContent {
    /** Distance to the left, in screen pixels. */
    private @NonNull Double left;

    public @NonNull Double getLeft() {
      return left;
    }

    public void setLeft(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"left\" is null.");
      }
      this.left = setterArg;
    }

    /** Distance to the top, in screen pixels. */
    private @NonNull Double top;

    public @NonNull Double getTop() {
      return top;
    }

    public void setTop(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"top\" is null.");
      }
      this.top = setterArg;
    }

    /** Distance to the right, in screen pixels. */
    private @NonNull Double right;

    public @NonNull Double getRight() {
      return right;
    }

    public void setRight(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"right\" is null.");
      }
      this.right = setterArg;
    }

    /** Distance to the bottom, in screen pixels. */
    private @NonNull Double bottom;

    public @NonNull Double getBottom() {
      return bottom;
    }

    public void setBottom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bottom\" is null.");
      }
      this.bottom = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ImageContent() {}

    public static final class Builder {

      private @Nullable Double left;

      @CanIgnoreReturnValue
      public @NonNull Builder setLeft(@NonNull Double setterArg) {
        this.left = setterArg;
        return this;
      }

      private @Nullable Double top;

      @CanIgnoreReturnValue
      public @NonNull Builder setTop(@NonNull Double setterArg) {
        this.top = setterArg;
        return this;
      }

      private @Nullable Double right;

      @CanIgnoreReturnValue
      public @NonNull Builder setRight(@NonNull Double setterArg) {
        this.right = setterArg;
        return this;
      }

      private @Nullable Double bottom;

      @CanIgnoreReturnValue
      public @NonNull Builder setBottom(@NonNull Double setterArg) {
        this.bottom = setterArg;
        return this;
      }

      public @NonNull ImageContent build() {
        ImageContent pigeonReturn = new ImageContent();
        pigeonReturn.setLeft(left);
        pigeonReturn.setTop(top);
        pigeonReturn.setRight(right);
        pigeonReturn.setBottom(bottom);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(left);
      toListResult.add(top);
      toListResult.add(right);
      toListResult.add(bottom);
      return toListResult;
    }

    static @NonNull ImageContent fromList(@NonNull ArrayList<Object> list) {
      ImageContent pigeonResult = new ImageContent();
      Object left = list.get(0);
      pigeonResult.setLeft((Double) left);
      Object top = list.get(1);
      pigeonResult.setTop((Double) top);
      Object right = list.get(2);
      pigeonResult.setRight((Double) right);
      Object bottom = list.get(3);
      pigeonResult.setBottom((Double) bottom);
      return pigeonResult;
    }
  }

  /**
   * The `transition options` controls timing for the interpolation between a transitionable style
   * property's previous value and new value. These can be used to define the style default property
   * transition behavior. Also, any transitionable style property may also have its own `-transition`
   * property that defines specific transition timing for that specific layer property, overriding
   * the global transition values.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class TransitionOptions {
    /** Time allotted for transitions to complete. Units in milliseconds. Defaults to `300.0`. */
    private @Nullable Long duration;

    public @Nullable Long getDuration() {
      return duration;
    }

    public void setDuration(@Nullable Long setterArg) {
      this.duration = setterArg;
    }

    /** Length of time before a transition begins. Units in milliseconds. Defaults to `0.0`. */
    private @Nullable Long delay;

    public @Nullable Long getDelay() {
      return delay;
    }

    public void setDelay(@Nullable Long setterArg) {
      this.delay = setterArg;
    }

    /** Whether the fade in/out symbol placement transition is enabled. Defaults to `true`. */
    private @Nullable Boolean enablePlacementTransitions;

    public @Nullable Boolean getEnablePlacementTransitions() {
      return enablePlacementTransitions;
    }

    public void setEnablePlacementTransitions(@Nullable Boolean setterArg) {
      this.enablePlacementTransitions = setterArg;
    }

    public static final class Builder {

      private @Nullable Long duration;

      @CanIgnoreReturnValue
      public @NonNull Builder setDuration(@Nullable Long setterArg) {
        this.duration = setterArg;
        return this;
      }

      private @Nullable Long delay;

      @CanIgnoreReturnValue
      public @NonNull Builder setDelay(@Nullable Long setterArg) {
        this.delay = setterArg;
        return this;
      }

      private @Nullable Boolean enablePlacementTransitions;

      @CanIgnoreReturnValue
      public @NonNull Builder setEnablePlacementTransitions(@Nullable Boolean setterArg) {
        this.enablePlacementTransitions = setterArg;
        return this;
      }

      public @NonNull TransitionOptions build() {
        TransitionOptions pigeonReturn = new TransitionOptions();
        pigeonReturn.setDuration(duration);
        pigeonReturn.setDelay(delay);
        pigeonReturn.setEnablePlacementTransitions(enablePlacementTransitions);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(duration);
      toListResult.add(delay);
      toListResult.add(enablePlacementTransitions);
      return toListResult;
    }

    static @NonNull TransitionOptions fromList(@NonNull ArrayList<Object> list) {
      TransitionOptions pigeonResult = new TransitionOptions();
      Object duration = list.get(0);
      pigeonResult.setDuration((duration == null) ? null : ((duration instanceof Integer) ? (Integer) duration : (Long) duration));
      Object delay = list.get(1);
      pigeonResult.setDelay((delay == null) ? null : ((delay instanceof Integer) ? (Integer) delay : (Long) delay));
      Object enablePlacementTransitions = list.get(2);
      pigeonResult.setEnablePlacementTransitions((Boolean) enablePlacementTransitions);
      return pigeonResult;
    }
  }

  /**
   * Represents a tile coordinate.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CanonicalTileID {
    /** The z value of the coordinate (zoom-level). */
    private @NonNull Long z;

    public @NonNull Long getZ() {
      return z;
    }

    public void setZ(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"z\" is null.");
      }
      this.z = setterArg;
    }

    /** The x value of the coordinate. */
    private @NonNull Long x;

    public @NonNull Long getX() {
      return x;
    }

    public void setX(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** The y value of the coordinate. */
    private @NonNull Long y;

    public @NonNull Long getY() {
      return y;
    }

    public void setY(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CanonicalTileID() {}

    public static final class Builder {

      private @Nullable Long z;

      @CanIgnoreReturnValue
      public @NonNull Builder setZ(@NonNull Long setterArg) {
        this.z = setterArg;
        return this;
      }

      private @Nullable Long x;

      @CanIgnoreReturnValue
      public @NonNull Builder setX(@NonNull Long setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Long y;

      @CanIgnoreReturnValue
      public @NonNull Builder setY(@NonNull Long setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull CanonicalTileID build() {
        CanonicalTileID pigeonReturn = new CanonicalTileID();
        pigeonReturn.setZ(z);
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(z);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull CanonicalTileID fromList(@NonNull ArrayList<Object> list) {
      CanonicalTileID pigeonResult = new CanonicalTileID();
      Object z = list.get(0);
      pigeonResult.setZ((z == null) ? null : ((z instanceof Integer) ? (Integer) z : (Long) z));
      Object x = list.get(1);
      pigeonResult.setX((x == null) ? null : ((x instanceof Integer) ? (Integer) x : (Long) x));
      Object y = list.get(2);
      pigeonResult.setY((y == null) ? null : ((y instanceof Integer) ? (Integer) y : (Long) y));
      return pigeonResult;
    }
  }

  /**
   * Holds a style property value with meta data.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class StylePropertyValue {
    /** The property value. */
    private @Nullable Object value;

    public @Nullable Object getValue() {
      return value;
    }

    public void setValue(@Nullable Object setterArg) {
      this.value = setterArg;
    }

    /** The kind of the property value. */
    private @NonNull StylePropertyValueKind kind;

    public @NonNull StylePropertyValueKind getKind() {
      return kind;
    }

    public void setKind(@NonNull StylePropertyValueKind setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"kind\" is null.");
      }
      this.kind = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    StylePropertyValue() {}

    public static final class Builder {

      private @Nullable Object value;

      @CanIgnoreReturnValue
      public @NonNull Builder setValue(@Nullable Object setterArg) {
        this.value = setterArg;
        return this;
      }

      private @Nullable StylePropertyValueKind kind;

      @CanIgnoreReturnValue
      public @NonNull Builder setKind(@NonNull StylePropertyValueKind setterArg) {
        this.kind = setterArg;
        return this;
      }

      public @NonNull StylePropertyValue build() {
        StylePropertyValue pigeonReturn = new StylePropertyValue();
        pigeonReturn.setValue(value);
        pigeonReturn.setKind(kind);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(value);
      toListResult.add(kind == null ? null : kind.index);
      return toListResult;
    }

    static @NonNull StylePropertyValue fromList(@NonNull ArrayList<Object> list) {
      StylePropertyValue pigeonResult = new StylePropertyValue();
      Object value = list.get(0);
      pigeonResult.setValue(value);
      Object kind = list.get(1);
      pigeonResult.setKind(StylePropertyValueKind.values()[(int) kind]);
      return pigeonResult;
    }
  }

  /** Asynchronous error handling return type for non-nullable API method returns. */
  public interface Result<T> {
    /** Success case callback method for handling returns. */
    void success(@NonNull T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for nullable API method returns. */
  public interface NullableResult<T> {
    /** Success case callback method for handling returns. */
    void success(@Nullable T result);

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }
  /** Asynchronous error handling return type for void API method returns. */
  public interface VoidResult {
    /** Success case callback method for handling returns. */
    void success();

    /** Failure case callback method for handling errors. */
    void error(@NonNull Throwable error);
  }

  private static class _AnimationManagerCodec extends StandardMessageCodec {
    public static final _AnimationManagerCodec INSTANCE = new _AnimationManagerCodec();

    private _AnimationManagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraOptions) {
        stream.write(128);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(129);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(130);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(131);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(132);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Interface for managing animation.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _AnimationManager {

    void easeTo(@NonNull CameraOptions cameraOptions, @Nullable MapAnimationOptions mapAnimationOptions);

    void flyTo(@NonNull CameraOptions cameraOptions, @Nullable MapAnimationOptions mapAnimationOptions);

    void pitchBy(@NonNull Double pitch, @Nullable MapAnimationOptions mapAnimationOptions);

    void scaleBy(@NonNull Double amount, @Nullable ScreenCoordinate screenCoordinate, @Nullable MapAnimationOptions mapAnimationOptions);

    void moveBy(@NonNull ScreenCoordinate screenCoordinate, @Nullable MapAnimationOptions mapAnimationOptions);

    void rotateBy(@NonNull ScreenCoordinate first, @NonNull ScreenCoordinate second, @Nullable MapAnimationOptions mapAnimationOptions);

    void cancelCameraAnimation();

    /** The codec used by _AnimationManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _AnimationManagerCodec.INSTANCE;
    }
    /**Sets up an instance of `_AnimationManager` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _AnimationManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraOptionsArg = (CameraOptions) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.easeTo(cameraOptionsArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraOptionsArg = (CameraOptions) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.flyTo(cameraOptionsArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Double pitchArg = (Double) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.pitchBy(pitchArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Double amountArg = (Double) args.get(0);
                ScreenCoordinate screenCoordinateArg = (ScreenCoordinate) args.get(1);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(2);
                try {
                  api.scaleBy(amountArg, screenCoordinateArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate screenCoordinateArg = (ScreenCoordinate) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.moveBy(screenCoordinateArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate firstArg = (ScreenCoordinate) args.get(0);
                ScreenCoordinate secondArg = (ScreenCoordinate) args.get(1);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(2);
                try {
                  api.rotateBy(firstArg, secondArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.cancelCameraAnimation();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class _CameraManagerCodec extends StandardMessageCodec {
    public static final _CameraManagerCodec INSTANCE = new _CameraManagerCodec();

    private _CameraManagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AmbientLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return DirectionalLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return FlatLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return QueriedRenderedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return QueriedSourceFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 162:
          return StyleProjection.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 163:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 164:
          return TileCacheBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 165:
          return TileCacheBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 166:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AmbientLight) {
        stream.write(128);
        writeValue(stream, ((AmbientLight) value).toList());
      } else if (value instanceof CameraBounds) {
        stream.write(129);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(130);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(131);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(132);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(133);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(134);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(135);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof DirectionalLight) {
        stream.write(136);
        writeValue(stream, ((DirectionalLight) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(137);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof FlatLight) {
        stream.write(138);
        writeValue(stream, ((FlatLight) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(139);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(140);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(141);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(142);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(143);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(144);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(145);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(146);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(147);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(148);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(150);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(151);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(152);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof QueriedRenderedFeature) {
        stream.write(153);
        writeValue(stream, ((QueriedRenderedFeature) value).toList());
      } else if (value instanceof QueriedSourceFeature) {
        stream.write(154);
        writeValue(stream, ((QueriedSourceFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(155);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(156);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(157);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(158);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(159);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(160);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(161);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StyleProjection) {
        stream.write(162);
        writeValue(stream, ((StyleProjection) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(163);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TileCacheBudgetInMegabytes) {
        stream.write(164);
        writeValue(stream, ((TileCacheBudgetInMegabytes) value).toList());
      } else if (value instanceof TileCacheBudgetInTiles) {
        stream.write(165);
        writeValue(stream, ((TileCacheBudgetInTiles) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(166);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Interface for managing camera.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _CameraManager {
    /**
     * Convenience method that returns a `camera options` object for the given parameters.
     *
     * @param coordinates The `coordinates` representing the bounds of the camera.
     * @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
     * If any of the fields in camera options is not provided then the current value from the map for that field will be used.
     * @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
     * This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
     * @param maxZoom The maximum zoom level allowed in the returned camera options.
     * @param offset The center of the given bounds relative to map center in screen points.
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForCoordinatesPadding(@NonNull List<Map<String, Object>> coordinates, @NonNull CameraOptions camera, @Nullable MbxEdgeInsets coordinatesPadding, @Nullable Double maxZoom, @Nullable ScreenCoordinate offset);
    /**
     * Convenience method that returns the `camera options` object for given parameters.
     *
     * @param bounds The `coordinate bounds` of the camera.
     * @param padding The `edge insets` of the camera.
     * @param bearing The bearing of the camera.
     * @param pitch The pitch of the camera.
     * @param maxZoom The maximum zoom level allowed in the returned camera options.
     * @param offset The center of the given bounds relative to map center in screen points.
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForCoordinateBounds(@NonNull CoordinateBounds bounds, @Nullable MbxEdgeInsets padding, @Nullable Double bearing, @Nullable Double pitch, @Nullable Double maxZoom, @Nullable ScreenCoordinate offset);
    /**
     * Convenience method that returns the `camera options` object for given parameters.
     *
     * @param coordinates The `coordinates` representing the bounds of the camera.
     * @param padding The `edge insets` of the camera.
     * @param bearing The bearing of the camera.
     * @param pitch The pitch of the camera.
     *
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForCoordinates(@NonNull List<Map<String, Object>> coordinates, @Nullable MbxEdgeInsets padding, @Nullable Double bearing, @Nullable Double pitch);
    /**
     * Convenience method that adjusts the provided `camera options` object for given parameters.
     *
     * Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
     * top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
     * Returns the provided `camera` options object unchanged upon an error.
     * Note that this method may fail if the principal point of the projection is not inside the `box` or
     * if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
     *
     * @param coordinates The `coordinates` representing the bounds of the camera.
     * @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
     * @param box The `screen box` into which `coordinates` should fit.
     *
     * @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
     */
    @NonNull 
    CameraOptions cameraForCoordinatesCameraOptions(@NonNull List<Map<String, Object>> coordinates, @NonNull CameraOptions camera, @NonNull ScreenBox box);
    /**
     * Convenience method that returns the `camera options` object for given parameters.
     *
     * @param geometry The `geometry` representing the bounds of the camera.
     * @param padding The `edge insets` of the camera.
     * @param bearing The bearing of the camera.
     * @param pitch The pitch of the camera.
     *
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForGeometry(@NonNull Map<String, Object> geometry, @NonNull MbxEdgeInsets padding, @Nullable Double bearing, @Nullable Double pitch);
    /**
     * Returns the `coordinate bounds` for a given camera.
     *
     * Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
     * might not represent the minimum bounding box.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds`.
     *
     * @return The `coordinate bounds` object representing a given `camera`.
     *
     */
    @NonNull 
    CoordinateBounds coordinateBoundsForCamera(@NonNull CameraOptions camera);
    /**
     * Returns the `coordinate bounds` for a given camera.
     *
     * This method is useful if the `camera` shows the antimeridian.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds`.
     *
     * @return The `coordinate bounds` object representing a given `camera`.
     *
     */
    @NonNull 
    CoordinateBounds coordinateBoundsForCameraUnwrapped(@NonNull CameraOptions camera);
    /**
     * Returns the `coordinate bounds` and the `zoom` for a given `camera`.
     *
     * Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
     * might not represent the minimum bounding box.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
     *
     * @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
     *
     */
    @NonNull 
    CoordinateBoundsZoom coordinateBoundsZoomForCamera(@NonNull CameraOptions camera);
    /**
     * Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
     *
     * This method is useful if the `camera` shows the antimeridian.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
     *
     * @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
     *
     */
    @NonNull 
    CoordinateBoundsZoom coordinateBoundsZoomForCameraUnwrapped(@NonNull CameraOptions camera);
    /**
     * Calculates a `screen coordinate` that corresponds to a geographical coordinate
     * (i.e., longitude-latitude pair).
     *
     * The `screen coordinate` is in `logical pixels` relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
     *
     * @return A `screen coordinate` on the screen in `logical pixels`.
     */
    @NonNull 
    ScreenCoordinate pixelForCoordinate(@NonNull Map<String, Object> coordinate);
    /**
     * Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
     * to a `screen coordinate`.
     *
     * The screen coordinate is in `logical pixels`relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param pixel A `screen coordinate` on the screen in `logical pixels`.
     *
     * @return A geographical `coordinate` corresponding to a given `screen coordinate`.
     */
    @NonNull 
    Map<String, Object> coordinateForPixel(@NonNull ScreenCoordinate pixel);
    /**
     * Calculates `screen coordinates` that correspond to geographical `coordinates`
     * (i.e., longitude-latitude pairs).
     *
     * The `screen coordinates` are in `logical pixels` relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
     *
     * @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
     */
    @NonNull 
    List<ScreenCoordinate> pixelsForCoordinates(@NonNull List<Map<String, Object>> coordinates);
    /**
     * Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
     * to `screen coordinates`.
     *
     * The screen coordinates are in `logical pixels` relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param pixels A `screen coordinates` in `logical pixels`.
     *
     * @return A `geographical coordinates` that correspond to a given `screen coordinates`.
     */
    @NonNull 
    List<Map<String, Object>> coordinatesForPixels(@NonNull List<ScreenCoordinate> pixels);
    /**
     * Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
     * The map will retain its current values for any details not passed via the camera options argument.
     * It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
     * different `camera state`.
     *
     * @param cameraOptions The new `camera options` to be set.
     */
    void setCamera(@NonNull CameraOptions cameraOptions);
    /**
     * Returns the current `camera state`.
     *
     * @return The current `camera state`.
     */
    @NonNull 
    CameraState getCameraState();
    /**
     * Sets the `camera bounds options` of the map. The map will retain its current values for any
     * details not passed via the camera bounds options arguments.
     * When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
     * zoom level of the camera, to prevent out of bounds areas to be visible.
     * Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
     *
     * @param options The `camera bounds options` to set.
     * @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
     */
    void setBounds(@NonNull CameraBoundsOptions options);
    /**
     * Returns the `camera bounds` of the map.
     * @return A `camera bounds` of the map.
     */
    @NonNull 
    CameraBounds getBounds();

    /** The codec used by _CameraManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _CameraManagerCodec.INSTANCE;
    }
    /**Sets up an instance of `_CameraManager` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _CameraManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesPadding", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                CameraOptions cameraArg = (CameraOptions) args.get(1);
                MbxEdgeInsets coordinatesPaddingArg = (MbxEdgeInsets) args.get(2);
                Double maxZoomArg = (Double) args.get(3);
                ScreenCoordinate offsetArg = (ScreenCoordinate) args.get(4);
                try {
                  CameraOptions output = api.cameraForCoordinatesPadding(coordinatesArg, cameraArg, coordinatesPaddingArg, maxZoomArg, offsetArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CoordinateBounds boundsArg = (CoordinateBounds) args.get(0);
                MbxEdgeInsets paddingArg = (MbxEdgeInsets) args.get(1);
                Double bearingArg = (Double) args.get(2);
                Double pitchArg = (Double) args.get(3);
                Double maxZoomArg = (Double) args.get(4);
                ScreenCoordinate offsetArg = (ScreenCoordinate) args.get(5);
                try {
                  CameraOptions output = api.cameraForCoordinateBounds(boundsArg, paddingArg, bearingArg, pitchArg, maxZoomArg, offsetArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                MbxEdgeInsets paddingArg = (MbxEdgeInsets) args.get(1);
                Double bearingArg = (Double) args.get(2);
                Double pitchArg = (Double) args.get(3);
                try {
                  CameraOptions output = api.cameraForCoordinates(coordinatesArg, paddingArg, bearingArg, pitchArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                CameraOptions cameraArg = (CameraOptions) args.get(1);
                ScreenBox boxArg = (ScreenBox) args.get(2);
                try {
                  CameraOptions output = api.cameraForCoordinatesCameraOptions(coordinatesArg, cameraArg, boxArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> geometryArg = (Map<String, Object>) args.get(0);
                MbxEdgeInsets paddingArg = (MbxEdgeInsets) args.get(1);
                Double bearingArg = (Double) args.get(2);
                Double pitchArg = (Double) args.get(3);
                try {
                  CameraOptions output = api.cameraForGeometry(geometryArg, paddingArg, bearingArg, pitchArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBounds output = api.coordinateBoundsForCamera(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBounds output = api.coordinateBoundsForCameraUnwrapped(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBoundsZoom output = api.coordinateBoundsZoomForCamera(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBoundsZoom output = api.coordinateBoundsZoomForCameraUnwrapped(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  ScreenCoordinate output = api.pixelForCoordinate(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate pixelArg = (ScreenCoordinate) args.get(0);
                try {
                  Map<String, Object> output = api.coordinateForPixel(pixelArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                try {
                  List<ScreenCoordinate> output = api.pixelsForCoordinates(coordinatesArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<ScreenCoordinate> pixelsArg = (List<ScreenCoordinate>) args.get(0);
                try {
                  List<Map<String, Object>> output = api.coordinatesForPixels(pixelsArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraOptionsArg = (CameraOptions) args.get(0);
                try {
                  api.setCamera(cameraOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  CameraState output = api.getCameraState();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraBoundsOptions optionsArg = (CameraBoundsOptions) args.get(0);
                try {
                  api.setBounds(optionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  CameraBounds output = api.getBounds();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class _MapInterfaceCodec extends StandardMessageCodec {
    public static final _MapInterfaceCodec INSTANCE = new _MapInterfaceCodec();

    private _MapInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AmbientLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return DirectionalLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return FlatLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return QueriedRenderedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return QueriedSourceFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 162:
          return StyleProjection.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 163:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 164:
          return TileCacheBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 165:
          return TileCacheBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 166:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AmbientLight) {
        stream.write(128);
        writeValue(stream, ((AmbientLight) value).toList());
      } else if (value instanceof CameraBounds) {
        stream.write(129);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(130);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(131);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(132);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(133);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(134);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(135);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof DirectionalLight) {
        stream.write(136);
        writeValue(stream, ((DirectionalLight) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(137);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof FlatLight) {
        stream.write(138);
        writeValue(stream, ((FlatLight) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(139);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(140);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(141);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(142);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(143);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(144);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(145);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(146);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(147);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(148);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(150);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(151);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(152);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof QueriedRenderedFeature) {
        stream.write(153);
        writeValue(stream, ((QueriedRenderedFeature) value).toList());
      } else if (value instanceof QueriedSourceFeature) {
        stream.write(154);
        writeValue(stream, ((QueriedSourceFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(155);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(156);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(157);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(158);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(159);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(160);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(161);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StyleProjection) {
        stream.write(162);
        writeValue(stream, ((StyleProjection) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(163);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TileCacheBudgetInMegabytes) {
        stream.write(164);
        writeValue(stream, ((TileCacheBudgetInMegabytes) value).toList());
      } else if (value instanceof TileCacheBudgetInTiles) {
        stream.write(165);
        writeValue(stream, ((TileCacheBudgetInTiles) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(166);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Map class provides map rendering functionality.
   *
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _MapInterface {

    void loadStyleURI(@NonNull String styleURI, @NonNull VoidResult result);

    void loadStyleJson(@NonNull String styleJson, @NonNull VoidResult result);

    void clearData(@NonNull VoidResult result);

    void setTileCacheBudget(@Nullable TileCacheBudgetInMegabytes tileCacheBudgetInMegabytes, @Nullable TileCacheBudgetInTiles tileCacheBudgetInTiles);
    /**
     * Gets the size of the map.
     *
     * @return The `size` of the map in `logical pixels`.
     */
    @NonNull 
    Size getSize();
    /** Triggers a repaint of the map. */
    void triggerRepaint();
    /**
     * Tells the map rendering engine that there is currently a gesture in progress. This
     * affects how the map renders labels, as it will use different texture filters if a gesture
     * is ongoing.
     *
     * @param inProgress The `boolean` value representing if a gesture is in progress.
     */
    void setGestureInProgress(@NonNull Boolean inProgress);
    /**
     * Returns `true` if a gesture is currently in progress.
     *
     * @return `true` if a gesture is currently in progress, `false` otherwise.
     */
    @NonNull 
    Boolean isGestureInProgress();
    /**
     * Tells the map rendering engine that the animation is currently performed by the
     * user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
     * In particular, it brings more stability to symbol placement and rendering.
     *
     * @param inProgress The `boolean` value representing if user animation is in progress
     */
    void setUserAnimationInProgress(@NonNull Boolean inProgress);
    /**
     * Returns `true` if user animation is currently in progress.
     *
     * @return `true` if a user animation is currently in progress, `false` otherwise.
     */
    @NonNull 
    Boolean isUserAnimationInProgress();
    /**
     * When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
     * the map will first request a tile at zoom level lower than `zoom - delta`, with requested
     * zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
     *
     * @param delta The new prefetch zoom delta.
     */
    void setPrefetchZoomDelta(@NonNull Long delta);
    /**
     * Returns the map's prefetch zoom delta.
     *
     * @return The map's prefetch zoom `delta`.
     */
    @NonNull 
    Long getPrefetchZoomDelta();
    /** Sets the north `orientation mode`. */
    void setNorthOrientation(@NonNull NorthOrientation orientation);
    /** Sets the map `constrain mode`. */
    void setConstrainMode(@NonNull ConstrainMode mode);
    /** Sets the `viewport mode`. */
    void setViewportMode(@NonNull ViewportMode mode);
    /**
     * Returns the `map options`.
     *
     * @return The map's `map options`.
     */
    @NonNull 
    MapOptions getMapOptions();
    /**
     * Returns the `map debug options`.
     *
     * @return An array of `map debug options` flags currently set to the map.
     */
    @NonNull 
    List<MapDebugOptions> getDebug();
    /**
     * Sets the `map debug options` and enables debug mode based on the passed value.
     *
     * @param debugOptions An array of `map debug options` to be set.
     * @param value A `boolean` value representing the state for a given `map debug options`.
     *
     */
    void setDebug(@NonNull List<MapDebugOptions> debugOptions, @NonNull Boolean value);
    /**
     * Queries the map for rendered features.
     *
     * @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
     * @param options The `render query options` for querying rendered features.
     * @return A `cancelable` object that could be used to cancel the pending query.
     */
    void queryRenderedFeatures(@NonNull RenderedQueryGeometry geometry, @NonNull RenderedQueryOptions options, @NonNull Result<List<QueriedRenderedFeature>> result);
    /**
     * Queries the map for source features.
     *
     * @param sourceId The style source identifier used to query for source features.
     * @param options The `source query options` for querying source features.
     */
    void querySourceFeatures(@NonNull String sourceId, @NonNull SourceQueryOptions options, @NonNull Result<List<QueriedSourceFeature>> result);
    /**
     * Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
     * to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
     *
     * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
     *
     * @param sourceIdentifier GeoJsonSource identifier.
     * @param cluster Cluster from which to retrieve leaves from
     * @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
     * @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
     *         The result is a feature collection or a string describing an error if the operation was not successful.
     */
    void getGeoJsonClusterLeaves(@NonNull String sourceIdentifier, @NonNull Map<String, Object> cluster, @Nullable Long limit, @Nullable Long offset, @NonNull Result<FeatureExtensionValue> result);
    /**
     * Returns the children (original points or clusters) of a cluster (on the next zoom level)
     * given its id (cluster_id value from feature properties) from a GeoJsonSource.
     *
     * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
     *
     * @param sourceIdentifier GeoJsonSource identifier.
     * @param cluster cluster from which to retrieve children from
     *         The result is a feature collection or a string describing an error if the operation was not successful.
     */
    void getGeoJsonClusterChildren(@NonNull String sourceIdentifier, @NonNull Map<String, Object> cluster, @NonNull Result<FeatureExtensionValue> result);
    /**
     * Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
     * given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
     *
     * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
     *
     * @param sourceIdentifier GeoJsonSource identifier.
     * @param cluster cluster from which to retrieve the expansion zoom from
     *         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
     */
    void getGeoJsonClusterExpansionZoom(@NonNull String sourceIdentifier, @NonNull Map<String, Object> cluster, @NonNull Result<FeatureExtensionValue> result);
    /**
     * Updates the state object of a feature within a style source.
     *
     * Update entries in the `state` object of a given feature within a style source. Only properties of the
     * `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
     * retain its previous value.
     *
     * Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
     * immediately visible using `getStateFeature`.
     *
     * @param sourceId The style source identifier.
     * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
     * @param featureId The feature identifier of the feature whose state should be updated.
     * @param state The `state` object with properties to update with their respective new values.
     */
    void setFeatureState(@NonNull String sourceId, @Nullable String sourceLayerId, @NonNull String featureId, @NonNull String state, @NonNull VoidResult result);
    /**
     * Gets the state map of a feature within a style source.
     *
     * Note that updates to feature state are asynchronous, so changes made by other methods might not be
     * immediately visible.
     *
     * @param sourceId The style source identifier.
     * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
     * @param featureId The feature identifier of the feature whose state should be queried.
     */
    void getFeatureState(@NonNull String sourceId, @Nullable String sourceLayerId, @NonNull String featureId, @NonNull Result<String> result);
    /**
     * Removes entries from a feature state object.
     *
     * Remove a specified property or all property from a feature's state object, depending on the value of
     * `stateKey`.
     *
     * Note that updates to feature state are asynchronous, so changes made by this method migth not be
     * immediately visible using `getStateFeature`.
     *
     * @param sourceId The style source identifier.
     * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
     * @param featureId The feature identifier of the feature whose state should be removed.
     * @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
     */
    void removeFeatureState(@NonNull String sourceId, @Nullable String sourceLayerId, @NonNull String featureId, @Nullable String stateKey, @NonNull VoidResult result);
    /** Reduces memory use. Useful to call when the application gets paused or sent to background. */
    void reduceMemoryUse();
    /**
     * Gets elevation for the given coordinate.
     * Note: Elevation is only available for the visible region on the screen.
     *
     * @param coordinate The `coordinate` defined as longitude-latitude pair.
     * @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
     */
    @Nullable 
    Double getElevation(@NonNull Map<String, Object> coordinate);

    /** The codec used by _MapInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _MapInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `_MapInterface` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _MapInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String styleURIArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.loadStyleURI(styleURIArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String styleJsonArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.loadStyleJson(styleJsonArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.clearData(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setTileCacheBudget", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                TileCacheBudgetInMegabytes tileCacheBudgetInMegabytesArg = (TileCacheBudgetInMegabytes) args.get(0);
                TileCacheBudgetInTiles tileCacheBudgetInTilesArg = (TileCacheBudgetInTiles) args.get(1);
                try {
                  api.setTileCacheBudget(tileCacheBudgetInMegabytesArg, tileCacheBudgetInTilesArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Size output = api.getSize();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.triggerRepaint();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean inProgressArg = (Boolean) args.get(0);
                try {
                  api.setGestureInProgress(inProgressArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isGestureInProgress();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean inProgressArg = (Boolean) args.get(0);
                try {
                  api.setUserAnimationInProgress(inProgressArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isUserAnimationInProgress();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Number deltaArg = (Number) args.get(0);
                try {
                  api.setPrefetchZoomDelta((deltaArg == null) ? null : deltaArg.longValue());
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Long output = api.getPrefetchZoomDelta();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                NorthOrientation orientationArg = NorthOrientation.values()[(int) args.get(0)];
                try {
                  api.setNorthOrientation(orientationArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ConstrainMode modeArg = ConstrainMode.values()[(int) args.get(0)];
                try {
                  api.setConstrainMode(modeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ViewportMode modeArg = ViewportMode.values()[(int) args.get(0)];
                try {
                  api.setViewportMode(modeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  MapOptions output = api.getMapOptions();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  List<MapDebugOptions> output = api.getDebug();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<MapDebugOptions> debugOptionsArg = (List<MapDebugOptions>) args.get(0);
                Boolean valueArg = (Boolean) args.get(1);
                try {
                  api.setDebug(debugOptionsArg, valueArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                RenderedQueryGeometry geometryArg = (RenderedQueryGeometry) args.get(0);
                RenderedQueryOptions optionsArg = (RenderedQueryOptions) args.get(1);
                Result<List<QueriedRenderedFeature>> resultCallback =
                    new Result<List<QueriedRenderedFeature>>() {
                      public void success(List<QueriedRenderedFeature> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.queryRenderedFeatures(geometryArg, optionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                SourceQueryOptions optionsArg = (SourceQueryOptions) args.get(1);
                Result<List<QueriedSourceFeature>> resultCallback =
                    new Result<List<QueriedSourceFeature>>() {
                      public void success(List<QueriedSourceFeature> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.querySourceFeatures(sourceIdArg, optionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdentifierArg = (String) args.get(0);
                Map<String, Object> clusterArg = (Map<String, Object>) args.get(1);
                Number limitArg = (Number) args.get(2);
                Number offsetArg = (Number) args.get(3);
                Result<FeatureExtensionValue> resultCallback =
                    new Result<FeatureExtensionValue>() {
                      public void success(FeatureExtensionValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getGeoJsonClusterLeaves(sourceIdentifierArg, clusterArg, (limitArg == null) ? null : limitArg.longValue(), (offsetArg == null) ? null : offsetArg.longValue(), resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdentifierArg = (String) args.get(0);
                Map<String, Object> clusterArg = (Map<String, Object>) args.get(1);
                Result<FeatureExtensionValue> resultCallback =
                    new Result<FeatureExtensionValue>() {
                      public void success(FeatureExtensionValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getGeoJsonClusterChildren(sourceIdentifierArg, clusterArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdentifierArg = (String) args.get(0);
                Map<String, Object> clusterArg = (Map<String, Object>) args.get(1);
                Result<FeatureExtensionValue> resultCallback =
                    new Result<FeatureExtensionValue>() {
                      public void success(FeatureExtensionValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getGeoJsonClusterExpansionZoom(sourceIdentifierArg, clusterArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String sourceLayerIdArg = (String) args.get(1);
                String featureIdArg = (String) args.get(2);
                String stateArg = (String) args.get(3);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, stateArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String sourceLayerIdArg = (String) args.get(1);
                String featureIdArg = (String) args.get(2);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String sourceLayerIdArg = (String) args.get(1);
                String featureIdArg = (String) args.get(2);
                String stateKeyArg = (String) args.get(3);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, stateKeyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.reduceMemoryUse();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  Double output = api.getElevation(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class OfflineRegionCodec extends StandardMessageCodec {
    public static final OfflineRegionCodec INSTANCE = new OfflineRegionCodec();

    private OfflineRegionCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CoordinateBounds) {
        stream.write(128);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(129);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(130);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * An offline region represents an identifiable geographic region with optional metadata.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface OfflineRegion {
    /** The regions identifier */
    @NonNull 
    Long getIdentifier();
    /**
     * The tile pyramid defining the region. Tile pyramid and geometry definitions are
     * mutually exclusive.
     *
     * @return A definition describing the tile pyramid including attributes, otherwise empty.
     */
    @Nullable 
    OfflineRegionTilePyramidDefinition getTilePyramidDefinition();
    /**
     * The geometry defining the region. Geometry and tile pyramid definitions are
     * mutually exclusive.
     *
     * @return A definition describing the geometry including attributes, otherwise empty.
     */
    @Nullable 
    OfflineRegionGeometryDefinition getGeometryDefinition();
    /**
     * Arbitrary binary region metadata.
     *
     * @return The metadata associated with the region.
     */
    @NonNull 
    byte[] getMetadata();
    /**
     * Sets arbitrary binary region metadata for the region.
     *
     * Note that this setter is asynchronous and the given metadata is applied only
     * after the resulting callback is invoked with no error.
     *
     * @param metadata The metadata associated with the region.
     * @param callback Called once the request is complete or an error occurred.
     */
    void setMetadata(@NonNull byte[] metadata, @NonNull VoidResult result);
    /**
     * Sets the download state of an offline region
     * A region is either inactive (not downloading, but previously-downloaded
     * resources are available for use), or active (resources are being downloaded
     * or will be downloaded, if necessary, when network access is available).
     *
     * If the region is already in the given state, this call is ignored.
     *
     * @param state The new state to set.
     */
    void setOfflineRegionDownloadState(@NonNull OfflineRegionDownloadState state);
    /**
     * Invalidate all the tiles for the region forcing to revalidate
     * the tiles with the server before using. This is more efficient than deleting the
     * offline region and downloading it again because if the data on the cache matches
     * the server, no new data gets transmitted.
     *
     * @param callback Called once the request is complete or an error occurred.
     */
    void invalidate(@NonNull VoidResult result);
    /**
     * Remove an offline region from the database and perform any resources
     * evictions necessary as a result.
     *
     * @param callback Called once the request is complete or an error occurred.
     */
    void purge(@NonNull VoidResult result);

    /** The codec used by OfflineRegion. */
    static @NonNull MessageCodec<Object> getCodec() {
      return OfflineRegionCodec.INSTANCE;
    }
    /**Sets up an instance of `OfflineRegion` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable OfflineRegion api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getIdentifier", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Long output = api.getIdentifier();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getTilePyramidDefinition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  OfflineRegionTilePyramidDefinition output = api.getTilePyramidDefinition();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getGeometryDefinition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  OfflineRegionGeometryDefinition output = api.getGeometryDefinition();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getMetadata", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  byte[] output = api.getMetadata();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setMetadata", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                byte[] metadataArg = (byte[]) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setMetadata(metadataArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setOfflineRegionDownloadState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                OfflineRegionDownloadState stateArg = OfflineRegionDownloadState.values()[(int) args.get(0)];
                try {
                  api.setOfflineRegionDownloadState(stateArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.invalidate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.invalidate(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.purge", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.purge(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * The `offline region manager` that manages offline packs. All of the classâ€™s instance methods are asynchronous
   * reflecting the fact that offline resources are stored in a database. The offline manager maintains a canonical
   * collection of offline packs.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface OfflineRegionManager {
    /**
     * Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
     *
     * By default, the limit is set to 6,000.
     * Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
     * fires every additional attempt to download additional tiles until already downloaded tiles are removed
     * by calling `OfflineRegion.purge()` API.
     *
     * @param limit the maximum number of tiles allowed to be downloaded
     */
    void setOfflineMapboxTileCountLimit(@NonNull Long limit);

    /** The codec used by OfflineRegionManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `OfflineRegionManager` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable OfflineRegionManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegionManager.setOfflineMapboxTileCountLimit", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Number limitArg = (Number) args.get(0);
                try {
                  api.setOfflineMapboxTileCountLimit((limitArg == null) ? null : limitArg.longValue());
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class ProjectionCodec extends StandardMessageCodec {
    public static final ProjectionCodec INSTANCE = new ProjectionCodec();

    private ProjectionCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AmbientLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return DirectionalLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return FlatLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return QueriedRenderedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return QueriedSourceFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 162:
          return StyleProjection.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 163:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 164:
          return TileCacheBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 165:
          return TileCacheBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 166:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AmbientLight) {
        stream.write(128);
        writeValue(stream, ((AmbientLight) value).toList());
      } else if (value instanceof CameraBounds) {
        stream.write(129);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(130);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(131);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(132);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(133);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(134);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(135);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof DirectionalLight) {
        stream.write(136);
        writeValue(stream, ((DirectionalLight) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(137);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof FlatLight) {
        stream.write(138);
        writeValue(stream, ((FlatLight) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(139);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(140);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(141);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(142);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(143);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(144);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(145);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(146);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(147);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(148);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(150);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(151);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(152);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof QueriedRenderedFeature) {
        stream.write(153);
        writeValue(stream, ((QueriedRenderedFeature) value).toList());
      } else if (value instanceof QueriedSourceFeature) {
        stream.write(154);
        writeValue(stream, ((QueriedSourceFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(155);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(156);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(157);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(158);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(159);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(160);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(161);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StyleProjection) {
        stream.write(162);
        writeValue(stream, ((StyleProjection) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(163);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TileCacheBudgetInMegabytes) {
        stream.write(164);
        writeValue(stream, ((TileCacheBudgetInMegabytes) value).toList());
      } else if (value instanceof TileCacheBudgetInTiles) {
        stream.write(165);
        writeValue(stream, ((TileCacheBudgetInTiles) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(166);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Collection of [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection methods.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface Projection {
    /**
     * Calculate distance spanned by one pixel at the specified latitude
     * and zoom level.
     *
     * @param latitude The latitude for which to return the value.
     * @param zoom The zoom level.
     *
     * @return Returns the distance measured in meters.
     */
    @NonNull 
    Double getMetersPerPixelAtLatitude(@NonNull Double latitude, @NonNull Double zoom);
    /**
     * Calculate Spherical Mercator ProjectedMeters coordinates.
     *
     * @param coordinate A longitude-latitude pair for which to calculate
     * `projected meters` coordinates.
     *
     * @return Returns Spherical Mercator ProjectedMeters coordinates.
     */
    @NonNull 
    ProjectedMeters projectedMetersForCoordinate(@NonNull Map<String, Object> coordinate);
    /**
     * Calculate a longitude-latitude pair for a Spherical Mercator projected
     * meters.
     *
     * @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
     * which to calculate a longitude-latitude pair.
     *
     * @return Returns a longitude-latitude pair.
     */
    @NonNull 
    Map<String, Object> coordinateForProjectedMeters(@NonNull ProjectedMeters projectedMeters);
    /**
     * Calculate a point on the map in Mercator Projection for a given
     * coordinate at the specified zoom scale.
     *
     * @param coordinate The longitude-latitude pair for which to return the value.
     * @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
     * calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
     * where tileSize is the width of a tile in pixels.
     *
     * @return Returns a point on the map in Mercator projection.
     */
    @NonNull 
    MercatorCoordinate project(@NonNull Map<String, Object> coordinate, @NonNull Double zoomScale);
    /**
     * Calculate a coordinate for a given point on the map in Mercator Projection.
     *
     * @param coordinate Point on the map in Mercator projection.
     * @param zoomScale The current zoom factor applied on the map, is used to
     * calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
     * where tileSize is the width of a tile in pixels.
     *
     * @return Returns a coordinate.
     */
    @NonNull 
    Map<String, Object> unproject(@NonNull MercatorCoordinate coordinate, @NonNull Double zoomScale);

    /** The codec used by Projection. */
    static @NonNull MessageCodec<Object> getCodec() {
      return ProjectionCodec.INSTANCE;
    }
    /**Sets up an instance of `Projection` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable Projection api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Double latitudeArg = (Double) args.get(0);
                Double zoomArg = (Double) args.get(1);
                try {
                  Double output = api.getMetersPerPixelAtLatitude(latitudeArg, zoomArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  ProjectedMeters output = api.projectedMetersForCoordinate(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ProjectedMeters projectedMetersArg = (ProjectedMeters) args.get(0);
                try {
                  Map<String, Object> output = api.coordinateForProjectedMeters(projectedMetersArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.project", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                Double zoomScaleArg = (Double) args.get(1);
                try {
                  MercatorCoordinate output = api.project(coordinateArg, zoomScaleArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                MercatorCoordinate coordinateArg = (MercatorCoordinate) args.get(0);
                Double zoomScaleArg = (Double) args.get(1);
                try {
                  Map<String, Object> output = api.unproject(coordinateArg, zoomScaleArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface _MapboxOptions {

    @NonNull 
    String getAccessToken();

    void setAccessToken(@NonNull String token);

    /** The codec used by _MapboxOptions. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `_MapboxOptions` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _MapboxOptions api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.getAccessToken", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  String output = api.getAccessToken();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.setAccessToken", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String tokenArg = (String) args.get(0);
                try {
                  api.setAccessToken(tokenArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /** Generated interface from Pigeon that represents a handler of messages from Flutter. */
  public interface _MapboxMapsOptions {

    @NonNull 
    String getBaseUrl();

    void setBaseUrl(@NonNull String url);

    @NonNull 
    String getDataPath();

    void setDataPath(@NonNull String path);

    @NonNull 
    String getAssetPath();

    void setAssetPath(@NonNull String path);

    @NonNull 
    TileStoreUsageMode getTileStoreUsageMode();

    void setTileStoreUsageMode(@NonNull TileStoreUsageMode mode);

    /** The codec used by _MapboxMapsOptions. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `_MapboxMapsOptions` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable _MapboxMapsOptions api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getBaseUrl", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  String output = api.getBaseUrl();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setBaseUrl", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String urlArg = (String) args.get(0);
                try {
                  api.setBaseUrl(urlArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getDataPath", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  String output = api.getDataPath();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setDataPath", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String pathArg = (String) args.get(0);
                try {
                  api.setDataPath(pathArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getAssetPath", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  String output = api.getAssetPath();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setAssetPath", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String pathArg = (String) args.get(0);
                try {
                  api.setAssetPath(pathArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getTileStoreUsageMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  TileStoreUsageMode output = api.getTileStoreUsageMode();
                  wrapped.add(0, output.index);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setTileStoreUsageMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                TileStoreUsageMode modeArg = TileStoreUsageMode.values()[(int) args.get(0)];
                try {
                  api.setTileStoreUsageMode(modeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * Settings class provides non-persistent, in-process key-value storage.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface Settings {
    /**
     * Sets setting value for a specified key.
     *
     * @param key A name of the key.
     * @param value The `value` for the key.
     */
    void set(@NonNull String key, @NonNull String value);
    /**
     * Return value for a key.
     *
     * @param key A name of the key.
     *
     * @return `value` if a key exists in settings otherwise a `null value` will be returned.
     */
    @NonNull 
    String get(@NonNull String key);

    /** The codec used by Settings. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `Settings` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable Settings api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Settings.set", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String keyArg = (String) args.get(0);
                String valueArg = (String) args.get(1);
                try {
                  api.set(keyArg, valueArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Settings.get", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String keyArg = (String) args.get(0);
                try {
                  String output = api.get(keyArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MapSnapshotCodec extends StandardMessageCodec {
    public static final MapSnapshotCodec INSTANCE = new MapSnapshotCodec();

    private MapSnapshotCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AmbientLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return DirectionalLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return FlatLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return QueriedRenderedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return QueriedSourceFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 162:
          return StyleProjection.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 163:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 164:
          return TileCacheBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 165:
          return TileCacheBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 166:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AmbientLight) {
        stream.write(128);
        writeValue(stream, ((AmbientLight) value).toList());
      } else if (value instanceof CameraBounds) {
        stream.write(129);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(130);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(131);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(132);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(133);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(134);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(135);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof DirectionalLight) {
        stream.write(136);
        writeValue(stream, ((DirectionalLight) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(137);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof FlatLight) {
        stream.write(138);
        writeValue(stream, ((FlatLight) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(139);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(140);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(141);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(142);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(143);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(144);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(145);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(146);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(147);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(148);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(150);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(151);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(152);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof QueriedRenderedFeature) {
        stream.write(153);
        writeValue(stream, ((QueriedRenderedFeature) value).toList());
      } else if (value instanceof QueriedSourceFeature) {
        stream.write(154);
        writeValue(stream, ((QueriedSourceFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(155);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(156);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(157);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(158);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(159);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(160);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(161);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StyleProjection) {
        stream.write(162);
        writeValue(stream, ((StyleProjection) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(163);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TileCacheBudgetInMegabytes) {
        stream.write(164);
        writeValue(stream, ((TileCacheBudgetInMegabytes) value).toList());
      } else if (value instanceof TileCacheBudgetInTiles) {
        stream.write(165);
        writeValue(stream, ((TileCacheBudgetInTiles) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(166);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * An image snapshot of a map rendered by `map snapshotter`.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface MapSnapshot {
    /**
     * Calculate screen coordinate on the snapshot from geographical `coordinate`.
     *
     * @param coordinate A geographical `coordinate`.
     * @return A `screen coordinate` measured in `logical pixels` on the snapshot for geographical `coordinate`.
     */
    @NonNull 
    ScreenCoordinate screenCoordinate(@NonNull Map<String, Object> coordinate);
    /**
     * Calculate geographical coordinates from a point on the snapshot.
     *
     * @param screenCoordinate A `screen coordinate` on the snapshot in `logical pixels`.
     * @return A geographical `coordinate` for a `screen coordinate` on the snapshot.
     */
    @NonNull 
    Map<String, Object> coordinate(@NonNull ScreenCoordinate screenCoordinate);
    /**
     * Get list of attributions for the sources in this snapshot.
     *
     * @return A list of attributions for the sources in this snapshot.
     */
    @NonNull 
    List<String> attributions();
    /**
     * Get the rendered snapshot `image`.
     *
     * @return A rendered snapshot `image`.
     */
    @NonNull 
    MbxImage image();

    /** The codec used by MapSnapshot. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MapSnapshotCodec.INSTANCE;
    }
    /**Sets up an instance of `MapSnapshot` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable MapSnapshot api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.screenCoordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  ScreenCoordinate output = api.screenCoordinate(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.coordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate screenCoordinateArg = (ScreenCoordinate) args.get(0);
                try {
                  Map<String, Object> output = api.coordinate(screenCoordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.attributions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  List<String> output = api.attributions();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.image", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  MbxImage output = api.image();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MapSnapshotterCodec extends StandardMessageCodec {
    public static final MapSnapshotterCodec INSTANCE = new MapSnapshotterCodec();

    private MapSnapshotterCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AmbientLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return DirectionalLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return FlatLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return QueriedRenderedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return QueriedSourceFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 162:
          return StyleProjection.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 163:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 164:
          return TileCacheBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 165:
          return TileCacheBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 166:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AmbientLight) {
        stream.write(128);
        writeValue(stream, ((AmbientLight) value).toList());
      } else if (value instanceof CameraBounds) {
        stream.write(129);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(130);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(131);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(132);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(133);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(134);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(135);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof DirectionalLight) {
        stream.write(136);
        writeValue(stream, ((DirectionalLight) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(137);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof FlatLight) {
        stream.write(138);
        writeValue(stream, ((FlatLight) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(139);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(140);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(141);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(142);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(143);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(144);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(145);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(146);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(147);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(148);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(150);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(151);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(152);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof QueriedRenderedFeature) {
        stream.write(153);
        writeValue(stream, ((QueriedRenderedFeature) value).toList());
      } else if (value instanceof QueriedSourceFeature) {
        stream.write(154);
        writeValue(stream, ((QueriedSourceFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(155);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(156);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(157);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(158);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(159);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(160);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(161);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StyleProjection) {
        stream.write(162);
        writeValue(stream, ((StyleProjection) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(163);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TileCacheBudgetInMegabytes) {
        stream.write(164);
        writeValue(stream, ((TileCacheBudgetInMegabytes) value).toList());
      } else if (value instanceof TileCacheBudgetInTiles) {
        stream.write(165);
        writeValue(stream, ((TileCacheBudgetInTiles) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(166);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * MapSnapshotter exposes functionality to capture static map images.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface MapSnapshotter {
    /**
     * Sets the `size` of the snapshot
     *
     * @param size The new `size` of the snapshot in `logical pixels`.
     */
    void setSize(@NonNull Size size);
    /**
     * Gets the size of the snapshot
     *
     * @return Snapshot `size` in `logical pixels`.
     */
    @NonNull 
    Size getSize();
    /**
     * Returns `true` if the snapshotter is in the tile mode.
     *
     * @return `true` if the snapshotter is in the tile mode, `false` otherwise.
     */
    @NonNull 
    Boolean isInTileMode();
    /**
     * Sets the snapshotter to the tile mode.
     *
     * In the tile mode, the snapshotter fetches the still image of a single tile.
     *
     * @param set A `boolean` value representing if the snapshotter is in the tile mode.
     */
    void setTileMode(@NonNull Boolean set);
    /**
     * Cancel the current snapshot operation.
     *
     * Cancel the current snapshot operation, if any. The callback passed to the start method
     * is called with error parameter set.
     */
    void cancel();
    /**
     * Get elevation for the given coordinate.
     * Note: Elevation is only available for the visible region on the screen.
     *
     * @param coordinate defined as longitude-latitude pair.
     *
     * @return Elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
     */
    @Nullable 
    Double getElevation(@NonNull Map<String, Object> coordinate);

    /** The codec used by MapSnapshotter. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MapSnapshotterCodec.INSTANCE;
    }
    /**Sets up an instance of `MapSnapshotter` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable MapSnapshotter api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setSize", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Size sizeArg = (Size) args.get(0);
                try {
                  api.setSize(sizeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getSize", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Size output = api.getSize();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.isInTileMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isInTileMode();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setTileMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean setArg = (Boolean) args.get(0);
                try {
                  api.setTileMode(setArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.cancel", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.cancel();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getElevation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  Double output = api.getElevation(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class StyleManagerCodec extends StandardMessageCodec {
    public static final StyleManagerCodec INSTANCE = new StyleManagerCodec();

    private StyleManagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return AmbientLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return DirectionalLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return FlatLight.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return QueriedRenderedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return QueriedSourceFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 162:
          return StyleProjection.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 163:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 164:
          return TileCacheBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 165:
          return TileCacheBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 166:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof AmbientLight) {
        stream.write(128);
        writeValue(stream, ((AmbientLight) value).toList());
      } else if (value instanceof CameraBounds) {
        stream.write(129);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(130);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(131);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(132);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(133);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(134);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(135);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof DirectionalLight) {
        stream.write(136);
        writeValue(stream, ((DirectionalLight) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(137);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof FlatLight) {
        stream.write(138);
        writeValue(stream, ((FlatLight) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(139);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(140);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(141);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(142);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(143);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(144);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(145);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(146);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(147);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(148);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(150);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(151);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(152);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof QueriedRenderedFeature) {
        stream.write(153);
        writeValue(stream, ((QueriedRenderedFeature) value).toList());
      } else if (value instanceof QueriedSourceFeature) {
        stream.write(154);
        writeValue(stream, ((QueriedSourceFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(155);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(156);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(157);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(158);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(159);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(160);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(161);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StyleProjection) {
        stream.write(162);
        writeValue(stream, ((StyleProjection) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(163);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TileCacheBudgetInMegabytes) {
        stream.write(164);
        writeValue(stream, ((TileCacheBudgetInMegabytes) value).toList());
      } else if (value instanceof TileCacheBudgetInTiles) {
        stream.write(165);
        writeValue(stream, ((TileCacheBudgetInTiles) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(166);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Interface for managing style of the `map`.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface StyleManager {
    /**
     * Get the URI of the current style in use.
     *
     * @return A string containing a style URI.
     */
    void getStyleURI(@NonNull Result<String> result);
    /**
     * Load style from provided URI.
     *
     * This is an asynchronous call. To check the result of this operation the user must register an observer observing
     * `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
     *
     * @param uri URI where the style should be loaded from.
     */
    void setStyleURI(@NonNull String uri, @NonNull VoidResult result);
    /**
     * Get the JSON serialization string of the current style in use.
     *
     * @return A JSON string containing a serialized style.
     */
    void getStyleJSON(@NonNull Result<String> result);
    /**
     * Load the style from a provided JSON string.
     *
     * @param json A JSON string containing a serialized style.
     */
    void setStyleJSON(@NonNull String json, @NonNull VoidResult result);
    /**
     * Returns the map style's default camera, if any, or a default camera otherwise.
     * The map style's default camera is defined as follows:
     * - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
     * - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
     * - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
     * - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
     *
     * The style default camera is re-evaluated when a new style is loaded.
     *
     * @return The default `camera options` of the current style in use.
     */
    void getStyleDefaultCamera(@NonNull Result<CameraOptions> result);
    /**
     * Returns the map style's transition options. By default, the style parser will attempt
     * to read the style default transition options, if any, fallbacking to an immediate transition
     * otherwise. Transition options can be overriden via `setStyleTransition`, but the options are
     * reset once a new style has been loaded.
     *
     * The style transition is re-evaluated when a new style is loaded.
     *
     * @return The `transition options` of the current style in use.
     */
    void getStyleTransition(@NonNull Result<TransitionOptions> result);
    /** Returns the list containing information about existing style import objects. */
    @NonNull 
    List<StyleObjectInfo> getStyleImports();
    /**
     * Removes an existing style import.
     *
     * @param importId Identifier of the style import to remove.
     */
    void removeStyleImport(@NonNull String importId);
    /**
     * Gets the style import schema.
     *
     * @param importId Identifier of the style import.
     *
     * Returns the style import schema, containing the default configurations for the style import.
     */
    @NonNull 
    Object getStyleImportSchema(@NonNull String importId);
    /**
     * Gets style import config.
     *
     * @param importId Identifier of the style import.
     *
     * Returns the style import configuration or a string describing an error if the operation was not successful.
     */
    @NonNull 
    Map<String, StylePropertyValue> getStyleImportConfigProperties(@NonNull String importId);
    /**
     * Gets the value of style import config.
     *
     * @param importId Identifier of the style import.
     * @param config The style import config name.
     *
     * Returns the style import configuration or a string describing an error if the operation was not successful.
     */
    @NonNull 
    StylePropertyValue getStyleImportConfigProperty(@NonNull String importId, @NonNull String config);
    /**
     * Sets style import config.
     * This method can be used to perform batch update for a style import configurations.
     *
     * @param importId Identifier of the style import.
     * @param configs A map of style import configurations.
     */
    void setStyleImportConfigProperties(@NonNull String importId, @NonNull Map<String, Object> configs);
    /**
     * Sets a value to a style import config.
     *
     * @param importId Identifier of the style import.
     * @param config The style import config name.
     * @param value The style import config value.
     */
    void setStyleImportConfigProperty(@NonNull String importId, @NonNull String config, @NonNull Object value);
    /**
     * Overrides the map style's transition options with user-provided options.
     *
     * The style transition is re-evaluated when a new style is loaded.
     *
     * @param transitionOptions The `transition options`.
     */
    void setStyleTransition(@NonNull TransitionOptions transitionOptions, @NonNull VoidResult result);
    /**
     * Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
     *
     * Runtime style layers are valid until they are either removed or a new style is loaded.
     *
     * @param properties A map of style layer properties.
     * @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void addStyleLayer(@NonNull String properties, @Nullable LayerPosition layerPosition, @NonNull VoidResult result);
    /**
     * Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
     *
     * Whenever a new style is being parsed and currently used style has persistent layers,
     * an engine will try to do following:
     *   - keep the persistent layer at its relative position
     *   - keep the source used by a persistent layer
     *   - keep images added through `addStyleImage` method
     *
     * In cases when a new style has the same layer, source or image resource, style's resources would be
     * used instead and `MapLoadingError` event will be emitted.
     *
     * @param properties A map of style layer properties.
     * @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void addPersistentStyleLayer(@NonNull String properties, @Nullable LayerPosition layerPosition, @NonNull VoidResult result);
    /**
     * Checks if a style layer is persistent.
     *
     * @param layerId A style layer identifier.
     * @return A string describing an error if the operation was not successful, boolean representing state otherwise.
     */
    void isStyleLayerPersistent(@NonNull String layerId, @NonNull Result<Boolean> result);
    /**
     * Removes an existing style layer.
     *
     * @param layerId An identifier of the style layer to remove.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void removeStyleLayer(@NonNull String layerId, @NonNull VoidResult result);
    /**
     * Moves an existing style layer
     *
     * @param layerId Identifier of the style layer to move.
     * @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
     *                      is provided then the layer is moved to the top of the layerstack.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void moveStyleLayer(@NonNull String layerId, @Nullable LayerPosition layerPosition, @NonNull VoidResult result);
    /**
     * Checks whether a given style layer exists.
     *
     * @param layerId Style layer identifier.
     *
     * @return A `true` value if the given style layer exists, `false` otherwise.
     */
    void styleLayerExists(@NonNull String layerId, @NonNull Result<Boolean> result);
    /**
     * Returns the existing style layers.
     *
     * @return The list containing the information about existing style layer objects.
     */
    void getStyleLayers(@NonNull Result<List<StyleObjectInfo>> result);
    /**
     * Gets the value of style layer property.
     *
     * @param layerId A style layer identifier.
     * @param property The style layer property name.
     * @return The `style property value`.
     */
    void getStyleLayerProperty(@NonNull String layerId, @NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to a style layer property.
     *
     * @param layerId A style layer identifier.
     * @param property The style layer property name.
     * @param value The style layer property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLayerProperty(@NonNull String layerId, @NonNull String property, @NonNull Object value, @NonNull VoidResult result);
    /**
     * Gets style layer properties.
     *
     * @return The style layer properties or a string describing an error if the operation was not successful.
     */
    void getStyleLayerProperties(@NonNull String layerId, @NonNull Result<String> result);
    /**
     * Sets style layer properties.
     * This method can be used to perform batch update for a style layer properties. The structure of a
     * provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
     * Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
     *
     * @param layerId A style layer identifier.
     * @param properties A map of style layer properties.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLayerProperties(@NonNull String layerId, @NonNull String properties, @NonNull VoidResult result);
    /**
     * Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
     *
     * @param sourceId An identifier for the style source.
     * @param properties A map of style source properties.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void addStyleSource(@NonNull String sourceId, @NonNull String properties, @NonNull VoidResult result);
    /**
     * Gets the value of style source property.
     *
     * @param sourceId A style source identifier.
     * @param property The style source property name.
     * @return The value of a `property` in the source with a `sourceId`.
     */
    void getStyleSourceProperty(@NonNull String sourceId, @NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to a style source property.
     * Note: When setting the `data` property of a `geojson` source, this method never returns an error.
     * In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
     *
     *
     * @param sourceId A style source identifier.
     * @param property The style source property name.
     * @param value The style source property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleSourceProperty(@NonNull String sourceId, @NonNull String property, @NonNull Object value, @NonNull VoidResult result);
    /**
     * Gets style source properties.
     *
     * @param sourceId A style source identifier.
     *
     * @return The style source properties or a string describing an error if the operation was not successful.
     */
    void getStyleSourceProperties(@NonNull String sourceId, @NonNull Result<String> result);
    /**
     * Sets style source properties.
     *
     * This method can be used to perform batch update for a style source properties. The structure of a
     * provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
     * Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
     *
     * @param sourceId A style source identifier.
     * @param properties A map of Style source properties.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleSourceProperties(@NonNull String sourceId, @NonNull String properties, @NonNull VoidResult result);
    /**
     * Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
     *
     * @param sourceId A style source identifier.
     * @param image An `image`.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void updateStyleImageSourceImage(@NonNull String sourceId, @NonNull MbxImage image, @NonNull VoidResult result);
    /**
     * Removes an existing style source.
     *
     * @param sourceId An identifier of the style source to remove.
     */
    void removeStyleSource(@NonNull String sourceId, @NonNull VoidResult result);
    /**
     * Checks whether a given style source exists.
     *
     * @param sourceId A style source identifier.
     *
     * @return `true` if the given source exists, `false` otherwise.
     */
    void styleSourceExists(@NonNull String sourceId, @NonNull Result<Boolean> result);
    /**
     * Returns the existing style sources.
     *
     * @return The list containing the information about existing style source objects.
     */
    void getStyleSources(@NonNull Result<List<StyleObjectInfo>> result);
    /** Returns an ordered list of the current style lights. */
    @NonNull 
    List<StyleObjectInfo> getStyleLights();
    /**
     * Set global directional lightning.
     *
     * @param flatLight The flat light source.
     */
    void setLight(@NonNull FlatLight flatLight);
    /**
     * Set dynamic lightning.
     *
     * @param ambientLight The ambient light source.
     * @param directionalLight The directional light source.
     */
    void setLights(@NonNull AmbientLight ambientLight, @NonNull DirectionalLight directionalLight);
    /**
     * Gets the value of a style light property.
     *
     * @param property The style light property name.
     * @param id The unique identifier of the style light in lights list.
     * @return The style light property value.
     */
    void getStyleLightProperty(@NonNull String id, @NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to the the style light property.
     *
     * @param property The style light property name.
     * @param id The unique identifier of the style light in lights list.
     * @param value The style light property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLightProperty(@NonNull String id, @NonNull String property, @NonNull Object value, @NonNull VoidResult result);
    /**
     * Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
     *
     * @param properties A map of style terrain properties values, with their names as a key.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleTerrain(@NonNull String properties, @NonNull VoidResult result);
    /**
     * Gets the value of a style terrain property.
     *
     * @param property The style terrain property name.
     * @return The style terrain property value.
     */
    void getStyleTerrainProperty(@NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to the the style terrain property.
     *
     * @param property The style terrain property name.
     * @param value The style terrain property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleTerrainProperty(@NonNull String property, @NonNull Object value, @NonNull VoidResult result);
    /**
     * Get an `image` from the style.
     *
     * @param imageId The identifier of the `image`.
     *
     * @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
     */
    void getStyleImage(@NonNull String imageId, @NonNull NullableResult<MbxImage> result);
    /**
     * Adds an image to be used in the style. This API can also be used for updating
     * an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
     *
     * The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
     * [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
     * [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
     * [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
     *
     * @param imageId An identifier of the image.
     * @param scale A scale factor for the image.
     * @param image A pixel data of the image.
     * @param sdf An option to treat whether image is SDF(signed distance field) or not.
     * @param stretchX An array of two-element arrays, consisting of two numbers that represent
     * the from position and the to position of areas that can be stretched horizontally.
     * @param stretchY An array of two-element arrays, consisting of two numbers that represent
     * the from position and the to position of areas that can be stretched vertically.
     * @param content An array of four numbers, with the first two specifying the left, top
     * corner, and the last two specifying the right, bottom corner. If present, and if the
     * icon uses icon-text-fit, the symbol's text will be fit inside the content box.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void addStyleImage(@NonNull String imageId, @NonNull Double scale, @NonNull MbxImage image, @NonNull Boolean sdf, @NonNull List<ImageStretches> stretchX, @NonNull List<ImageStretches> stretchY, @Nullable ImageContent content, @NonNull VoidResult result);
    /**
     * Removes an image from the style.
     *
     * @param imageId The identifier of the image to remove.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void removeStyleImage(@NonNull String imageId, @NonNull VoidResult result);
    /**
     * Checks whether an image exists.
     *
     * @param imageId The identifier of the image.
     *
     * @return True if image exists, false otherwise.
     */
    void hasStyleImage(@NonNull String imageId, @NonNull Result<Boolean> result);
    /**
     * Set tile data of a custom geometry.
     *
     * @param sourceId A style source identifier.
     * @param tileId A `canonical tile id` of the tile.
     * @param featureCollection An array with the features to add.
     * Invalidate tile for provided custom geometry source.
     *
     * @param sourceId A style source identifier,.
     * @param tileId A `canonical tile id` of the tile.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void invalidateStyleCustomGeometrySourceTile(@NonNull String sourceId, @NonNull CanonicalTileID tileId, @NonNull VoidResult result);
    /**
     * Invalidate region for provided custom geometry source.
     *
     * @param sourceId A style source identifier
     * @param bounds A `coordinate bounds` object.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void invalidateStyleCustomGeometrySourceRegion(@NonNull String sourceId, @NonNull CoordinateBounds bounds, @NonNull VoidResult result);
    /**
     * Check if the style is completely loaded.
     *
     * Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
     * Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
     *
     * @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
     *
     */
    void isStyleLoaded(@NonNull Result<Boolean> result);
    /**
     * Function to get the projection provided by the Style Extension.
     *
     * @return Projection that is currently applied to the map
     */
    @Nullable 
    StyleProjection getProjection();
    /**
     * Function to set the projection provided by the Style Extension.
     *
     * @param projection The projection to be set.
     */
    void setProjection(@NonNull StyleProjection projection);
    /**
     * Function to localize style labels.
     *
     * @param locale The locale to apply for localization
     * @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
     */
    void localizeLabels(@NonNull String locale, @Nullable List<String> layerIds, @NonNull VoidResult result);

    /** The codec used by StyleManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return StyleManagerCodec.INSTANCE;
    }
    /**Sets up an instance of `StyleManager` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable StyleManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleURI(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String uriArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleURI(uriArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleJSON(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String jsonArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleJSON(jsonArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<CameraOptions> resultCallback =
                    new Result<CameraOptions>() {
                      public void success(CameraOptions result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleDefaultCamera(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<TransitionOptions> resultCallback =
                    new Result<TransitionOptions>() {
                      public void success(TransitionOptions result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleTransition(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImports", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  List<StyleObjectInfo> output = api.getStyleImports();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImport", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String importIdArg = (String) args.get(0);
                try {
                  api.removeStyleImport(importIdArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportSchema", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String importIdArg = (String) args.get(0);
                try {
                  Object output = api.getStyleImportSchema(importIdArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String importIdArg = (String) args.get(0);
                try {
                  Map<String, StylePropertyValue> output = api.getStyleImportConfigProperties(importIdArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String importIdArg = (String) args.get(0);
                String configArg = (String) args.get(1);
                try {
                  StylePropertyValue output = api.getStyleImportConfigProperty(importIdArg, configArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String importIdArg = (String) args.get(0);
                Map<String, Object> configsArg = (Map<String, Object>) args.get(1);
                try {
                  api.setStyleImportConfigProperties(importIdArg, configsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String importIdArg = (String) args.get(0);
                String configArg = (String) args.get(1);
                Object valueArg = args.get(2);
                try {
                  api.setStyleImportConfigProperty(importIdArg, configArg, valueArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                TransitionOptions transitionOptionsArg = (TransitionOptions) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleTransition(transitionOptionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                LayerPosition layerPositionArg = (LayerPosition) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addStyleLayer(propertiesArg, layerPositionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                LayerPosition layerPositionArg = (LayerPosition) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addPersistentStyleLayer(propertiesArg, layerPositionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.isStyleLayerPersistent(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeStyleLayer(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                LayerPosition layerPositionArg = (LayerPosition) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.moveStyleLayer(layerIdArg, layerPositionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.styleLayerExists(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<List<StyleObjectInfo>> resultCallback =
                    new Result<List<StyleObjectInfo>>() {
                      public void success(List<StyleObjectInfo> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLayers(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLayerProperty(layerIdArg, propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Object valueArg = args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLayerProperty(layerIdArg, propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLayerProperties(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                String propertiesArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLayerProperties(layerIdArg, propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertiesArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addStyleSource(sourceIdArg, propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleSourceProperty(sourceIdArg, propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Object valueArg = args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleSourceProperty(sourceIdArg, propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleSourceProperties(sourceIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertiesArg = (String) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleSourceProperties(sourceIdArg, propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                MbxImage imageArg = (MbxImage) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.updateStyleImageSourceImage(sourceIdArg, imageArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeStyleSource(sourceIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.styleSourceExists(sourceIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<List<StyleObjectInfo>> resultCallback =
                    new Result<List<StyleObjectInfo>>() {
                      public void success(List<StyleObjectInfo> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleSources(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLights", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  List<StyleObjectInfo> output = api.getStyleLights();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLight", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                FlatLight flatLightArg = (FlatLight) args.get(0);
                try {
                  api.setLight(flatLightArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLights", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                AmbientLight ambientLightArg = (AmbientLight) args.get(0);
                DirectionalLight directionalLightArg = (DirectionalLight) args.get(1);
                try {
                  api.setLights(ambientLightArg, directionalLightArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String idArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLightProperty(idArg, propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String idArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Object valueArg = args.get(2);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLightProperty(idArg, propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleTerrain(propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertyArg = (String) args.get(0);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleTerrainProperty(propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertyArg = (String) args.get(0);
                Object valueArg = args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleTerrainProperty(propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                NullableResult<MbxImage> resultCallback =
                    new NullableResult<MbxImage>() {
                      public void success(MbxImage result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleImage(imageIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                Double scaleArg = (Double) args.get(1);
                MbxImage imageArg = (MbxImage) args.get(2);
                Boolean sdfArg = (Boolean) args.get(3);
                List<ImageStretches> stretchXArg = (List<ImageStretches>) args.get(4);
                List<ImageStretches> stretchYArg = (List<ImageStretches>) args.get(5);
                ImageContent contentArg = (ImageContent) args.get(6);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addStyleImage(imageIdArg, scaleArg, imageArg, sdfArg, stretchXArg, stretchYArg, contentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeStyleImage(imageIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.hasStyleImage(imageIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                CanonicalTileID tileIdArg = (CanonicalTileID) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.invalidateStyleCustomGeometrySourceTile(sourceIdArg, tileIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                CoordinateBounds boundsArg = (CoordinateBounds) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.invalidateStyleCustomGeometrySourceRegion(sourceIdArg, boundsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.isStyleLoaded(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  StyleProjection output = api.getProjection();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                StyleProjection projectionArg = (StyleProjection) args.get(0);
                try {
                  api.setProjection(projectionArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String localeArg = (String) args.get(0);
                List<String> layerIdsArg = (List<String>) args.get(1);
                VoidResult resultCallback =
                    new VoidResult() {
                      public void success() {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.localizeLabels(localeArg, layerIdsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * Allows to cancel the associated asynchronous operation
   *
   * The the associated asynchronous operation is not automatically canceled if this
   * object goes out of scope.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface Cancelable {
    /**
     * Cancels the associated asynchronous operation
     *
     * If the associated asynchronous operation has already finished, this call is ignored.
     */
    void cancel();

    /** The codec used by Cancelable. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `Cancelable` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable Cancelable api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.cancel();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * Instance that allows connecting or disconnecting the Mapbox stack to the network.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface OfflineSwitch {
    /**
     * Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
     * with HttpRequestErrorType#ConnectionError.
     *
     * @param connected Set false to disconnect the Mapbox stack
     */
    void setMapboxStackConnected(@NonNull Boolean connected);
    /**
     * Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
     *
     * @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
     */
    @NonNull 
    Boolean isMapboxStackConnected();
    /**
     * Releases the OfflineSwitch singleton instance.
     *
     * Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
     * If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
     */
    void reset();

    /** The codec used by OfflineSwitch. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `OfflineSwitch` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable OfflineSwitch api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.setMapboxStackConnected", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean connectedArg = (Boolean) args.get(0);
                try {
                  api.setMapboxStackConnected(connectedArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.isMapboxStackConnected", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isMapboxStackConnected();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.reset", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.reset();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * A bundle that encapsulates tilesets creation for the tile store implementation.
   *
   * Tileset descriptors describe the type of data that should be part of the Offline Region, like the routing profile for Navigation and the Tilesets of the Map style.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface TilesetDescriptor {

    /** The codec used by TilesetDescriptor. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `TilesetDescriptor` to handle messages through the `binaryMessenger`. */
    static void setUp(@NonNull BinaryMessenger binaryMessenger, @Nullable TilesetDescriptor api) {
    }
  }
}
