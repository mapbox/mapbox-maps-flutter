// Autogenerated from Pigeon (v25.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package com.mapbox.maps.mapbox_maps.pigeons

import com.mapbox.geojson.Point
import com.mapbox.maps.mapbox_maps.mapping.turf.*

/**
 * Describes the coordinate on the screen, measured from top to bottom and from left to right.
 * Note: the `map` uses screen coordinate units measured in `logical pixels`.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ScreenCoordinate(
  /** A value representing the x position of this coordinate. */
  val x: Double,
  /** A value representing the y position of this coordinate. */
  val y: Double
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ScreenCoordinate {
      val x = pigeonVar_list[0] as Double
      val y = pigeonVar_list[1] as Double
      return ScreenCoordinate(x, y)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      x,
      y,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ScreenCoordinate) {
      return false
    }
    if (this === other) {
      return true
    }
    return x == other.x &&
      y == other.y
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * The distance on each side between rectangles, when one is contained into other.
 *
 * All fields' values are in `logical pixel` units.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MbxEdgeInsets(
  /** Padding from the top. */
  val top: Double,
  /** Padding from the left. */
  val left: Double,
  /** Padding from the bottom. */
  val bottom: Double,
  /** Padding from the right. */
  val right: Double
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MbxEdgeInsets {
      val top = pigeonVar_list[0] as Double
      val left = pigeonVar_list[1] as Double
      val bottom = pigeonVar_list[2] as Double
      val right = pigeonVar_list[3] as Double
      return MbxEdgeInsets(top, left, bottom, right)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      top,
      left,
      bottom,
      right,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is MbxEdgeInsets) {
      return false
    }
    if (this === other) {
      return true
    }
    return top == other.top &&
      left == other.left &&
      bottom == other.bottom &&
      right == other.right
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Various options for describing the viewpoint of a camera. All fields are
 * optional.
 *
 * Anchor and center points are mutually exclusive, with preference for the
 * center point when both are set.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraOptions(
  /** Coordinate at the center of the camera. */
  val center: Point? = null,
  /**
   * Padding around the interior of the view that affects the frame of
   * reference for `center`.
   */
  val padding: MbxEdgeInsets? = null,
  /**
   * Point of reference for `zoom` and `angle`, assuming an origin at the
   * top-left corner of the view.
   */
  val anchor: ScreenCoordinate? = null,
  /**
   * Zero-based zoom level. Constrained to the minimum and maximum zoom
   * levels.
   */
  val zoom: Double? = null,
  /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
  val bearing: Double? = null,
  /** Pitch toward the horizon measured in degrees. */
  val pitch: Double? = null
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CameraOptions {
      val center = pigeonVar_list[0] as Point?
      val padding = pigeonVar_list[1] as MbxEdgeInsets?
      val anchor = pigeonVar_list[2] as ScreenCoordinate?
      val zoom = pigeonVar_list[3] as Double?
      val bearing = pigeonVar_list[4] as Double?
      val pitch = pigeonVar_list[5] as Double?
      return CameraOptions(center, padding, anchor, zoom, bearing, pitch)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      center,
      padding,
      anchor,
      zoom,
      bearing,
      pitch,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CameraOptions) {
      return false
    }
    if (this === other) {
      return true
    }
    return center == other.center &&
      padding == other.padding &&
      anchor == other.anchor &&
      zoom == other.zoom &&
      bearing == other.bearing &&
      pitch == other.pitch
  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Describes the viewpoint of a camera.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class CameraState(
  /** Coordinate at the center of the camera. */
  val center: Point,
  /**
   * Padding around the interior of the view that affects the frame of
   * reference for `center`.
   */
  val padding: MbxEdgeInsets,
  /**
   * Zero-based zoom level. Constrained to the minimum and maximum zoom
   * levels.
   */
  val zoom: Double,
  /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
  val bearing: Double,
  /** Pitch toward the horizon measured in degrees. */
  val pitch: Double
) {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CameraState {
      val center = pigeonVar_list[0] as Point
      val padding = pigeonVar_list[1] as MbxEdgeInsets
      val zoom = pigeonVar_list[2] as Double
      val bearing = pigeonVar_list[3] as Double
      val pitch = pigeonVar_list[4] as Double
      return CameraState(center, padding, zoom, bearing, pitch)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      center,
      padding,
      zoom,
      bearing,
      pitch,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CameraState) {
      return false
    }
    if (this === other) {
      return true
    }
    return center == other.center &&
      padding == other.padding &&
      zoom == other.zoom &&
      bearing == other.bearing &&
      pitch == other.pitch
  }

  override fun hashCode(): Int = toList().hashCode()
}