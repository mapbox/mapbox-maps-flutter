// Autogenerated from Pigeon (v17.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum OrnamentPosition: Int {
  case tOPLEFT = 0
  case tOPRIGHT = 1
  case bOTTOMRIGHT = 2
  case bOTTOMLEFT = 3
}

/// Configures the directions in which the map is allowed to move during a scroll gesture.
enum ScrollMode: Int {
  /// The map may only move horizontally.
  case hORIZONTAL = 0
  /// The map may only move vertically.
  case vERTICAL = 1
  /// The map may move both horizontally and vertically.
  case hORIZONTALANDVERTICAL = 2
}

/// The enum controls how the puck is oriented
enum PuckBearing: Int {
  /// Orients the puck to match the direction in which the device is facing.
  case hEADING = 0
  /// Orients the puck to match the direction in which the device is moving.
  case cOURSE = 1
}

/// Defines scaling mode. Only applies to location-indicator type layers.
enum ModelScaleMode: Int {
  /// Model is scaled so that it's always the same size relative to other map features. The property model-scale specifies how many meters each unit in the model file should cover.
  case mAP = 0
  /// Model is scaled so that it's always the same size on the screen. The property model-scale specifies how many pixels each unit in model file should cover.
  case vIEWPORT = 1
}

/// Gesture configuration allows to control the user touch interaction.
///
/// Generated class from Pigeon that represents data sent in messages.
struct GesturesSettings {
  /// Whether the rotate gesture is enabled.
  var rotateEnabled: Bool? = nil
  /// Whether the pinch to zoom gesture is enabled.
  var pinchToZoomEnabled: Bool? = nil
  /// Whether the single-touch scroll gesture is enabled.
  var scrollEnabled: Bool? = nil
  /// Whether rotation is enabled for the pinch to zoom gesture.
  var simultaneousRotateAndPinchToZoomEnabled: Bool? = nil
  /// Whether the pitch gesture is enabled.
  var pitchEnabled: Bool? = nil
  /// Configures the directions in which the map is allowed to move during a scroll gesture.
  var scrollMode: ScrollMode? = nil
  /// Whether double tapping the map with one touch results in a zoom-in animation.
  var doubleTapToZoomInEnabled: Bool? = nil
  /// Whether single tapping the map with two touches results in a zoom-out animation.
  var doubleTouchToZoomOutEnabled: Bool? = nil
  /// Whether the quick zoom gesture is enabled.
  var quickZoomEnabled: Bool? = nil
  /// By default, gestures rotate and zoom around the center of the gesture. Set this property to rotate and zoom around a fixed point instead.
  var focalPoint: ScreenCoordinate? = nil
  /// Whether a deceleration animation following a pinch-to-zoom gesture is enabled. True by default.
  var pinchToZoomDecelerationEnabled: Bool? = nil
  /// Whether a deceleration animation following a rotate gesture is enabled. True by default.
  var rotateDecelerationEnabled: Bool? = nil
  /// Whether a deceleration animation following a scroll gesture is enabled. True by default.
  var scrollDecelerationEnabled: Bool? = nil
  /// Whether rotate threshold increases when pinching to zoom. true by default.
  var increaseRotateThresholdWhenPinchingToZoom: Bool? = nil
  /// Whether pinch to zoom threshold increases when rotating. true by default.
  var increasePinchToZoomThresholdWhenRotating: Bool? = nil
  /// The amount by which the zoom level increases or decreases during a double-tap-to-zoom-in or double-touch-to-zoom-out gesture. 1.0 by default. Must be positive.
  var zoomAnimationAmount: Double? = nil
  /// Whether pan is enabled for the pinch gesture.
  var pinchPanEnabled: Bool? = nil

  static func fromList(_ list: [Any?]) -> GesturesSettings? {
    let rotateEnabled: Bool? = nilOrValue(list[0])
    let pinchToZoomEnabled: Bool? = nilOrValue(list[1])
    let scrollEnabled: Bool? = nilOrValue(list[2])
    let simultaneousRotateAndPinchToZoomEnabled: Bool? = nilOrValue(list[3])
    let pitchEnabled: Bool? = nilOrValue(list[4])
    var scrollMode: ScrollMode? = nil
    let scrollModeEnumVal: Int? = nilOrValue(list[5])
    if let scrollModeRawValue = scrollModeEnumVal {
      scrollMode = ScrollMode(rawValue: scrollModeRawValue)!
    }
    let doubleTapToZoomInEnabled: Bool? = nilOrValue(list[6])
    let doubleTouchToZoomOutEnabled: Bool? = nilOrValue(list[7])
    let quickZoomEnabled: Bool? = nilOrValue(list[8])
    var focalPoint: ScreenCoordinate? = nil
    if let focalPointList: [Any?] = nilOrValue(list[9]) {
      focalPoint = ScreenCoordinate.fromList(focalPointList)
    }
    let pinchToZoomDecelerationEnabled: Bool? = nilOrValue(list[10])
    let rotateDecelerationEnabled: Bool? = nilOrValue(list[11])
    let scrollDecelerationEnabled: Bool? = nilOrValue(list[12])
    let increaseRotateThresholdWhenPinchingToZoom: Bool? = nilOrValue(list[13])
    let increasePinchToZoomThresholdWhenRotating: Bool? = nilOrValue(list[14])
    let zoomAnimationAmount: Double? = nilOrValue(list[15])
    let pinchPanEnabled: Bool? = nilOrValue(list[16])

    return GesturesSettings(
      rotateEnabled: rotateEnabled,
      pinchToZoomEnabled: pinchToZoomEnabled,
      scrollEnabled: scrollEnabled,
      simultaneousRotateAndPinchToZoomEnabled: simultaneousRotateAndPinchToZoomEnabled,
      pitchEnabled: pitchEnabled,
      scrollMode: scrollMode,
      doubleTapToZoomInEnabled: doubleTapToZoomInEnabled,
      doubleTouchToZoomOutEnabled: doubleTouchToZoomOutEnabled,
      quickZoomEnabled: quickZoomEnabled,
      focalPoint: focalPoint,
      pinchToZoomDecelerationEnabled: pinchToZoomDecelerationEnabled,
      rotateDecelerationEnabled: rotateDecelerationEnabled,
      scrollDecelerationEnabled: scrollDecelerationEnabled,
      increaseRotateThresholdWhenPinchingToZoom: increaseRotateThresholdWhenPinchingToZoom,
      increasePinchToZoomThresholdWhenRotating: increasePinchToZoomThresholdWhenRotating,
      zoomAnimationAmount: zoomAnimationAmount,
      pinchPanEnabled: pinchPanEnabled
    )
  }
  func toList() -> [Any?] {
    return [
      rotateEnabled,
      pinchToZoomEnabled,
      scrollEnabled,
      simultaneousRotateAndPinchToZoomEnabled,
      pitchEnabled,
      scrollMode?.rawValue,
      doubleTapToZoomInEnabled,
      doubleTouchToZoomOutEnabled,
      quickZoomEnabled,
      focalPoint?.toList(),
      pinchToZoomDecelerationEnabled,
      rotateDecelerationEnabled,
      scrollDecelerationEnabled,
      increaseRotateThresholdWhenPinchingToZoom,
      increasePinchToZoomThresholdWhenRotating,
      zoomAnimationAmount,
      pinchPanEnabled,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LocationPuck2D {
  /// Name of image in sprite to use as the top of the location indicator.
  var topImage: FlutterStandardTypedData? = nil
  /// Name of image in sprite to use as the middle of the location indicator.
  var bearingImage: FlutterStandardTypedData? = nil
  /// Name of image in sprite to use as the background of the location indicator.
  var shadowImage: FlutterStandardTypedData? = nil
  /// The scale expression of the images. If defined, it will be applied to all the three images.
  var scaleExpression: String? = nil
  /// The opacity of the entire location puck
  var opacity: Double? = nil

  static func fromList(_ list: [Any?]) -> LocationPuck2D? {
    let topImage: FlutterStandardTypedData? = nilOrValue(list[0])
    let bearingImage: FlutterStandardTypedData? = nilOrValue(list[1])
    let shadowImage: FlutterStandardTypedData? = nilOrValue(list[2])
    let scaleExpression: String? = nilOrValue(list[3])
    let opacity: Double? = nilOrValue(list[4])

    return LocationPuck2D(
      topImage: topImage,
      bearingImage: bearingImage,
      shadowImage: shadowImage,
      scaleExpression: scaleExpression,
      opacity: opacity
    )
  }
  func toList() -> [Any?] {
    return [
      topImage,
      bearingImage,
      shadowImage,
      scaleExpression,
      opacity,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LocationPuck3D {
  /// An URL for the model file in gltf format.
  var modelUri: String? = nil
  /// The position of the model.
  var position: [Double?]? = nil
  /// The opacity of the model.
  var modelOpacity: Double? = nil
  /// The scale of the model.
  var modelScale: [Double?]? = nil
  /// The scale expression of the model, which will overwrite the default scale expression that keeps the model size constant during zoom.
  var modelScaleExpression: String? = nil
  /// The translation of the model [lon, lat, z]
  var modelTranslation: [Double?]? = nil
  /// The rotation of the model.
  var modelRotation: [Double?]? = nil
  /// Enable/Disable shadow casting for the 3D location puck.
  var modelCastShadows: Bool? = nil
  /// Enable/Disable shadow receiving for the 3D location puck.
  var modelReceiveShadows: Bool? = nil
  /// Defines scaling mode. Only applies to location-indicator type layers.
  var modelScaleMode: ModelScaleMode? = nil
  /// Strength of the emission. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors).
  var modelEmissiveStrength: Double? = nil
  /// Strength of the emission as Expression string, note that when [modelEmissiveStrengthExpression] is specified, it will overwrite the [modelEmissiveStrength] property. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors).
  var modelEmissiveStrengthExpression: String? = nil

  static func fromList(_ list: [Any?]) -> LocationPuck3D? {
    let modelUri: String? = nilOrValue(list[0])
    let position: [Double?]? = nilOrValue(list[1])
    let modelOpacity: Double? = nilOrValue(list[2])
    let modelScale: [Double?]? = nilOrValue(list[3])
    let modelScaleExpression: String? = nilOrValue(list[4])
    let modelTranslation: [Double?]? = nilOrValue(list[5])
    let modelRotation: [Double?]? = nilOrValue(list[6])
    let modelCastShadows: Bool? = nilOrValue(list[7])
    let modelReceiveShadows: Bool? = nilOrValue(list[8])
    var modelScaleMode: ModelScaleMode? = nil
    let modelScaleModeEnumVal: Int? = nilOrValue(list[9])
    if let modelScaleModeRawValue = modelScaleModeEnumVal {
      modelScaleMode = ModelScaleMode(rawValue: modelScaleModeRawValue)!
    }
    let modelEmissiveStrength: Double? = nilOrValue(list[10])
    let modelEmissiveStrengthExpression: String? = nilOrValue(list[11])

    return LocationPuck3D(
      modelUri: modelUri,
      position: position,
      modelOpacity: modelOpacity,
      modelScale: modelScale,
      modelScaleExpression: modelScaleExpression,
      modelTranslation: modelTranslation,
      modelRotation: modelRotation,
      modelCastShadows: modelCastShadows,
      modelReceiveShadows: modelReceiveShadows,
      modelScaleMode: modelScaleMode,
      modelEmissiveStrength: modelEmissiveStrength,
      modelEmissiveStrengthExpression: modelEmissiveStrengthExpression
    )
  }
  func toList() -> [Any?] {
    return [
      modelUri,
      position,
      modelOpacity,
      modelScale,
      modelScaleExpression,
      modelTranslation,
      modelRotation,
      modelCastShadows,
      modelReceiveShadows,
      modelScaleMode?.rawValue,
      modelEmissiveStrength,
      modelEmissiveStrengthExpression,
    ]
  }
}

/// Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LocationPuck {
  var locationPuck2D: LocationPuck2D? = nil
  var locationPuck3D: LocationPuck3D? = nil

  static func fromList(_ list: [Any?]) -> LocationPuck? {
    var locationPuck2D: LocationPuck2D? = nil
    if let locationPuck2DList: [Any?] = nilOrValue(list[0]) {
      locationPuck2D = LocationPuck2D.fromList(locationPuck2DList)
    }
    var locationPuck3D: LocationPuck3D? = nil
    if let locationPuck3DList: [Any?] = nilOrValue(list[1]) {
      locationPuck3D = LocationPuck3D.fromList(locationPuck3DList)
    }

    return LocationPuck(
      locationPuck2D: locationPuck2D,
      locationPuck3D: locationPuck3D
    )
  }
  func toList() -> [Any?] {
    return [
      locationPuck2D?.toList(),
      locationPuck3D?.toList(),
    ]
  }
}

/// Shows a location puck on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LocationComponentSettings {
  /// Whether the user location is visible on the map.
  var enabled: Bool? = nil
  /// Whether the location puck is pulsing on the map. Works for 2D location puck only.
  var pulsingEnabled: Bool? = nil
  /// The color of the pulsing circle. Works for 2D location puck only.
  var pulsingColor: Int64? = nil
  /// The maximum radius of the pulsing circle. Works for 2D location puck only. Note: Setting [pulsingMaxRadius] to LocationComponentConstants.PULSING_MAX_RADIUS_FOLLOW_ACCURACY will set the pulsing circle's maximum radius to follow location accuracy circle. This property is specified in pixels.
  var pulsingMaxRadius: Double? = nil
  /// Whether show accuracy ring with location puck. Works for 2D location puck only.
  var showAccuracyRing: Bool? = nil
  /// The color of the accuracy ring. Works for 2D location puck only.
  var accuracyRingColor: Int64? = nil
  /// The color of the accuracy ring border. Works for 2D location puck only.
  var accuracyRingBorderColor: Int64? = nil
  /// Sets the id of the layer that's added above to when placing the component on the map.
  var layerAbove: String? = nil
  /// Sets the id of the layer that's added below to when placing the component on the map.
  var layerBelow: String? = nil
  /// Whether the puck rotates to track the bearing source.
  var puckBearingEnabled: Bool? = nil
  /// The enum controls how the puck is oriented
  var puckBearing: PuckBearing? = nil
  /// Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
  var locationPuck: LocationPuck? = nil

  static func fromList(_ list: [Any?]) -> LocationComponentSettings? {
    let enabled: Bool? = nilOrValue(list[0])
    let pulsingEnabled: Bool? = nilOrValue(list[1])
    let pulsingColor: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let pulsingMaxRadius: Double? = nilOrValue(list[3])
    let showAccuracyRing: Bool? = nilOrValue(list[4])
    let accuracyRingColor: Int64? = isNullish(list[5]) ? nil : (list[5] is Int64? ? list[5] as! Int64? : Int64(list[5] as! Int32))
    let accuracyRingBorderColor: Int64? = isNullish(list[6]) ? nil : (list[6] is Int64? ? list[6] as! Int64? : Int64(list[6] as! Int32))
    let layerAbove: String? = nilOrValue(list[7])
    let layerBelow: String? = nilOrValue(list[8])
    let puckBearingEnabled: Bool? = nilOrValue(list[9])
    var puckBearing: PuckBearing? = nil
    let puckBearingEnumVal: Int? = nilOrValue(list[10])
    if let puckBearingRawValue = puckBearingEnumVal {
      puckBearing = PuckBearing(rawValue: puckBearingRawValue)!
    }
    var locationPuck: LocationPuck? = nil
    if let locationPuckList: [Any?] = nilOrValue(list[11]) {
      locationPuck = LocationPuck.fromList(locationPuckList)
    }

    return LocationComponentSettings(
      enabled: enabled,
      pulsingEnabled: pulsingEnabled,
      pulsingColor: pulsingColor,
      pulsingMaxRadius: pulsingMaxRadius,
      showAccuracyRing: showAccuracyRing,
      accuracyRingColor: accuracyRingColor,
      accuracyRingBorderColor: accuracyRingBorderColor,
      layerAbove: layerAbove,
      layerBelow: layerBelow,
      puckBearingEnabled: puckBearingEnabled,
      puckBearing: puckBearing,
      locationPuck: locationPuck
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      pulsingEnabled,
      pulsingColor,
      pulsingMaxRadius,
      showAccuracyRing,
      accuracyRingColor,
      accuracyRingBorderColor,
      layerAbove,
      layerBelow,
      puckBearingEnabled,
      puckBearing?.rawValue,
      locationPuck?.toList(),
    ]
  }
}

/// Shows the scale bar on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ScaleBarSettings {
  /// Whether the scale is visible on the map.
  var enabled: Bool? = nil
  /// Defines where the scale bar is positioned on the map
  var position: OrnamentPosition? = nil
  /// Defines the margin to the left that the scale bar honors. This property is specified in pixels.
  var marginLeft: Double? = nil
  /// Defines the margin to the top that the scale bar honors. This property is specified in pixels.
  var marginTop: Double? = nil
  /// Defines the margin to the right that the scale bar honors. This property is specified in pixels.
  var marginRight: Double? = nil
  /// Defines the margin to the bottom that the scale bar honors. This property is specified in pixels.
  var marginBottom: Double? = nil
  /// Defines text color of the scale bar.
  var textColor: Int64? = nil
  /// Defines primary color of the scale bar.
  var primaryColor: Int64? = nil
  /// Defines secondary color of the scale bar.
  var secondaryColor: Int64? = nil
  /// Defines width of the border for the scale bar. This property is specified in pixels.
  var borderWidth: Double? = nil
  /// Defines height of the scale bar. This property is specified in pixels.
  var height: Double? = nil
  /// Defines margin of the text bar of the scale bar. This property is specified in pixels.
  var textBarMargin: Double? = nil
  /// Defines text border width of the scale bar. This property is specified in pixels.
  var textBorderWidth: Double? = nil
  /// Defines text size of the scale bar. This property is specified in pixels.
  var textSize: Double? = nil
  /// Whether the scale bar is using metric unit. True if the scale bar is using metric system, false if the scale bar is using imperial units.
  var isMetricUnits: Bool? = nil
  /// Configures minimum refresh interval, in millisecond, default is 15.
  var refreshInterval: Int64? = nil
  /// Configures whether to show the text border or not, default is true.
  var showTextBorder: Bool? = nil
  /// configures ratio of scale bar max width compared with MapView width, default is 0.5.
  var ratio: Double? = nil
  /// If set to True scale bar will be triggering onDraw depending on [ScaleBarSettings.refreshInterval] even if actual data did not change. If set to False scale bar will redraw only on demand. Defaults to False and should not be changed explicitly in most cases. Could be set to True to produce correct GPU frame metrics when running gfxinfo command.
  var useContinuousRendering: Bool? = nil

  static func fromList(_ list: [Any?]) -> ScaleBarSettings? {
    let enabled: Bool? = nilOrValue(list[0])
    var position: OrnamentPosition? = nil
    let positionEnumVal: Int? = nilOrValue(list[1])
    if let positionRawValue = positionEnumVal {
      position = OrnamentPosition(rawValue: positionRawValue)!
    }
    let marginLeft: Double? = nilOrValue(list[2])
    let marginTop: Double? = nilOrValue(list[3])
    let marginRight: Double? = nilOrValue(list[4])
    let marginBottom: Double? = nilOrValue(list[5])
    let textColor: Int64? = isNullish(list[6]) ? nil : (list[6] is Int64? ? list[6] as! Int64? : Int64(list[6] as! Int32))
    let primaryColor: Int64? = isNullish(list[7]) ? nil : (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))
    let secondaryColor: Int64? = isNullish(list[8]) ? nil : (list[8] is Int64? ? list[8] as! Int64? : Int64(list[8] as! Int32))
    let borderWidth: Double? = nilOrValue(list[9])
    let height: Double? = nilOrValue(list[10])
    let textBarMargin: Double? = nilOrValue(list[11])
    let textBorderWidth: Double? = nilOrValue(list[12])
    let textSize: Double? = nilOrValue(list[13])
    let isMetricUnits: Bool? = nilOrValue(list[14])
    let refreshInterval: Int64? = isNullish(list[15]) ? nil : (list[15] is Int64? ? list[15] as! Int64? : Int64(list[15] as! Int32))
    let showTextBorder: Bool? = nilOrValue(list[16])
    let ratio: Double? = nilOrValue(list[17])
    let useContinuousRendering: Bool? = nilOrValue(list[18])

    return ScaleBarSettings(
      enabled: enabled,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      textColor: textColor,
      primaryColor: primaryColor,
      secondaryColor: secondaryColor,
      borderWidth: borderWidth,
      height: height,
      textBarMargin: textBarMargin,
      textBorderWidth: textBorderWidth,
      textSize: textSize,
      isMetricUnits: isMetricUnits,
      refreshInterval: refreshInterval,
      showTextBorder: showTextBorder,
      ratio: ratio,
      useContinuousRendering: useContinuousRendering
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      position?.rawValue,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      textColor,
      primaryColor,
      secondaryColor,
      borderWidth,
      height,
      textBarMargin,
      textBorderWidth,
      textSize,
      isMetricUnits,
      refreshInterval,
      showTextBorder,
      ratio,
      useContinuousRendering,
    ]
  }
}

/// Shows the compass on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CompassSettings {
  /// Whether the compass is visible on the map.
  var enabled: Bool? = nil
  /// Defines where the compass is positioned on the map
  var position: OrnamentPosition? = nil
  /// Defines the margin to the left that the compass icon honors. This property is specified in pixels.
  var marginLeft: Double? = nil
  /// Defines the margin to the top that the compass icon honors. This property is specified in pixels.
  var marginTop: Double? = nil
  /// Defines the margin to the right that the compass icon honors. This property is specified in pixels.
  var marginRight: Double? = nil
  /// Defines the margin to the bottom that the compass icon honors. This property is specified in pixels.
  var marginBottom: Double? = nil
  /// The alpha channel value of the compass image
  var opacity: Double? = nil
  /// The clockwise rotation value in degrees of the compass.
  var rotation: Double? = nil
  /// Whether the compass is displayed.
  var visibility: Bool? = nil
  /// Whether the compass fades out to invisible when facing north direction.
  var fadeWhenFacingNorth: Bool? = nil
  /// Whether the compass can be clicked and click events can be registered.
  var clickable: Bool? = nil
  /// The compass image, the visual representation of the compass.
  var image: FlutterStandardTypedData? = nil

  static func fromList(_ list: [Any?]) -> CompassSettings? {
    let enabled: Bool? = nilOrValue(list[0])
    var position: OrnamentPosition? = nil
    let positionEnumVal: Int? = nilOrValue(list[1])
    if let positionRawValue = positionEnumVal {
      position = OrnamentPosition(rawValue: positionRawValue)!
    }
    let marginLeft: Double? = nilOrValue(list[2])
    let marginTop: Double? = nilOrValue(list[3])
    let marginRight: Double? = nilOrValue(list[4])
    let marginBottom: Double? = nilOrValue(list[5])
    let opacity: Double? = nilOrValue(list[6])
    let rotation: Double? = nilOrValue(list[7])
    let visibility: Bool? = nilOrValue(list[8])
    let fadeWhenFacingNorth: Bool? = nilOrValue(list[9])
    let clickable: Bool? = nilOrValue(list[10])
    let image: FlutterStandardTypedData? = nilOrValue(list[11])

    return CompassSettings(
      enabled: enabled,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      opacity: opacity,
      rotation: rotation,
      visibility: visibility,
      fadeWhenFacingNorth: fadeWhenFacingNorth,
      clickable: clickable,
      image: image
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      position?.rawValue,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      opacity,
      rotation,
      visibility,
      fadeWhenFacingNorth,
      clickable,
      image,
    ]
  }
}

/// Shows the attribution icon on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct AttributionSettings {
  /// Defines text color of the attribution icon.
  var iconColor: Int64? = nil
  /// Defines where the attribution icon is positioned on the map
  var position: OrnamentPosition? = nil
  /// Defines the margin to the left that the attribution icon honors. This property is specified in pixels.
  var marginLeft: Double? = nil
  /// Defines the margin to the top that the attribution icon honors. This property is specified in pixels.
  var marginTop: Double? = nil
  /// Defines the margin to the right that the attribution icon honors. This property is specified in pixels.
  var marginRight: Double? = nil
  /// Defines the margin to the bottom that the attribution icon honors. This property is specified in pixels.
  var marginBottom: Double? = nil
  /// Whether the attribution can be clicked and click events can be registered.
  var clickable: Bool? = nil

  static func fromList(_ list: [Any?]) -> AttributionSettings? {
    let iconColor: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    var position: OrnamentPosition? = nil
    let positionEnumVal: Int? = nilOrValue(list[1])
    if let positionRawValue = positionEnumVal {
      position = OrnamentPosition(rawValue: positionRawValue)!
    }
    let marginLeft: Double? = nilOrValue(list[2])
    let marginTop: Double? = nilOrValue(list[3])
    let marginRight: Double? = nilOrValue(list[4])
    let marginBottom: Double? = nilOrValue(list[5])
    let clickable: Bool? = nilOrValue(list[6])

    return AttributionSettings(
      iconColor: iconColor,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      clickable: clickable
    )
  }
  func toList() -> [Any?] {
    return [
      iconColor,
      position?.rawValue,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      clickable,
    ]
  }
}

/// Shows the Mapbox logo on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LogoSettings {
  /// Defines where the logo is positioned on the map
  var position: OrnamentPosition? = nil
  /// Defines the margin to the left that the attribution icon honors. This property is specified in pixels.
  var marginLeft: Double? = nil
  /// Defines the margin to the top that the attribution icon honors. This property is specified in pixels.
  var marginTop: Double? = nil
  /// Defines the margin to the right that the attribution icon honors. This property is specified in pixels.
  var marginRight: Double? = nil
  /// Defines the margin to the bottom that the attribution icon honors. This property is specified in pixels.
  var marginBottom: Double? = nil

  static func fromList(_ list: [Any?]) -> LogoSettings? {
    var position: OrnamentPosition? = nil
    let positionEnumVal: Int? = nilOrValue(list[0])
    if let positionRawValue = positionEnumVal {
      position = OrnamentPosition(rawValue: positionRawValue)!
    }
    let marginLeft: Double? = nilOrValue(list[1])
    let marginTop: Double? = nilOrValue(list[2])
    let marginRight: Double? = nilOrValue(list[3])
    let marginBottom: Double? = nilOrValue(list[4])

    return LogoSettings(
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom
    )
  }
  func toList() -> [Any?] {
    return [
      position?.rawValue,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
    ]
  }
}
private class GesturesSettingsInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return GesturesSettings.fromList(self.readValue() as! [Any?])
    case 129:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class GesturesSettingsInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? GesturesSettings {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class GesturesSettingsInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return GesturesSettingsInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return GesturesSettingsInterfaceCodecWriter(data: data)
  }
}

class GesturesSettingsInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = GesturesSettingsInterfaceCodec(readerWriter: GesturesSettingsInterfaceCodecReaderWriter())
}

/// Gesture configuration allows to control the user touch interaction.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol GesturesSettingsInterface {
  func getSettings() throws -> GesturesSettings
  func updateSettings(settings: GesturesSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class GesturesSettingsInterfaceSetup {
  /// The codec used by GesturesSettingsInterface.
  static var codec: FlutterStandardMessageCodec { GesturesSettingsInterfaceCodec.shared }
  /// Sets up an instance of `GesturesSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: GesturesSettingsInterface?) {
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.getSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.updateSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! GesturesSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
private class _LocationComponentSettingsInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return LocationComponentSettings.fromList(self.readValue() as! [Any?])
    case 129:
      return LocationPuck.fromList(self.readValue() as! [Any?])
    case 130:
      return LocationPuck2D.fromList(self.readValue() as! [Any?])
    case 131:
      return LocationPuck3D.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _LocationComponentSettingsInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? LocationComponentSettings {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? LocationPuck {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? LocationPuck2D {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? LocationPuck3D {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _LocationComponentSettingsInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _LocationComponentSettingsInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _LocationComponentSettingsInterfaceCodecWriter(data: data)
  }
}

class _LocationComponentSettingsInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = _LocationComponentSettingsInterfaceCodec(readerWriter: _LocationComponentSettingsInterfaceCodecReaderWriter())
}

/// Shows a location puck on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _LocationComponentSettingsInterface {
  func getSettings() throws -> LocationComponentSettings
  func updateSettings(settings: LocationComponentSettings, useDefaultPuck2DIfNeeded: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _LocationComponentSettingsInterfaceSetup {
  /// The codec used by _LocationComponentSettingsInterface.
  static var codec: FlutterStandardMessageCodec { _LocationComponentSettingsInterfaceCodec.shared }
  /// Sets up an instance of `_LocationComponentSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _LocationComponentSettingsInterface?) {
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.getSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.updateSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! LocationComponentSettings
        let useDefaultPuck2DIfNeededArg = args[1] as! Bool
        do {
          try api.updateSettings(settings: settingsArg, useDefaultPuck2DIfNeeded: useDefaultPuck2DIfNeededArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
private class ScaleBarSettingsInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return ScaleBarSettings.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ScaleBarSettingsInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ScaleBarSettings {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ScaleBarSettingsInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ScaleBarSettingsInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ScaleBarSettingsInterfaceCodecWriter(data: data)
  }
}

class ScaleBarSettingsInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = ScaleBarSettingsInterfaceCodec(readerWriter: ScaleBarSettingsInterfaceCodecReaderWriter())
}

/// Shows the scale bar on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ScaleBarSettingsInterface {
  func getSettings() throws -> ScaleBarSettings
  func updateSettings(settings: ScaleBarSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ScaleBarSettingsInterfaceSetup {
  /// The codec used by ScaleBarSettingsInterface.
  static var codec: FlutterStandardMessageCodec { ScaleBarSettingsInterfaceCodec.shared }
  /// Sets up an instance of `ScaleBarSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ScaleBarSettingsInterface?) {
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.getSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.updateSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! ScaleBarSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
private class CompassSettingsInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CompassSettings.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class CompassSettingsInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CompassSettings {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class CompassSettingsInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CompassSettingsInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CompassSettingsInterfaceCodecWriter(data: data)
  }
}

class CompassSettingsInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = CompassSettingsInterfaceCodec(readerWriter: CompassSettingsInterfaceCodecReaderWriter())
}

/// Shows the compass on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CompassSettingsInterface {
  func getSettings() throws -> CompassSettings
  func updateSettings(settings: CompassSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CompassSettingsInterfaceSetup {
  /// The codec used by CompassSettingsInterface.
  static var codec: FlutterStandardMessageCodec { CompassSettingsInterfaceCodec.shared }
  /// Sets up an instance of `CompassSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CompassSettingsInterface?) {
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.getSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.updateSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! CompassSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
private class AttributionSettingsInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AttributionSettings.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class AttributionSettingsInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AttributionSettings {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class AttributionSettingsInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return AttributionSettingsInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return AttributionSettingsInterfaceCodecWriter(data: data)
  }
}

class AttributionSettingsInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = AttributionSettingsInterfaceCodec(readerWriter: AttributionSettingsInterfaceCodecReaderWriter())
}

/// Shows the attribution icon on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AttributionSettingsInterface {
  func getSettings() throws -> AttributionSettings
  func updateSettings(settings: AttributionSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AttributionSettingsInterfaceSetup {
  /// The codec used by AttributionSettingsInterface.
  static var codec: FlutterStandardMessageCodec { AttributionSettingsInterfaceCodec.shared }
  /// Sets up an instance of `AttributionSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AttributionSettingsInterface?) {
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.getSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.updateSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! AttributionSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
private class LogoSettingsInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return LogoSettings.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class LogoSettingsInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? LogoSettings {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class LogoSettingsInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return LogoSettingsInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return LogoSettingsInterfaceCodecWriter(data: data)
  }
}

class LogoSettingsInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = LogoSettingsInterfaceCodec(readerWriter: LogoSettingsInterfaceCodecReaderWriter())
}

/// Shows the Mapbox logo on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol LogoSettingsInterface {
  func getSettings() throws -> LogoSettings
  func updateSettings(settings: LogoSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class LogoSettingsInterfaceSetup {
  /// The codec used by LogoSettingsInterface.
  static var codec: FlutterStandardMessageCodec { LogoSettingsInterfaceCodec.shared }
  /// Sets up an instance of `LogoSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: LogoSettingsInterface?) {
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.getSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.updateSettings", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! LogoSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
