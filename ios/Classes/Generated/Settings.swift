// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class SettingsError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "SettingsError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? SettingsError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum OrnamentPosition: Int {
  case tOPLEFT = 0
  case tOPRIGHT = 1
  case bOTTOMRIGHT = 2
  case bOTTOMLEFT = 3
}

/// Configures the directions in which the map is allowed to move during a scroll gesture.
/// Default value: "horizontal-and-vertical".
enum ScrollMode: Int {
  /// The map may only move horizontally.
  case hORIZONTAL = 0
  /// The map may only move vertically.
  case vERTICAL = 1
  /// The map may move both horizontally and vertically.
  case hORIZONTALANDVERTICAL = 2
}

/// The enum controls how the puck is oriented
/// Default value: "heading".
enum PuckBearing: Int {
  /// Orients the puck to match the direction in which the device is facing.
  case hEADING = 0
  /// Orients the puck to match the direction in which the device is moving.
  case cOURSE = 1
}

/// Defines scaling mode. Only applies to location-indicator type layers.
/// Default value: "map".
enum ModelScaleMode: Int {
  /// Model is scaled so that it's always the same size relative to other map features. The property model-scale specifies how many meters each unit in the model file should cover.
  case mAP = 0
  /// Model is scaled so that it's always the same size on the screen. The property model-scale specifies how many pixels each unit in model file should cover.
  case vIEWPORT = 1
}

/// Gesture configuration allows to control the user touch interaction.
///
/// Generated class from Pigeon that represents data sent in messages.
struct GesturesSettings {
  /// Whether the rotate gesture is enabled.
  /// Default value: true.
  var rotateEnabled: Bool?
  /// Whether the pinch to zoom gesture is enabled.
  /// Default value: true.
  var pinchToZoomEnabled: Bool?
  /// Whether the single-touch scroll gesture is enabled.
  /// Default value: true.
  var scrollEnabled: Bool?
  /// Whether rotation is enabled for the pinch to zoom gesture.
  /// Default value: true.
  var simultaneousRotateAndPinchToZoomEnabled: Bool?
  /// Whether the pitch gesture is enabled.
  /// Default value: true.
  var pitchEnabled: Bool?
  /// Configures the directions in which the map is allowed to move during a scroll gesture.
  /// Default value: "horizontal-and-vertical".
  var scrollMode: ScrollMode?
  /// Whether double tapping the map with one touch results in a zoom-in animation.
  /// Default value: true.
  var doubleTapToZoomInEnabled: Bool?
  /// Whether single tapping the map with two touches results in a zoom-out animation.
  /// Default value: true.
  var doubleTouchToZoomOutEnabled: Bool?
  /// Whether the quick zoom gesture is enabled.
  /// Default value: true.
  var quickZoomEnabled: Bool?
  /// By default, gestures rotate and zoom around the center of the gesture. Set this property to rotate and zoom around a fixed point instead.
  var focalPoint: ScreenCoordinate?
  /// Whether a deceleration animation following a pinch-to-zoom gesture is enabled. True by default.
  /// Default value: true.
  var pinchToZoomDecelerationEnabled: Bool?
  /// Whether a deceleration animation following a rotate gesture is enabled. True by default.
  /// Default value: true.
  var rotateDecelerationEnabled: Bool?
  /// Whether a deceleration animation following a scroll gesture is enabled. True by default.
  /// Default value: true.
  var scrollDecelerationEnabled: Bool?
  /// Whether rotate threshold increases when pinching to zoom. true by default.
  /// Default value: true.
  var increaseRotateThresholdWhenPinchingToZoom: Bool?
  /// Whether pinch to zoom threshold increases when rotating. true by default.
  /// Default value: true.
  var increasePinchToZoomThresholdWhenRotating: Bool?
  /// The amount by which the zoom level increases or decreases during a double-tap-to-zoom-in or double-touch-to-zoom-out gesture. 1.0 by default. Must be positive.
  /// Default value: 1.
  var zoomAnimationAmount: Double?
  /// Whether pan is enabled for the pinch gesture.
  /// Default value: true.
  var pinchPanEnabled: Bool?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GesturesSettings? {
    let rotateEnabled: Bool? = nilOrValue(pigeonVar_list[0])
    let pinchToZoomEnabled: Bool? = nilOrValue(pigeonVar_list[1])
    let scrollEnabled: Bool? = nilOrValue(pigeonVar_list[2])
    let simultaneousRotateAndPinchToZoomEnabled: Bool? = nilOrValue(pigeonVar_list[3])
    let pitchEnabled: Bool? = nilOrValue(pigeonVar_list[4])
    let scrollMode: ScrollMode? = nilOrValue(pigeonVar_list[5])
    let doubleTapToZoomInEnabled: Bool? = nilOrValue(pigeonVar_list[6])
    let doubleTouchToZoomOutEnabled: Bool? = nilOrValue(pigeonVar_list[7])
    let quickZoomEnabled: Bool? = nilOrValue(pigeonVar_list[8])
    let focalPoint: ScreenCoordinate? = nilOrValue(pigeonVar_list[9])
    let pinchToZoomDecelerationEnabled: Bool? = nilOrValue(pigeonVar_list[10])
    let rotateDecelerationEnabled: Bool? = nilOrValue(pigeonVar_list[11])
    let scrollDecelerationEnabled: Bool? = nilOrValue(pigeonVar_list[12])
    let increaseRotateThresholdWhenPinchingToZoom: Bool? = nilOrValue(pigeonVar_list[13])
    let increasePinchToZoomThresholdWhenRotating: Bool? = nilOrValue(pigeonVar_list[14])
    let zoomAnimationAmount: Double? = nilOrValue(pigeonVar_list[15])
    let pinchPanEnabled: Bool? = nilOrValue(pigeonVar_list[16])

    return GesturesSettings(
      rotateEnabled: rotateEnabled,
      pinchToZoomEnabled: pinchToZoomEnabled,
      scrollEnabled: scrollEnabled,
      simultaneousRotateAndPinchToZoomEnabled: simultaneousRotateAndPinchToZoomEnabled,
      pitchEnabled: pitchEnabled,
      scrollMode: scrollMode,
      doubleTapToZoomInEnabled: doubleTapToZoomInEnabled,
      doubleTouchToZoomOutEnabled: doubleTouchToZoomOutEnabled,
      quickZoomEnabled: quickZoomEnabled,
      focalPoint: focalPoint,
      pinchToZoomDecelerationEnabled: pinchToZoomDecelerationEnabled,
      rotateDecelerationEnabled: rotateDecelerationEnabled,
      scrollDecelerationEnabled: scrollDecelerationEnabled,
      increaseRotateThresholdWhenPinchingToZoom: increaseRotateThresholdWhenPinchingToZoom,
      increasePinchToZoomThresholdWhenRotating: increasePinchToZoomThresholdWhenRotating,
      zoomAnimationAmount: zoomAnimationAmount,
      pinchPanEnabled: pinchPanEnabled
    )
  }
  func toList() -> [Any?] {
    return [
      rotateEnabled,
      pinchToZoomEnabled,
      scrollEnabled,
      simultaneousRotateAndPinchToZoomEnabled,
      pitchEnabled,
      scrollMode,
      doubleTapToZoomInEnabled,
      doubleTouchToZoomOutEnabled,
      quickZoomEnabled,
      focalPoint,
      pinchToZoomDecelerationEnabled,
      rotateDecelerationEnabled,
      scrollDecelerationEnabled,
      increaseRotateThresholdWhenPinchingToZoom,
      increasePinchToZoomThresholdWhenRotating,
      zoomAnimationAmount,
      pinchPanEnabled,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LocationPuck2D {
  /// Name of image in sprite to use as the top of the location indicator.
  var topImage: FlutterStandardTypedData?
  /// Name of image in sprite to use as the middle of the location indicator.
  var bearingImage: FlutterStandardTypedData?
  /// Name of image in sprite to use as the background of the location indicator.
  var shadowImage: FlutterStandardTypedData?
  /// The scale expression of the images. If defined, it will be applied to all the three images.
  var scaleExpression: String?
  /// The opacity of the entire location puck
  /// Default value: 1. Value range: [0, 1]
  var opacity: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> LocationPuck2D? {
    let topImage: FlutterStandardTypedData? = nilOrValue(pigeonVar_list[0])
    let bearingImage: FlutterStandardTypedData? = nilOrValue(pigeonVar_list[1])
    let shadowImage: FlutterStandardTypedData? = nilOrValue(pigeonVar_list[2])
    let scaleExpression: String? = nilOrValue(pigeonVar_list[3])
    let opacity: Double? = nilOrValue(pigeonVar_list[4])

    return LocationPuck2D(
      topImage: topImage,
      bearingImage: bearingImage,
      shadowImage: shadowImage,
      scaleExpression: scaleExpression,
      opacity: opacity
    )
  }
  func toList() -> [Any?] {
    return [
      topImage,
      bearingImage,
      shadowImage,
      scaleExpression,
      opacity,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LocationPuck3D {
  /// An URL for the model file in gltf format.
  /// Default value: null.
  var modelUri: String?
  /// The position of the model.
  /// Default value: [0,0].
  var position: [Double?]?
  /// The opacity of the model.
  /// Default value: 1. Value range: [0, 1]
  var modelOpacity: Double?
  /// The scale of the model.
  /// Default value: [1,1,1].
  var modelScale: [Double?]?
  /// The scale expression of the model, which will overwrite the default scale expression that keeps the model size constant during zoom.
  var modelScaleExpression: String?
  /// The translation of the model [lon, lat, z]
  /// Default value: [0,0,0].
  var modelTranslation: [Double?]?
  /// The rotation of the model.
  /// Default value: [0,0,90].
  var modelRotation: [Double?]?
  /// Enable/Disable shadow casting for the 3D location puck.
  /// Default value: true.
  var modelCastShadows: Bool?
  /// Enable/Disable shadow receiving for the 3D location puck.
  /// Default value: true.
  var modelReceiveShadows: Bool?
  /// Defines scaling mode. Only applies to location-indicator type layers.
  /// Default value: "map".
  var modelScaleMode: ModelScaleMode?
  /// Strength of the emission. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors).
  /// Default value: 1. Value range: [0, 5]
  var modelEmissiveStrength: Double?
  /// Strength of the emission as Expression string, note that when [modelEmissiveStrengthExpression] is specified, it will overwrite the [modelEmissiveStrength] property. There is no emission for value 0. For value 1.0, only emissive component (no shading) is displayed and values above 1.0 produce light contribution to surrounding area, for some of the parts (e.g. doors).
  var modelEmissiveStrengthExpression: String?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> LocationPuck3D? {
    let modelUri: String? = nilOrValue(pigeonVar_list[0])
    let position: [Double?]? = nilOrValue(pigeonVar_list[1])
    let modelOpacity: Double? = nilOrValue(pigeonVar_list[2])
    let modelScale: [Double?]? = nilOrValue(pigeonVar_list[3])
    let modelScaleExpression: String? = nilOrValue(pigeonVar_list[4])
    let modelTranslation: [Double?]? = nilOrValue(pigeonVar_list[5])
    let modelRotation: [Double?]? = nilOrValue(pigeonVar_list[6])
    let modelCastShadows: Bool? = nilOrValue(pigeonVar_list[7])
    let modelReceiveShadows: Bool? = nilOrValue(pigeonVar_list[8])
    let modelScaleMode: ModelScaleMode? = nilOrValue(pigeonVar_list[9])
    let modelEmissiveStrength: Double? = nilOrValue(pigeonVar_list[10])
    let modelEmissiveStrengthExpression: String? = nilOrValue(pigeonVar_list[11])

    return LocationPuck3D(
      modelUri: modelUri,
      position: position,
      modelOpacity: modelOpacity,
      modelScale: modelScale,
      modelScaleExpression: modelScaleExpression,
      modelTranslation: modelTranslation,
      modelRotation: modelRotation,
      modelCastShadows: modelCastShadows,
      modelReceiveShadows: modelReceiveShadows,
      modelScaleMode: modelScaleMode,
      modelEmissiveStrength: modelEmissiveStrength,
      modelEmissiveStrengthExpression: modelEmissiveStrengthExpression
    )
  }
  func toList() -> [Any?] {
    return [
      modelUri,
      position,
      modelOpacity,
      modelScale,
      modelScaleExpression,
      modelTranslation,
      modelRotation,
      modelCastShadows,
      modelReceiveShadows,
      modelScaleMode,
      modelEmissiveStrength,
      modelEmissiveStrengthExpression,
    ]
  }
}

/// Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LocationPuck {
  var locationPuck2D: LocationPuck2D?
  var locationPuck3D: LocationPuck3D?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> LocationPuck? {
    let locationPuck2D: LocationPuck2D? = nilOrValue(pigeonVar_list[0])
    let locationPuck3D: LocationPuck3D? = nilOrValue(pigeonVar_list[1])

    return LocationPuck(
      locationPuck2D: locationPuck2D,
      locationPuck3D: locationPuck3D
    )
  }
  func toList() -> [Any?] {
    return [
      locationPuck2D,
      locationPuck3D,
    ]
  }
}

/// Shows a location puck on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LocationComponentSettings {
  /// Whether the user location is visible on the map.
  /// Default value: false.
  var enabled: Bool?
  /// Whether the location puck is pulsing on the map. Works for 2D location puck only.
  /// Default value: false.
  var pulsingEnabled: Bool?
  /// The color of the pulsing circle. Works for 2D location puck only.
  /// Default value: "#4A90E2".
  var pulsingColor: Int64?
  /// The maximum radius of the pulsing circle. Works for 2D location puck only. Note: Setting [pulsingMaxRadius] to LocationComponentConstants.PULSING_MAX_RADIUS_FOLLOW_ACCURACY will set the pulsing circle's maximum radius to follow location accuracy circle.
  /// Default value: 10.
  var pulsingMaxRadius: Double?
  /// Whether show accuracy ring with location puck. Works for 2D location puck only.
  /// Default value: false.
  var showAccuracyRing: Bool?
  /// The color of the accuracy ring. Works for 2D location puck only.
  /// Default value: "#4d89cff0".
  var accuracyRingColor: Int64?
  /// The color of the accuracy ring border. Works for 2D location puck only.
  /// Default value: "#4d89cff0".
  var accuracyRingBorderColor: Int64?
  /// Sets the id of the layer that's added above to when placing the component on the map.
  var layerAbove: String?
  /// Sets the id of the layer that's added below to when placing the component on the map.
  var layerBelow: String?
  /// Whether the puck rotates to track the bearing source.
  /// Default value: false.
  var puckBearingEnabled: Bool?
  /// The enum controls how the puck is oriented
  /// Default value: "heading".
  var puckBearing: PuckBearing?
  /// The slot this layer is assigned to. If specified, and a slot with that name exists, it will be placed at that position in the layer order.
  var slot: String?
  /// Defines what the customised look of the location puck. Note that direct changes to the puck variables won't have any effect, a new puck needs to be set every time.
  var locationPuck: LocationPuck?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> LocationComponentSettings? {
    let enabled: Bool? = nilOrValue(pigeonVar_list[0])
    let pulsingEnabled: Bool? = nilOrValue(pigeonVar_list[1])
    let pulsingColor: Int64? = nilOrValue(pigeonVar_list[2])
    let pulsingMaxRadius: Double? = nilOrValue(pigeonVar_list[3])
    let showAccuracyRing: Bool? = nilOrValue(pigeonVar_list[4])
    let accuracyRingColor: Int64? = nilOrValue(pigeonVar_list[5])
    let accuracyRingBorderColor: Int64? = nilOrValue(pigeonVar_list[6])
    let layerAbove: String? = nilOrValue(pigeonVar_list[7])
    let layerBelow: String? = nilOrValue(pigeonVar_list[8])
    let puckBearingEnabled: Bool? = nilOrValue(pigeonVar_list[9])
    let puckBearing: PuckBearing? = nilOrValue(pigeonVar_list[10])
    let slot: String? = nilOrValue(pigeonVar_list[11])
    let locationPuck: LocationPuck? = nilOrValue(pigeonVar_list[12])

    return LocationComponentSettings(
      enabled: enabled,
      pulsingEnabled: pulsingEnabled,
      pulsingColor: pulsingColor,
      pulsingMaxRadius: pulsingMaxRadius,
      showAccuracyRing: showAccuracyRing,
      accuracyRingColor: accuracyRingColor,
      accuracyRingBorderColor: accuracyRingBorderColor,
      layerAbove: layerAbove,
      layerBelow: layerBelow,
      puckBearingEnabled: puckBearingEnabled,
      puckBearing: puckBearing,
      slot: slot,
      locationPuck: locationPuck
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      pulsingEnabled,
      pulsingColor,
      pulsingMaxRadius,
      showAccuracyRing,
      accuracyRingColor,
      accuracyRingBorderColor,
      layerAbove,
      layerBelow,
      puckBearingEnabled,
      puckBearing,
      slot,
      locationPuck,
    ]
  }
}

/// Shows the scale bar on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ScaleBarSettings {
  /// Whether the scale is visible on the map.
  /// Default value: true.
  var enabled: Bool?
  /// Defines where the scale bar is positioned on the map
  /// Default value: "top-left".
  var position: OrnamentPosition?
  /// Defines the margin to the left that the scale bar honors.
  /// Default value: 4.
  var marginLeft: Double?
  /// Defines the margin to the top that the scale bar honors.
  /// Default value: 4.
  var marginTop: Double?
  /// Defines the margin to the right that the scale bar honors.
  /// Default value: 4.
  var marginRight: Double?
  /// Defines the margin to the bottom that the scale bar honors.
  /// Default value: 4.
  var marginBottom: Double?
  /// Defines text color of the scale bar.
  /// Default value: "black".
  var textColor: Int64?
  /// Defines primary color of the scale bar.
  /// Default value: "black".
  var primaryColor: Int64?
  /// Defines secondary color of the scale bar.
  /// Default value: "white".
  var secondaryColor: Int64?
  /// Defines width of the border for the scale bar.
  /// Default value: 2.
  var borderWidth: Double?
  /// Defines height of the scale bar.
  /// Default value: 2.
  var height: Double?
  /// Defines margin of the text bar of the scale bar.
  /// Default value: 8.
  var textBarMargin: Double?
  /// Defines text border width of the scale bar.
  /// Default value: 2.
  var textBorderWidth: Double?
  /// Defines text size of the scale bar.
  /// Default value: 8.
  var textSize: Double?
  /// Whether the scale bar is using metric unit. True if the scale bar is using metric system, false if the scale bar is using imperial units.
  /// Default value: true.
  var isMetricUnits: Bool?
  /// Configures minimum refresh interval, in millisecond, default is 15.
  /// Default value: 15.
  var refreshInterval: Int64?
  /// Configures whether to show the text border or not, default is true.
  /// Default value: true.
  var showTextBorder: Bool?
  /// configures ratio of scale bar max width compared with MapView width, default is 0.5.
  /// Default value: 0.5.
  var ratio: Double?
  /// If set to True scale bar will be triggering onDraw depending on [ScaleBarSettings.refreshInterval] even if actual data did not change. If set to False scale bar will redraw only on demand. Defaults to False and should not be changed explicitly in most cases. Could be set to True to produce correct GPU frame metrics when running gfxinfo command.
  /// Default value: false.
  var useContinuousRendering: Bool?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ScaleBarSettings? {
    let enabled: Bool? = nilOrValue(pigeonVar_list[0])
    let position: OrnamentPosition? = nilOrValue(pigeonVar_list[1])
    let marginLeft: Double? = nilOrValue(pigeonVar_list[2])
    let marginTop: Double? = nilOrValue(pigeonVar_list[3])
    let marginRight: Double? = nilOrValue(pigeonVar_list[4])
    let marginBottom: Double? = nilOrValue(pigeonVar_list[5])
    let textColor: Int64? = nilOrValue(pigeonVar_list[6])
    let primaryColor: Int64? = nilOrValue(pigeonVar_list[7])
    let secondaryColor: Int64? = nilOrValue(pigeonVar_list[8])
    let borderWidth: Double? = nilOrValue(pigeonVar_list[9])
    let height: Double? = nilOrValue(pigeonVar_list[10])
    let textBarMargin: Double? = nilOrValue(pigeonVar_list[11])
    let textBorderWidth: Double? = nilOrValue(pigeonVar_list[12])
    let textSize: Double? = nilOrValue(pigeonVar_list[13])
    let isMetricUnits: Bool? = nilOrValue(pigeonVar_list[14])
    let refreshInterval: Int64? = nilOrValue(pigeonVar_list[15])
    let showTextBorder: Bool? = nilOrValue(pigeonVar_list[16])
    let ratio: Double? = nilOrValue(pigeonVar_list[17])
    let useContinuousRendering: Bool? = nilOrValue(pigeonVar_list[18])

    return ScaleBarSettings(
      enabled: enabled,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      textColor: textColor,
      primaryColor: primaryColor,
      secondaryColor: secondaryColor,
      borderWidth: borderWidth,
      height: height,
      textBarMargin: textBarMargin,
      textBorderWidth: textBorderWidth,
      textSize: textSize,
      isMetricUnits: isMetricUnits,
      refreshInterval: refreshInterval,
      showTextBorder: showTextBorder,
      ratio: ratio,
      useContinuousRendering: useContinuousRendering
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      textColor,
      primaryColor,
      secondaryColor,
      borderWidth,
      height,
      textBarMargin,
      textBorderWidth,
      textSize,
      isMetricUnits,
      refreshInterval,
      showTextBorder,
      ratio,
      useContinuousRendering,
    ]
  }
}

/// Shows the compass on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CompassSettings {
  /// Whether the compass is visible on the map.
  /// Default value: true.
  var enabled: Bool?
  /// Defines where the compass is positioned on the map
  /// Default value: "top-right".
  var position: OrnamentPosition?
  /// Defines the margin to the left that the compass icon honors.
  /// Default value: 4.
  var marginLeft: Double?
  /// Defines the margin to the top that the compass icon honors.
  /// Default value: 4.
  var marginTop: Double?
  /// Defines the margin to the right that the compass icon honors.
  /// Default value: 4.
  var marginRight: Double?
  /// Defines the margin to the bottom that the compass icon honors.
  /// Default value: 4.
  var marginBottom: Double?
  /// The alpha channel value of the compass image
  /// Default value: 1.
  var opacity: Double?
  /// The clockwise rotation value in degrees of the compass.
  /// Default value: 0.
  var rotation: Double?
  /// Whether the compass is displayed.
  /// Default value: true.
  var visibility: Bool?
  /// Whether the compass fades out to invisible when facing north direction.
  /// Default value: true.
  var fadeWhenFacingNorth: Bool?
  /// Whether the compass can be clicked and click events can be registered.
  /// Default value: true.
  var clickable: Bool?
  /// The compass image, the visual representation of the compass.
  var image: FlutterStandardTypedData?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CompassSettings? {
    let enabled: Bool? = nilOrValue(pigeonVar_list[0])
    let position: OrnamentPosition? = nilOrValue(pigeonVar_list[1])
    let marginLeft: Double? = nilOrValue(pigeonVar_list[2])
    let marginTop: Double? = nilOrValue(pigeonVar_list[3])
    let marginRight: Double? = nilOrValue(pigeonVar_list[4])
    let marginBottom: Double? = nilOrValue(pigeonVar_list[5])
    let opacity: Double? = nilOrValue(pigeonVar_list[6])
    let rotation: Double? = nilOrValue(pigeonVar_list[7])
    let visibility: Bool? = nilOrValue(pigeonVar_list[8])
    let fadeWhenFacingNorth: Bool? = nilOrValue(pigeonVar_list[9])
    let clickable: Bool? = nilOrValue(pigeonVar_list[10])
    let image: FlutterStandardTypedData? = nilOrValue(pigeonVar_list[11])

    return CompassSettings(
      enabled: enabled,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      opacity: opacity,
      rotation: rotation,
      visibility: visibility,
      fadeWhenFacingNorth: fadeWhenFacingNorth,
      clickable: clickable,
      image: image
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      opacity,
      rotation,
      visibility,
      fadeWhenFacingNorth,
      clickable,
      image,
    ]
  }
}

/// Shows the attribution icon on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct AttributionSettings {
  /// Whether the attribution icon is visible on the map.
  /// Default value: true.
  /// Restricted API. Please contact Mapbox to discuss your use case if you intend to use this property.
  var enabled: Bool?
  /// Defines text color of the attribution icon.
  /// Default value: "#FF1E8CAB".
  var iconColor: Int64?
  /// Defines where the attribution icon is positioned on the map
  /// Default value: "bottom-left".
  var position: OrnamentPosition?
  /// Defines the margin to the left that the attribution icon honors.
  /// Default value: 92.
  var marginLeft: Double?
  /// Defines the margin to the top that the attribution icon honors.
  /// Default value: 4.
  var marginTop: Double?
  /// Defines the margin to the right that the attribution icon honors.
  /// Default value: 4.
  var marginRight: Double?
  /// Defines the margin to the bottom that the attribution icon honors.
  /// Default value: 4.
  var marginBottom: Double?
  /// Whether the attribution can be clicked and click events can be registered.
  /// Default value: true.
  var clickable: Bool?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AttributionSettings? {
    let enabled: Bool? = nilOrValue(pigeonVar_list[0])
    let iconColor: Int64? = nilOrValue(pigeonVar_list[1])
    let position: OrnamentPosition? = nilOrValue(pigeonVar_list[2])
    let marginLeft: Double? = nilOrValue(pigeonVar_list[3])
    let marginTop: Double? = nilOrValue(pigeonVar_list[4])
    let marginRight: Double? = nilOrValue(pigeonVar_list[5])
    let marginBottom: Double? = nilOrValue(pigeonVar_list[6])
    let clickable: Bool? = nilOrValue(pigeonVar_list[7])

    return AttributionSettings(
      enabled: enabled,
      iconColor: iconColor,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom,
      clickable: clickable
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      iconColor,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
      clickable,
    ]
  }
}

/// Shows the Mapbox logo on the map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LogoSettings {
  /// Whether the logo is visible on the map.
  /// Default value: true.
  /// Restricted API. Please contact Mapbox to discuss your use case if you intend to use this property.
  var enabled: Bool?
  /// Defines where the logo is positioned on the map
  /// Default value: "bottom-left".
  var position: OrnamentPosition?
  /// Defines the margin to the left that the attribution icon honors.
  /// Default value: 4.
  var marginLeft: Double?
  /// Defines the margin to the top that the attribution icon honors.
  /// Default value: 4.
  var marginTop: Double?
  /// Defines the margin to the right that the attribution icon honors.
  /// Default value: 4.
  var marginRight: Double?
  /// Defines the margin to the bottom that the attribution icon honors.
  /// Default value: 4.
  var marginBottom: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> LogoSettings? {
    let enabled: Bool? = nilOrValue(pigeonVar_list[0])
    let position: OrnamentPosition? = nilOrValue(pigeonVar_list[1])
    let marginLeft: Double? = nilOrValue(pigeonVar_list[2])
    let marginTop: Double? = nilOrValue(pigeonVar_list[3])
    let marginRight: Double? = nilOrValue(pigeonVar_list[4])
    let marginBottom: Double? = nilOrValue(pigeonVar_list[5])

    return LogoSettings(
      enabled: enabled,
      position: position,
      marginLeft: marginLeft,
      marginTop: marginTop,
      marginRight: marginRight,
      marginBottom: marginBottom
    )
  }
  func toList() -> [Any?] {
    return [
      enabled,
      position,
      marginLeft,
      marginTop,
      marginRight,
      marginBottom,
    ]
  }
}

private class SettingsPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return OrnamentPosition(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ScrollMode(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PuckBearing(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ModelScaleMode(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 134:
      return GesturesSettings.fromList(self.readValue() as! [Any?])
    case 135:
      return LocationPuck2D.fromList(self.readValue() as! [Any?])
    case 136:
      return LocationPuck3D.fromList(self.readValue() as! [Any?])
    case 137:
      return LocationPuck.fromList(self.readValue() as! [Any?])
    case 138:
      return LocationComponentSettings.fromList(self.readValue() as! [Any?])
    case 139:
      return ScaleBarSettings.fromList(self.readValue() as! [Any?])
    case 140:
      return CompassSettings.fromList(self.readValue() as! [Any?])
    case 141:
      return AttributionSettings.fromList(self.readValue() as! [Any?])
    case 142:
      return LogoSettings.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class SettingsPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? OrnamentPosition {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? ScrollMode {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? PuckBearing {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? ModelScaleMode {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? GesturesSettings {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? LocationPuck2D {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? LocationPuck3D {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? LocationPuck {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? LocationComponentSettings {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? ScaleBarSettings {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? CompassSettings {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? AttributionSettings {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? LogoSettings {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class SettingsPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SettingsPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SettingsPigeonCodecWriter(data: data)
  }
}

class SettingsPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = SettingsPigeonCodec(readerWriter: SettingsPigeonCodecReaderWriter())
}

/// Gesture configuration allows to control the user touch interaction.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol GesturesSettingsInterface {
  func getSettings() throws -> GesturesSettings
  func updateSettings(settings: GesturesSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class GesturesSettingsInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { SettingsPigeonCodec.shared }
  /// Sets up an instance of `GesturesSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: GesturesSettingsInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.getSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.GesturesSettingsInterface.updateSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! GesturesSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
/// Shows a location puck on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _LocationComponentSettingsInterface {
  func getSettings() throws -> LocationComponentSettings
  func updateSettings(settings: LocationComponentSettings, useDefaultPuck2DIfNeeded: Bool) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _LocationComponentSettingsInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { SettingsPigeonCodec.shared }
  /// Sets up an instance of `_LocationComponentSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _LocationComponentSettingsInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.getSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._LocationComponentSettingsInterface.updateSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! LocationComponentSettings
        let useDefaultPuck2DIfNeededArg = args[1] as! Bool
        do {
          try api.updateSettings(settings: settingsArg, useDefaultPuck2DIfNeeded: useDefaultPuck2DIfNeededArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
/// Shows the scale bar on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ScaleBarSettingsInterface {
  func getSettings() throws -> ScaleBarSettings
  func updateSettings(settings: ScaleBarSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ScaleBarSettingsInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { SettingsPigeonCodec.shared }
  /// Sets up an instance of `ScaleBarSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ScaleBarSettingsInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.getSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.ScaleBarSettingsInterface.updateSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! ScaleBarSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
/// Shows the compass on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CompassSettingsInterface {
  func getSettings() throws -> CompassSettings
  func updateSettings(settings: CompassSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CompassSettingsInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { SettingsPigeonCodec.shared }
  /// Sets up an instance of `CompassSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CompassSettingsInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.getSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.CompassSettingsInterface.updateSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! CompassSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
/// Shows the attribution icon on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AttributionSettingsInterface {
  func getSettings() throws -> AttributionSettings
  func updateSettings(settings: AttributionSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AttributionSettingsInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { SettingsPigeonCodec.shared }
  /// Sets up an instance of `AttributionSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AttributionSettingsInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.getSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.AttributionSettingsInterface.updateSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! AttributionSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
/// Shows the Mapbox logo on the map.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol LogoSettingsInterface {
  func getSettings() throws -> LogoSettings
  func updateSettings(settings: LogoSettings) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class LogoSettingsInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { SettingsPigeonCodec.shared }
  /// Sets up an instance of `LogoSettingsInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: LogoSettingsInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.getSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSettingsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSettings()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSettingsChannel.setMessageHandler(nil)
    }
    let updateSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.LogoSettingsInterface.updateSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateSettingsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let settingsArg = args[0] as! LogoSettings
        do {
          try api.updateSettings(settings: settingsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      updateSettingsChannel.setMessageHandler(nil)
    }
  }
}
