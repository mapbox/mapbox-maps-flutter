// Autogenerated from Pigeon (v21.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point

/// Error class for passing custom error details to Dart side.
final class PointAnnotationMessengerError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PointAnnotationMessengerError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PointAnnotationMessengerError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PointAnnotationMessengerError {
  return PointAnnotationMessengerError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Part of the icon placed closest to the anchor.
/// Default value: "center".
enum IconAnchor: Int {
  /// The center of the icon is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the icon is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the icon is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the icon is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the icon is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the icon is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the icon is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the icon is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the icon is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// Orientation of icon when map is pitched.
/// Default value: "auto".
enum IconPitchAlignment: Int {
  /// The icon is aligned to the plane of the map.
  case mAP = 0
  /// The icon is aligned to the plane of the viewport.
  case vIEWPORT = 1
  /// Automatically matches the value of `icon-rotation-alignment`.
  case aUTO = 2
}

/// In combination with `symbol-placement`, determines the rotation behavior of icons.
/// Default value: "auto".
enum IconRotationAlignment: Int {
  /// When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line.
  case mAP = 0
  /// Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.
  case vIEWPORT = 1
  /// When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.
  case aUTO = 2
}

/// Scales the icon to fit around the associated text.
/// Default value: "none".
enum IconTextFit: Int {
  /// The icon is displayed at its intrinsic aspect ratio.
  case nONE = 0
  /// The icon is scaled in the x-dimension to fit the width of the text.
  case wIDTH = 1
  /// The icon is scaled in the y-dimension to fit the height of the text.
  case hEIGHT = 2
  /// The icon is scaled in both x- and y-dimensions.
  case bOTH = 3
}

/// Label placement relative to its geometry.
/// Default value: "point".
enum SymbolPlacement: Int {
  /// The label is placed at the point where the geometry is located.
  case pOINT = 0
  /// The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries.
  case lINE = 1
  /// The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries.
  case lINECENTER = 2
}

/// Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.
/// Default value: "auto".
enum SymbolZOrder: Int {
  /// Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.
  case aUTO = 0
  /// Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.
  case vIEWPORTY = 1
  /// Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data.
  case sOURCE = 2
}

/// Part of the text placed closest to the anchor.
/// Default value: "center".
enum TextAnchor: Int {
  /// The center of the text is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the text is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the text is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the text is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the text is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the text is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the text is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the text is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the text is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// Text justification options.
/// Default value: "center".
enum TextJustify: Int {
  /// The text is aligned towards the anchor position.
  case aUTO = 0
  /// The text is aligned to the left.
  case lEFT = 1
  /// The text is centered.
  case cENTER = 2
  /// The text is aligned to the right.
  case rIGHT = 3
}

/// Orientation of text when map is pitched.
/// Default value: "auto".
enum TextPitchAlignment: Int {
  /// The text is aligned to the plane of the map.
  case mAP = 0
  /// The text is aligned to the plane of the viewport.
  case vIEWPORT = 1
  /// Automatically matches the value of `text-rotation-alignment`.
  case aUTO = 2
}

/// In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.
/// Default value: "auto".
enum TextRotationAlignment: Int {
  /// When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line.
  case mAP = 0
  /// Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.
  case vIEWPORT = 1
  /// When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.
  case aUTO = 2
}

/// Specifies how to capitalize text, similar to the CSS `text-transform` property.
/// Default value: "none".
enum TextTransform: Int {
  /// The text is not altered.
  case nONE = 0
  /// Forces all letters to be displayed in uppercase.
  case uPPERCASE = 1
  /// Forces all letters to be displayed in lowercase.
  case lOWERCASE = 2
}

/// To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.
enum TextVariableAnchor: Int {
  /// The center of the text is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the text is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the text is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the text is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the text is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the text is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the text is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the text is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the text is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnâ€™t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement.
enum TextWritingMode: Int {
  /// If a text's language supports horizontal writing mode, symbols would be laid out horizontally.
  case hORIZONTAL = 0
  /// If a text's language supports vertical writing mode, symbols would be laid out vertically.
  case vERTICAL = 1
}

/// Controls the frame of reference for `icon-translate`.
/// Default value: "map".
enum IconTranslateAnchor: Int {
  /// Icons are translated relative to the map.
  case mAP = 0
  /// Icons are translated relative to the viewport.
  case vIEWPORT = 1
}

/// Controls the frame of reference for `text-translate`.
/// Default value: "map".
enum TextTranslateAnchor: Int {
  /// The text is translated relative to the map.
  case mAP = 0
  /// The text is translated relative to the viewport.
  case vIEWPORT = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointAnnotation {
  /// The id for annotation
  var id: String
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// The bitmap image for this Annotation
  /// Will not take effect if [iconImage] has been set.
  var image: FlutterStandardTypedData?
  /// Part of the icon placed closest to the anchor.
  /// Default value: "center".
  var iconAnchor: IconAnchor?
  /// Name of image in sprite to use for drawing an image background.
  var iconImage: String?
  /// Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
  /// Default value: [0,0].
  var iconOffset: [Double?]?
  /// Rotates the icon clockwise.
  /// Default value: 0.
  var iconRotate: Double?
  /// Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
  /// Default value: 1. Minimum value: 0.
  var iconSize: Double?
  /// Scales the icon to fit around the associated text.
  /// Default value: "none".
  var iconTextFit: IconTextFit?
  /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
  /// Default value: [0,0,0,0].
  var iconTextFitPadding: [Double?]?
  /// Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.
  var symbolSortKey: Double?
  /// Part of the text placed closest to the anchor.
  /// Default value: "center".
  var textAnchor: TextAnchor?
  /// Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
  /// Default value: "".
  var textField: String?
  /// Text justification options.
  /// Default value: "center".
  var textJustify: TextJustify?
  /// Text tracking amount.
  /// Default value: 0.
  var textLetterSpacing: Double?
  /// Text leading value for multi-line text.
  /// Default value: 1.2.
  var textLineHeight: Double?
  /// The maximum line width for text wrapping.
  /// Default value: 10. Minimum value: 0.
  var textMaxWidth: Double?
  /// Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
  /// Default value: [0,0].
  var textOffset: [Double?]?
  /// Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
  /// Default value: 0.
  var textRadialOffset: Double?
  /// Rotates the text clockwise.
  /// Default value: 0.
  var textRotate: Double?
  /// Font size.
  /// Default value: 16. Minimum value: 0.
  var textSize: Double?
  /// Specifies how to capitalize text, similar to the CSS `text-transform` property.
  /// Default value: "none".
  var textTransform: TextTransform?
  /// The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "#000000".
  var iconColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var iconEmissiveStrength: Double?
  /// Fade out the halo towards the outside.
  /// Default value: 0. Minimum value: 0.
  var iconHaloBlur: Double?
  /// The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "rgba(0, 0, 0, 0)".
  var iconHaloColor: Int64?
  /// Distance of halo to the icon outline.
  /// Default value: 0. Minimum value: 0.
  var iconHaloWidth: Double?
  /// Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
  /// Default value: 0. Value range: [0, 1]
  var iconImageCrossFade: Double?
  /// The opacity at which the icon will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var iconOpacity: Double?
  /// The color with which the text will be drawn.
  /// Default value: "#000000".
  var textColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var textEmissiveStrength: Double?
  /// The halo's fadeout distance towards the outside.
  /// Default value: 0. Minimum value: 0.
  var textHaloBlur: Double?
  /// The color of the text's halo, which helps it stand out from backgrounds.
  /// Default value: "rgba(0, 0, 0, 0)".
  var textHaloColor: Int64?
  /// Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
  /// Default value: 0. Minimum value: 0.
  var textHaloWidth: Double?
  /// The opacity at which the text will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var textOpacity: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> PointAnnotation? {
    let id = __pigeon_list[0] as! String
    let geometry = __pigeon_list[1] as! Point
    let image: FlutterStandardTypedData? = nilOrValue(__pigeon_list[2])
    let iconAnchor: IconAnchor? = nilOrValue(__pigeon_list[3])
    let iconImage: String? = nilOrValue(__pigeon_list[4])
    let iconOffset: [Double?]? = nilOrValue(__pigeon_list[5])
    let iconRotate: Double? = nilOrValue(__pigeon_list[6])
    let iconSize: Double? = nilOrValue(__pigeon_list[7])
    let iconTextFit: IconTextFit? = nilOrValue(__pigeon_list[8])
    let iconTextFitPadding: [Double?]? = nilOrValue(__pigeon_list[9])
    let symbolSortKey: Double? = nilOrValue(__pigeon_list[10])
    let textAnchor: TextAnchor? = nilOrValue(__pigeon_list[11])
    let textField: String? = nilOrValue(__pigeon_list[12])
    let textJustify: TextJustify? = nilOrValue(__pigeon_list[13])
    let textLetterSpacing: Double? = nilOrValue(__pigeon_list[14])
    let textLineHeight: Double? = nilOrValue(__pigeon_list[15])
    let textMaxWidth: Double? = nilOrValue(__pigeon_list[16])
    let textOffset: [Double?]? = nilOrValue(__pigeon_list[17])
    let textRadialOffset: Double? = nilOrValue(__pigeon_list[18])
    let textRotate: Double? = nilOrValue(__pigeon_list[19])
    let textSize: Double? = nilOrValue(__pigeon_list[20])
    let textTransform: TextTransform? = nilOrValue(__pigeon_list[21])
    let iconColor: Int64? = isNullish(__pigeon_list[22]) ? nil : (__pigeon_list[22] is Int64? ? __pigeon_list[22] as! Int64? : Int64(__pigeon_list[22] as! Int32))
    let iconEmissiveStrength: Double? = nilOrValue(__pigeon_list[23])
    let iconHaloBlur: Double? = nilOrValue(__pigeon_list[24])
    let iconHaloColor: Int64? = isNullish(__pigeon_list[25]) ? nil : (__pigeon_list[25] is Int64? ? __pigeon_list[25] as! Int64? : Int64(__pigeon_list[25] as! Int32))
    let iconHaloWidth: Double? = nilOrValue(__pigeon_list[26])
    let iconImageCrossFade: Double? = nilOrValue(__pigeon_list[27])
    let iconOpacity: Double? = nilOrValue(__pigeon_list[28])
    let textColor: Int64? = isNullish(__pigeon_list[29]) ? nil : (__pigeon_list[29] is Int64? ? __pigeon_list[29] as! Int64? : Int64(__pigeon_list[29] as! Int32))
    let textEmissiveStrength: Double? = nilOrValue(__pigeon_list[30])
    let textHaloBlur: Double? = nilOrValue(__pigeon_list[31])
    let textHaloColor: Int64? = isNullish(__pigeon_list[32]) ? nil : (__pigeon_list[32] is Int64? ? __pigeon_list[32] as! Int64? : Int64(__pigeon_list[32] as! Int32))
    let textHaloWidth: Double? = nilOrValue(__pigeon_list[33])
    let textOpacity: Double? = nilOrValue(__pigeon_list[34])

    return PointAnnotation(
      id: id,
      geometry: geometry,
      image: image,
      iconAnchor: iconAnchor,
      iconImage: iconImage,
      iconOffset: iconOffset,
      iconRotate: iconRotate,
      iconSize: iconSize,
      iconTextFit: iconTextFit,
      iconTextFitPadding: iconTextFitPadding,
      symbolSortKey: symbolSortKey,
      textAnchor: textAnchor,
      textField: textField,
      textJustify: textJustify,
      textLetterSpacing: textLetterSpacing,
      textLineHeight: textLineHeight,
      textMaxWidth: textMaxWidth,
      textOffset: textOffset,
      textRadialOffset: textRadialOffset,
      textRotate: textRotate,
      textSize: textSize,
      textTransform: textTransform,
      iconColor: iconColor,
      iconEmissiveStrength: iconEmissiveStrength,
      iconHaloBlur: iconHaloBlur,
      iconHaloColor: iconHaloColor,
      iconHaloWidth: iconHaloWidth,
      iconImageCrossFade: iconImageCrossFade,
      iconOpacity: iconOpacity,
      textColor: textColor,
      textEmissiveStrength: textEmissiveStrength,
      textHaloBlur: textHaloBlur,
      textHaloColor: textHaloColor,
      textHaloWidth: textHaloWidth,
      textOpacity: textOpacity
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      geometry,
      image,
      iconAnchor,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor,
      textField,
      textJustify,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointAnnotationOptions {
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// The bitmap image for this Annotation
  /// Will not take effect if [iconImage] has been set.
  var image: FlutterStandardTypedData?
  /// Part of the icon placed closest to the anchor.
  /// Default value: "center".
  var iconAnchor: IconAnchor?
  /// Name of image in sprite to use for drawing an image background.
  var iconImage: String?
  /// Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
  /// Default value: [0,0].
  var iconOffset: [Double?]?
  /// Rotates the icon clockwise.
  /// Default value: 0.
  var iconRotate: Double?
  /// Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
  /// Default value: 1. Minimum value: 0.
  var iconSize: Double?
  /// Scales the icon to fit around the associated text.
  /// Default value: "none".
  var iconTextFit: IconTextFit?
  /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
  /// Default value: [0,0,0,0].
  var iconTextFitPadding: [Double?]?
  /// Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.
  var symbolSortKey: Double?
  /// Part of the text placed closest to the anchor.
  /// Default value: "center".
  var textAnchor: TextAnchor?
  /// Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
  /// Default value: "".
  var textField: String?
  /// Text justification options.
  /// Default value: "center".
  var textJustify: TextJustify?
  /// Text tracking amount.
  /// Default value: 0.
  var textLetterSpacing: Double?
  /// Text leading value for multi-line text.
  /// Default value: 1.2.
  var textLineHeight: Double?
  /// The maximum line width for text wrapping.
  /// Default value: 10. Minimum value: 0.
  var textMaxWidth: Double?
  /// Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
  /// Default value: [0,0].
  var textOffset: [Double?]?
  /// Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
  /// Default value: 0.
  var textRadialOffset: Double?
  /// Rotates the text clockwise.
  /// Default value: 0.
  var textRotate: Double?
  /// Font size.
  /// Default value: 16. Minimum value: 0.
  var textSize: Double?
  /// Specifies how to capitalize text, similar to the CSS `text-transform` property.
  /// Default value: "none".
  var textTransform: TextTransform?
  /// The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "#000000".
  var iconColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var iconEmissiveStrength: Double?
  /// Fade out the halo towards the outside.
  /// Default value: 0. Minimum value: 0.
  var iconHaloBlur: Double?
  /// The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "rgba(0, 0, 0, 0)".
  var iconHaloColor: Int64?
  /// Distance of halo to the icon outline.
  /// Default value: 0. Minimum value: 0.
  var iconHaloWidth: Double?
  /// Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
  /// Default value: 0. Value range: [0, 1]
  var iconImageCrossFade: Double?
  /// The opacity at which the icon will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var iconOpacity: Double?
  /// The color with which the text will be drawn.
  /// Default value: "#000000".
  var textColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var textEmissiveStrength: Double?
  /// The halo's fadeout distance towards the outside.
  /// Default value: 0. Minimum value: 0.
  var textHaloBlur: Double?
  /// The color of the text's halo, which helps it stand out from backgrounds.
  /// Default value: "rgba(0, 0, 0, 0)".
  var textHaloColor: Int64?
  /// Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
  /// Default value: 0. Minimum value: 0.
  var textHaloWidth: Double?
  /// The opacity at which the text will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var textOpacity: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> PointAnnotationOptions? {
    let geometry = __pigeon_list[0] as! Point
    let image: FlutterStandardTypedData? = nilOrValue(__pigeon_list[1])
    let iconAnchor: IconAnchor? = nilOrValue(__pigeon_list[2])
    let iconImage: String? = nilOrValue(__pigeon_list[3])
    let iconOffset: [Double?]? = nilOrValue(__pigeon_list[4])
    let iconRotate: Double? = nilOrValue(__pigeon_list[5])
    let iconSize: Double? = nilOrValue(__pigeon_list[6])
    let iconTextFit: IconTextFit? = nilOrValue(__pigeon_list[7])
    let iconTextFitPadding: [Double?]? = nilOrValue(__pigeon_list[8])
    let symbolSortKey: Double? = nilOrValue(__pigeon_list[9])
    let textAnchor: TextAnchor? = nilOrValue(__pigeon_list[10])
    let textField: String? = nilOrValue(__pigeon_list[11])
    let textJustify: TextJustify? = nilOrValue(__pigeon_list[12])
    let textLetterSpacing: Double? = nilOrValue(__pigeon_list[13])
    let textLineHeight: Double? = nilOrValue(__pigeon_list[14])
    let textMaxWidth: Double? = nilOrValue(__pigeon_list[15])
    let textOffset: [Double?]? = nilOrValue(__pigeon_list[16])
    let textRadialOffset: Double? = nilOrValue(__pigeon_list[17])
    let textRotate: Double? = nilOrValue(__pigeon_list[18])
    let textSize: Double? = nilOrValue(__pigeon_list[19])
    let textTransform: TextTransform? = nilOrValue(__pigeon_list[20])
    let iconColor: Int64? = isNullish(__pigeon_list[21]) ? nil : (__pigeon_list[21] is Int64? ? __pigeon_list[21] as! Int64? : Int64(__pigeon_list[21] as! Int32))
    let iconEmissiveStrength: Double? = nilOrValue(__pigeon_list[22])
    let iconHaloBlur: Double? = nilOrValue(__pigeon_list[23])
    let iconHaloColor: Int64? = isNullish(__pigeon_list[24]) ? nil : (__pigeon_list[24] is Int64? ? __pigeon_list[24] as! Int64? : Int64(__pigeon_list[24] as! Int32))
    let iconHaloWidth: Double? = nilOrValue(__pigeon_list[25])
    let iconImageCrossFade: Double? = nilOrValue(__pigeon_list[26])
    let iconOpacity: Double? = nilOrValue(__pigeon_list[27])
    let textColor: Int64? = isNullish(__pigeon_list[28]) ? nil : (__pigeon_list[28] is Int64? ? __pigeon_list[28] as! Int64? : Int64(__pigeon_list[28] as! Int32))
    let textEmissiveStrength: Double? = nilOrValue(__pigeon_list[29])
    let textHaloBlur: Double? = nilOrValue(__pigeon_list[30])
    let textHaloColor: Int64? = isNullish(__pigeon_list[31]) ? nil : (__pigeon_list[31] is Int64? ? __pigeon_list[31] as! Int64? : Int64(__pigeon_list[31] as! Int32))
    let textHaloWidth: Double? = nilOrValue(__pigeon_list[32])
    let textOpacity: Double? = nilOrValue(__pigeon_list[33])

    return PointAnnotationOptions(
      geometry: geometry,
      image: image,
      iconAnchor: iconAnchor,
      iconImage: iconImage,
      iconOffset: iconOffset,
      iconRotate: iconRotate,
      iconSize: iconSize,
      iconTextFit: iconTextFit,
      iconTextFitPadding: iconTextFitPadding,
      symbolSortKey: symbolSortKey,
      textAnchor: textAnchor,
      textField: textField,
      textJustify: textJustify,
      textLetterSpacing: textLetterSpacing,
      textLineHeight: textLineHeight,
      textMaxWidth: textMaxWidth,
      textOffset: textOffset,
      textRadialOffset: textRadialOffset,
      textRotate: textRotate,
      textSize: textSize,
      textTransform: textTransform,
      iconColor: iconColor,
      iconEmissiveStrength: iconEmissiveStrength,
      iconHaloBlur: iconHaloBlur,
      iconHaloColor: iconHaloColor,
      iconHaloWidth: iconHaloWidth,
      iconImageCrossFade: iconImageCrossFade,
      iconOpacity: iconOpacity,
      textColor: textColor,
      textEmissiveStrength: textEmissiveStrength,
      textHaloBlur: textHaloBlur,
      textHaloColor: textHaloColor,
      textHaloWidth: textHaloWidth,
      textOpacity: textOpacity
    )
  }
  func toList() -> [Any?] {
    return [
      geometry,
      image,
      iconAnchor,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor,
      textField,
      textJustify,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    ]
  }
}
private class PointAnnotationMessengerPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return Point.fromList(self.readValue() as! [Any?])
    case 130:
      return PointAnnotation.fromList(self.readValue() as! [Any?])
    case 131:
      return PointAnnotationOptions.fromList(self.readValue() as! [Any?])
    case 132:
      var enumResult: IconAnchor?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = IconAnchor(rawValue: enumResultAsInt)
      }
      return enumResult
    case 133:
      var enumResult: IconPitchAlignment?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = IconPitchAlignment(rawValue: enumResultAsInt)
      }
      return enumResult
    case 134:
      var enumResult: IconRotationAlignment?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = IconRotationAlignment(rawValue: enumResultAsInt)
      }
      return enumResult
    case 135:
      var enumResult: IconTextFit?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = IconTextFit(rawValue: enumResultAsInt)
      }
      return enumResult
    case 136:
      var enumResult: SymbolPlacement?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = SymbolPlacement(rawValue: enumResultAsInt)
      }
      return enumResult
    case 137:
      var enumResult: SymbolZOrder?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = SymbolZOrder(rawValue: enumResultAsInt)
      }
      return enumResult
    case 138:
      var enumResult: TextAnchor?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextAnchor(rawValue: enumResultAsInt)
      }
      return enumResult
    case 139:
      var enumResult: TextJustify?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextJustify(rawValue: enumResultAsInt)
      }
      return enumResult
    case 140:
      var enumResult: TextPitchAlignment?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextPitchAlignment(rawValue: enumResultAsInt)
      }
      return enumResult
    case 141:
      var enumResult: TextRotationAlignment?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextRotationAlignment(rawValue: enumResultAsInt)
      }
      return enumResult
    case 142:
      var enumResult: TextTransform?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextTransform(rawValue: enumResultAsInt)
      }
      return enumResult
    case 143:
      var enumResult: TextVariableAnchor?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextVariableAnchor(rawValue: enumResultAsInt)
      }
      return enumResult
    case 144:
      var enumResult: TextWritingMode?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextWritingMode(rawValue: enumResultAsInt)
      }
      return enumResult
    case 145:
      var enumResult: IconTranslateAnchor?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = IconTranslateAnchor(rawValue: enumResultAsInt)
      }
      return enumResult
    case 146:
      var enumResult: TextTranslateAnchor?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TextTranslateAnchor(rawValue: enumResultAsInt)
      }
      return enumResult
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PointAnnotationMessengerPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Point {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotation {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotationOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? IconAnchor {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconPitchAlignment {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconRotationAlignment {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconTextFit {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? SymbolPlacement {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? SymbolZOrder {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextAnchor {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextJustify {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextPitchAlignment {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextRotationAlignment {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextTransform {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextVariableAnchor {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextWritingMode {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconTranslateAnchor {
      super.writeByte(145)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextTranslateAnchor {
      super.writeByte(146)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class PointAnnotationMessengerPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PointAnnotationMessengerPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PointAnnotationMessengerPigeonCodecWriter(data: data)
  }
}

class PointAnnotationMessengerPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PointAnnotationMessengerPigeonCodec(readerWriter: PointAnnotationMessengerPigeonCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnPointAnnotationClickListenerProtocol {
  func onPointAnnotationClick(annotation annotationArg: PointAnnotation, completion: @escaping (Result<Void, PointAnnotationMessengerError>) -> Void)
}
class OnPointAnnotationClickListener: OnPointAnnotationClickListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PointAnnotationMessengerPigeonCodec {
    return PointAnnotationMessengerPigeonCodec.shared
  }
  func onPointAnnotationClick(annotation annotationArg: PointAnnotation, completion: @escaping (Result<Void, PointAnnotationMessengerError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PointAnnotationMessengerError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _PointAnnotationMessenger {
  func create(managerId: String, annotationOption: PointAnnotationOptions, completion: @escaping (Result<PointAnnotation, Error>) -> Void)
  func createMulti(managerId: String, annotationOptions: [PointAnnotationOptions], completion: @escaping (Result<[PointAnnotation], Error>) -> Void)
  func update(managerId: String, annotation: PointAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func delete(managerId: String, annotation: PointAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func deleteAll(managerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func setIconAllowOverlap(managerId: String, iconAllowOverlap: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconAllowOverlap(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconIgnorePlacement(managerId: String, iconIgnorePlacement: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconIgnorePlacement(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconKeepUpright(managerId: String, iconKeepUpright: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconKeepUpright(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconOptional(managerId: String, iconOptional: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOptional(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconPadding(managerId: String, iconPadding: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconPadding(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconPitchAlignment(managerId: String, iconPitchAlignment: IconPitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconPitchAlignment(managerId: String, completion: @escaping (Result<IconPitchAlignment?, Error>) -> Void)
  func setIconRotationAlignment(managerId: String, iconRotationAlignment: IconRotationAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconRotationAlignment(managerId: String, completion: @escaping (Result<IconRotationAlignment?, Error>) -> Void)
  func setSymbolAvoidEdges(managerId: String, symbolAvoidEdges: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolAvoidEdges(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setSymbolPlacement(managerId: String, symbolPlacement: SymbolPlacement, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolPlacement(managerId: String, completion: @escaping (Result<SymbolPlacement?, Error>) -> Void)
  func setSymbolSpacing(managerId: String, symbolSpacing: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolSpacing(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setSymbolZElevate(managerId: String, symbolZElevate: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZElevate(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setSymbolZOrder(managerId: String, symbolZOrder: SymbolZOrder, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZOrder(managerId: String, completion: @escaping (Result<SymbolZOrder?, Error>) -> Void)
  func setTextAllowOverlap(managerId: String, textAllowOverlap: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextAllowOverlap(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextFont(managerId: String, textFont: [String?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextFont(managerId: String, completion: @escaping (Result<[String?]?, Error>) -> Void)
  func setTextIgnorePlacement(managerId: String, textIgnorePlacement: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextIgnorePlacement(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextKeepUpright(managerId: String, textKeepUpright: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextKeepUpright(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextMaxAngle(managerId: String, textMaxAngle: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextMaxAngle(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextOptional(managerId: String, textOptional: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOptional(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextPadding(managerId: String, textPadding: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextPadding(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextPitchAlignment(managerId: String, textPitchAlignment: TextPitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextPitchAlignment(managerId: String, completion: @escaping (Result<TextPitchAlignment?, Error>) -> Void)
  func setTextRotationAlignment(managerId: String, textRotationAlignment: TextRotationAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextRotationAlignment(managerId: String, completion: @escaping (Result<TextRotationAlignment?, Error>) -> Void)
  func setIconColorSaturation(managerId: String, iconColorSaturation: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconColorSaturation(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconOcclusionOpacity(managerId: String, iconOcclusionOpacity: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOcclusionOpacity(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconTranslate(managerId: String, iconTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setIconTranslateAnchor(managerId: String, iconTranslateAnchor: IconTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTranslateAnchor(managerId: String, completion: @escaping (Result<IconTranslateAnchor?, Error>) -> Void)
  func setTextOcclusionOpacity(managerId: String, textOcclusionOpacity: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOcclusionOpacity(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextTranslate(managerId: String, textTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setTextTranslateAnchor(managerId: String, textTranslateAnchor: TextTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTranslateAnchor(managerId: String, completion: @escaping (Result<TextTranslateAnchor?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _PointAnnotationMessengerSetup {
  static var codec: FlutterStandardMessageCodec { PointAnnotationMessengerPigeonCodec.shared }
  /// Sets up an instance of `_PointAnnotationMessenger` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _PointAnnotationMessenger?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionArg = args[1] as! PointAnnotationOptions
        api.create(managerId: managerIdArg, annotationOption: annotationOptionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let createMultiChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.createMulti\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createMultiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionsArg = args[1] as! [PointAnnotationOptions]
        api.createMulti(managerId: managerIdArg, annotationOptions: annotationOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createMultiChannel.setMessageHandler(nil)
    }
    let updateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.update\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PointAnnotation
        api.update(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateChannel.setMessageHandler(nil)
    }
    let deleteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.delete\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PointAnnotation
        api.delete(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteChannel.setMessageHandler(nil)
    }
    let deleteAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.deleteAll\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteAllChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.deleteAll(managerId: managerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteAllChannel.setMessageHandler(nil)
    }
    let setIconAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconAllowOverlapArg = args[1] as! Bool
        api.setIconAllowOverlap(managerId: managerIdArg, iconAllowOverlap: iconAllowOverlapArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconAllowOverlapChannel.setMessageHandler(nil)
    }
    let getIconAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconAllowOverlap(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconAllowOverlapChannel.setMessageHandler(nil)
    }
    let setIconIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconIgnorePlacementArg = args[1] as! Bool
        api.setIconIgnorePlacement(managerId: managerIdArg, iconIgnorePlacement: iconIgnorePlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconIgnorePlacementChannel.setMessageHandler(nil)
    }
    let getIconIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconIgnorePlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconIgnorePlacementChannel.setMessageHandler(nil)
    }
    let setIconKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconKeepUprightArg = args[1] as! Bool
        api.setIconKeepUpright(managerId: managerIdArg, iconKeepUpright: iconKeepUprightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconKeepUprightChannel.setMessageHandler(nil)
    }
    let getIconKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconKeepUpright(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconKeepUprightChannel.setMessageHandler(nil)
    }
    let setIconOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOptionalArg = args[1] as! Bool
        api.setIconOptional(managerId: managerIdArg, iconOptional: iconOptionalArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOptionalChannel.setMessageHandler(nil)
    }
    let getIconOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOptional(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOptionalChannel.setMessageHandler(nil)
    }
    let setIconPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconPaddingArg = args[1] as! Double
        api.setIconPadding(managerId: managerIdArg, iconPadding: iconPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconPaddingChannel.setMessageHandler(nil)
    }
    let getIconPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconPaddingChannel.setMessageHandler(nil)
    }
    let setIconPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconPitchAlignmentArg = args[1] as! IconPitchAlignment
        api.setIconPitchAlignment(managerId: managerIdArg, iconPitchAlignment: iconPitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconPitchAlignmentChannel.setMessageHandler(nil)
    }
    let getIconPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconPitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconPitchAlignmentChannel.setMessageHandler(nil)
    }
    let setIconRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconRotationAlignmentArg = args[1] as! IconRotationAlignment
        api.setIconRotationAlignment(managerId: managerIdArg, iconRotationAlignment: iconRotationAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconRotationAlignmentChannel.setMessageHandler(nil)
    }
    let getIconRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconRotationAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconRotationAlignmentChannel.setMessageHandler(nil)
    }
    let setSymbolAvoidEdgesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolAvoidEdges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolAvoidEdgesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolAvoidEdgesArg = args[1] as! Bool
        api.setSymbolAvoidEdges(managerId: managerIdArg, symbolAvoidEdges: symbolAvoidEdgesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolAvoidEdgesChannel.setMessageHandler(nil)
    }
    let getSymbolAvoidEdgesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolAvoidEdges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolAvoidEdgesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolAvoidEdges(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolAvoidEdgesChannel.setMessageHandler(nil)
    }
    let setSymbolPlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolPlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolPlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolPlacementArg = args[1] as! SymbolPlacement
        api.setSymbolPlacement(managerId: managerIdArg, symbolPlacement: symbolPlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolPlacementChannel.setMessageHandler(nil)
    }
    let getSymbolPlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolPlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolPlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolPlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolPlacementChannel.setMessageHandler(nil)
    }
    let setSymbolSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolSpacingArg = args[1] as! Double
        api.setSymbolSpacing(managerId: managerIdArg, symbolSpacing: symbolSpacingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolSpacingChannel.setMessageHandler(nil)
    }
    let getSymbolSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolSpacing(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolSpacingChannel.setMessageHandler(nil)
    }
    let setSymbolZElevateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZElevate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZElevateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZElevateArg = args[1] as! Bool
        api.setSymbolZElevate(managerId: managerIdArg, symbolZElevate: symbolZElevateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZElevateChannel.setMessageHandler(nil)
    }
    let getSymbolZElevateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZElevate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZElevateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZElevate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZElevateChannel.setMessageHandler(nil)
    }
    let setSymbolZOrderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZOrder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZOrderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZOrderArg = args[1] as! SymbolZOrder
        api.setSymbolZOrder(managerId: managerIdArg, symbolZOrder: symbolZOrderArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZOrderChannel.setMessageHandler(nil)
    }
    let getSymbolZOrderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZOrder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZOrderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZOrder(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZOrderChannel.setMessageHandler(nil)
    }
    let setTextAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textAllowOverlapArg = args[1] as! Bool
        api.setTextAllowOverlap(managerId: managerIdArg, textAllowOverlap: textAllowOverlapArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextAllowOverlapChannel.setMessageHandler(nil)
    }
    let getTextAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextAllowOverlap(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextAllowOverlapChannel.setMessageHandler(nil)
    }
    let setTextFontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextFont\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextFontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textFontArg = args[1] as! [String?]
        api.setTextFont(managerId: managerIdArg, textFont: textFontArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextFontChannel.setMessageHandler(nil)
    }
    let getTextFontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextFont\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextFontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextFont(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextFontChannel.setMessageHandler(nil)
    }
    let setTextIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textIgnorePlacementArg = args[1] as! Bool
        api.setTextIgnorePlacement(managerId: managerIdArg, textIgnorePlacement: textIgnorePlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextIgnorePlacementChannel.setMessageHandler(nil)
    }
    let getTextIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextIgnorePlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextIgnorePlacementChannel.setMessageHandler(nil)
    }
    let setTextKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textKeepUprightArg = args[1] as! Bool
        api.setTextKeepUpright(managerId: managerIdArg, textKeepUpright: textKeepUprightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextKeepUprightChannel.setMessageHandler(nil)
    }
    let getTextKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextKeepUpright(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextKeepUprightChannel.setMessageHandler(nil)
    }
    let setTextMaxAngleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextMaxAngle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextMaxAngleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textMaxAngleArg = args[1] as! Double
        api.setTextMaxAngle(managerId: managerIdArg, textMaxAngle: textMaxAngleArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextMaxAngleChannel.setMessageHandler(nil)
    }
    let getTextMaxAngleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextMaxAngle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextMaxAngleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextMaxAngle(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextMaxAngleChannel.setMessageHandler(nil)
    }
    let setTextOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOptionalArg = args[1] as! Bool
        api.setTextOptional(managerId: managerIdArg, textOptional: textOptionalArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOptionalChannel.setMessageHandler(nil)
    }
    let getTextOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOptional(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOptionalChannel.setMessageHandler(nil)
    }
    let setTextPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textPaddingArg = args[1] as! Double
        api.setTextPadding(managerId: managerIdArg, textPadding: textPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextPaddingChannel.setMessageHandler(nil)
    }
    let getTextPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextPaddingChannel.setMessageHandler(nil)
    }
    let setTextPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textPitchAlignmentArg = args[1] as! TextPitchAlignment
        api.setTextPitchAlignment(managerId: managerIdArg, textPitchAlignment: textPitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextPitchAlignmentChannel.setMessageHandler(nil)
    }
    let getTextPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextPitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextPitchAlignmentChannel.setMessageHandler(nil)
    }
    let setTextRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textRotationAlignmentArg = args[1] as! TextRotationAlignment
        api.setTextRotationAlignment(managerId: managerIdArg, textRotationAlignment: textRotationAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextRotationAlignmentChannel.setMessageHandler(nil)
    }
    let getTextRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextRotationAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextRotationAlignmentChannel.setMessageHandler(nil)
    }
    let setIconColorSaturationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconColorSaturation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconColorSaturationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconColorSaturationArg = args[1] as! Double
        api.setIconColorSaturation(managerId: managerIdArg, iconColorSaturation: iconColorSaturationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconColorSaturationChannel.setMessageHandler(nil)
    }
    let getIconColorSaturationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconColorSaturation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconColorSaturationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconColorSaturation(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconColorSaturationChannel.setMessageHandler(nil)
    }
    let setIconOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOcclusionOpacityArg = args[1] as! Double
        api.setIconOcclusionOpacity(managerId: managerIdArg, iconOcclusionOpacity: iconOcclusionOpacityArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let getIconOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOcclusionOpacity(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let setIconTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTranslateArg = args[1] as! [Double?]
        api.setIconTranslate(managerId: managerIdArg, iconTranslate: iconTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTranslateChannel.setMessageHandler(nil)
    }
    let getIconTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTranslateChannel.setMessageHandler(nil)
    }
    let setIconTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTranslateAnchorArg = args[1] as! IconTranslateAnchor
        api.setIconTranslateAnchor(managerId: managerIdArg, iconTranslateAnchor: iconTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getIconTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTranslateAnchorChannel.setMessageHandler(nil)
    }
    let setTextOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOcclusionOpacityArg = args[1] as! Double
        api.setTextOcclusionOpacity(managerId: managerIdArg, textOcclusionOpacity: textOcclusionOpacityArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let getTextOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOcclusionOpacity(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let setTextTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTranslateArg = args[1] as! [Double?]
        api.setTextTranslate(managerId: managerIdArg, textTranslate: textTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTranslateChannel.setMessageHandler(nil)
    }
    let getTextTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTranslateChannel.setMessageHandler(nil)
    }
    let setTextTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTranslateAnchorArg = args[1] as! TextTranslateAnchor
        api.setTextTranslateAnchor(managerId: managerIdArg, textTranslateAnchor: textTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getTextTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTranslateAnchorChannel.setMessageHandler(nil)
    }
  }
}
