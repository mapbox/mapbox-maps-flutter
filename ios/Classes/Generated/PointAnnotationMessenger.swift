// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Part of the icon placed closest to the anchor.
enum IconAnchor: Int {
  /// The center of the icon is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the icon is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the icon is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the icon is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the icon is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the icon is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the icon is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the icon is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the icon is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// Orientation of icon when map is pitched.
enum IconPitchAlignment: Int {
  /// The icon is aligned to the plane of the map.
  case mAP = 0
  /// The icon is aligned to the plane of the viewport.
  case vIEWPORT = 1
  /// Automatically matches the value of {@link ICON_ROTATION_ALIGNMENT}.
  case aUTO = 2
}

/// In combination with `symbol-placement`, determines the rotation behavior of icons.
enum IconRotationAlignment: Int {
  /// When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns icons east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns icon x-axes with the line.
  case mAP = 0
  /// Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}.
  case vIEWPORT = 1
  /// When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#ICON_ROTATION_ALIGNMENT_MAP}.
  case aUTO = 2
}

/// Scales the icon to fit around the associated text.
enum IconTextFit: Int {
  /// The icon is displayed at its intrinsic aspect ratio.
  case nONE = 0
  /// The icon is scaled in the x-dimension to fit the width of the text.
  case wIDTH = 1
  /// The icon is scaled in the y-dimension to fit the height of the text.
  case hEIGHT = 2
  /// The icon is scaled in both x- and y-dimensions.
  case bOTH = 3
}

/// Label placement relative to its geometry.
enum SymbolPlacement: Int {
  /// The label is placed at the point where the geometry is located.
  case pOINT = 0
  /// The label is placed along the line of the geometry. Can only be used on LineString and Polygon geometries.
  case lINE = 1
  /// The label is placed at the center of the line of the geometry. Can only be used on LineString and Polygon geometries. Note that a single feature in a vector tile may contain multiple line geometries.
  case lINECENTER = 2
}

/// Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.
enum SymbolZOrder: Int {
  /// Sorts symbols by symbol sort key if set. Otherwise, sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}.
  case aUTO = 0
  /// Sorts symbols by their y-position relative to the viewport if {@link ICON_ALLOW_OVERLAP} or {@link TEXT_ALLOW_OVERLAP} is set to {@link TRUE} or {@link ICON_IGNORE_PLACEMENT} or {@link TEXT_IGNORE_PLACEMENT} is {@link FALSE}.
  case vIEWPORTY = 1
  /// Sorts symbols by symbol sort key if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data.
  case sOURCE = 2
}

/// Part of the text placed closest to the anchor.
enum TextAnchor: Int {
  /// The center of the text is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the text is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the text is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the text is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the text is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the text is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the text is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the text is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the text is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// Text justification options.
enum TextJustify: Int {
  /// The text is aligned towards the anchor position.
  case aUTO = 0
  /// The text is aligned to the left.
  case lEFT = 1
  /// The text is centered.
  case cENTER = 2
  /// The text is aligned to the right.
  case rIGHT = 3
}

/// Orientation of text when map is pitched.
enum TextPitchAlignment: Int {
  /// The text is aligned to the plane of the map.
  case mAP = 0
  /// The text is aligned to the plane of the viewport.
  case vIEWPORT = 1
  /// Automatically matches the value of {@link TEXT_ROTATION_ALIGNMENT}.
  case aUTO = 2
}

/// In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.
enum TextRotationAlignment: Int {
  /// When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, aligns text east-west. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, aligns text x-axes with the line.
  case mAP = 0
  /// Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of {@link SYMBOL_PLACEMENT}.
  case vIEWPORT = 1
  /// When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_POINT}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_VIEWPORT}. When {@link SYMBOL_PLACEMENT} is set to {@link Property#SYMBOL_PLACEMENT_LINE} or {@link Property#SYMBOL_PLACEMENT_LINE_CENTER}, this is equivalent to {@link Property#TEXT_ROTATION_ALIGNMENT_MAP}.
  case aUTO = 2
}

/// Specifies how to capitalize text, similar to the CSS `text-transform` property.
enum TextTransform: Int {
  /// The text is not altered.
  case nONE = 0
  /// Forces all letters to be displayed in uppercase.
  case uPPERCASE = 1
  /// Forces all letters to be displayed in lowercase.
  case lOWERCASE = 2
}

/// To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.
enum TextVariableAnchor: Int {
  /// The center of the text is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the text is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the text is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the text is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the text is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the text is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the text is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the text is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the text is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnâ€™t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement.
enum TextWritingMode: Int {
  /// If a text's language supports horizontal writing mode, symbols would be laid out horizontally.
  case hORIZONTAL = 0
  /// If a text's language supports vertical writing mode, symbols would be laid out vertically.
  case vERTICAL = 1
}

/// Controls the frame of reference for `icon-translate`.
enum IconTranslateAnchor: Int {
  /// Icons are translated relative to the map.
  case mAP = 0
  /// Icons are translated relative to the viewport.
  case vIEWPORT = 1
}

/// Controls the frame of reference for `text-translate`.
enum TextTranslateAnchor: Int {
  /// The text is translated relative to the map.
  case mAP = 0
  /// The text is translated relative to the viewport.
  case vIEWPORT = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointAnnotation {
  /// The id for annotation
  var id: String
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// The bitmap image for this Annotation
  /// Will not take effect if [iconImage] has been set.
  var image: FlutterStandardTypedData?
  /// Part of the icon placed closest to the anchor.
  var iconAnchor: IconAnchor?
  /// Name of image in sprite to use for drawing an image background.
  var iconImage: String?
  /// Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
  var iconOffset: [Double?]?
  /// Rotates the icon clockwise.
  var iconRotate: Double?
  /// Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
  var iconSize: Double?
  /// Scales the icon to fit around the associated text.
  var iconTextFit: IconTextFit?
  /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
  var iconTextFitPadding: [Double?]?
  /// Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.
  var symbolSortKey: Double?
  /// Part of the text placed closest to the anchor.
  var textAnchor: TextAnchor?
  /// Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
  var textField: String?
  /// Text justification options.
  var textJustify: TextJustify?
  /// Text tracking amount.
  var textLetterSpacing: Double?
  /// Text leading value for multi-line text.
  var textLineHeight: Double?
  /// The maximum line width for text wrapping.
  var textMaxWidth: Double?
  /// Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
  var textOffset: [Double?]?
  /// Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
  var textRadialOffset: Double?
  /// Rotates the text clockwise.
  var textRotate: Double?
  /// Font size.
  var textSize: Double?
  /// Specifies how to capitalize text, similar to the CSS `text-transform` property.
  var textTransform: TextTransform?
  /// The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  var iconColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  var iconEmissiveStrength: Double?
  /// Fade out the halo towards the outside.
  var iconHaloBlur: Double?
  /// The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  var iconHaloColor: Int64?
  /// Distance of halo to the icon outline.
  var iconHaloWidth: Double?
  /// Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
  var iconImageCrossFade: Double?
  /// The opacity at which the icon will be drawn.
  var iconOpacity: Double?
  /// The color with which the text will be drawn.
  var textColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  var textEmissiveStrength: Double?
  /// The halo's fadeout distance towards the outside.
  var textHaloBlur: Double?
  /// The color of the text's halo, which helps it stand out from backgrounds.
  var textHaloColor: Int64?
  /// Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
  var textHaloWidth: Double?
  /// The opacity at which the text will be drawn.
  var textOpacity: Double?

  static func fromList(_ list: [Any?]) -> PointAnnotation? {
    let id = list[0] as! String
    let geometry = Point.fromList(list[1] as! [Any?])!
    let image: FlutterStandardTypedData? = nilOrValue(list[2])
    var iconAnchor: IconAnchor?
    let iconAnchorEnumVal: Int? = nilOrValue(list[3])
    if let iconAnchorRawValue = iconAnchorEnumVal {
      iconAnchor = IconAnchor(rawValue: iconAnchorRawValue)!
    }
    let iconImage: String? = nilOrValue(list[4])
    let iconOffset: [Double?]? = nilOrValue(list[5])
    let iconRotate: Double? = nilOrValue(list[6])
    let iconSize: Double? = nilOrValue(list[7])
    var iconTextFit: IconTextFit?
    let iconTextFitEnumVal: Int? = nilOrValue(list[8])
    if let iconTextFitRawValue = iconTextFitEnumVal {
      iconTextFit = IconTextFit(rawValue: iconTextFitRawValue)!
    }
    let iconTextFitPadding: [Double?]? = nilOrValue(list[9])
    let symbolSortKey: Double? = nilOrValue(list[10])
    var textAnchor: TextAnchor?
    let textAnchorEnumVal: Int? = nilOrValue(list[11])
    if let textAnchorRawValue = textAnchorEnumVal {
      textAnchor = TextAnchor(rawValue: textAnchorRawValue)!
    }
    let textField: String? = nilOrValue(list[12])
    var textJustify: TextJustify?
    let textJustifyEnumVal: Int? = nilOrValue(list[13])
    if let textJustifyRawValue = textJustifyEnumVal {
      textJustify = TextJustify(rawValue: textJustifyRawValue)!
    }
    let textLetterSpacing: Double? = nilOrValue(list[14])
    let textLineHeight: Double? = nilOrValue(list[15])
    let textMaxWidth: Double? = nilOrValue(list[16])
    let textOffset: [Double?]? = nilOrValue(list[17])
    let textRadialOffset: Double? = nilOrValue(list[18])
    let textRotate: Double? = nilOrValue(list[19])
    let textSize: Double? = nilOrValue(list[20])
    var textTransform: TextTransform?
    let textTransformEnumVal: Int? = nilOrValue(list[21])
    if let textTransformRawValue = textTransformEnumVal {
      textTransform = TextTransform(rawValue: textTransformRawValue)!
    }
    let iconColor: Int64? = isNullish(list[22]) ? nil : (list[22] is Int64? ? list[22] as! Int64? : Int64(list[22] as! Int32))
    let iconEmissiveStrength: Double? = nilOrValue(list[23])
    let iconHaloBlur: Double? = nilOrValue(list[24])
    let iconHaloColor: Int64? = isNullish(list[25]) ? nil : (list[25] is Int64? ? list[25] as! Int64? : Int64(list[25] as! Int32))
    let iconHaloWidth: Double? = nilOrValue(list[26])
    let iconImageCrossFade: Double? = nilOrValue(list[27])
    let iconOpacity: Double? = nilOrValue(list[28])
    let textColor: Int64? = isNullish(list[29]) ? nil : (list[29] is Int64? ? list[29] as! Int64? : Int64(list[29] as! Int32))
    let textEmissiveStrength: Double? = nilOrValue(list[30])
    let textHaloBlur: Double? = nilOrValue(list[31])
    let textHaloColor: Int64? = isNullish(list[32]) ? nil : (list[32] is Int64? ? list[32] as! Int64? : Int64(list[32] as! Int32))
    let textHaloWidth: Double? = nilOrValue(list[33])
    let textOpacity: Double? = nilOrValue(list[34])

    return PointAnnotation(
      id: id,
      geometry: geometry,
      image: image,
      iconAnchor: iconAnchor,
      iconImage: iconImage,
      iconOffset: iconOffset,
      iconRotate: iconRotate,
      iconSize: iconSize,
      iconTextFit: iconTextFit,
      iconTextFitPadding: iconTextFitPadding,
      symbolSortKey: symbolSortKey,
      textAnchor: textAnchor,
      textField: textField,
      textJustify: textJustify,
      textLetterSpacing: textLetterSpacing,
      textLineHeight: textLineHeight,
      textMaxWidth: textMaxWidth,
      textOffset: textOffset,
      textRadialOffset: textRadialOffset,
      textRotate: textRotate,
      textSize: textSize,
      textTransform: textTransform,
      iconColor: iconColor,
      iconEmissiveStrength: iconEmissiveStrength,
      iconHaloBlur: iconHaloBlur,
      iconHaloColor: iconHaloColor,
      iconHaloWidth: iconHaloWidth,
      iconImageCrossFade: iconImageCrossFade,
      iconOpacity: iconOpacity,
      textColor: textColor,
      textEmissiveStrength: textEmissiveStrength,
      textHaloBlur: textHaloBlur,
      textHaloColor: textHaloColor,
      textHaloWidth: textHaloWidth,
      textOpacity: textOpacity
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      geometry.toList(),
      image,
      iconAnchor?.rawValue,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit?.rawValue,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor?.rawValue,
      textField,
      textJustify?.rawValue,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform?.rawValue,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointAnnotationOptions {
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// The bitmap image for this Annotation
  /// Will not take effect if [iconImage] has been set.
  var image: FlutterStandardTypedData?
  /// Part of the icon placed closest to the anchor.
  var iconAnchor: IconAnchor?
  /// Name of image in sprite to use for drawing an image background.
  var iconImage: String?
  /// Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
  var iconOffset: [Double?]?
  /// Rotates the icon clockwise.
  var iconRotate: Double?
  /// Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
  var iconSize: Double?
  /// Scales the icon to fit around the associated text.
  var iconTextFit: IconTextFit?
  /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
  var iconTextFitPadding: [Double?]?
  /// Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.
  var symbolSortKey: Double?
  /// Part of the text placed closest to the anchor.
  var textAnchor: TextAnchor?
  /// Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
  var textField: String?
  /// Text justification options.
  var textJustify: TextJustify?
  /// Text tracking amount.
  var textLetterSpacing: Double?
  /// Text leading value for multi-line text.
  var textLineHeight: Double?
  /// The maximum line width for text wrapping.
  var textMaxWidth: Double?
  /// Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
  var textOffset: [Double?]?
  /// Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
  var textRadialOffset: Double?
  /// Rotates the text clockwise.
  var textRotate: Double?
  /// Font size.
  var textSize: Double?
  /// Specifies how to capitalize text, similar to the CSS `text-transform` property.
  var textTransform: TextTransform?
  /// The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  var iconColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  var iconEmissiveStrength: Double?
  /// Fade out the halo towards the outside.
  var iconHaloBlur: Double?
  /// The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  var iconHaloColor: Int64?
  /// Distance of halo to the icon outline.
  var iconHaloWidth: Double?
  /// Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
  var iconImageCrossFade: Double?
  /// The opacity at which the icon will be drawn.
  var iconOpacity: Double?
  /// The color with which the text will be drawn.
  var textColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  var textEmissiveStrength: Double?
  /// The halo's fadeout distance towards the outside.
  var textHaloBlur: Double?
  /// The color of the text's halo, which helps it stand out from backgrounds.
  var textHaloColor: Int64?
  /// Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
  var textHaloWidth: Double?
  /// The opacity at which the text will be drawn.
  var textOpacity: Double?

  static func fromList(_ list: [Any?]) -> PointAnnotationOptions? {
    let geometry = Point.fromList(list[0] as! [Any?])!
    let image: FlutterStandardTypedData? = nilOrValue(list[1])
    var iconAnchor: IconAnchor?
    let iconAnchorEnumVal: Int? = nilOrValue(list[2])
    if let iconAnchorRawValue = iconAnchorEnumVal {
      iconAnchor = IconAnchor(rawValue: iconAnchorRawValue)!
    }
    let iconImage: String? = nilOrValue(list[3])
    let iconOffset: [Double?]? = nilOrValue(list[4])
    let iconRotate: Double? = nilOrValue(list[5])
    let iconSize: Double? = nilOrValue(list[6])
    var iconTextFit: IconTextFit?
    let iconTextFitEnumVal: Int? = nilOrValue(list[7])
    if let iconTextFitRawValue = iconTextFitEnumVal {
      iconTextFit = IconTextFit(rawValue: iconTextFitRawValue)!
    }
    let iconTextFitPadding: [Double?]? = nilOrValue(list[8])
    let symbolSortKey: Double? = nilOrValue(list[9])
    var textAnchor: TextAnchor?
    let textAnchorEnumVal: Int? = nilOrValue(list[10])
    if let textAnchorRawValue = textAnchorEnumVal {
      textAnchor = TextAnchor(rawValue: textAnchorRawValue)!
    }
    let textField: String? = nilOrValue(list[11])
    var textJustify: TextJustify?
    let textJustifyEnumVal: Int? = nilOrValue(list[12])
    if let textJustifyRawValue = textJustifyEnumVal {
      textJustify = TextJustify(rawValue: textJustifyRawValue)!
    }
    let textLetterSpacing: Double? = nilOrValue(list[13])
    let textLineHeight: Double? = nilOrValue(list[14])
    let textMaxWidth: Double? = nilOrValue(list[15])
    let textOffset: [Double?]? = nilOrValue(list[16])
    let textRadialOffset: Double? = nilOrValue(list[17])
    let textRotate: Double? = nilOrValue(list[18])
    let textSize: Double? = nilOrValue(list[19])
    var textTransform: TextTransform?
    let textTransformEnumVal: Int? = nilOrValue(list[20])
    if let textTransformRawValue = textTransformEnumVal {
      textTransform = TextTransform(rawValue: textTransformRawValue)!
    }
    let iconColor: Int64? = isNullish(list[21]) ? nil : (list[21] is Int64? ? list[21] as! Int64? : Int64(list[21] as! Int32))
    let iconEmissiveStrength: Double? = nilOrValue(list[22])
    let iconHaloBlur: Double? = nilOrValue(list[23])
    let iconHaloColor: Int64? = isNullish(list[24]) ? nil : (list[24] is Int64? ? list[24] as! Int64? : Int64(list[24] as! Int32))
    let iconHaloWidth: Double? = nilOrValue(list[25])
    let iconImageCrossFade: Double? = nilOrValue(list[26])
    let iconOpacity: Double? = nilOrValue(list[27])
    let textColor: Int64? = isNullish(list[28]) ? nil : (list[28] is Int64? ? list[28] as! Int64? : Int64(list[28] as! Int32))
    let textEmissiveStrength: Double? = nilOrValue(list[29])
    let textHaloBlur: Double? = nilOrValue(list[30])
    let textHaloColor: Int64? = isNullish(list[31]) ? nil : (list[31] is Int64? ? list[31] as! Int64? : Int64(list[31] as! Int32))
    let textHaloWidth: Double? = nilOrValue(list[32])
    let textOpacity: Double? = nilOrValue(list[33])

    return PointAnnotationOptions(
      geometry: geometry,
      image: image,
      iconAnchor: iconAnchor,
      iconImage: iconImage,
      iconOffset: iconOffset,
      iconRotate: iconRotate,
      iconSize: iconSize,
      iconTextFit: iconTextFit,
      iconTextFitPadding: iconTextFitPadding,
      symbolSortKey: symbolSortKey,
      textAnchor: textAnchor,
      textField: textField,
      textJustify: textJustify,
      textLetterSpacing: textLetterSpacing,
      textLineHeight: textLineHeight,
      textMaxWidth: textMaxWidth,
      textOffset: textOffset,
      textRadialOffset: textRadialOffset,
      textRotate: textRotate,
      textSize: textSize,
      textTransform: textTransform,
      iconColor: iconColor,
      iconEmissiveStrength: iconEmissiveStrength,
      iconHaloBlur: iconHaloBlur,
      iconHaloColor: iconHaloColor,
      iconHaloWidth: iconHaloWidth,
      iconImageCrossFade: iconImageCrossFade,
      iconOpacity: iconOpacity,
      textColor: textColor,
      textEmissiveStrength: textEmissiveStrength,
      textHaloBlur: textHaloBlur,
      textHaloColor: textHaloColor,
      textHaloWidth: textHaloWidth,
      textOpacity: textOpacity
    )
  }
  func toList() -> [Any?] {
    return [
      geometry.toList(),
      image,
      iconAnchor?.rawValue,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit?.rawValue,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor?.rawValue,
      textField,
      textJustify?.rawValue,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform?.rawValue,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOpacity,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOpacity,
    ]
  }
}
private class OnPointAnnotationClickListenerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return Point.fromList(self.readValue() as! [Any?])
    case 129:
      return PointAnnotation.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OnPointAnnotationClickListenerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Point {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotation {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class OnPointAnnotationClickListenerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OnPointAnnotationClickListenerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OnPointAnnotationClickListenerCodecWriter(data: data)
  }
}

class OnPointAnnotationClickListenerCodec: FlutterStandardMessageCodec {
  static let shared = OnPointAnnotationClickListenerCodec(readerWriter: OnPointAnnotationClickListenerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnPointAnnotationClickListenerProtocol {
  func onPointAnnotationClick(annotation annotationArg: PointAnnotation, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class OnPointAnnotationClickListener: OnPointAnnotationClickListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: FlutterStandardMessageCodec {
    return OnPointAnnotationClickListenerCodec.shared
  }
  func onPointAnnotationClick(annotation annotationArg: PointAnnotation, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
private class _PointAnnotationMessengerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return Point.fromList(self.readValue() as! [Any?])
    case 129:
      return PointAnnotation.fromList(self.readValue() as! [Any?])
    case 130:
      return PointAnnotation.fromList(self.readValue() as! [Any?])
    case 131:
      return PointAnnotationOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return PointAnnotationOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _PointAnnotationMessengerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Point {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotation {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotation {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotationOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotationOptions {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _PointAnnotationMessengerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _PointAnnotationMessengerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _PointAnnotationMessengerCodecWriter(data: data)
  }
}

class _PointAnnotationMessengerCodec: FlutterStandardMessageCodec {
  static let shared = _PointAnnotationMessengerCodec(readerWriter: _PointAnnotationMessengerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _PointAnnotationMessenger {
  func create(managerId: String, annotationOption: PointAnnotationOptions, completion: @escaping (Result<PointAnnotation, Error>) -> Void)
  func createMulti(managerId: String, annotationOptions: [PointAnnotationOptions], completion: @escaping (Result<[PointAnnotation], Error>) -> Void)
  func update(managerId: String, annotation: PointAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func delete(managerId: String, annotation: PointAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func deleteAll(managerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func setIconAllowOverlap(managerId: String, iconAllowOverlap: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconAllowOverlap(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconIgnorePlacement(managerId: String, iconIgnorePlacement: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconIgnorePlacement(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconKeepUpright(managerId: String, iconKeepUpright: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconKeepUpright(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconOptional(managerId: String, iconOptional: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOptional(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconPadding(managerId: String, iconPadding: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconPadding(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconPitchAlignment(managerId: String, iconPitchAlignment: IconPitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconPitchAlignment(managerId: String, completion: @escaping (Result<IconPitchAlignment?, Error>) -> Void)
  func setIconRotationAlignment(managerId: String, iconRotationAlignment: IconRotationAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconRotationAlignment(managerId: String, completion: @escaping (Result<IconRotationAlignment?, Error>) -> Void)
  func setSymbolAvoidEdges(managerId: String, symbolAvoidEdges: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolAvoidEdges(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setSymbolPlacement(managerId: String, symbolPlacement: SymbolPlacement, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolPlacement(managerId: String, completion: @escaping (Result<SymbolPlacement?, Error>) -> Void)
  func setSymbolSpacing(managerId: String, symbolSpacing: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolSpacing(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setSymbolZElevate(managerId: String, symbolZElevate: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZElevate(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setSymbolZOrder(managerId: String, symbolZOrder: SymbolZOrder, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZOrder(managerId: String, completion: @escaping (Result<SymbolZOrder?, Error>) -> Void)
  func setTextAllowOverlap(managerId: String, textAllowOverlap: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextAllowOverlap(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextFont(managerId: String, textFont: [String?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextFont(managerId: String, completion: @escaping (Result<[String?]?, Error>) -> Void)
  func setTextIgnorePlacement(managerId: String, textIgnorePlacement: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextIgnorePlacement(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextKeepUpright(managerId: String, textKeepUpright: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextKeepUpright(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextMaxAngle(managerId: String, textMaxAngle: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextMaxAngle(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextOptional(managerId: String, textOptional: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOptional(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextPadding(managerId: String, textPadding: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextPadding(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextPitchAlignment(managerId: String, textPitchAlignment: TextPitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextPitchAlignment(managerId: String, completion: @escaping (Result<TextPitchAlignment?, Error>) -> Void)
  func setTextRotationAlignment(managerId: String, textRotationAlignment: TextRotationAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextRotationAlignment(managerId: String, completion: @escaping (Result<TextRotationAlignment?, Error>) -> Void)
  func setIconColorSaturation(managerId: String, iconColorSaturation: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconColorSaturation(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconTranslate(managerId: String, iconTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setIconTranslateAnchor(managerId: String, iconTranslateAnchor: IconTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTranslateAnchor(managerId: String, completion: @escaping (Result<IconTranslateAnchor?, Error>) -> Void)
  func setTextTranslate(managerId: String, textTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setTextTranslateAnchor(managerId: String, textTranslateAnchor: TextTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTranslateAnchor(managerId: String, completion: @escaping (Result<TextTranslateAnchor?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _PointAnnotationMessengerSetup {
  /// The codec used by _PointAnnotationMessenger.
  static var codec: FlutterStandardMessageCodec { _PointAnnotationMessengerCodec.shared }
  /// Sets up an instance of `_PointAnnotationMessenger` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _PointAnnotationMessenger?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionArg = args[1] as! PointAnnotationOptions
        api.create(managerId: managerIdArg, annotationOption: annotationOptionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let createMultiChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.createMulti\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createMultiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionsArg = args[1] as! [PointAnnotationOptions]
        api.createMulti(managerId: managerIdArg, annotationOptions: annotationOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createMultiChannel.setMessageHandler(nil)
    }
    let updateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.update\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PointAnnotation
        api.update(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateChannel.setMessageHandler(nil)
    }
    let deleteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.delete\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PointAnnotation
        api.delete(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteChannel.setMessageHandler(nil)
    }
    let deleteAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.deleteAll\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteAllChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.deleteAll(managerId: managerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteAllChannel.setMessageHandler(nil)
    }
    let setIconAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconAllowOverlapArg = args[1] as! Bool
        api.setIconAllowOverlap(managerId: managerIdArg, iconAllowOverlap: iconAllowOverlapArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconAllowOverlapChannel.setMessageHandler(nil)
    }
    let getIconAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconAllowOverlap(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconAllowOverlapChannel.setMessageHandler(nil)
    }
    let setIconIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconIgnorePlacementArg = args[1] as! Bool
        api.setIconIgnorePlacement(managerId: managerIdArg, iconIgnorePlacement: iconIgnorePlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconIgnorePlacementChannel.setMessageHandler(nil)
    }
    let getIconIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconIgnorePlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconIgnorePlacementChannel.setMessageHandler(nil)
    }
    let setIconKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconKeepUprightArg = args[1] as! Bool
        api.setIconKeepUpright(managerId: managerIdArg, iconKeepUpright: iconKeepUprightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconKeepUprightChannel.setMessageHandler(nil)
    }
    let getIconKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconKeepUpright(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconKeepUprightChannel.setMessageHandler(nil)
    }
    let setIconOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOptionalArg = args[1] as! Bool
        api.setIconOptional(managerId: managerIdArg, iconOptional: iconOptionalArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOptionalChannel.setMessageHandler(nil)
    }
    let getIconOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOptional(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOptionalChannel.setMessageHandler(nil)
    }
    let setIconPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconPaddingArg = args[1] as! Double
        api.setIconPadding(managerId: managerIdArg, iconPadding: iconPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconPaddingChannel.setMessageHandler(nil)
    }
    let getIconPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconPaddingChannel.setMessageHandler(nil)
    }
    let setIconPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconPitchAlignmentArg = IconPitchAlignment(rawValue: args[1] as! Int)!
        api.setIconPitchAlignment(managerId: managerIdArg, iconPitchAlignment: iconPitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconPitchAlignmentChannel.setMessageHandler(nil)
    }
    let getIconPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconPitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconPitchAlignmentChannel.setMessageHandler(nil)
    }
    let setIconRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconRotationAlignmentArg = IconRotationAlignment(rawValue: args[1] as! Int)!
        api.setIconRotationAlignment(managerId: managerIdArg, iconRotationAlignment: iconRotationAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconRotationAlignmentChannel.setMessageHandler(nil)
    }
    let getIconRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconRotationAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconRotationAlignmentChannel.setMessageHandler(nil)
    }
    let setSymbolAvoidEdgesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolAvoidEdges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolAvoidEdgesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolAvoidEdgesArg = args[1] as! Bool
        api.setSymbolAvoidEdges(managerId: managerIdArg, symbolAvoidEdges: symbolAvoidEdgesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolAvoidEdgesChannel.setMessageHandler(nil)
    }
    let getSymbolAvoidEdgesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolAvoidEdges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolAvoidEdgesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolAvoidEdges(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolAvoidEdgesChannel.setMessageHandler(nil)
    }
    let setSymbolPlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolPlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolPlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolPlacementArg = SymbolPlacement(rawValue: args[1] as! Int)!
        api.setSymbolPlacement(managerId: managerIdArg, symbolPlacement: symbolPlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolPlacementChannel.setMessageHandler(nil)
    }
    let getSymbolPlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolPlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolPlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolPlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolPlacementChannel.setMessageHandler(nil)
    }
    let setSymbolSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolSpacingArg = args[1] as! Double
        api.setSymbolSpacing(managerId: managerIdArg, symbolSpacing: symbolSpacingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolSpacingChannel.setMessageHandler(nil)
    }
    let getSymbolSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolSpacing(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolSpacingChannel.setMessageHandler(nil)
    }
    let setSymbolZElevateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZElevate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZElevateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZElevateArg = args[1] as! Bool
        api.setSymbolZElevate(managerId: managerIdArg, symbolZElevate: symbolZElevateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZElevateChannel.setMessageHandler(nil)
    }
    let getSymbolZElevateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZElevate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZElevateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZElevate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZElevateChannel.setMessageHandler(nil)
    }
    let setSymbolZOrderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZOrder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZOrderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZOrderArg = SymbolZOrder(rawValue: args[1] as! Int)!
        api.setSymbolZOrder(managerId: managerIdArg, symbolZOrder: symbolZOrderArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZOrderChannel.setMessageHandler(nil)
    }
    let getSymbolZOrderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZOrder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZOrderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZOrder(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZOrderChannel.setMessageHandler(nil)
    }
    let setTextAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textAllowOverlapArg = args[1] as! Bool
        api.setTextAllowOverlap(managerId: managerIdArg, textAllowOverlap: textAllowOverlapArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextAllowOverlapChannel.setMessageHandler(nil)
    }
    let getTextAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextAllowOverlap(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextAllowOverlapChannel.setMessageHandler(nil)
    }
    let setTextFontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextFont\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextFontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textFontArg = args[1] as! [String?]
        api.setTextFont(managerId: managerIdArg, textFont: textFontArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextFontChannel.setMessageHandler(nil)
    }
    let getTextFontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextFont\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextFontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextFont(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextFontChannel.setMessageHandler(nil)
    }
    let setTextIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textIgnorePlacementArg = args[1] as! Bool
        api.setTextIgnorePlacement(managerId: managerIdArg, textIgnorePlacement: textIgnorePlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextIgnorePlacementChannel.setMessageHandler(nil)
    }
    let getTextIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextIgnorePlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextIgnorePlacementChannel.setMessageHandler(nil)
    }
    let setTextKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textKeepUprightArg = args[1] as! Bool
        api.setTextKeepUpright(managerId: managerIdArg, textKeepUpright: textKeepUprightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextKeepUprightChannel.setMessageHandler(nil)
    }
    let getTextKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextKeepUpright(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextKeepUprightChannel.setMessageHandler(nil)
    }
    let setTextMaxAngleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextMaxAngle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextMaxAngleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textMaxAngleArg = args[1] as! Double
        api.setTextMaxAngle(managerId: managerIdArg, textMaxAngle: textMaxAngleArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextMaxAngleChannel.setMessageHandler(nil)
    }
    let getTextMaxAngleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextMaxAngle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextMaxAngleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextMaxAngle(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextMaxAngleChannel.setMessageHandler(nil)
    }
    let setTextOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOptionalArg = args[1] as! Bool
        api.setTextOptional(managerId: managerIdArg, textOptional: textOptionalArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOptionalChannel.setMessageHandler(nil)
    }
    let getTextOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOptional(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOptionalChannel.setMessageHandler(nil)
    }
    let setTextPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textPaddingArg = args[1] as! Double
        api.setTextPadding(managerId: managerIdArg, textPadding: textPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextPaddingChannel.setMessageHandler(nil)
    }
    let getTextPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextPaddingChannel.setMessageHandler(nil)
    }
    let setTextPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textPitchAlignmentArg = TextPitchAlignment(rawValue: args[1] as! Int)!
        api.setTextPitchAlignment(managerId: managerIdArg, textPitchAlignment: textPitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextPitchAlignmentChannel.setMessageHandler(nil)
    }
    let getTextPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextPitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextPitchAlignmentChannel.setMessageHandler(nil)
    }
    let setTextRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textRotationAlignmentArg = TextRotationAlignment(rawValue: args[1] as! Int)!
        api.setTextRotationAlignment(managerId: managerIdArg, textRotationAlignment: textRotationAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextRotationAlignmentChannel.setMessageHandler(nil)
    }
    let getTextRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextRotationAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextRotationAlignmentChannel.setMessageHandler(nil)
    }
    let setIconColorSaturationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconColorSaturation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconColorSaturationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconColorSaturationArg = args[1] as! Double
        api.setIconColorSaturation(managerId: managerIdArg, iconColorSaturation: iconColorSaturationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconColorSaturationChannel.setMessageHandler(nil)
    }
    let getIconColorSaturationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconColorSaturation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconColorSaturationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconColorSaturation(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconColorSaturationChannel.setMessageHandler(nil)
    }
    let setIconTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTranslateArg = args[1] as! [Double?]
        api.setIconTranslate(managerId: managerIdArg, iconTranslate: iconTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTranslateChannel.setMessageHandler(nil)
    }
    let getIconTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTranslateChannel.setMessageHandler(nil)
    }
    let setIconTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTranslateAnchorArg = IconTranslateAnchor(rawValue: args[1] as! Int)!
        api.setIconTranslateAnchor(managerId: managerIdArg, iconTranslateAnchor: iconTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getIconTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTranslateAnchorChannel.setMessageHandler(nil)
    }
    let setTextTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTranslateArg = args[1] as! [Double?]
        api.setTextTranslate(managerId: managerIdArg, textTranslate: textTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTranslateChannel.setMessageHandler(nil)
    }
    let getTextTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTranslateChannel.setMessageHandler(nil)
    }
    let setTextTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTranslateAnchorArg = TextTranslateAnchor(rawValue: args[1] as! Int)!
        api.setTextTranslateAnchor(managerId: managerIdArg, textTranslateAnchor: textTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getTextTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTranslateAnchorChannel.setMessageHandler(nil)
    }
  }
}
