// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Describes glyphs rasterization modes.
enum GlyphsRasterizationMode: Int {
  /// No glyphs are rasterized locally. All glyphs are loaded from the server.
  case nOGLYPHSRASTERIZEDLOCALLY = 0
  /// Ideographs are rasterized locally, and they are not loaded from the server.
  case iDEOGRAPHSRASTERIZEDLOCALLY = 1
  /// All glyphs are rasterized locally. No glyphs are loaded from the server.
  case aLLGLYPHSRASTERIZEDLOCALLY = 2
}

/// Describes the glyphs rasterization option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct GlyphsRasterizationOptions {
  /// Glyphs rasterization mode for client-side text rendering.
  var rasterizationMode: GlyphsRasterizationMode
  /// Font family to use as font fallback for client-side text renderings.
  ///
  /// Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
  /// or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
  /// font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
  /// default font are varied in platforms:
  /// - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
  ///   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
  /// - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
  ///
  /// Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
  ///
  var fontFamily: String?

  static func fromList(_ list: [Any?]) -> GlyphsRasterizationOptions? {
    let rasterizationMode = GlyphsRasterizationMode(rawValue: list[0] as! Int)!
    let fontFamily: String? = nilOrValue(list[1])

    return GlyphsRasterizationOptions(
      rasterizationMode: rasterizationMode,
      fontFamily: fontFamily
    )
  }
  func toList() -> [Any?] {
    return [
      rasterizationMode.rawValue,
      fontFamily,
    ]
  }
}

/// Describes the style package load option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePackLoadOptions {
  /// Specifies glyphs rasterization mode.
  ///
  /// If provided, updates the style package's glyphs rasterization mode,
  /// which defines which glyphs will be loaded from the server.
  ///
  /// By default, ideographs are rasterized locally and other glyphs are loaded
  /// from network (i.e. `IdeographsRasterizedLocally` value is used).
  var glyphsRasterizationMode: GlyphsRasterizationMode?
  /// A custom Mapbox value associated with this style package for storing metadata.
  ///
  /// If provided, the custom value value will be stored alongside the style package. Previous values will
  /// be replaced with the new value.
  ///
  /// Developers can use this field to store custom metadata associated with a style package.
  var metadata: String?
  /// Accepts expired data when loading style resources.
  ///
  /// This flag should be set to true to accept expired responses. When a style resource is already loaded but expired,
  /// no attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
  /// for a style is up-to-date.
  var acceptExpired: Bool

  static func fromList(_ list: [Any?]) -> StylePackLoadOptions? {
    var glyphsRasterizationMode: GlyphsRasterizationMode?
    let glyphsRasterizationModeEnumVal: Int? = nilOrValue(list[0])
    if let glyphsRasterizationModeRawValue = glyphsRasterizationModeEnumVal {
      glyphsRasterizationMode = GlyphsRasterizationMode(rawValue: glyphsRasterizationModeRawValue)!
    }
    let metadata: String? = nilOrValue(list[1])
    let acceptExpired = list[2] as! Bool

    return StylePackLoadOptions(
      glyphsRasterizationMode: glyphsRasterizationMode,
      metadata: metadata,
      acceptExpired: acceptExpired
    )
  }
  func toList() -> [Any?] {
    return [
      glyphsRasterizationMode?.rawValue,
      metadata,
      acceptExpired,
    ]
  }
}

/// The `style pack` represents a stored style package.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePack {
  /// The style associated with the style package.
  var styleURI: String
  /// The glyphs rasterization mode of the style package.
  ///
  /// It defines which glyphs will be loaded from the server.
  var glyphsRasterizationMode: GlyphsRasterizationMode
  /// The number of resources that are known to be required for this style package.
  var requiredResourceCount: Int64
  /// The number of resources that have been fully downloaded and are ready for
  /// offline access.
  var completedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources that have
  /// been fully downloaded.
  var completedResourceSize: Int64
  /// The earliest point in time when any of the style package resources gets expired.
  ///
  /// Unitialized for incomplete style packages or for complete style packages with all immutable resources.
  var expires: Int64?

  static func fromList(_ list: [Any?]) -> StylePack? {
    let styleURI = list[0] as! String
    let glyphsRasterizationMode = GlyphsRasterizationMode(rawValue: list[1] as! Int)!
    let requiredResourceCount = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)
    let completedResourceCount = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let completedResourceSize = list[4] is Int64 ? list[4] as! Int64 : Int64(list[4] as! Int32)
    let expires: Int64? = isNullish(list[5]) ? nil : (list[5] is Int64? ? list[5] as! Int64? : Int64(list[5] as! Int32))

    return StylePack(
      styleURI: styleURI,
      glyphsRasterizationMode: glyphsRasterizationMode,
      requiredResourceCount: requiredResourceCount,
      completedResourceCount: completedResourceCount,
      completedResourceSize: completedResourceSize,
      expires: expires
    )
  }
  func toList() -> [Any?] {
    return [
      styleURI,
      glyphsRasterizationMode.rawValue,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    ]
  }
}

/// A `style pack load` progress includes information about
/// the number of resources that have completed downloading
/// and the total number of resources that are required.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePackLoadProgress {
  /// The number of resources that are ready for offline access.
  var completedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources that are ready for offline access.
  var completedResourceSize: Int64
  /// The number of resources that have failed to download due to an error.
  var erroredResourceCount: Int64
  /// The number of resources that are known to be required for this style package.
  var requiredResourceCount: Int64
  /// The number of resources that have been fully downloaded from the network.
  var loadedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources that have been fully downloaded
  /// from the network.
  var loadedResourceSize: Int64

  static func fromList(_ list: [Any?]) -> StylePackLoadProgress? {
    let completedResourceCount = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let completedResourceSize = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let erroredResourceCount = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)
    let requiredResourceCount = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let loadedResourceCount = list[4] is Int64 ? list[4] as! Int64 : Int64(list[4] as! Int32)
    let loadedResourceSize = list[5] is Int64 ? list[5] as! Int64 : Int64(list[5] as! Int32)

    return StylePackLoadProgress(
      completedResourceCount: completedResourceCount,
      completedResourceSize: completedResourceSize,
      erroredResourceCount: erroredResourceCount,
      requiredResourceCount: requiredResourceCount,
      loadedResourceCount: loadedResourceCount,
      loadedResourceSize: loadedResourceSize
    )
  }
  func toList() -> [Any?] {
    return [
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    ]
  }
}
private class HolderCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return GlyphsRasterizationOptions.fromList(self.readValue() as! [Any?])
    case 129:
      return StylePackLoadProgress.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class HolderCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? GlyphsRasterizationOptions {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? StylePackLoadProgress {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class HolderCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return HolderCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return HolderCodecWriter(data: data)
  }
}

class HolderCodec: FlutterStandardMessageCodec {
  static let shared = HolderCodec(readerWriter: HolderCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Holder {
  func options() throws -> GlyphsRasterizationOptions
  func progress() throws -> StylePackLoadProgress
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class HolderSetup {
  /// The codec used by Holder.
  static var codec: FlutterStandardMessageCodec { HolderCodec.shared }
  /// Sets up an instance of `Holder` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Holder?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let optionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Holder.options\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      optionsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.options()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      optionsChannel.setMessageHandler(nil)
    }
    let progressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Holder.progress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      progressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.progress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      progressChannel.setMessageHandler(nil)
    }
  }
}
private class _OfflineManagerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return StylePack.fromList(self.readValue() as! [Any?])
    case 129:
      return StylePackLoadOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _OfflineManagerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? StylePack {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? StylePackLoadOptions {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _OfflineManagerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _OfflineManagerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _OfflineManagerCodecWriter(data: data)
  }
}

class _OfflineManagerCodec: FlutterStandardMessageCodec {
  static let shared = _OfflineManagerCodec(readerWriter: _OfflineManagerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _OfflineManager {
  func loadStylePack(styleURI: String, loadOptions: StylePackLoadOptions, completion: @escaping (Result<StylePack, Error>) -> Void)
  func removeStylePack(styleURI: String, completion: @escaping (Result<StylePack, Error>) -> Void)
  func addStylePackLoadProgressListener(styleURI: String) throws
  func stylePack(styleURI: String, completion: @escaping (Result<StylePack, Error>) -> Void)
  func stylePackMetadata(styleURI: String, completion: @escaping (Result<String?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _OfflineManagerSetup {
  /// The codec used by _OfflineManager.
  static var codec: FlutterStandardMessageCodec { _OfflineManagerCodec.shared }
  /// Sets up an instance of `_OfflineManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _OfflineManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadStylePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.loadStylePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadStylePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        let loadOptionsArg = args[1] as! StylePackLoadOptions
        api.loadStylePack(styleURI: styleURIArg, loadOptions: loadOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadStylePackChannel.setMessageHandler(nil)
    }
    let removeStylePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.removeStylePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStylePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.removeStylePack(styleURI: styleURIArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStylePackChannel.setMessageHandler(nil)
    }
    let addStylePackLoadProgressListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.addStylePackLoadProgressListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStylePackLoadProgressListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        do {
          try api.addStylePackLoadProgressListener(styleURI: styleURIArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addStylePackLoadProgressListenerChannel.setMessageHandler(nil)
    }
    let stylePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stylePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.stylePack(styleURI: styleURIArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stylePackChannel.setMessageHandler(nil)
    }
    let stylePackMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePackMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stylePackMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.stylePackMetadata(styleURI: styleURIArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stylePackMetadataChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _OfflineMapInstanceManager {
  func setupOfflineManager(channelSuffix: String) throws
  func tearDownOfflineManager(channelSuffix: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _OfflineMapInstanceManagerSetup {
  /// The codec used by _OfflineMapInstanceManager.
  /// Sets up an instance of `_OfflineMapInstanceManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _OfflineMapInstanceManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setupOfflineManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.setupOfflineManager\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setupOfflineManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.setupOfflineManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setupOfflineManagerChannel.setMessageHandler(nil)
    }
    let tearDownOfflineManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.tearDownOfflineManager\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      tearDownOfflineManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.tearDownOfflineManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tearDownOfflineManagerChannel.setMessageHandler(nil)
    }
  }
}
