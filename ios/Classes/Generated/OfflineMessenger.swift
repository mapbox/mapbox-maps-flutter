// Autogenerated from Pigeon (v21.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point

/// Error class for passing custom error details to Dart side.
final class OfflineMessengerError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "OfflineMessengerError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? OfflineMessengerError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Classify network types based on cost.
enum NetworkRestriction: Int {
  /// Allow access to all network types.
  case nONE = 0
  /// Forbid network access to expensive networks, such as cellular.
  case dISALLOWEXPENSIVE = 1
  /// Forbid access to all network types.
  case dISALLOWALL = 2
}

/// Describes the tiles data domain.
enum TileDataDomain: Int {
  /// Data for Maps.
  case mAPS = 0
  /// Data for Navigation.
  case nAVIGATION = 1
  /// Data for Search.
  case sEARCH = 2
  /// Data for ADAS
  case aDAS = 3
}

enum _TileStoreOptionsKey: Int {
  case dISKQUOTA = 0
  case mAPBOXAPIURL = 1
  case tILEURLTEMPLATE = 2
}

/// Describes the style package load option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePackLoadOptions {
  /// Specifies glyphs rasterization mode.
  ///
  /// If provided, updates the style package's glyphs rasterization mode,
  /// which defines which glyphs will be loaded from the server.
  ///
  /// By default, ideographs are rasterized locally and other glyphs are loaded
  /// from network (i.e. `IdeographsRasterizedLocally` value is used).
  var glyphsRasterizationMode: GlyphsRasterizationMode?
  /// A custom Mapbox value associated with this style package for storing metadata.
  ///
  /// If provided, the custom value value will be stored alongside the style package. Previous values will
  /// be replaced with the new value.
  ///
  /// Developers can use this field to store custom metadata associated with a style package.
  var metadata: [String?: Any?]?
  /// Accepts expired data when loading style resources.
  ///
  /// This flag should be set to true to accept expired responses. When a style resource is already loaded but expired,
  /// no attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
  /// for a style is up-to-date.
  var acceptExpired: Bool

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> StylePackLoadOptions? {
    let glyphsRasterizationMode: GlyphsRasterizationMode? = nilOrValue(__pigeon_list[0])
    let metadata: [String?: Any?]? = nilOrValue(__pigeon_list[1])
    let acceptExpired = __pigeon_list[2] as! Bool

    return StylePackLoadOptions(
      glyphsRasterizationMode: glyphsRasterizationMode,
      metadata: metadata,
      acceptExpired: acceptExpired
    )
  }
  func toList() -> [Any?] {
    return [
      glyphsRasterizationMode,
      metadata,
      acceptExpired,
    ]
  }
}

/// The `style pack` represents a stored style package.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePack {
  /// The style associated with the style package.
  var styleURI: String
  /// The glyphs rasterization mode of the style package.
  ///
  /// It defines which glyphs will be loaded from the server.
  var glyphsRasterizationMode: GlyphsRasterizationMode
  /// The number of resources that are known to be required for this style package.
  var requiredResourceCount: Int64
  /// The number of resources that have been fully downloaded and are ready for
  /// offline access.
  var completedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources that have
  /// been fully downloaded.
  var completedResourceSize: Int64
  /// The earliest point in time when any of the style package resources gets expired.
  ///
  /// Uninitialized for incomplete style packages or for complete style packages with all immutable resources.
  var expires: Int64?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> StylePack? {
    let styleURI = __pigeon_list[0] as! String
    let glyphsRasterizationMode = __pigeon_list[1] as! GlyphsRasterizationMode
    let requiredResourceCount = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)
    let completedResourceCount = __pigeon_list[3] is Int64 ? __pigeon_list[3] as! Int64 : Int64(__pigeon_list[3] as! Int32)
    let completedResourceSize = __pigeon_list[4] is Int64 ? __pigeon_list[4] as! Int64 : Int64(__pigeon_list[4] as! Int32)
    let expires: Int64? = isNullish(__pigeon_list[5]) ? nil : (__pigeon_list[5] is Int64? ? __pigeon_list[5] as! Int64? : Int64(__pigeon_list[5] as! Int32))

    return StylePack(
      styleURI: styleURI,
      glyphsRasterizationMode: glyphsRasterizationMode,
      requiredResourceCount: requiredResourceCount,
      completedResourceCount: completedResourceCount,
      completedResourceSize: completedResourceSize,
      expires: expires
    )
  }
  func toList() -> [Any?] {
    return [
      styleURI,
      glyphsRasterizationMode,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    ]
  }
}

/// A `style pack load` progress includes information about
/// the number of resources that have completed downloading
/// and the total number of resources that are required.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePackLoadProgress {
  /// The number of resources that are ready for offline access.
  var completedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources that are ready for offline access.
  var completedResourceSize: Int64
  /// The number of resources that have failed to download due to an error.
  var erroredResourceCount: Int64
  /// The number of resources that are known to be required for this style package.
  var requiredResourceCount: Int64
  /// The number of resources that have been fully downloaded from the network.
  var loadedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources that have been fully downloaded
  /// from the network.
  var loadedResourceSize: Int64

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> StylePackLoadProgress? {
    let completedResourceCount = __pigeon_list[0] is Int64 ? __pigeon_list[0] as! Int64 : Int64(__pigeon_list[0] as! Int32)
    let completedResourceSize = __pigeon_list[1] is Int64 ? __pigeon_list[1] as! Int64 : Int64(__pigeon_list[1] as! Int32)
    let erroredResourceCount = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)
    let requiredResourceCount = __pigeon_list[3] is Int64 ? __pigeon_list[3] as! Int64 : Int64(__pigeon_list[3] as! Int32)
    let loadedResourceCount = __pigeon_list[4] is Int64 ? __pigeon_list[4] as! Int64 : Int64(__pigeon_list[4] as! Int32)
    let loadedResourceSize = __pigeon_list[5] is Int64 ? __pigeon_list[5] as! Int64 : Int64(__pigeon_list[5] as! Int32)

    return StylePackLoadProgress(
      completedResourceCount: completedResourceCount,
      completedResourceSize: completedResourceSize,
      erroredResourceCount: erroredResourceCount,
      requiredResourceCount: requiredResourceCount,
      loadedResourceCount: loadedResourceCount,
      loadedResourceSize: loadedResourceSize
    )
  }
  func toList() -> [Any?] {
    return [
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    ]
  }
}

/// Describes the tileset descriptor option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TilesetDescriptorOptions {
  /// The style associated with the tileset descriptor.
  var styleURI: String
  /// Minimum zoom level for the tile package.
  /// Note: the implementation loads and stores the loaded tiles
  /// in batches, each batch has a pre-defined zoom range and it contains
  /// all child tiles within the range. The zoom leveling scheme for the tile
  /// batches can be defined in Tile JSON, otherwise the default scheme is used:
  /// - Global coverage: 0 - 5
  /// - Regional information: 6 - 10
  /// - Local information: 11 - 14
  /// - Streets detail: 15 - 16
  /// Internally, the implementation maps the given tile pack zoom range
  /// and geometry to a set of pre-defined batches to load, therefore
  /// it is highly recommended to choose the `minZoom` and `maxZoom` values
  /// in accordance with the tile batches zoom ranges (see the list above).
  var minZoom: Int64
  /// Maximum zoom level for the tile package.
  /// maxZoom value cannot exceed the maximum allowed tile batch zoom value.
  var maxZoom: Int64
  /// Pixel ratio to be accounted for when downloading raster tiles.
  /// The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
  var pixelRatio: Double?
  /// The tilesets associated with the tileset descriptor.
  /// Contains an array, each element of which must be either a URI to a TileJSON
  /// resource or a JSON string representing the inline tileset.
  /// This property can be used to resolve extra tilesets that are not part of the original style
  /// represented by `styleURL`, it can be used also with the empty `styleURL`.
  /// The provided URIs must have "mapbox://" scheme, e.g. "mapbox://mapbox.mapbox-streets-v8".
  var tilesets: [String?]?
  /// Style package load options, associated with the tileset descriptor.
  /// If provided, `offline manager` will create a style package while resolving the corresponding
  /// tileset descriptor and load all the resources as defined in the provided style package options,
  /// i.e. resolving of corresponding the tileset descriptor will be equivalent to calling the `loadStylePack`
  /// method of `offline manager`.
  /// If not provided, resolving of the corresponding tileset descriptor will not cause creating of a new style
  /// package but the loaded resources will be stored in the disk cache.
  ///
  /// Style package creation requires nonempty `styleURL`, which will be the created style package identifier.
  var stylePackOptions: StylePackLoadOptions?
  /// Extra tileset descriptor options.
  var extraOptions: [String?: Any?]?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TilesetDescriptorOptions? {
    let styleURI = __pigeon_list[0] as! String
    let minZoom = __pigeon_list[1] is Int64 ? __pigeon_list[1] as! Int64 : Int64(__pigeon_list[1] as! Int32)
    let maxZoom = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)
    let pixelRatio: Double? = nilOrValue(__pigeon_list[3])
    let tilesets: [String?]? = nilOrValue(__pigeon_list[4])
    let stylePackOptions: StylePackLoadOptions? = nilOrValue(__pigeon_list[5])
    let extraOptions: [String?: Any?]? = nilOrValue(__pigeon_list[6])

    return TilesetDescriptorOptions(
      styleURI: styleURI,
      minZoom: minZoom,
      maxZoom: maxZoom,
      pixelRatio: pixelRatio,
      tilesets: tilesets,
      stylePackOptions: stylePackOptions,
      extraOptions: extraOptions
    )
  }
  func toList() -> [Any?] {
    return [
      styleURI,
      minZoom,
      maxZoom,
      pixelRatio,
      tilesets,
      stylePackOptions,
      extraOptions,
    ]
  }
}

/// Describes the tile region load option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileRegionLoadOptions {
  /// The tile region's associated geometry.
  ///
  /// If provided, updates the tile region's associated geometry i.e. geometry,
  /// which is used in the tile cover algorithm to find out a set of tiles to be loaded
  /// for the tile region.
  ///
  /// Providing an empty geometry list is equivalent to removeTileRegion() call.
  var geometry: [String?: Any?]?
  /// The tile region's tileset descriptors.
  ///
  /// If provided, updates the tile region's tileset descriptors that define
  /// the tilesets and zoom ranges of the tiles for the tile region.
  ///
  /// Providing an empty tileset descriptors list is equivalent to removeTileRegion() call.
  var descriptorsOptions: [TilesetDescriptorOptions?]?
  /// A custom Mapbox Value associated with this tile region for storing metadata.
  ///
  /// If provided, the custom value value will be stored alongside the tile region. Previous values will
  /// be replaced with the new value.
  ///
  /// Developers can use this field to store custom metadata associated with a tile region. This value
  /// can be retrieved with getTileRegionMetadata().
  var metadata: [String?: Any?]?
  /// Accepts expired data when loading tiles.
  ///
  /// This flag should be set to true to accept expired responses. When a tile is already loaded but expired, no
  /// attempt will be made to refresh the data. This may lead to outdated data. Set to false to ensure that data
  /// for a tile is up-to-date. Set to true to continue loading a group without updating expired data for tiles that
  /// are already downloaded.
  var acceptExpired: Bool
  /// Controls which networks may be used to load the tile.
  ///
  /// By default, all networks are allowed. However, in some situations, it's useful to limit the kind of networks
  /// that are allowed, e.g. to ensure that data is only transferred over a connection that doesn't incur cost to
  /// the user, like a WiFi connection, and prohibit data transfer over expensive connections like cellular.
  var networkRestriction: NetworkRestriction
  /// Starts loading the tile region at the given location and then proceeds to tiles that are further away
  /// from it.
  ///
  /// Note that this functionality is not currently implemented.
  var startLocation: Point?
  /// Limits the download speed of the tile region.
  ///
  /// Note that this is not a strict bandwidth limit, but only limits the average download speed. tile regions may
  /// be temporarily downloaded with higher speed, then pause downloading until the rolling average has dropped below
  /// this value.
  ///
  /// If unspecified, the download speed will not be restricted.
  ///
  /// Note that this functionality is not currently implemented.
  var averageBytesPerSecond: Int64?
  /// Extra tile region load options.
  ///
  /// If provided, contains an object value with extra tile region load options.
  ///
  /// There are currently no extra options.
  var extraOptions: [String?: Any?]?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TileRegionLoadOptions? {
    let geometry: [String?: Any?]? = nilOrValue(__pigeon_list[0])
    let descriptorsOptions: [TilesetDescriptorOptions?]? = nilOrValue(__pigeon_list[1])
    let metadata: [String?: Any?]? = nilOrValue(__pigeon_list[2])
    let acceptExpired = __pigeon_list[3] as! Bool
    let networkRestriction = __pigeon_list[4] as! NetworkRestriction
    let startLocation: Point? = nilOrValue(__pigeon_list[5])
    let averageBytesPerSecond: Int64? = isNullish(__pigeon_list[6]) ? nil : (__pigeon_list[6] is Int64? ? __pigeon_list[6] as! Int64? : Int64(__pigeon_list[6] as! Int32))
    let extraOptions: [String?: Any?]? = nilOrValue(__pigeon_list[7])

    return TileRegionLoadOptions(
      geometry: geometry,
      descriptorsOptions: descriptorsOptions,
      metadata: metadata,
      acceptExpired: acceptExpired,
      networkRestriction: networkRestriction,
      startLocation: startLocation,
      averageBytesPerSecond: averageBytesPerSecond,
      extraOptions: extraOptions
    )
  }
  func toList() -> [Any?] {
    return [
      geometry,
      descriptorsOptions,
      metadata,
      acceptExpired,
      networkRestriction,
      startLocation,
      averageBytesPerSecond,
      extraOptions,
    ]
  }
}

/// TileRegion represents an identifiable geographic tile region with metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileRegion {
  /// The id of the tile region
  var id: String
  /// The number of resources that are known to be required for this tile region.
  var requiredResourceCount: Int64
  /// The number of resources that have been fully downloaded and are ready for
  /// offline access.
  ///
  /// The tile region is complete if `completedResourceCount` is equal to `requiredResourceCount`.
  var completedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources (inclusive of tiles) that have
  /// been fully downloaded.
  var completedResourceSize: Int64
  /// The earliest point in time when any of the region resources gets expired.
  ///
  /// Uninitialized for incomplete tile regions or for complete tile regions with all immutable resources.
  var expires: Int64?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TileRegion? {
    let id = __pigeon_list[0] as! String
    let requiredResourceCount = __pigeon_list[1] is Int64 ? __pigeon_list[1] as! Int64 : Int64(__pigeon_list[1] as! Int32)
    let completedResourceCount = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)
    let completedResourceSize = __pigeon_list[3] is Int64 ? __pigeon_list[3] as! Int64 : Int64(__pigeon_list[3] as! Int32)
    let expires: Int64? = isNullish(__pigeon_list[4]) ? nil : (__pigeon_list[4] is Int64? ? __pigeon_list[4] as! Int64? : Int64(__pigeon_list[4] as! Int32))

    return TileRegion(
      id: id,
      requiredResourceCount: requiredResourceCount,
      completedResourceCount: completedResourceCount,
      completedResourceSize: completedResourceSize,
      expires: expires
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      requiredResourceCount,
      completedResourceCount,
      completedResourceSize,
      expires,
    ]
  }
}

/// The result of tile region estimation.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileRegionEstimateResult {
  /// Error margin of the estimate, given a fixed confidence level of 99.9%, represented by
  /// a value between 0 and 1. There is a 99.9% probability that the real value is contained
  /// in the interval [ (1 - errorMargin) * estimated value, (1 + errorMargin) * estimated value].
  ///
  /// Note: the assumptions used to calculate the error margin may not hold true for sparse
  /// datasets.
  var errorMargin: Double
  /// Estimated number of bytes that would have to be transferred from the network in order
  /// to download the estimated tile region.
  var transferSize: Int64
  /// Estimated number of bytes required to store the tile region on disk after the download
  /// is complete.
  var storageSize: Int64
  /// Reserved for future use.
  var extraOptions: [String?: Any?]?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TileRegionEstimateResult? {
    let errorMargin = __pigeon_list[0] as! Double
    let transferSize = __pigeon_list[1] is Int64 ? __pigeon_list[1] as! Int64 : Int64(__pigeon_list[1] as! Int32)
    let storageSize = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)
    let extraOptions: [String?: Any?]? = nilOrValue(__pigeon_list[3])

    return TileRegionEstimateResult(
      errorMargin: errorMargin,
      transferSize: transferSize,
      storageSize: storageSize,
      extraOptions: extraOptions
    )
  }
  func toList() -> [Any?] {
    return [
      errorMargin,
      transferSize,
      storageSize,
      extraOptions,
    ]
  }
}

/// Holds options for the tile region estimation operation.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileRegionEstimateOptions {
  /// Accepted error margin.
  var errorMargin: Double
  /// If after this timeout the estimate is within the error margin, the operation
  /// will be completed without attempting to reduce the error margin to 0.
  /// A value of 0 means no timeout. If unspecified, defaults to 5 seconds.
  var preciseEstimationTimeout: Double
  /// Timeout after which the operation will be interrupted, regardless of the
  /// current error margin.
  /// A value of 0 means no timeout. If unspecified, defaults to 0.
  var timeout: Double
  /// Reserved for future use.
  var extraOptions: [String?: Any?]?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TileRegionEstimateOptions? {
    let errorMargin = __pigeon_list[0] as! Double
    let preciseEstimationTimeout = __pigeon_list[1] as! Double
    let timeout = __pigeon_list[2] as! Double
    let extraOptions: [String?: Any?]? = nilOrValue(__pigeon_list[3])

    return TileRegionEstimateOptions(
      errorMargin: errorMargin,
      preciseEstimationTimeout: preciseEstimationTimeout,
      timeout: timeout,
      extraOptions: extraOptions
    )
  }
  func toList() -> [Any?] {
    return [
      errorMargin,
      preciseEstimationTimeout,
      timeout,
      extraOptions,
    ]
  }
}

/// A tile region's load progress includes counts
/// of the number of resources that have completed downloading
/// and the total number of resources that are required.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileRegionLoadProgress {
  /// The number of resources that are ready for offline access.
  var completedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources (inclusive of tiles) that
  /// are ready for offline access.
  var completedResourceSize: Int64
  /// The number of resources that have failed to download due to an error.
  var erroredResourceCount: Int64
  /// The number of resources that are known to be required for this tile region.
  var requiredResourceCount: Int64
  /// The number of resources that are ready for offline use and that (at least partially)
  /// have been downloaded from the network.
  var loadedResourceCount: Int64
  /// The cumulative size, in bytes, of all resources (inclusive of tiles) that have
  /// been downloaded from the network.
  var loadedResourceSize: Int64

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TileRegionLoadProgress? {
    let completedResourceCount = __pigeon_list[0] is Int64 ? __pigeon_list[0] as! Int64 : Int64(__pigeon_list[0] as! Int32)
    let completedResourceSize = __pigeon_list[1] is Int64 ? __pigeon_list[1] as! Int64 : Int64(__pigeon_list[1] as! Int32)
    let erroredResourceCount = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)
    let requiredResourceCount = __pigeon_list[3] is Int64 ? __pigeon_list[3] as! Int64 : Int64(__pigeon_list[3] as! Int32)
    let loadedResourceCount = __pigeon_list[4] is Int64 ? __pigeon_list[4] as! Int64 : Int64(__pigeon_list[4] as! Int32)
    let loadedResourceSize = __pigeon_list[5] is Int64 ? __pigeon_list[5] as! Int64 : Int64(__pigeon_list[5] as! Int32)

    return TileRegionLoadProgress(
      completedResourceCount: completedResourceCount,
      completedResourceSize: completedResourceSize,
      erroredResourceCount: erroredResourceCount,
      requiredResourceCount: requiredResourceCount,
      loadedResourceCount: loadedResourceCount,
      loadedResourceSize: loadedResourceSize
    )
  }
  func toList() -> [Any?] {
    return [
      completedResourceCount,
      completedResourceSize,
      erroredResourceCount,
      requiredResourceCount,
      loadedResourceCount,
      loadedResourceSize,
    ]
  }
}

/// A tile region's estimate progress includes counts of the number of resources that have
/// been estimated and the total number of resources as well as a partial result with the
/// current estimate, calculated using the data available at the moment.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileRegionEstimateProgress {
  /// The number of resources that are known to be required for this tile region.
  var requiredResourceCount: Int64
  /// The number of resources that are ready for offline access.
  var completedResourceCount: Int64
  /// The number of resources that have failed to download due to an error.
  var erroredResourceCount: Int64

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ __pigeon_list: [Any?]) -> TileRegionEstimateProgress? {
    let requiredResourceCount = __pigeon_list[0] is Int64 ? __pigeon_list[0] as! Int64 : Int64(__pigeon_list[0] as! Int32)
    let completedResourceCount = __pigeon_list[1] is Int64 ? __pigeon_list[1] as! Int64 : Int64(__pigeon_list[1] as! Int32)
    let erroredResourceCount = __pigeon_list[2] is Int64 ? __pigeon_list[2] as! Int64 : Int64(__pigeon_list[2] as! Int32)

    return TileRegionEstimateProgress(
      requiredResourceCount: requiredResourceCount,
      completedResourceCount: completedResourceCount,
      erroredResourceCount: erroredResourceCount
    )
  }
  func toList() -> [Any?] {
    return [
      requiredResourceCount,
      completedResourceCount,
      erroredResourceCount,
    ]
  }
}
private class OfflineMessengerPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return Point.fromList(self.readValue() as! [Any?])
    case 130:
      return StylePackLoadOptions.fromList(self.readValue() as! [Any?])
    case 131:
      return StylePack.fromList(self.readValue() as! [Any?])
    case 132:
      return StylePackLoadProgress.fromList(self.readValue() as! [Any?])
    case 133:
      return TilesetDescriptorOptions.fromList(self.readValue() as! [Any?])
    case 134:
      return TileRegionLoadOptions.fromList(self.readValue() as! [Any?])
    case 135:
      return TileRegion.fromList(self.readValue() as! [Any?])
    case 136:
      return TileRegionEstimateResult.fromList(self.readValue() as! [Any?])
    case 137:
      return TileRegionEstimateOptions.fromList(self.readValue() as! [Any?])
    case 138:
      return TileRegionLoadProgress.fromList(self.readValue() as! [Any?])
    case 139:
      return TileRegionEstimateProgress.fromList(self.readValue() as! [Any?])
    case 140:
      var enumResult: GlyphsRasterizationMode?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = GlyphsRasterizationMode(rawValue: enumResultAsInt)
      }
      return enumResult
    case 141:
      var enumResult: NetworkRestriction?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = NetworkRestriction(rawValue: enumResultAsInt)
      }
      return enumResult
    case 142:
      var enumResult: TileDataDomain?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = TileDataDomain(rawValue: enumResultAsInt)
      }
      return enumResult
    case 143:
      var enumResult: _TileStoreOptionsKey?
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as? Int)
      if let enumResultAsInt = enumResultAsInt {
        enumResult = _TileStoreOptionsKey(rawValue: enumResultAsInt)
      }
      return enumResult
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OfflineMessengerPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Point {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? StylePackLoadOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? StylePack {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? StylePackLoadProgress {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? TilesetDescriptorOptions {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? TileRegionLoadOptions {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? TileRegion {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? TileRegionEstimateResult {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? TileRegionEstimateOptions {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? TileRegionLoadProgress {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? TileRegionEstimateProgress {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? GlyphsRasterizationMode {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? NetworkRestriction {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? TileDataDomain {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? _TileStoreOptionsKey {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else {
      super.writeValue(value)
    }
  }
}

private class OfflineMessengerPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OfflineMessengerPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OfflineMessengerPigeonCodecWriter(data: data)
  }
}

class OfflineMessengerPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = OfflineMessengerPigeonCodec(readerWriter: OfflineMessengerPigeonCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _Holder {
  func stylePackLoadProgress() throws -> StylePackLoadProgress
  func tileRegionLoadProgress() throws -> TileRegionLoadProgress
  func tileRegionEstimateProgress() throws -> TileRegionEstimateProgress
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _HolderSetup {
  static var codec: FlutterStandardMessageCodec { OfflineMessengerPigeonCodec.shared }
  /// Sets up an instance of `_Holder` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _Holder?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let stylePackLoadProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._Holder.stylePackLoadProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stylePackLoadProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.stylePackLoadProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stylePackLoadProgressChannel.setMessageHandler(nil)
    }
    let tileRegionLoadProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._Holder.tileRegionLoadProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileRegionLoadProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.tileRegionLoadProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tileRegionLoadProgressChannel.setMessageHandler(nil)
    }
    let tileRegionEstimateProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._Holder.tileRegionEstimateProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileRegionEstimateProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.tileRegionEstimateProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tileRegionEstimateProgressChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _OfflineManager {
  func loadStylePack(styleURI: String, loadOptions: StylePackLoadOptions, completion: @escaping (Result<StylePack, Error>) -> Void)
  func removeStylePack(styleURI: String, completion: @escaping (Result<StylePack, Error>) -> Void)
  func addStylePackLoadProgressListener(styleURI: String) throws
  func stylePack(styleURI: String, completion: @escaping (Result<StylePack, Error>) -> Void)
  func stylePackMetadata(styleURI: String, completion: @escaping (Result<[String: Any], Error>) -> Void)
  func allStylePacks(completion: @escaping (Result<[StylePack], Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _OfflineManagerSetup {
  static var codec: FlutterStandardMessageCodec { OfflineMessengerPigeonCodec.shared }
  /// Sets up an instance of `_OfflineManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _OfflineManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadStylePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.loadStylePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadStylePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        let loadOptionsArg = args[1] as! StylePackLoadOptions
        api.loadStylePack(styleURI: styleURIArg, loadOptions: loadOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadStylePackChannel.setMessageHandler(nil)
    }
    let removeStylePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.removeStylePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStylePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.removeStylePack(styleURI: styleURIArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStylePackChannel.setMessageHandler(nil)
    }
    let addStylePackLoadProgressListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.addStylePackLoadProgressListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStylePackLoadProgressListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        do {
          try api.addStylePackLoadProgressListener(styleURI: styleURIArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addStylePackLoadProgressListenerChannel.setMessageHandler(nil)
    }
    let stylePackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stylePackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.stylePack(styleURI: styleURIArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stylePackChannel.setMessageHandler(nil)
    }
    let stylePackMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.stylePackMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stylePackMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.stylePackMetadata(styleURI: styleURIArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stylePackMetadataChannel.setMessageHandler(nil)
    }
    let allStylePacksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineManager.allStylePacks\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      allStylePacksChannel.setMessageHandler { _, reply in
        api.allStylePacks { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      allStylePacksChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _TileStore {
  func loadTileRegion(id: String, loadOptions: TileRegionLoadOptions, completion: @escaping (Result<TileRegion, Error>) -> Void)
  func addTileRegionLoadProgressListener(id: String) throws
  func estimateTileRegion(id: String, loadOptions: TileRegionLoadOptions, estimateOptions: TileRegionEstimateOptions?, completion: @escaping (Result<TileRegionEstimateResult, Error>) -> Void)
  func addTileRegionEstimateProgressListener(id: String) throws
  func tileRegionMetadata(id: String, completion: @escaping (Result<[String: Any], Error>) -> Void)
  func tileRegionContainsDescriptor(id: String, options: [TilesetDescriptorOptions], completion: @escaping (Result<Bool, Error>) -> Void)
  func allTileRegions(completion: @escaping (Result<[TileRegion], Error>) -> Void)
  func tileRegion(id: String, completion: @escaping (Result<TileRegion, Error>) -> Void)
  func removeRegion(id: String, completion: @escaping (Result<TileRegion, Error>) -> Void)
  func setOptionForKey(key: _TileStoreOptionsKey, domain: TileDataDomain?, value: Any?) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _TileStoreSetup {
  static var codec: FlutterStandardMessageCodec { OfflineMessengerPigeonCodec.shared }
  /// Sets up an instance of `_TileStore` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _TileStore?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadTileRegionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.loadTileRegion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadTileRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let loadOptionsArg = args[1] as! TileRegionLoadOptions
        api.loadTileRegion(id: idArg, loadOptions: loadOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadTileRegionChannel.setMessageHandler(nil)
    }
    let addTileRegionLoadProgressListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.addTileRegionLoadProgressListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addTileRegionLoadProgressListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        do {
          try api.addTileRegionLoadProgressListener(id: idArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addTileRegionLoadProgressListenerChannel.setMessageHandler(nil)
    }
    let estimateTileRegionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.estimateTileRegion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      estimateTileRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let loadOptionsArg = args[1] as! TileRegionLoadOptions
        let estimateOptionsArg: TileRegionEstimateOptions? = nilOrValue(args[2])
        api.estimateTileRegion(id: idArg, loadOptions: loadOptionsArg, estimateOptions: estimateOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      estimateTileRegionChannel.setMessageHandler(nil)
    }
    let addTileRegionEstimateProgressListenerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.addTileRegionEstimateProgressListener\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addTileRegionEstimateProgressListenerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        do {
          try api.addTileRegionEstimateProgressListener(id: idArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      addTileRegionEstimateProgressListenerChannel.setMessageHandler(nil)
    }
    let tileRegionMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.tileRegionMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileRegionMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        api.tileRegionMetadata(id: idArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      tileRegionMetadataChannel.setMessageHandler(nil)
    }
    let tileRegionContainsDescriptorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.tileRegionContainsDescriptor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileRegionContainsDescriptorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let optionsArg = args[1] as! [TilesetDescriptorOptions]
        api.tileRegionContainsDescriptor(id: idArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      tileRegionContainsDescriptorChannel.setMessageHandler(nil)
    }
    let allTileRegionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.allTileRegions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      allTileRegionsChannel.setMessageHandler { _, reply in
        api.allTileRegions { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      allTileRegionsChannel.setMessageHandler(nil)
    }
    let tileRegionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.tileRegion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        api.tileRegion(id: idArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      tileRegionChannel.setMessageHandler(nil)
    }
    let removeRegionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.removeRegion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        api.removeRegion(id: idArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeRegionChannel.setMessageHandler(nil)
    }
    let setOptionForKeyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStore.setOptionForKey\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setOptionForKeyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keyArg = args[0] as! _TileStoreOptionsKey
        let domainArg: TileDataDomain? = nilOrValue(args[1])
        let valueArg: Any? = args[2]
        do {
          try api.setOptionForKey(key: keyArg, domain: domainArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setOptionForKeyChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _OfflineMapInstanceManager {
  func setupOfflineManager(channelSuffix: String) throws
  func tearDownOfflineManager(channelSuffix: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _OfflineMapInstanceManagerSetup {
  static var codec: FlutterStandardMessageCodec { OfflineMessengerPigeonCodec.shared }
  /// Sets up an instance of `_OfflineMapInstanceManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _OfflineMapInstanceManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setupOfflineManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.setupOfflineManager\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setupOfflineManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.setupOfflineManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setupOfflineManagerChannel.setMessageHandler(nil)
    }
    let tearDownOfflineManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineMapInstanceManager.tearDownOfflineManager\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tearDownOfflineManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.tearDownOfflineManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tearDownOfflineManagerChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _TileStoreInstanceManager {
  func setupTileStore(channelSuffix: String, filePath: String?) throws
  func tearDownTileStore(channelSuffix: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _TileStoreInstanceManagerSetup {
  static var codec: FlutterStandardMessageCodec { OfflineMessengerPigeonCodec.shared }
  /// Sets up an instance of `_TileStoreInstanceManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _TileStoreInstanceManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setupTileStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStoreInstanceManager.setupTileStore\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setupTileStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        let filePathArg: String? = nilOrValue(args[1])
        do {
          try api.setupTileStore(channelSuffix: channelSuffixArg, filePath: filePathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setupTileStoreChannel.setMessageHandler(nil)
    }
    let tearDownTileStoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._TileStoreInstanceManager.tearDownTileStore\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tearDownTileStoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.tearDownTileStore(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tearDownTileStoreChannel.setMessageHandler(nil)
    }
  }
}
/// Instance that allows connecting or disconnecting the Mapbox stack to the network.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _OfflineSwitch {
  /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
  /// with HttpRequestErrorType#ConnectionError.
  ///
  /// @param connected Set false to disconnect the Mapbox stack
  func setMapboxStackConnected(connected: Bool) throws
  /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
  ///
  /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
  func isMapboxStackConnected() throws -> Bool
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _OfflineSwitchSetup {
  static var codec: FlutterStandardMessageCodec { OfflineMessengerPigeonCodec.shared }
  /// Sets up an instance of `_OfflineSwitch` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _OfflineSwitch?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
    /// with HttpRequestErrorType#ConnectionError.
    ///
    /// @param connected Set false to disconnect the Mapbox stack
    let setMapboxStackConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineSwitch.setMapboxStackConnected\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMapboxStackConnectedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectedArg = args[0] as! Bool
        do {
          try api.setMapboxStackConnected(connected: connectedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMapboxStackConnectedChannel.setMessageHandler(nil)
    }
    /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
    ///
    /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
    let isMapboxStackConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._OfflineSwitch.isMapboxStackConnected\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isMapboxStackConnectedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isMapboxStackConnected()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMapboxStackConnectedChannel.setMessageHandler(nil)
    }
  }
}
