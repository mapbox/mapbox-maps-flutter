// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Polygon

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Controls the frame of reference for `fill-translate`.
enum FillTranslateAnchor: Int {
  /// The fill is translated relative to the map.
  case mAP = 0
  /// The fill is translated relative to the viewport.
  case vIEWPORT = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolygonAnnotation {
  /// The id for annotation
  var id: String
  /// The geometry that determines the location/shape of this annotation
  var geometry: Polygon
  /// Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.
  var fillSortKey: Double?
  /// The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.
  var fillColor: Int64?
  /// The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.
  var fillOpacity: Double?
  /// The outline color of the fill. Matches the value of `fill-color` if unspecified.
  var fillOutlineColor: Int64?
  /// Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.
  var fillPattern: String?

  static func fromList(_ list: [Any?]) -> PolygonAnnotation? {
    let id = list[0] as! String
    let geometry = Polygon.fromList(list[1] as! [Any?])!
    let fillSortKey: Double? = nilOrValue(list[2])
    let fillColor: Int64? = isNullish(list[3]) ? nil : (list[3] is Int64? ? list[3] as! Int64? : Int64(list[3] as! Int32))
    let fillOpacity: Double? = nilOrValue(list[4])
    let fillOutlineColor: Int64? = isNullish(list[5]) ? nil : (list[5] is Int64? ? list[5] as! Int64? : Int64(list[5] as! Int32))
    let fillPattern: String? = nilOrValue(list[6])

    return PolygonAnnotation(
      id: id,
      geometry: geometry,
      fillSortKey: fillSortKey,
      fillColor: fillColor,
      fillOpacity: fillOpacity,
      fillOutlineColor: fillOutlineColor,
      fillPattern: fillPattern
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      geometry.toList(),
      fillSortKey,
      fillColor,
      fillOpacity,
      fillOutlineColor,
      fillPattern,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PolygonAnnotationOptions {
  /// The geometry that determines the location/shape of this annotation
  var geometry: Polygon
  /// Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.
  var fillSortKey: Double?
  /// The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color's opacity will not affect the opacity of the 1px stroke, if it is used.
  var fillColor: Int64?
  /// The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.
  var fillOpacity: Double?
  /// The outline color of the fill. Matches the value of `fill-color` if unspecified.
  var fillOutlineColor: Int64?
  /// Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.
  var fillPattern: String?

  static func fromList(_ list: [Any?]) -> PolygonAnnotationOptions? {
    let geometry = Polygon.fromList(list[0] as! [Any?])!
    let fillSortKey: Double? = nilOrValue(list[1])
    let fillColor: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let fillOpacity: Double? = nilOrValue(list[3])
    let fillOutlineColor: Int64? = isNullish(list[4]) ? nil : (list[4] is Int64? ? list[4] as! Int64? : Int64(list[4] as! Int32))
    let fillPattern: String? = nilOrValue(list[5])

    return PolygonAnnotationOptions(
      geometry: geometry,
      fillSortKey: fillSortKey,
      fillColor: fillColor,
      fillOpacity: fillOpacity,
      fillOutlineColor: fillOutlineColor,
      fillPattern: fillPattern
    )
  }
  func toList() -> [Any?] {
    return [
      geometry.toList(),
      fillSortKey,
      fillColor,
      fillOpacity,
      fillOutlineColor,
      fillPattern,
    ]
  }
}
private class OnPolygonAnnotationClickListenerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return Polygon.fromList(self.readValue() as! [Any?])
    case 129:
      return PolygonAnnotation.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OnPolygonAnnotationClickListenerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Polygon {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonAnnotation {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class OnPolygonAnnotationClickListenerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OnPolygonAnnotationClickListenerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OnPolygonAnnotationClickListenerCodecWriter(data: data)
  }
}

class OnPolygonAnnotationClickListenerCodec: FlutterStandardMessageCodec {
  static let shared = OnPolygonAnnotationClickListenerCodec(readerWriter: OnPolygonAnnotationClickListenerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnPolygonAnnotationClickListenerProtocol {
  func onPolygonAnnotationClick(annotation annotationArg: PolygonAnnotation, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class OnPolygonAnnotationClickListener: OnPolygonAnnotationClickListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: FlutterStandardMessageCodec {
    return OnPolygonAnnotationClickListenerCodec.shared
  }
  func onPolygonAnnotationClick(annotation annotationArg: PolygonAnnotation, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnPolygonAnnotationClickListener.onPolygonAnnotationClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
private class _PolygonAnnotationMessengerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return Polygon.fromList(self.readValue() as! [Any?])
    case 129:
      return PolygonAnnotation.fromList(self.readValue() as! [Any?])
    case 130:
      return PolygonAnnotation.fromList(self.readValue() as! [Any?])
    case 131:
      return PolygonAnnotationOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return PolygonAnnotationOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _PolygonAnnotationMessengerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Polygon {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonAnnotation {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonAnnotation {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonAnnotationOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? PolygonAnnotationOptions {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _PolygonAnnotationMessengerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _PolygonAnnotationMessengerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _PolygonAnnotationMessengerCodecWriter(data: data)
  }
}

class _PolygonAnnotationMessengerCodec: FlutterStandardMessageCodec {
  static let shared = _PolygonAnnotationMessengerCodec(readerWriter: _PolygonAnnotationMessengerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _PolygonAnnotationMessenger {
  func create(managerId: String, annotationOption: PolygonAnnotationOptions, completion: @escaping (Result<PolygonAnnotation, Error>) -> Void)
  func createMulti(managerId: String, annotationOptions: [PolygonAnnotationOptions], completion: @escaping (Result<[PolygonAnnotation], Error>) -> Void)
  func update(managerId: String, annotation: PolygonAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func delete(managerId: String, annotation: PolygonAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func deleteAll(managerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func setFillAntialias(managerId: String, fillAntialias: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getFillAntialias(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setFillEmissiveStrength(managerId: String, fillEmissiveStrength: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getFillEmissiveStrength(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setFillTranslate(managerId: String, fillTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getFillTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setFillTranslateAnchor(managerId: String, fillTranslateAnchor: FillTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getFillTranslateAnchor(managerId: String, completion: @escaping (Result<FillTranslateAnchor?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _PolygonAnnotationMessengerSetup {
  /// The codec used by _PolygonAnnotationMessenger.
  static var codec: FlutterStandardMessageCodec { _PolygonAnnotationMessengerCodec.shared }
  /// Sets up an instance of `_PolygonAnnotationMessenger` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _PolygonAnnotationMessenger?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionArg = args[1] as! PolygonAnnotationOptions
        api.create(managerId: managerIdArg, annotationOption: annotationOptionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let createMultiChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.createMulti\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createMultiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionsArg = args[1] as! [PolygonAnnotationOptions]
        api.createMulti(managerId: managerIdArg, annotationOptions: annotationOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createMultiChannel.setMessageHandler(nil)
    }
    let updateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.update\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PolygonAnnotation
        api.update(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateChannel.setMessageHandler(nil)
    }
    let deleteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.delete\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PolygonAnnotation
        api.delete(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteChannel.setMessageHandler(nil)
    }
    let deleteAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.deleteAll\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteAllChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.deleteAll(managerId: managerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteAllChannel.setMessageHandler(nil)
    }
    let setFillAntialiasChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.setFillAntialias\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFillAntialiasChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let fillAntialiasArg = args[1] as! Bool
        api.setFillAntialias(managerId: managerIdArg, fillAntialias: fillAntialiasArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFillAntialiasChannel.setMessageHandler(nil)
    }
    let getFillAntialiasChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.getFillAntialias\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFillAntialiasChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getFillAntialias(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFillAntialiasChannel.setMessageHandler(nil)
    }
    let setFillEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.setFillEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFillEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let fillEmissiveStrengthArg = args[1] as! Double
        api.setFillEmissiveStrength(managerId: managerIdArg, fillEmissiveStrength: fillEmissiveStrengthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFillEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let getFillEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.getFillEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFillEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getFillEmissiveStrength(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFillEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let setFillTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.setFillTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFillTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let fillTranslateArg = args[1] as! [Double?]
        api.setFillTranslate(managerId: managerIdArg, fillTranslate: fillTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFillTranslateChannel.setMessageHandler(nil)
    }
    let getFillTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.getFillTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFillTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getFillTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFillTranslateChannel.setMessageHandler(nil)
    }
    let setFillTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.setFillTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFillTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let fillTranslateAnchorArg = FillTranslateAnchor(rawValue: args[1] as! Int)!
        api.setFillTranslateAnchor(managerId: managerIdArg, fillTranslateAnchor: fillTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFillTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getFillTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PolygonAnnotationMessenger.getFillTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFillTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getFillTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFillTranslateAnchorChannel.setMessageHandler(nil)
    }
  }
}
