// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Describes glyphs rasterization modes.
enum GlyphsRasterizationMode: Int {
  /// No glyphs are rasterized locally. All glyphs are loaded from the server.
  case nOGLYPHSRASTERIZEDLOCALLY = 0
  /// Ideographs are rasterized locally, and they are not loaded from the server.
  case iDEOGRAPHSRASTERIZEDLOCALLY = 1
  /// All glyphs are rasterized locally. No glyphs are loaded from the server.
  case aLLGLYPHSRASTERIZEDLOCALLY = 2
}

/// Describes the map context mode.
/// We can make some optimizations if we know that the drawing context is not shared with other code.
enum ContextMode: Int {
  /// Unique context mode: in OpenGL, the GL context is not shared, thus we can retain knowledge about the GL state
  /// from a previous render pass. It also enables clearing the screen using glClear for the bottommost background
  /// layer when no pattern is applied to that layer.
  case uNIQUE = 0
  /// Shared context mode: in OpenGL, the GL context is shared with other renderers, thus we cannot rely on the GL
  /// state set from a previous render pass.
  case sHARED = 1
}

/// Describes whether to constrain the map in both axes or only vertically e.g. while panning.
enum ConstrainMode: Int {
  /// No constrains.
  case nONE = 0
  /// Constrain to height only
  case hEIGHTONLY = 1
  /// Constrain both width and height axes.
  case wIDTHANDHEIGHT = 2
}

/// Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards.
enum ViewportMode: Int {
  /// Default viewport
  case dEFAULT = 0
  /// Viewport flipped on the y-axis.
  case fLIPPEDY = 1
}

/// Describes the map orientation.
enum NorthOrientation: Int {
  /// Default, map oriented upwards
  case uPWARDS = 0
  /// Map oriented righwards
  case rIGHTWARDS = 1
  /// Map oriented downwards
  case dOWNWARDS = 2
  /// Map oriented leftwards
  case lEFTWARDS = 3
}

/// Options for enabling debugging features in a map.
enum MapDebugOptionsData: Int {
  /// Edges of tile boundaries are shown as thick, red lines to help diagnose
  /// tile clipping issues.
  case tILEBORDERS = 0
  /// Each tile shows its tile coordinate (x/y/z) in the upper-left corner.
  case pARSESTATUS = 1
  /// Each tile shows a timestamp indicating when it was loaded.
  case tIMESTAMPS = 2
  /// Edges of glyphs and symbols are shown as faint, green lines to help
  /// diagnose collision and label placement issues.
  case cOLLISION = 3
  /// Each drawing operation is replaced by a translucent fill. Overlapping
  /// drawing operations appear more prominent to help diagnose overdrawing.
  case oVERDRAW = 4
  /// The stencil buffer is shown instead of the color buffer.
  case sTENCILCLIP = 5
  /// The depth buffer is shown instead of the color buffer.
  case dEPTHBUFFER = 6
  /// Visualize residency of tiles in the render cache. Tile boundaries of cached tiles
  /// are rendered with green, tiles waiting for an update with yellow and tiles not in the cache
  /// with red.
  case rENDERCACHE = 7
  /// Show 3D model bounding boxes.
  case mODELBOUNDS = 8
  /// Show a wireframe for terrain.
  case tERRAINWIREFRAME = 9
}

/// Enum describing how to place view annotation relatively to geometry.
enum ViewAnnotationAnchor: Int {
  /// The top of the view annotation is placed closest to the geometry.
  case tOP = 0
  /// The left side of the view annotation is placed closest to the geometry.
  case lEFT = 1
  /// The bottom of the view annotation is placed closest to the geometry.
  case bOTTOM = 2
  /// The right side of the view annotation is placed closest to the geometry.
  case rIGHT = 3
  /// The top-left corner of the view annotation is placed closest to the geometry.
  case tOPLEFT = 4
  /// The bottom-right corner of the view annotation is placed closest to the geometry.
  case bOTTOMRIGHT = 5
  /// The top-right corner of the view annotation is placed closest to the geometry.
  case tOPRIGHT = 6
  /// The bottom-left corner of the view annotation is placed closest to the geometry.
  case bOTTOMLEFT = 7
  /// The center of the view annotation is placed closest to the geometry.
  case cENTER = 8
}

/// Type information of the variant's content
enum Type: Int {
  case sCREENBOX = 0
  case sCREENCOORDINATE = 1
  case lIST = 2
}

/// Describes the reason for a style package download request failure.
enum StylePackErrorType: Int {
  /// The operation was canceled.
  case cANCELED = 0
  /// The style package does not exist.
  case dOESNOTEXIST = 1
  /// There is no available space to store the resources.
  case dISKFULL = 2
  /// Other reason.
  case oTHER = 3
}

/// Describes the reason for an offline request response error.
enum ResponseErrorReason: Int {
  /// No error occurred during the resource request.
  case sUCCESS = 0
  /// The resource is not found.
  case nOTFOUND = 1
  /// The server error.
  case sERVER = 2
  /// The connection error.
  case cONNECTION = 3
  /// The error happened because of a rate limit.
  case rATELIMIT = 4
  /// The resource cannot be loaded because the device is in offline mode.
  case iNOFFLINEMODE = 5
  /// Other reason.
  case oTHER = 6
}

/// Describes the download state of a region.
enum OfflineRegionDownloadState: Int {
  /// Indicates downloading is inactive.
  case iNACTIVE = 0
  /// Indicates downloading is active.
  case aCTIVE = 1
}

/// Describes tile store usage modes.
enum TileStoreUsageMode: Int {
  /// Tile store usage is disabled.
  ///
  /// The implementation skips checking tile store when requesting a tile.
  case dISABLED = 0
  /// Tile store enabled for accessing loaded tile packs.
  ///
  /// The implementation first checks tile store when requesting a tile.
  /// If a tile pack is already loaded, the tile will be extracted and returned. Otherwise, the implementation
  /// falls back to requesting the individual tile and storing it in the disk cache.
  case rEADONLY = 1
  /// Tile store enabled for accessing local tile packs and for loading new tile packs from server.
  ///
  /// All tile requests are converted to tile pack requests, i.e.
  /// the tile pack that includes the request tile will be loaded, and the tile extracted
  /// from it. In this mode, no individual tile requests will be made.
  ///
  /// This mode can be useful if the map trajectory is predefined and the user cannot pan
  /// freely (e.g. navigation use cases), so that there is a good chance tile packs are already loaded
  /// in the vicinity of the user.
  ///
  /// If users can pan freely, this mode is not recommended. Otherwise, panning
  /// will download tile packs instead of using individual tiles. Note that this means that we could first
  /// download an individual tile, and then a tile pack that also includes this tile. The individual tile in
  /// the disk cache wonâ€™t be used as long as the up-to-date tile pack exists in the cache.
  case rEADANDUPDATE = 2
}

/// Describes the kind of a style property value.
enum StylePropertyValueKind: Int {
  /// The property value is not defined.
  case uNDEFINED = 0
  /// The property value is a constant.
  case cONSTANT = 1
  /// The property value is a style [expression](https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions).
  case eXPRESSION = 2
  /// Property value is a style [transition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#transition).
  case tRANSITION = 3
}

enum StyleProjectionName: Int {
  case mercator = 0
  case globe = 1
}

/// Whether extruded geometries are lit relative to the map or viewport.
enum Anchor: Int {
  /// The position of the light source is aligned to the rotation of the map.
  case mAP = 0
  /// The position of the light source is aligned to the rotation of the viewport.
  case vIEWPORT = 1
}

/// HTTP defines a set of request methods to indicate the desired action to be performed for a given resource.
enum HttpMethod: Int {
  /// The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
  case gET = 0
  /// The HEAD method asks for a response identical to that of a GET request, but without the response body.
  case hEAD = 1
  /// The POST method sends data (stored in the request body) to a server to create or update a given resource.
  case pOST = 2
}

/// Classify network types based on cost.
enum NetworkRestriction: Int {
  /// Allow access to all network types.
  case nONE = 0
  /// Forbid network access to expensive networks, such as cellular.
  case dISALLOWEXPENSIVE = 1
  /// Forbid access to all network types.
  case dISALLOWALL = 2
}

/// Enum which describes possible error types which could happen during HTTP request/download calls.
enum HttpRequestErrorType: Int {
  /// Establishing connection related error.
  case cONNECTIONERROR = 0
  /// SSL related error.
  case sSLERROR = 1
  /// Request was cancelled by the user.
  case rEQUESTCANCELLED = 2
  /// Timeout error.
  case rEQUESTTIMEDOUT = 3
  /// Range request failed.
  case rANGEERROR = 4
  /// Other than above error.
  case oTHERERROR = 5
}

/// Enum which represents different error cases which could happen during download session.
enum DownloadErrorCode: Int {
  /// General filesystem related error code. For cases like: write error, no such file or directory, not enough space and etc.
  case fILESYSTEMERROR = 0
  /// General network related error. Should be probably representation of HttpRequestError.
  case nETWORKERROR = 1
}

/// Enum representing state of download session.
enum DownloadState: Int {
  /// Download session initiated but not started yet.
  case pENDING = 0
  /// Download session is in progress.
  case dOWNLOADING = 1
  /// Download session failed.
  case fAILED = 2
  /// Download session successfully finished.
  case fINISHED = 3
}

/// Describes the tiles data domain.
enum TileDataDomain: Int {
  /// Data for Maps.
  case mAPS = 0
  /// Data for Navigation.
  case nAVIGATION = 1
  /// Data for Search.
  case sEARCH = 2
  /// Data for ADAS
  case aDAS = 3
}

/// Describes the reason for a tile region download request failure.
enum TileRegionErrorType: Int {
  /// The operation was canceled.
  case cANCELED = 0
  /// tile region does not exist.
  case dOESNOTEXIST = 1
  /// Tileset descriptors resolving failed.
  case tILESETDESCRIPTOR = 2
  /// There is no available space to store the resources
  case dISKFULL = 3
  /// Other reason.
  case oTHER = 4
  /// The region contains more tiles than allowed.
  case tILECOUNTEXCEEDED = 5
}

enum _MapEvent: Int {
  case mapLoaded = 0
  case mapLoadingError = 1
  case styleLoaded = 2
  case styleDataLoaded = 3
  case cameraChanged = 4
  case mapIdle = 5
  case sourceAdded = 6
  case sourceRemoved = 7
  case sourceDataLoaded = 8
  case styleImageMissing = 9
  case styleImageRemoveUnused = 10
  case renderFrameStarted = 11
  case renderFrameFinished = 12
  case resourceRequest = 13
}

/// Various options needed for tile cover.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileCoverOptions {
  /// Tile size of the source. Defaults to 512.
  var tileSize: Int64?
  /// Min zoom defined in the source between range [0, 22].
  /// if not provided or is out of range, defaults to 0.
  var minZoom: Int64?
  /// Max zoom defined in the source between range [0, 22].
  /// Should be greater than or equal to minZoom.
  /// If not provided or is out of range, defaults to 22.
  var maxZoom: Int64?
  /// Whether to round zoom values when calculating tilecover.
  /// Set this to true for raster and raster-dem sources.
  /// If not specified, defaults to false.
  var roundZoom: Bool?

  static func fromList(_ list: [Any?]) -> TileCoverOptions? {
    let tileSize: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let minZoom: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let maxZoom: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let roundZoom: Bool? = nilOrValue(list[3])

    return TileCoverOptions(
      tileSize: tileSize,
      minZoom: minZoom,
      maxZoom: maxZoom,
      roundZoom: roundZoom
    )
  }
  func toList() -> [Any?] {
    return [
      tileSize,
      minZoom,
      maxZoom,
      roundZoom,
    ]
  }
}

/// The distance on each side between rectangles, when one is contained into other.
///
/// All fields' values are in `logical pixel` units.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MbxEdgeInsets {
  /// Padding from the top.
  var top: Double
  /// Padding from the left.
  var left: Double
  /// Padding from the bottom.
  var bottom: Double
  /// Padding from the right.
  var right: Double

  static func fromList(_ list: [Any?]) -> MbxEdgeInsets? {
    let top = list[0] as! Double
    let left = list[1] as! Double
    let bottom = list[2] as! Double
    let right = list[3] as! Double

    return MbxEdgeInsets(
      top: top,
      left: left,
      bottom: bottom,
      right: right
    )
  }
  func toList() -> [Any?] {
    return [
      top,
      left,
      bottom,
      right,
    ]
  }
}

/// Various options for describing the viewpoint of a camera. All fields are
/// optional.
///
/// Anchor and center points are mutually exclusive, with preference for the
/// center point when both are set.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraOptions {
  /// Coordinate at the center of the camera.
  var center: Point?
  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  var padding: MbxEdgeInsets?
  /// Point of reference for `zoom` and `angle`, assuming an origin at the
  /// top-left corner of the view.
  var anchor: ScreenCoordinate?
  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  var zoom: Double?
  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  var bearing: Double?
  /// Pitch toward the horizon measured in degrees.
  var pitch: Double?

  static func fromList(_ list: [Any?]) -> CameraOptions? {
    var center: Point?
    if let centerList: [Any?] = nilOrValue(list[0]) {
      center = Point.fromList(centerList)
    }
    var padding: MbxEdgeInsets?
    if let paddingList: [Any?] = nilOrValue(list[1]) {
      padding = MbxEdgeInsets.fromList(paddingList)
    }
    var anchor: ScreenCoordinate?
    if let anchorList: [Any?] = nilOrValue(list[2]) {
      anchor = ScreenCoordinate.fromList(anchorList)
    }
    let zoom: Double? = nilOrValue(list[3])
    let bearing: Double? = nilOrValue(list[4])
    let pitch: Double? = nilOrValue(list[5])

    return CameraOptions(
      center: center,
      padding: padding,
      anchor: anchor,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch
    )
  }
  func toList() -> [Any?] {
    return [
      center?.toList(),
      padding?.toList(),
      anchor?.toList(),
      zoom,
      bearing,
      pitch,
    ]
  }
}

/// Describes the viewpoint of a camera.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraState {
  /// Coordinate at the center of the camera.
  var center: Point
  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  var padding: MbxEdgeInsets
  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  var zoom: Double
  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  var bearing: Double
  /// Pitch toward the horizon measured in degrees.
  var pitch: Double

  static func fromList(_ list: [Any?]) -> CameraState? {
    let center = Point.fromList(list[0] as! [Any?])!
    let padding = MbxEdgeInsets.fromList(list[1] as! [Any?])!
    let zoom = list[2] as! Double
    let bearing = list[3] as! Double
    let pitch = list[4] as! Double

    return CameraState(
      center: center,
      padding: padding,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch
    )
  }
  func toList() -> [Any?] {
    return [
      center.toList(),
      padding.toList(),
      zoom,
      bearing,
      pitch,
    ]
  }
}

/// Holds options to be used for setting `camera bounds`.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraBoundsOptions {
  /// The latitude and longitude bounds to which the camera center are constrained.
  var bounds: CoordinateBounds?
  /// The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area.
  var maxZoom: Double?
  /// The minimum zoom level, in Mapbox zoom levels 0-25.5.
  var minZoom: Double?
  /// The maximum allowed pitch value in degrees.
  var maxPitch: Double?
  /// The minimum allowed pitch value in degrees.
  var minPitch: Double?

  static func fromList(_ list: [Any?]) -> CameraBoundsOptions? {
    var bounds: CoordinateBounds?
    if let boundsList: [Any?] = nilOrValue(list[0]) {
      bounds = CoordinateBounds.fromList(boundsList)
    }
    let maxZoom: Double? = nilOrValue(list[1])
    let minZoom: Double? = nilOrValue(list[2])
    let maxPitch: Double? = nilOrValue(list[3])
    let minPitch: Double? = nilOrValue(list[4])

    return CameraBoundsOptions(
      bounds: bounds,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch
    )
  }
  func toList() -> [Any?] {
    return [
      bounds?.toList(),
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    ]
  }
}

/// Holds information about `camera bounds`.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraBounds {
  /// The latitude and longitude bounds to which the camera center are constrained.
  var bounds: CoordinateBounds
  /// The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area.
  var maxZoom: Double
  /// The minimum zoom level, in Mapbox zoom levels 0-25.5.
  var minZoom: Double
  /// The maximum allowed pitch value in degrees.
  var maxPitch: Double
  /// The minimum allowed pitch value in degrees.
  var minPitch: Double

  static func fromList(_ list: [Any?]) -> CameraBounds? {
    let bounds = CoordinateBounds.fromList(list[0] as! [Any?])!
    let maxZoom = list[1] as! Double
    let minZoom = list[2] as! Double
    let maxPitch = list[3] as! Double
    let minPitch = list[4] as! Double

    return CameraBounds(
      bounds: bounds,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch
    )
  }
  func toList() -> [Any?] {
    return [
      bounds.toList(),
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MapAnimationOptions {
  /// The duration of the animation in milliseconds.
  /// If not set explicitly default duration will be taken 300ms
  var duration: Int64?
  /// The amount of time, in milliseconds, to delay starting the animation after animation start.
  /// If not set explicitly default startDelay will be taken 0ms. This only works for Android.
  var startDelay: Int64?

  static func fromList(_ list: [Any?]) -> MapAnimationOptions? {
    let duration: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let startDelay: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))

    return MapAnimationOptions(
      duration: duration,
      startDelay: startDelay
    )
  }
  func toList() -> [Any?] {
    return [
      duration,
      startDelay,
    ]
  }
}

/// A rectangular area as measured on a two-dimensional map projection.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CoordinateBounds {
  /// Coordinate at the southwest corner.
  /// Note: setting this field with invalid values (infinite, NaN) will crash the application.
  var southwest: Point
  /// Coordinate at the northeast corner.
  /// Note: setting this field with invalid values (infinite, NaN) will crash the application.
  var northeast: Point
  /// If set to `true`, an infinite (unconstrained) bounds covering the world coordinates would be used.
  /// Coordinates provided in `southwest` and `northeast` fields would be omitted and have no effect.
  var infiniteBounds: Bool

  static func fromList(_ list: [Any?]) -> CoordinateBounds? {
    let southwest = Point.fromList(list[0] as! [Any?])!
    let northeast = Point.fromList(list[1] as! [Any?])!
    let infiniteBounds = list[2] as! Bool

    return CoordinateBounds(
      southwest: southwest,
      northeast: northeast,
      infiniteBounds: infiniteBounds
    )
  }
  func toList() -> [Any?] {
    return [
      southwest.toList(),
      northeast.toList(),
      infiniteBounds,
    ]
  }
}

/// Options for enabling debugging features in a map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapDebugOptions {
  var data: MapDebugOptionsData

  static func fromList(_ list: [Any?]) -> MapDebugOptions? {
    let data = MapDebugOptionsData(rawValue: list[0] as! Int)!

    return MapDebugOptions(
      data: data
    )
  }
  func toList() -> [Any?] {
    return [
      data.rawValue
    ]
  }
}

/// Describes the glyphs rasterization option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct GlyphsRasterizationOptions {
  /// Glyphs rasterization mode for client-side text rendering.
  var rasterizationMode: GlyphsRasterizationMode
  /// Font family to use as font fallback for client-side text renderings.
  ///
  /// Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
  /// or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
  /// font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
  /// default font are varied in platforms:
  /// - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
  ///   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
  /// - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
  ///
  /// Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
  ///
  var fontFamily: String?

  static func fromList(_ list: [Any?]) -> GlyphsRasterizationOptions? {
    let rasterizationMode = GlyphsRasterizationMode(rawValue: list[0] as! Int)!
    let fontFamily: String? = nilOrValue(list[1])

    return GlyphsRasterizationOptions(
      rasterizationMode: rasterizationMode,
      fontFamily: fontFamily
    )
  }
  func toList() -> [Any?] {
    return [
      rasterizationMode.rawValue,
      fontFamily,
    ]
  }
}

/// Map memory budget in megabytes.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileCacheBudgetInMegabytes {
  var size: Int64

  static func fromList(_ list: [Any?]) -> TileCacheBudgetInMegabytes? {
    let size = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)

    return TileCacheBudgetInMegabytes(
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      size
    ]
  }
}

/// Map memory budget in tiles.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileCacheBudgetInTiles {
  var size: Int64

  static func fromList(_ list: [Any?]) -> TileCacheBudgetInTiles? {
    let size = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)

    return TileCacheBudgetInTiles(
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      size
    ]
  }
}

/// Describes the map option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapOptions {
  /// The map context mode. This can be used to optimizations
  /// if we know that the drawing context is not shared with other code.
  var contextMode: ContextMode?
  /// The map constrain mode. This can be used to limit the map
  /// to wrap around the globe horizontally. By default, it is set to
  /// `HeightOnly`.
  var constrainMode: ConstrainMode?
  /// The viewport mode. This can be used to flip the vertical
  /// orientation of the map as some devices may use inverted orientation.
  var viewportMode: ViewportMode?
  /// The orientation of the Map. By default, it is set to
  /// `Upwards`.
  var orientation: NorthOrientation?
  /// Specify whether to enable cross-source symbol collision detection
  /// or not. By default, it is set to `true`.
  var crossSourceCollisions: Bool?
  /// The size to resize the map object and renderer backend.
  /// The size is given in `logical pixel` units. macOS and iOS platforms use
  /// device-independent pixel units, while other platforms, such as Android,
  /// use screen pixel units.
  var size: Size?
  /// The custom pixel ratio. By default, it is set to 1.0
  var pixelRatio: Double
  /// Glyphs rasterization options to use for client-side text rendering.
  var glyphsRasterizationOptions: GlyphsRasterizationOptions?

  static func fromList(_ list: [Any?]) -> MapOptions? {
    var contextMode: ContextMode?
    let contextModeEnumVal: Int? = nilOrValue(list[0])
    if let contextModeRawValue = contextModeEnumVal {
      contextMode = ContextMode(rawValue: contextModeRawValue)!
    }
    var constrainMode: ConstrainMode?
    let constrainModeEnumVal: Int? = nilOrValue(list[1])
    if let constrainModeRawValue = constrainModeEnumVal {
      constrainMode = ConstrainMode(rawValue: constrainModeRawValue)!
    }
    var viewportMode: ViewportMode?
    let viewportModeEnumVal: Int? = nilOrValue(list[2])
    if let viewportModeRawValue = viewportModeEnumVal {
      viewportMode = ViewportMode(rawValue: viewportModeRawValue)!
    }
    var orientation: NorthOrientation?
    let orientationEnumVal: Int? = nilOrValue(list[3])
    if let orientationRawValue = orientationEnumVal {
      orientation = NorthOrientation(rawValue: orientationRawValue)!
    }
    let crossSourceCollisions: Bool? = nilOrValue(list[4])
    var size: Size?
    if let sizeList: [Any?] = nilOrValue(list[5]) {
      size = Size.fromList(sizeList)
    }
    let pixelRatio = list[6] as! Double
    var glyphsRasterizationOptions: GlyphsRasterizationOptions?
    if let glyphsRasterizationOptionsList: [Any?] = nilOrValue(list[7]) {
      glyphsRasterizationOptions = GlyphsRasterizationOptions.fromList(glyphsRasterizationOptionsList)
    }

    return MapOptions(
      contextMode: contextMode,
      constrainMode: constrainMode,
      viewportMode: viewportMode,
      orientation: orientation,
      crossSourceCollisions: crossSourceCollisions,
      size: size,
      pixelRatio: pixelRatio,
      glyphsRasterizationOptions: glyphsRasterizationOptions
    )
  }
  func toList() -> [Any?] {
    return [
      contextMode?.rawValue,
      constrainMode?.rawValue,
      viewportMode?.rawValue,
      orientation?.rawValue,
      crossSourceCollisions,
      size?.toList(),
      pixelRatio,
      glyphsRasterizationOptions?.toList(),
    ]
  }
}

/// Describes the coordinate on the screen, measured from top to bottom and from left to right.
/// Note: the `map` uses screen coordinate units measured in `logical pixels`.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ScreenCoordinate {
  /// A value representing the x position of this coordinate.
  var x: Double
  /// A value representing the y position of this coordinate.
  var y: Double

  static func fromList(_ list: [Any?]) -> ScreenCoordinate? {
    let x = list[0] as! Double
    let y = list[1] as! Double

    return ScreenCoordinate(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

/// Describes the coordinate box on the screen, measured in `logical pixels`
/// from top to bottom and from left to right.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ScreenBox {
  /// The screen coordinate close to the top left corner of the screen.
  var min: ScreenCoordinate
  /// The screen coordinate close to the bottom right corner of the screen.
  var max: ScreenCoordinate

  static func fromList(_ list: [Any?]) -> ScreenBox? {
    let min = ScreenCoordinate.fromList(list[0] as! [Any?])!
    let max = ScreenCoordinate.fromList(list[1] as! [Any?])!

    return ScreenBox(
      min: min,
      max: max
    )
  }
  func toList() -> [Any?] {
    return [
      min.toList(),
      max.toList(),
    ]
  }
}

/// A coordinate bounds and zoom.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CoordinateBoundsZoom {
  /// The latitude and longitude bounds.
  var bounds: CoordinateBounds
  /// Zoom.
  var zoom: Double

  static func fromList(_ list: [Any?]) -> CoordinateBoundsZoom? {
    let bounds = CoordinateBounds.fromList(list[0] as! [Any?])!
    let zoom = list[1] as! Double

    return CoordinateBoundsZoom(
      bounds: bounds,
      zoom: zoom
    )
  }
  func toList() -> [Any?] {
    return [
      bounds.toList(),
      zoom,
    ]
  }
}

/// Size type.
///
/// Generated class from Pigeon that represents data sent in messages.
struct Size {
  /// Width of the size.
  var width: Double
  /// Height of the size.
  var height: Double

  static func fromList(_ list: [Any?]) -> Size? {
    let width = list[0] as! Double
    let height = list[1] as! Double

    return Size(
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
    ]
  }
}

/// Options for querying rendered features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RenderedQueryOptions {
  /// Layer IDs to include in the query.
  var layerIds: [String?]?
  /// Filters the returned features with an expression
  var filter: String?

  static func fromList(_ list: [Any?]) -> RenderedQueryOptions? {
    let layerIds: [String?]? = nilOrValue(list[0])
    let filter: String? = nilOrValue(list[1])

    return RenderedQueryOptions(
      layerIds: layerIds,
      filter: filter
    )
  }
  func toList() -> [Any?] {
    return [
      layerIds,
      filter,
    ]
  }
}

/// Options for querying source features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct SourceQueryOptions {
  /// Source layer IDs to include in the query.
  var sourceLayerIds: [String?]?
  /// Filters the returned features with an expression
  var filter: String

  static func fromList(_ list: [Any?]) -> SourceQueryOptions? {
    let sourceLayerIds: [String?]? = nilOrValue(list[0])
    let filter = list[1] as! String

    return SourceQueryOptions(
      sourceLayerIds: sourceLayerIds,
      filter: filter
    )
  }
  func toList() -> [Any?] {
    return [
      sourceLayerIds,
      filter,
    ]
  }
}

/// A value or a collection of a feature extension.
///
/// Generated class from Pigeon that represents data sent in messages.
struct FeatureExtensionValue {
  /// An optional value of a feature extension
  var value: String?
  /// An optional array of features from a feature extension.
  var featureCollection: [[String?: Any?]?]?

  static func fromList(_ list: [Any?]) -> FeatureExtensionValue? {
    let value: String? = nilOrValue(list[0])
    let featureCollection: [[String?: Any?]?]? = nilOrValue(list[1])

    return FeatureExtensionValue(
      value: value,
      featureCollection: featureCollection
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      featureCollection,
    ]
  }
}

/// Specifies position of a layer that is added via addStyleLayer method.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LayerPosition {
  /// Layer should be positioned above specified layer id.
  var above: String?
  /// Layer should be positioned below specified layer id.
  var below: String?
  /// Layer should be positioned at specified index in a layers stack.
  var at: Int64?

  static func fromList(_ list: [Any?]) -> LayerPosition? {
    let above: String? = nilOrValue(list[0])
    let below: String? = nilOrValue(list[1])
    let at: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))

    return LayerPosition(
      above: above,
      below: below,
      at: at
    )
  }
  func toList() -> [Any?] {
    return [
      above,
      below,
      at,
    ]
  }
}

/// Represents query result that is returned in QueryRenderedFeaturesCallback.
/// @see `queryRenderedFeatures`
///
/// Generated class from Pigeon that represents data sent in messages.
struct QueriedRenderedFeature {
  /// Feature returned by the query.
  var queriedFeature: QueriedFeature
  /// An array of layer Ids for the queried feature.
  /// If the feature has been rendered in multiple layers, multiple Ids will be provided.
  /// If the feature is only rendered in one layer, a single Id will be provided.
  var layers: [String?]

  static func fromList(_ list: [Any?]) -> QueriedRenderedFeature? {
    let queriedFeature = QueriedFeature.fromList(list[0] as! [Any?])!
    let layers = list[1] as! [String?]

    return QueriedRenderedFeature(
      queriedFeature: queriedFeature,
      layers: layers
    )
  }
  func toList() -> [Any?] {
    return [
      queriedFeature.toList(),
      layers,
    ]
  }
}

/// Represents query result that is returned in QuerySourceFeaturesCallback.
/// @see `querySourceFeatures`
///
/// Generated class from Pigeon that represents data sent in messages.
struct QueriedSourceFeature {
  /// Feature returned by the query.
  var queriedFeature: QueriedFeature

  static func fromList(_ list: [Any?]) -> QueriedSourceFeature? {
    let queriedFeature = QueriedFeature.fromList(list[0] as! [Any?])!

    return QueriedSourceFeature(
      queriedFeature: queriedFeature
    )
  }
  func toList() -> [Any?] {
    return [
      queriedFeature.toList()
    ]
  }
}

/// Represents query result that is returned in QueryFeaturesCallback.
/// @see `queryRenderedFeatures` or `querySourceFeatures`
///
/// Generated class from Pigeon that represents data sent in messages.
struct QueriedFeature {
  /// Feature returned by the query.
  var feature: [String?: Any?]
  /// Source id for a queried feature.
  var source: String
  /// Source layer id for a queried feature. May be null if source does not support layers, e.g., 'geojson' source,
  /// or when data provided by the source is not layered.
  var sourceLayer: String?
  /// Feature state for a queried feature. Type of the value is an Object.
  /// @see `setFeatureState` and `getFeatureState`
  var state: String

  static func fromList(_ list: [Any?]) -> QueriedFeature? {
    let feature = list[0] as! [String?: Any?]
    let source = list[1] as! String
    let sourceLayer: String? = nilOrValue(list[2])
    let state = list[3] as! String

    return QueriedFeature(
      feature: feature,
      source: source,
      sourceLayer: sourceLayer,
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      feature,
      source,
      sourceLayer,
      state,
    ]
  }
}

/// Geometry for querying rendered features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RenderedQueryGeometry {
  /// ScreenCoordinate/List<ScreenCoordinate>/ScreenBox in Json mode.
  var value: String
  var type: Type

  static func fromList(_ list: [Any?]) -> RenderedQueryGeometry? {
    let value = list[0] as! String
    let type = Type(rawValue: list[1] as! Int)!

    return RenderedQueryGeometry(
      value: value,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      type.rawValue,
    ]
  }
}

/// An offline region definition is a geographic region defined by a style URL,
/// a geometry, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be â‰¥ 0,
/// and `maxZoom` must be â‰¥ `minZoom`. The `maxZoom` may be âˆž, in which case for each tile source,
/// the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
/// The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
///
/// Generated class from Pigeon that represents data sent in messages.
struct OfflineRegionGeometryDefinition {
  /// The style associated with the offline region
  var styleURL: String
  /// The geometry that defines the boundary of the offline region
  var geometry: [String?: Any?]
  /// Minimum zoom level for the offline region
  var minZoom: Double
  /// Maximum zoom level for the offline region
  var maxZoom: Double
  /// Pixel ratio to be accounted for when downloading assets
  var pixelRatio: Double
  /// Specifies glyphs rasterization mode. It defines which glyphs will be loaded from the server
  var glyphsRasterizationMode: GlyphsRasterizationMode

  static func fromList(_ list: [Any?]) -> OfflineRegionGeometryDefinition? {
    let styleURL = list[0] as! String
    let geometry = list[1] as! [String?: Any?]
    let minZoom = list[2] as! Double
    let maxZoom = list[3] as! Double
    let pixelRatio = list[4] as! Double
    let glyphsRasterizationMode = GlyphsRasterizationMode(rawValue: list[5] as! Int)!

    return OfflineRegionGeometryDefinition(
      styleURL: styleURL,
      geometry: geometry,
      minZoom: minZoom,
      maxZoom: maxZoom,
      pixelRatio: pixelRatio,
      glyphsRasterizationMode: glyphsRasterizationMode
    )
  }
  func toList() -> [Any?] {
    return [
      styleURL,
      geometry,
      minZoom,
      maxZoom,
      pixelRatio,
      glyphsRasterizationMode.rawValue,
    ]
  }
}

/// An offline region definition is a geographic region defined by a style URL,
/// geographic bounding box, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be â‰¥ 0,
/// and `maxZoom` must be â‰¥ `minZoom`. The `maxZoom` may be âˆž, in which case for each tile source,
/// the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
/// The `pixelRatio` must be â‰¥ 0 and should typically be 1.0 or 2.0.
///
/// Generated class from Pigeon that represents data sent in messages.
struct OfflineRegionTilePyramidDefinition {
  /// The style associated with the offline region.
  var styleURL: String
  /// The bounds covering the region.
  var bounds: CoordinateBounds
  /// Minimum zoom level for the offline region.
  var minZoom: Double
  /// Maximum zoom level for the offline region.
  var maxZoom: Double
  /// Pixel ratio to be accounted for when downloading assets.
  var pixelRatio: Double
  /// Specifies glyphs download mode.
  var glyphsRasterizationMode: GlyphsRasterizationMode

  static func fromList(_ list: [Any?]) -> OfflineRegionTilePyramidDefinition? {
    let styleURL = list[0] as! String
    let bounds = CoordinateBounds.fromList(list[1] as! [Any?])!
    let minZoom = list[2] as! Double
    let maxZoom = list[3] as! Double
    let pixelRatio = list[4] as! Double
    let glyphsRasterizationMode = GlyphsRasterizationMode(rawValue: list[5] as! Int)!

    return OfflineRegionTilePyramidDefinition(
      styleURL: styleURL,
      bounds: bounds,
      minZoom: minZoom,
      maxZoom: maxZoom,
      pixelRatio: pixelRatio,
      glyphsRasterizationMode: glyphsRasterizationMode
    )
  }
  func toList() -> [Any?] {
    return [
      styleURL,
      bounds.toList(),
      minZoom,
      maxZoom,
      pixelRatio,
      glyphsRasterizationMode.rawValue,
    ]
  }
}

/// ProjectedMeters is a coordinate in a specific
/// [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection.
///
/// This specific Spherical Mercator projection assumes the Earth is a sphere with a radius
/// of 6,378,137 meters. Coordinates are determined as distances, in meters, on the surface
/// of that sphere.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ProjectedMeters {
  /// Projected meters in north direction.
  var northing: Double
  /// Projected meters in east direction.
  var easting: Double

  static func fromList(_ list: [Any?]) -> ProjectedMeters? {
    let northing = list[0] as! Double
    let easting = list[1] as! Double

    return ProjectedMeters(
      northing: northing,
      easting: easting
    )
  }
  func toList() -> [Any?] {
    return [
      northing,
      easting,
    ]
  }
}

/// Describes a point on the map in Mercator projection.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MercatorCoordinate {
  /// A value representing the x position of this coordinate.
  var x: Double
  /// A value representing the y position of this coordinate.
  var y: Double

  static func fromList(_ list: [Any?]) -> MercatorCoordinate? {
    let x = list[0] as! Double
    let y = list[1] as! Double

    return MercatorCoordinate(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

/// The information about style object (source or layer).
///
/// Generated class from Pigeon that represents data sent in messages.
struct StyleObjectInfo {
  /// The object's identifier.
  var id: String
  /// The object's type.
  var type: String

  static func fromList(_ list: [Any?]) -> StyleObjectInfo? {
    let id = list[0] as! String
    let type = list[1] as! String

    return StyleObjectInfo(
      id: id,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      type,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StyleProjection {
  var name: StyleProjectionName

  static func fromList(_ list: [Any?]) -> StyleProjection? {
    let name = StyleProjectionName(rawValue: list[0] as! Int)!

    return StyleProjection(
      name: name
    )
  }
  func toList() -> [Any?] {
    return [
      name.rawValue
    ]
  }
}

/// A global directional light source which is only applied on 3D layers and hillshade layers. Using this type disables other light sources.
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
///
/// Generated class from Pigeon that represents data sent in messages.
struct FlatLight {
  /// Unique light name
  var id: String
  /// Whether extruded geometries are lit relative to the map or viewport.
  var anchor: Anchor?
  /// Color tint for lighting extruded geometries.
  var color: Int64?
  /// Transition property for `color`
  var colorTransition: TransitionOptions?
  /// Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.
  var intensity: Double?
  /// Transition property for `intensity`
  var intensityTransition: TransitionOptions?
  /// Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0 degree (0 degree when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0 degree when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0 degree, directly above, to 180 degree, directly below).
  var position: [Double?]?
  /// Transition property for `position`
  var positionTransition: TransitionOptions?

  static func fromList(_ list: [Any?]) -> FlatLight? {
    let id = list[0] as! String
    var anchor: Anchor?
    let anchorEnumVal: Int? = nilOrValue(list[1])
    if let anchorRawValue = anchorEnumVal {
      anchor = Anchor(rawValue: anchorRawValue)!
    }
    let color: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    var colorTransition: TransitionOptions?
    if let colorTransitionList: [Any?] = nilOrValue(list[3]) {
      colorTransition = TransitionOptions.fromList(colorTransitionList)
    }
    let intensity: Double? = nilOrValue(list[4])
    var intensityTransition: TransitionOptions?
    if let intensityTransitionList: [Any?] = nilOrValue(list[5]) {
      intensityTransition = TransitionOptions.fromList(intensityTransitionList)
    }
    let position: [Double?]? = nilOrValue(list[6])
    var positionTransition: TransitionOptions?
    if let positionTransitionList: [Any?] = nilOrValue(list[7]) {
      positionTransition = TransitionOptions.fromList(positionTransitionList)
    }

    return FlatLight(
      id: id,
      anchor: anchor,
      color: color,
      colorTransition: colorTransition,
      intensity: intensity,
      intensityTransition: intensityTransition,
      position: position,
      positionTransition: positionTransition
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      anchor?.rawValue,
      color,
      colorTransition?.toList(),
      intensity,
      intensityTransition?.toList(),
      position,
      positionTransition?.toList(),
    ]
  }
}

/// A light that has a direction and is located at infinite, so its rays are parallel. Simulates the sun light and it can cast shadows
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
///
/// Generated class from Pigeon that represents data sent in messages.
struct DirectionalLight {
  /// Unique light name
  var id: String
  /// Enable/Disable shadow casting for this light
  var castShadows: Bool?
  /// Color of the directional light.
  var color: Int64?
  /// Transition property for `color`
  var colorTransition: TransitionOptions?
  /// Direction of the light source specified as [a azimuthal angle, p polar angle] where a indicates the azimuthal angle of the light relative to north (in degrees and proceeding clockwise), and p indicates polar angle of the light (from 0 degree, directly above, to 180 degree, directly below).
  var direction: [Double?]?
  /// Transition property for `direction`
  var directionTransition: TransitionOptions?
  /// A multiplier for the color of the directional light.
  var intensity: Double?
  /// Transition property for `intensity`
  var intensityTransition: TransitionOptions?
  /// Determines the shadow strength, affecting the shadow receiver surfaces final color. Values near 0.0 reduce the shadow contribution to the final color. Values near to 1.0 make occluded surfaces receive almost no directional light. Designed to be used mostly for transitioning between values 0 and 1.
  var shadowIntensity: Double?
  /// Transition property for `shadowIntensity`
  var shadowIntensityTransition: TransitionOptions?

  static func fromList(_ list: [Any?]) -> DirectionalLight? {
    let id = list[0] as! String
    let castShadows: Bool? = nilOrValue(list[1])
    let color: Int64? = isNullish(list[2]) ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    var colorTransition: TransitionOptions?
    if let colorTransitionList: [Any?] = nilOrValue(list[3]) {
      colorTransition = TransitionOptions.fromList(colorTransitionList)
    }
    let direction: [Double?]? = nilOrValue(list[4])
    var directionTransition: TransitionOptions?
    if let directionTransitionList: [Any?] = nilOrValue(list[5]) {
      directionTransition = TransitionOptions.fromList(directionTransitionList)
    }
    let intensity: Double? = nilOrValue(list[6])
    var intensityTransition: TransitionOptions?
    if let intensityTransitionList: [Any?] = nilOrValue(list[7]) {
      intensityTransition = TransitionOptions.fromList(intensityTransitionList)
    }
    let shadowIntensity: Double? = nilOrValue(list[8])
    var shadowIntensityTransition: TransitionOptions?
    if let shadowIntensityTransitionList: [Any?] = nilOrValue(list[9]) {
      shadowIntensityTransition = TransitionOptions.fromList(shadowIntensityTransitionList)
    }

    return DirectionalLight(
      id: id,
      castShadows: castShadows,
      color: color,
      colorTransition: colorTransition,
      direction: direction,
      directionTransition: directionTransition,
      intensity: intensity,
      intensityTransition: intensityTransition,
      shadowIntensity: shadowIntensity,
      shadowIntensityTransition: shadowIntensityTransition
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      castShadows,
      color,
      colorTransition?.toList(),
      direction,
      directionTransition?.toList(),
      intensity,
      intensityTransition?.toList(),
      shadowIntensity,
      shadowIntensityTransition?.toList(),
    ]
  }
}

/// An indirect light affecting all objects in the map adding a constant amount of light on them. It has no explicit direction and cannot cast shadows.
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
///
/// Generated class from Pigeon that represents data sent in messages.
struct AmbientLight {
  /// Unique light name
  var id: String
  /// Color of the ambient light.
  var color: Int64?
  /// Transition property for `color`
  var colorTransition: TransitionOptions?
  /// A multiplier for the color of the ambient light.
  var intensity: Double?
  /// Transition property for `intensity`
  var intensityTransition: TransitionOptions?

  static func fromList(_ list: [Any?]) -> AmbientLight? {
    let id = list[0] as! String
    let color: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    var colorTransition: TransitionOptions?
    if let colorTransitionList: [Any?] = nilOrValue(list[2]) {
      colorTransition = TransitionOptions.fromList(colorTransitionList)
    }
    let intensity: Double? = nilOrValue(list[3])
    var intensityTransition: TransitionOptions?
    if let intensityTransitionList: [Any?] = nilOrValue(list[4]) {
      intensityTransition = TransitionOptions.fromList(intensityTransitionList)
    }

    return AmbientLight(
      id: id,
      color: color,
      colorTransition: colorTransition,
      intensity: intensity,
      intensityTransition: intensityTransition
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      color,
      colorTransition?.toList(),
      intensity,
      intensityTransition?.toList(),
    ]
  }
}

/// Image type.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MbxImage {
  /// The width of the image, in screen pixels.
  var width: Int64
  /// The height of the image, in screen pixels.
  var height: Int64
  /// 32-bit premultiplied RGBA image data.
  ///
  /// An uncompressed image data encoded in 32-bit RGBA format with premultiplied
  /// alpha channel. This field should contain exactly `4 * width * height` bytes. It
  /// should consist of a sequence of scanlines.
  var data: FlutterStandardTypedData

  static func fromList(_ list: [Any?]) -> MbxImage? {
    let width = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let height = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let data = list[2] as! FlutterStandardTypedData

    return MbxImage(
      width: width,
      height: height,
      data: data
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
      data,
    ]
  }
}

/// Describes the image stretch areas.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ImageStretches {
  /// The first stretchable part in screen pixel units.
  var first: Double
  /// The second stretchable part in screen pixel units.
  var second: Double

  static func fromList(_ list: [Any?]) -> ImageStretches? {
    let first = list[0] as! Double
    let second = list[1] as! Double

    return ImageStretches(
      first: first,
      second: second
    )
  }
  func toList() -> [Any?] {
    return [
      first,
      second,
    ]
  }
}

/// Describes the image content, e.g. where text can be fit into an image.
///
/// When sizing icons with `icon-text-fit`, the icon size will be adjusted so that the this content box fits exactly around the text.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ImageContent {
  /// Distance to the left, in screen pixels.
  var left: Double
  /// Distance to the top, in screen pixels.
  var top: Double
  /// Distance to the right, in screen pixels.
  var right: Double
  /// Distance to the bottom, in screen pixels.
  var bottom: Double

  static func fromList(_ list: [Any?]) -> ImageContent? {
    let left = list[0] as! Double
    let top = list[1] as! Double
    let right = list[2] as! Double
    let bottom = list[3] as! Double

    return ImageContent(
      left: left,
      top: top,
      right: right,
      bottom: bottom
    )
  }
  func toList() -> [Any?] {
    return [
      left,
      top,
      right,
      bottom,
    ]
  }
}

/// The `transition options` controls timing for the interpolation between a transitionable style
/// property's previous value and new value. These can be used to define the style default property
/// transition behavior. Also, any transitionable style property may also have its own `-transition`
/// property that defines specific transition timing for that specific layer property, overriding
/// the global transition values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TransitionOptions {
  /// Time allotted for transitions to complete. Units in milliseconds. Defaults to `300.0`.
  var duration: Int64?
  /// Length of time before a transition begins. Units in milliseconds. Defaults to `0.0`.
  var delay: Int64?
  /// Whether the fade in/out symbol placement transition is enabled. Defaults to `true`.
  var enablePlacementTransitions: Bool?

  static func fromList(_ list: [Any?]) -> TransitionOptions? {
    let duration: Int64? = isNullish(list[0]) ? nil : (list[0] is Int64? ? list[0] as! Int64? : Int64(list[0] as! Int32))
    let delay: Int64? = isNullish(list[1]) ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let enablePlacementTransitions: Bool? = nilOrValue(list[2])

    return TransitionOptions(
      duration: duration,
      delay: delay,
      enablePlacementTransitions: enablePlacementTransitions
    )
  }
  func toList() -> [Any?] {
    return [
      duration,
      delay,
      enablePlacementTransitions,
    ]
  }
}

/// Represents a tile coordinate.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CanonicalTileID {
  /// The z value of the coordinate (zoom-level).
  var z: Int64
  /// The x value of the coordinate.
  var x: Int64
  /// The y value of the coordinate.
  var y: Int64

  static func fromList(_ list: [Any?]) -> CanonicalTileID? {
    let z = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let x = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let y = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)

    return CanonicalTileID(
      z: z,
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      z,
      x,
      y,
    ]
  }
}

/// Holds a style property value with meta data.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePropertyValue {
  /// The property value.
  var value: Any?
  /// The kind of the property value.
  var kind: StylePropertyValueKind

  static func fromList(_ list: [Any?]) -> StylePropertyValue? {
    let value: Any? = list[0]
    let kind = StylePropertyValueKind(rawValue: list[1] as! Int)!

    return StylePropertyValue(
      value: value,
      kind: kind
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      kind.rawValue,
    ]
  }
}
private class _AnimationManagerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CameraOptions.fromList(self.readValue() as! [Any?])
    case 129:
      return MapAnimationOptions.fromList(self.readValue() as! [Any?])
    case 130:
      return MbxEdgeInsets.fromList(self.readValue() as! [Any?])
    case 131:
      return Point.fromList(self.readValue() as! [Any?])
    case 132:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 133:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _AnimationManagerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CameraOptions {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? MapAnimationOptions {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? MbxEdgeInsets {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _AnimationManagerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _AnimationManagerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _AnimationManagerCodecWriter(data: data)
  }
}

class _AnimationManagerCodec: FlutterStandardMessageCodec {
  static let shared = _AnimationManagerCodec(readerWriter: _AnimationManagerCodecReaderWriter())
}

/// Interface for managing animation.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _AnimationManager {
  func easeTo(cameraOptions: CameraOptions, mapAnimationOptions: MapAnimationOptions?) throws
  func flyTo(cameraOptions: CameraOptions, mapAnimationOptions: MapAnimationOptions?) throws
  func pitchBy(pitch: Double, mapAnimationOptions: MapAnimationOptions?) throws
  func scaleBy(amount: Double, screenCoordinate: ScreenCoordinate?, mapAnimationOptions: MapAnimationOptions?) throws
  func moveBy(screenCoordinate: ScreenCoordinate, mapAnimationOptions: MapAnimationOptions?) throws
  func rotateBy(first: ScreenCoordinate, second: ScreenCoordinate, mapAnimationOptions: MapAnimationOptions?) throws
  func cancelCameraAnimation() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _AnimationManagerSetup {
  /// The codec used by _AnimationManager.
  static var codec: FlutterStandardMessageCodec { _AnimationManagerCodec.shared }
  /// Sets up an instance of `_AnimationManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _AnimationManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let easeToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      easeToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraOptionsArg = args[0] as! CameraOptions
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.easeTo(cameraOptions: cameraOptionsArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      easeToChannel.setMessageHandler(nil)
    }
    let flyToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      flyToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraOptionsArg = args[0] as! CameraOptions
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.flyTo(cameraOptions: cameraOptionsArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      flyToChannel.setMessageHandler(nil)
    }
    let pitchByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pitchByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pitchArg = args[0] as! Double
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.pitchBy(pitch: pitchArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pitchByChannel.setMessageHandler(nil)
    }
    let scaleByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      scaleByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let amountArg = args[0] as! Double
        let screenCoordinateArg: ScreenCoordinate? = nilOrValue(args[1])
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[2])
        do {
          try api.scaleBy(amount: amountArg, screenCoordinate: screenCoordinateArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      scaleByChannel.setMessageHandler(nil)
    }
    let moveByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      moveByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let screenCoordinateArg = args[0] as! ScreenCoordinate
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.moveBy(screenCoordinate: screenCoordinateArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveByChannel.setMessageHandler(nil)
    }
    let rotateByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      rotateByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let firstArg = args[0] as! ScreenCoordinate
        let secondArg = args[1] as! ScreenCoordinate
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[2])
        do {
          try api.rotateBy(first: firstArg, second: secondArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      rotateByChannel.setMessageHandler(nil)
    }
    let cancelCameraAnimationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelCameraAnimationChannel.setMessageHandler { _, reply in
        do {
          try api.cancelCameraAnimation()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelCameraAnimationChannel.setMessageHandler(nil)
    }
  }
}
private class _CameraManagerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AmbientLight.fromList(self.readValue() as! [Any?])
    case 129:
      return CameraBounds.fromList(self.readValue() as! [Any?])
    case 130:
      return CameraBoundsOptions.fromList(self.readValue() as! [Any?])
    case 131:
      return CameraOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return CameraState.fromList(self.readValue() as! [Any?])
    case 133:
      return CanonicalTileID.fromList(self.readValue() as! [Any?])
    case 134:
      return CoordinateBounds.fromList(self.readValue() as! [Any?])
    case 135:
      return CoordinateBoundsZoom.fromList(self.readValue() as! [Any?])
    case 136:
      return DirectionalLight.fromList(self.readValue() as! [Any?])
    case 137:
      return FeatureExtensionValue.fromList(self.readValue() as! [Any?])
    case 138:
      return FlatLight.fromList(self.readValue() as! [Any?])
    case 139:
      return GlyphsRasterizationOptions.fromList(self.readValue() as! [Any?])
    case 140:
      return ImageContent.fromList(self.readValue() as! [Any?])
    case 141:
      return ImageStretches.fromList(self.readValue() as! [Any?])
    case 142:
      return LayerPosition.fromList(self.readValue() as! [Any?])
    case 143:
      return MapAnimationOptions.fromList(self.readValue() as! [Any?])
    case 144:
      return MapDebugOptions.fromList(self.readValue() as! [Any?])
    case 145:
      return MapOptions.fromList(self.readValue() as! [Any?])
    case 146:
      return MbxEdgeInsets.fromList(self.readValue() as! [Any?])
    case 147:
      return MbxImage.fromList(self.readValue() as! [Any?])
    case 148:
      return MercatorCoordinate.fromList(self.readValue() as! [Any?])
    case 149:
      return OfflineRegionGeometryDefinition.fromList(self.readValue() as! [Any?])
    case 150:
      return OfflineRegionTilePyramidDefinition.fromList(self.readValue() as! [Any?])
    case 151:
      return Point.fromList(self.readValue() as! [Any?])
    case 152:
      return ProjectedMeters.fromList(self.readValue() as! [Any?])
    case 153:
      return QueriedFeature.fromList(self.readValue() as! [Any?])
    case 154:
      return QueriedRenderedFeature.fromList(self.readValue() as! [Any?])
    case 155:
      return QueriedSourceFeature.fromList(self.readValue() as! [Any?])
    case 156:
      return RenderedQueryGeometry.fromList(self.readValue() as! [Any?])
    case 157:
      return RenderedQueryOptions.fromList(self.readValue() as! [Any?])
    case 158:
      return ScreenBox.fromList(self.readValue() as! [Any?])
    case 159:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 160:
      return Size.fromList(self.readValue() as! [Any?])
    case 161:
      return SourceQueryOptions.fromList(self.readValue() as! [Any?])
    case 162:
      return StyleObjectInfo.fromList(self.readValue() as! [Any?])
    case 163:
      return StyleProjection.fromList(self.readValue() as! [Any?])
    case 164:
      return StylePropertyValue.fromList(self.readValue() as! [Any?])
    case 165:
      return TileCacheBudgetInMegabytes.fromList(self.readValue() as! [Any?])
    case 166:
      return TileCacheBudgetInTiles.fromList(self.readValue() as! [Any?])
    case 167:
      return TileCoverOptions.fromList(self.readValue() as! [Any?])
    case 168:
      return TransitionOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _CameraManagerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AmbientLight {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBounds {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBoundsOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? CameraOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? CameraState {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? CanonicalTileID {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBounds {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBoundsZoom {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? DirectionalLight {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? FeatureExtensionValue {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? FlatLight {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? GlyphsRasterizationOptions {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? ImageContent {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? ImageStretches {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? LayerPosition {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? MapAnimationOptions {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? MapDebugOptions {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? MapOptions {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? MbxEdgeInsets {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? MbxImage {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? MercatorCoordinate {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionGeometryDefinition {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionTilePyramidDefinition {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? ProjectedMeters {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedFeature {
      super.writeByte(153)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedRenderedFeature {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedSourceFeature {
      super.writeByte(155)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryGeometry {
      super.writeByte(156)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryOptions {
      super.writeByte(157)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenBox {
      super.writeByte(158)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(159)
      super.writeValue(value.toList())
    } else if let value = value as? Size {
      super.writeByte(160)
      super.writeValue(value.toList())
    } else if let value = value as? SourceQueryOptions {
      super.writeByte(161)
      super.writeValue(value.toList())
    } else if let value = value as? StyleObjectInfo {
      super.writeByte(162)
      super.writeValue(value.toList())
    } else if let value = value as? StyleProjection {
      super.writeByte(163)
      super.writeValue(value.toList())
    } else if let value = value as? StylePropertyValue {
      super.writeByte(164)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInMegabytes {
      super.writeByte(165)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInTiles {
      super.writeByte(166)
      super.writeValue(value.toList())
    } else if let value = value as? TileCoverOptions {
      super.writeByte(167)
      super.writeValue(value.toList())
    } else if let value = value as? TransitionOptions {
      super.writeByte(168)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _CameraManagerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _CameraManagerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _CameraManagerCodecWriter(data: data)
  }
}

class _CameraManagerCodec: FlutterStandardMessageCodec {
  static let shared = _CameraManagerCodec(readerWriter: _CameraManagerCodecReaderWriter())
}

/// Interface for managing camera.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _CameraManager {
  /// Convenience method that returns a `camera options` object for the given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
  /// If any of the fields in camera options is not provided then the current value from the map for that field will be used.
  /// @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
  /// This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  func cameraForCoordinatesPadding(coordinates: [Point], camera: CameraOptions, coordinatesPadding: MbxEdgeInsets?, maxZoom: Double?, offset: ScreenCoordinate?) throws -> CameraOptions
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param bounds The `coordinate bounds` of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  func cameraForCoordinateBounds(bounds: CoordinateBounds, padding: MbxEdgeInsets?, bearing: Double?, pitch: Double?, maxZoom: Double?, offset: ScreenCoordinate?) throws -> CameraOptions
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  func cameraForCoordinates(coordinates: [Point], padding: MbxEdgeInsets?, bearing: Double?, pitch: Double?) throws -> CameraOptions
  /// Convenience method that adjusts the provided `camera options` object for given parameters.
  ///
  /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
  /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
  /// Returns the provided `camera` options object unchanged upon an error.
  /// Note that this method may fail if the principal point of the projection is not inside the `box` or
  /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
  /// @param box The `screen box` into which `coordinates` should fit.
  ///
  /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
  func cameraForCoordinatesCameraOptions(coordinates: [Point], camera: CameraOptions, box: ScreenBox) throws -> CameraOptions
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param geometry The `geometry` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  func cameraForGeometry(geometry: [String?: Any?], padding: MbxEdgeInsets, bearing: Double?, pitch: Double?) throws -> CameraOptions
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  func coordinateBoundsForCamera(camera: CameraOptions) throws -> CoordinateBounds
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  func coordinateBoundsForCameraUnwrapped(camera: CameraOptions) throws -> CoordinateBounds
  /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  func coordinateBoundsZoomForCamera(camera: CameraOptions) throws -> CoordinateBoundsZoom
  /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  func coordinateBoundsZoomForCameraUnwrapped(camera: CameraOptions) throws -> CoordinateBoundsZoom
  /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
  /// (i.e., longitude-latitude pair).
  ///
  /// The `screen coordinate` is in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
  ///
  /// @return A `screen coordinate` on the screen in `logical pixels`.
  func pixelForCoordinate(coordinate: Point) throws -> ScreenCoordinate
  /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
  /// to a `screen coordinate`.
  ///
  /// The screen coordinate is in `logical pixels`relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
  ///
  /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
  func coordinateForPixel(pixel: ScreenCoordinate) throws -> Point
  /// Calculates `screen coordinates` that correspond to geographical `coordinates`
  /// (i.e., longitude-latitude pairs).
  ///
  /// The `screen coordinates` are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
  ///
  /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
  func pixelsForCoordinates(coordinates: [Point]) throws -> [ScreenCoordinate?]
  /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
  /// to `screen coordinates`.
  ///
  /// The screen coordinates are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixels A `screen coordinates` in `logical pixels`.
  ///
  /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
  func coordinatesForPixels(pixels: [ScreenCoordinate?]) throws -> [Point]
  /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
  /// The map will retain its current values for any details not passed via the camera options argument.
  /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
  /// different `camera state`.
  ///
  /// @param cameraOptions The new `camera options` to be set.
  func setCamera(cameraOptions: CameraOptions) throws
  /// Returns the current `camera state`.
  ///
  /// @return The current `camera state`.
  func getCameraState() throws -> CameraState
  /// Sets the `camera bounds options` of the map. The map will retain its current values for any
  /// details not passed via the camera bounds options arguments.
  /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
  /// zoom level of the camera, to prevent out of bounds areas to be visible.
  /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
  ///
  /// @param options The `camera bounds options` to set.
  /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
  func setBounds(options: CameraBoundsOptions) throws
  /// Returns the `camera bounds` of the map.
  /// @return A `camera bounds` of the map.
  func getBounds() throws -> CameraBounds
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _CameraManagerSetup {
  /// The codec used by _CameraManager.
  static var codec: FlutterStandardMessageCodec { _CameraManagerCodec.shared }
  /// Sets up an instance of `_CameraManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _CameraManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Convenience method that returns a `camera options` object for the given parameters.
    ///
    /// @param coordinates The `coordinates` representing the bounds of the camera.
    /// @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
    /// If any of the fields in camera options is not provided then the current value from the map for that field will be used.
    /// @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
    /// This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
    /// @param maxZoom The maximum zoom level allowed in the returned camera options.
    /// @param offset The center of the given bounds relative to map center in screen points.
    /// @return The `camera options` object representing the provided parameters.
    let cameraForCoordinatesPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinatesPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        let cameraArg = args[1] as! CameraOptions
        let coordinatesPaddingArg: MbxEdgeInsets? = nilOrValue(args[2])
        let maxZoomArg: Double? = nilOrValue(args[3])
        let offsetArg: ScreenCoordinate? = nilOrValue(args[4])
        do {
          let result = try api.cameraForCoordinatesPadding(coordinates: coordinatesArg, camera: cameraArg, coordinatesPadding: coordinatesPaddingArg, maxZoom: maxZoomArg, offset: offsetArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinatesPaddingChannel.setMessageHandler(nil)
    }
    /// Convenience method that returns the `camera options` object for given parameters.
    ///
    /// @param bounds The `coordinate bounds` of the camera.
    /// @param padding The `edge insets` of the camera.
    /// @param bearing The bearing of the camera.
    /// @param pitch The pitch of the camera.
    /// @param maxZoom The maximum zoom level allowed in the returned camera options.
    /// @param offset The center of the given bounds relative to map center in screen points.
    /// @return The `camera options` object representing the provided parameters.
    let cameraForCoordinateBoundsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinateBoundsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let boundsArg = args[0] as! CoordinateBounds
        let paddingArg: MbxEdgeInsets? = nilOrValue(args[1])
        let bearingArg: Double? = nilOrValue(args[2])
        let pitchArg: Double? = nilOrValue(args[3])
        let maxZoomArg: Double? = nilOrValue(args[4])
        let offsetArg: ScreenCoordinate? = nilOrValue(args[5])
        do {
          let result = try api.cameraForCoordinateBounds(bounds: boundsArg, padding: paddingArg, bearing: bearingArg, pitch: pitchArg, maxZoom: maxZoomArg, offset: offsetArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinateBoundsChannel.setMessageHandler(nil)
    }
    /// Convenience method that returns the `camera options` object for given parameters.
    ///
    /// @param coordinates The `coordinates` representing the bounds of the camera.
    /// @param padding The `edge insets` of the camera.
    /// @param bearing The bearing of the camera.
    /// @param pitch The pitch of the camera.
    ///
    /// @return The `camera options` object representing the provided parameters.
    let cameraForCoordinatesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinatesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        let paddingArg: MbxEdgeInsets? = nilOrValue(args[1])
        let bearingArg: Double? = nilOrValue(args[2])
        let pitchArg: Double? = nilOrValue(args[3])
        do {
          let result = try api.cameraForCoordinates(coordinates: coordinatesArg, padding: paddingArg, bearing: bearingArg, pitch: pitchArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinatesChannel.setMessageHandler(nil)
    }
    /// Convenience method that adjusts the provided `camera options` object for given parameters.
    ///
    /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
    /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
    /// Returns the provided `camera` options object unchanged upon an error.
    /// Note that this method may fail if the principal point of the projection is not inside the `box` or
    /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
    ///
    /// @param coordinates The `coordinates` representing the bounds of the camera.
    /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
    /// @param box The `screen box` into which `coordinates` should fit.
    ///
    /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
    let cameraForCoordinatesCameraOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinatesCameraOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        let cameraArg = args[1] as! CameraOptions
        let boxArg = args[2] as! ScreenBox
        do {
          let result = try api.cameraForCoordinatesCameraOptions(coordinates: coordinatesArg, camera: cameraArg, box: boxArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinatesCameraOptionsChannel.setMessageHandler(nil)
    }
    /// Convenience method that returns the `camera options` object for given parameters.
    ///
    /// @param geometry The `geometry` representing the bounds of the camera.
    /// @param padding The `edge insets` of the camera.
    /// @param bearing The bearing of the camera.
    /// @param pitch The pitch of the camera.
    ///
    /// @return The `camera options` object representing the provided parameters.
    let cameraForGeometryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForGeometryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let geometryArg = args[0] as! [String?: Any?]
        let paddingArg = args[1] as! MbxEdgeInsets
        let bearingArg: Double? = nilOrValue(args[2])
        let pitchArg: Double? = nilOrValue(args[3])
        do {
          let result = try api.cameraForGeometry(geometry: geometryArg, padding: paddingArg, bearing: bearingArg, pitch: pitchArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForGeometryChannel.setMessageHandler(nil)
    }
    /// Returns the `coordinate bounds` for a given camera.
    ///
    /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
    /// might not represent the minimum bounding box.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds`.
    ///
    /// @return The `coordinate bounds` object representing a given `camera`.
    ///
    let coordinateBoundsForCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsForCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsForCamera(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsForCameraChannel.setMessageHandler(nil)
    }
    /// Returns the `coordinate bounds` for a given camera.
    ///
    /// This method is useful if the `camera` shows the antimeridian.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds`.
    ///
    /// @return The `coordinate bounds` object representing a given `camera`.
    ///
    let coordinateBoundsForCameraUnwrappedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsForCameraUnwrappedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsForCameraUnwrapped(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsForCameraUnwrappedChannel.setMessageHandler(nil)
    }
    /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
    ///
    /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
    /// might not represent the minimum bounding box.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
    ///
    /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
    ///
    let coordinateBoundsZoomForCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsZoomForCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsZoomForCamera(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsZoomForCameraChannel.setMessageHandler(nil)
    }
    /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
    ///
    /// This method is useful if the `camera` shows the antimeridian.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
    ///
    /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
    ///
    let coordinateBoundsZoomForCameraUnwrappedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsZoomForCameraUnwrappedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsZoomForCameraUnwrapped(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsZoomForCameraUnwrappedChannel.setMessageHandler(nil)
    }
    /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
    /// (i.e., longitude-latitude pair).
    ///
    /// The `screen coordinate` is in `logical pixels` relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
    ///
    /// @return A `screen coordinate` on the screen in `logical pixels`.
    let pixelForCoordinateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pixelForCoordinateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        do {
          let result = try api.pixelForCoordinate(coordinate: coordinateArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pixelForCoordinateChannel.setMessageHandler(nil)
    }
    /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
    /// to a `screen coordinate`.
    ///
    /// The screen coordinate is in `logical pixels`relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
    ///
    /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
    let coordinateForPixelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateForPixelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pixelArg = args[0] as! ScreenCoordinate
        do {
          let result = try api.coordinateForPixel(pixel: pixelArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateForPixelChannel.setMessageHandler(nil)
    }
    /// Calculates `screen coordinates` that correspond to geographical `coordinates`
    /// (i.e., longitude-latitude pairs).
    ///
    /// The `screen coordinates` are in `logical pixels` relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
    ///
    /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
    let pixelsForCoordinatesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pixelsForCoordinatesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        do {
          let result = try api.pixelsForCoordinates(coordinates: coordinatesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pixelsForCoordinatesChannel.setMessageHandler(nil)
    }
    /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
    /// to `screen coordinates`.
    ///
    /// The screen coordinates are in `logical pixels` relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param pixels A `screen coordinates` in `logical pixels`.
    ///
    /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
    let coordinatesForPixelsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinatesForPixelsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pixelsArg = args[0] as! [ScreenCoordinate?]
        do {
          let result = try api.coordinatesForPixels(pixels: pixelsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinatesForPixelsChannel.setMessageHandler(nil)
    }
    /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
    /// The map will retain its current values for any details not passed via the camera options argument.
    /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
    /// different `camera state`.
    ///
    /// @param cameraOptions The new `camera options` to be set.
    let setCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraOptionsArg = args[0] as! CameraOptions
        do {
          try api.setCamera(cameraOptions: cameraOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCameraChannel.setMessageHandler(nil)
    }
    /// Returns the current `camera state`.
    ///
    /// @return The current `camera state`.
    let getCameraStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraStateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCameraState()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraStateChannel.setMessageHandler(nil)
    }
    /// Sets the `camera bounds options` of the map. The map will retain its current values for any
    /// details not passed via the camera bounds options arguments.
    /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
    /// zoom level of the camera, to prevent out of bounds areas to be visible.
    /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
    ///
    /// @param options The `camera bounds options` to set.
    /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
    let setBoundsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setBoundsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! CameraBoundsOptions
        do {
          try api.setBounds(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setBoundsChannel.setMessageHandler(nil)
    }
    /// Returns the `camera bounds` of the map.
    /// @return A `camera bounds` of the map.
    let getBoundsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBoundsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getBounds()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBoundsChannel.setMessageHandler(nil)
    }
  }
}
private class _MapInterfaceCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AmbientLight.fromList(self.readValue() as! [Any?])
    case 129:
      return CameraBounds.fromList(self.readValue() as! [Any?])
    case 130:
      return CameraBoundsOptions.fromList(self.readValue() as! [Any?])
    case 131:
      return CameraOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return CameraState.fromList(self.readValue() as! [Any?])
    case 133:
      return CanonicalTileID.fromList(self.readValue() as! [Any?])
    case 134:
      return CoordinateBounds.fromList(self.readValue() as! [Any?])
    case 135:
      return CoordinateBoundsZoom.fromList(self.readValue() as! [Any?])
    case 136:
      return DirectionalLight.fromList(self.readValue() as! [Any?])
    case 137:
      return FeatureExtensionValue.fromList(self.readValue() as! [Any?])
    case 138:
      return FlatLight.fromList(self.readValue() as! [Any?])
    case 139:
      return GlyphsRasterizationOptions.fromList(self.readValue() as! [Any?])
    case 140:
      return ImageContent.fromList(self.readValue() as! [Any?])
    case 141:
      return ImageStretches.fromList(self.readValue() as! [Any?])
    case 142:
      return LayerPosition.fromList(self.readValue() as! [Any?])
    case 143:
      return MapAnimationOptions.fromList(self.readValue() as! [Any?])
    case 144:
      return MapDebugOptions.fromList(self.readValue() as! [Any?])
    case 145:
      return MapOptions.fromList(self.readValue() as! [Any?])
    case 146:
      return MbxEdgeInsets.fromList(self.readValue() as! [Any?])
    case 147:
      return MbxImage.fromList(self.readValue() as! [Any?])
    case 148:
      return MercatorCoordinate.fromList(self.readValue() as! [Any?])
    case 149:
      return OfflineRegionGeometryDefinition.fromList(self.readValue() as! [Any?])
    case 150:
      return OfflineRegionTilePyramidDefinition.fromList(self.readValue() as! [Any?])
    case 151:
      return Point.fromList(self.readValue() as! [Any?])
    case 152:
      return ProjectedMeters.fromList(self.readValue() as! [Any?])
    case 153:
      return QueriedFeature.fromList(self.readValue() as! [Any?])
    case 154:
      return QueriedRenderedFeature.fromList(self.readValue() as! [Any?])
    case 155:
      return QueriedSourceFeature.fromList(self.readValue() as! [Any?])
    case 156:
      return RenderedQueryGeometry.fromList(self.readValue() as! [Any?])
    case 157:
      return RenderedQueryOptions.fromList(self.readValue() as! [Any?])
    case 158:
      return ScreenBox.fromList(self.readValue() as! [Any?])
    case 159:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 160:
      return Size.fromList(self.readValue() as! [Any?])
    case 161:
      return SourceQueryOptions.fromList(self.readValue() as! [Any?])
    case 162:
      return StyleObjectInfo.fromList(self.readValue() as! [Any?])
    case 163:
      return StyleProjection.fromList(self.readValue() as! [Any?])
    case 164:
      return StylePropertyValue.fromList(self.readValue() as! [Any?])
    case 165:
      return TileCacheBudgetInMegabytes.fromList(self.readValue() as! [Any?])
    case 166:
      return TileCacheBudgetInTiles.fromList(self.readValue() as! [Any?])
    case 167:
      return TileCoverOptions.fromList(self.readValue() as! [Any?])
    case 168:
      return TransitionOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _MapInterfaceCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AmbientLight {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBounds {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBoundsOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? CameraOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? CameraState {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? CanonicalTileID {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBounds {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBoundsZoom {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? DirectionalLight {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? FeatureExtensionValue {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? FlatLight {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? GlyphsRasterizationOptions {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? ImageContent {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? ImageStretches {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? LayerPosition {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? MapAnimationOptions {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? MapDebugOptions {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? MapOptions {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? MbxEdgeInsets {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? MbxImage {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? MercatorCoordinate {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionGeometryDefinition {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionTilePyramidDefinition {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? ProjectedMeters {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedFeature {
      super.writeByte(153)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedRenderedFeature {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedSourceFeature {
      super.writeByte(155)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryGeometry {
      super.writeByte(156)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryOptions {
      super.writeByte(157)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenBox {
      super.writeByte(158)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(159)
      super.writeValue(value.toList())
    } else if let value = value as? Size {
      super.writeByte(160)
      super.writeValue(value.toList())
    } else if let value = value as? SourceQueryOptions {
      super.writeByte(161)
      super.writeValue(value.toList())
    } else if let value = value as? StyleObjectInfo {
      super.writeByte(162)
      super.writeValue(value.toList())
    } else if let value = value as? StyleProjection {
      super.writeByte(163)
      super.writeValue(value.toList())
    } else if let value = value as? StylePropertyValue {
      super.writeByte(164)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInMegabytes {
      super.writeByte(165)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInTiles {
      super.writeByte(166)
      super.writeValue(value.toList())
    } else if let value = value as? TileCoverOptions {
      super.writeByte(167)
      super.writeValue(value.toList())
    } else if let value = value as? TransitionOptions {
      super.writeByte(168)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _MapInterfaceCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _MapInterfaceCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _MapInterfaceCodecWriter(data: data)
  }
}

class _MapInterfaceCodec: FlutterStandardMessageCodec {
  static let shared = _MapInterfaceCodec(readerWriter: _MapInterfaceCodecReaderWriter())
}

/// Map class provides map rendering functionality.
///
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapInterface {
  func loadStyleURI(styleURI: String, completion: @escaping (Result<Void, Error>) -> Void)
  func loadStyleJson(styleJson: String, completion: @escaping (Result<Void, Error>) -> Void)
  func clearData(completion: @escaping (Result<Void, Error>) -> Void)
  func setTileCacheBudget(tileCacheBudgetInMegabytes: TileCacheBudgetInMegabytes?, tileCacheBudgetInTiles: TileCacheBudgetInTiles?) throws
  /// Gets the size of the map.
  ///
  /// @return The `size` of the map in `logical pixels`.
  func getSize() throws -> Size
  /// Triggers a repaint of the map.
  func triggerRepaint() throws
  /// Tells the map rendering engine that there is currently a gesture in progress. This
  /// affects how the map renders labels, as it will use different texture filters if a gesture
  /// is ongoing.
  ///
  /// @param inProgress The `boolean` value representing if a gesture is in progress.
  func setGestureInProgress(inProgress: Bool) throws
  /// Returns `true` if a gesture is currently in progress.
  ///
  /// @return `true` if a gesture is currently in progress, `false` otherwise.
  func isGestureInProgress() throws -> Bool
  /// Tells the map rendering engine that the animation is currently performed by the
  /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
  /// In particular, it brings more stability to symbol placement and rendering.
  ///
  /// @param inProgress The `boolean` value representing if user animation is in progress
  func setUserAnimationInProgress(inProgress: Bool) throws
  /// Returns `true` if user animation is currently in progress.
  ///
  /// @return `true` if a user animation is currently in progress, `false` otherwise.
  func isUserAnimationInProgress() throws -> Bool
  /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
  /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
  /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
  ///
  /// @param delta The new prefetch zoom delta.
  func setPrefetchZoomDelta(delta: Int64) throws
  /// Returns the map's prefetch zoom delta.
  ///
  /// @return The map's prefetch zoom `delta`.
  func getPrefetchZoomDelta() throws -> Int64
  /// Sets the north `orientation mode`.
  func setNorthOrientation(orientation: NorthOrientation) throws
  /// Sets the map `constrain mode`.
  func setConstrainMode(mode: ConstrainMode) throws
  /// Sets the `viewport mode`.
  func setViewportMode(mode: ViewportMode) throws
  /// Returns the `map options`.
  ///
  /// @return The map's `map options`.
  func getMapOptions() throws -> MapOptions
  /// Returns the `map debug options`.
  ///
  /// @return An array of `map debug options` flags currently set to the map.
  func getDebug() throws -> [MapDebugOptions?]
  /// Sets the `map debug options` and enables debug mode based on the passed value.
  ///
  /// @param debugOptions An array of `map debug options` to be set.
  /// @param value A `boolean` value representing the state for a given `map debug options`.
  ///
  func setDebug(debugOptions: [MapDebugOptions?], value: Bool) throws
  /// Queries the map for rendered features.
  ///
  /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
  /// @param options The `render query options` for querying rendered features.
  /// @param completion The `query features completion` called when the query completes.
  /// @return A `cancelable` object that could be used to cancel the pending query.
  func queryRenderedFeatures(geometry: RenderedQueryGeometry, options: RenderedQueryOptions, completion: @escaping (Result<[QueriedRenderedFeature?], Error>) -> Void)
  /// Queries the map for source features.
  ///
  /// @param sourceId The style source identifier used to query for source features.
  /// @param options The `source query options` for querying source features.
  /// @param completion The `query features completion` called when the query completes.
  func querySourceFeatures(sourceId: String, options: SourceQueryOptions, completion: @escaping (Result<[QueriedSourceFeature?], Error>) -> Void)
  /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
  /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster Cluster from which to retrieve leaves from
  /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
  /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  func getGeoJsonClusterLeaves(sourceIdentifier: String, cluster: [String?: Any?], limit: Int64?, offset: Int64?, completion: @escaping (Result<FeatureExtensionValue, Error>) -> Void)
  /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
  /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve children from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  func getGeoJsonClusterChildren(sourceIdentifier: String, cluster: [String?: Any?], completion: @escaping (Result<FeatureExtensionValue, Error>) -> Void)
  /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
  /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve the expansion zoom from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
  func getGeoJsonClusterExpansionZoom(sourceIdentifier: String, cluster: [String?: Any?], completion: @escaping (Result<FeatureExtensionValue, Error>) -> Void)
  /// Updates the state object of a feature within a style source.
  ///
  /// Update entries in the `state` object of a given feature within a style source. Only properties of the
  /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
  /// retain its previous value.
  ///
  /// Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be updated.
  /// @param state The `state` object with properties to update with their respective new values.
  func setFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, state: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the state map of a feature within a style source.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
  /// immediately visible.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be queried.
  /// @param completion The `query feature state completion` called when the query completes.
  func getFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Removes entries from a feature state object.
  ///
  /// Remove a specified property or all property from a feature's state object, depending on the value of
  /// `stateKey`.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method migth not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
  func removeFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, stateKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Reduces memory use. Useful to call when the application gets paused or sent to background.
  func reduceMemoryUse() throws
  /// Gets elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate The `coordinate` defined as longitude-latitude pair.
  /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  func getElevation(coordinate: Point) throws -> Double?
  /// Returns array of tile identifiers that cover current map camera.
  func tileCover(options: TileCoverOptions) throws -> [CanonicalTileID]
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapInterfaceSetup {
  /// The codec used by _MapInterface.
  static var codec: FlutterStandardMessageCodec { _MapInterfaceCodec.shared }
  /// Sets up an instance of `_MapInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadStyleURIChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadStyleURIChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.loadStyleURI(styleURI: styleURIArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadStyleURIChannel.setMessageHandler(nil)
    }
    let loadStyleJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadStyleJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleJsonArg = args[0] as! String
        api.loadStyleJson(styleJson: styleJsonArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadStyleJsonChannel.setMessageHandler(nil)
    }
    let clearDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearDataChannel.setMessageHandler { _, reply in
        api.clearData { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      clearDataChannel.setMessageHandler(nil)
    }
    let setTileCacheBudgetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setTileCacheBudget\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTileCacheBudgetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tileCacheBudgetInMegabytesArg: TileCacheBudgetInMegabytes? = nilOrValue(args[0])
        let tileCacheBudgetInTilesArg: TileCacheBudgetInTiles? = nilOrValue(args[1])
        do {
          try api.setTileCacheBudget(tileCacheBudgetInMegabytes: tileCacheBudgetInMegabytesArg, tileCacheBudgetInTiles: tileCacheBudgetInTilesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTileCacheBudgetChannel.setMessageHandler(nil)
    }
    /// Gets the size of the map.
    ///
    /// @return The `size` of the map in `logical pixels`.
    let getSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSizeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSize()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSizeChannel.setMessageHandler(nil)
    }
    /// Triggers a repaint of the map.
    let triggerRepaintChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      triggerRepaintChannel.setMessageHandler { _, reply in
        do {
          try api.triggerRepaint()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      triggerRepaintChannel.setMessageHandler(nil)
    }
    /// Tells the map rendering engine that there is currently a gesture in progress. This
    /// affects how the map renders labels, as it will use different texture filters if a gesture
    /// is ongoing.
    ///
    /// @param inProgress The `boolean` value representing if a gesture is in progress.
    let setGestureInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setGestureInProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let inProgressArg = args[0] as! Bool
        do {
          try api.setGestureInProgress(inProgress: inProgressArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setGestureInProgressChannel.setMessageHandler(nil)
    }
    /// Returns `true` if a gesture is currently in progress.
    ///
    /// @return `true` if a gesture is currently in progress, `false` otherwise.
    let isGestureInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isGestureInProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isGestureInProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isGestureInProgressChannel.setMessageHandler(nil)
    }
    /// Tells the map rendering engine that the animation is currently performed by the
    /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
    /// In particular, it brings more stability to symbol placement and rendering.
    ///
    /// @param inProgress The `boolean` value representing if user animation is in progress
    let setUserAnimationInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUserAnimationInProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let inProgressArg = args[0] as! Bool
        do {
          try api.setUserAnimationInProgress(inProgress: inProgressArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserAnimationInProgressChannel.setMessageHandler(nil)
    }
    /// Returns `true` if user animation is currently in progress.
    ///
    /// @return `true` if a user animation is currently in progress, `false` otherwise.
    let isUserAnimationInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isUserAnimationInProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isUserAnimationInProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isUserAnimationInProgressChannel.setMessageHandler(nil)
    }
    /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
    /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
    /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
    ///
    /// @param delta The new prefetch zoom delta.
    let setPrefetchZoomDeltaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPrefetchZoomDeltaChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deltaArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.setPrefetchZoomDelta(delta: deltaArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPrefetchZoomDeltaChannel.setMessageHandler(nil)
    }
    /// Returns the map's prefetch zoom delta.
    ///
    /// @return The map's prefetch zoom `delta`.
    let getPrefetchZoomDeltaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPrefetchZoomDeltaChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPrefetchZoomDelta()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPrefetchZoomDeltaChannel.setMessageHandler(nil)
    }
    /// Sets the north `orientation mode`.
    let setNorthOrientationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setNorthOrientationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let orientationArg = NorthOrientation(rawValue: args[0] as! Int)!
        do {
          try api.setNorthOrientation(orientation: orientationArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNorthOrientationChannel.setMessageHandler(nil)
    }
    /// Sets the map `constrain mode`.
    let setConstrainModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setConstrainModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = ConstrainMode(rawValue: args[0] as! Int)!
        do {
          try api.setConstrainMode(mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setConstrainModeChannel.setMessageHandler(nil)
    }
    /// Sets the `viewport mode`.
    let setViewportModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setViewportModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = ViewportMode(rawValue: args[0] as! Int)!
        do {
          try api.setViewportMode(mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setViewportModeChannel.setMessageHandler(nil)
    }
    /// Returns the `map options`.
    ///
    /// @return The map's `map options`.
    let getMapOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMapOptionsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getMapOptions()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMapOptionsChannel.setMessageHandler(nil)
    }
    /// Returns the `map debug options`.
    ///
    /// @return An array of `map debug options` flags currently set to the map.
    let getDebugChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDebugChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDebug()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDebugChannel.setMessageHandler(nil)
    }
    /// Sets the `map debug options` and enables debug mode based on the passed value.
    ///
    /// @param debugOptions An array of `map debug options` to be set.
    /// @param value A `boolean` value representing the state for a given `map debug options`.
    ///
    let setDebugChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDebugChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let debugOptionsArg = args[0] as! [MapDebugOptions?]
        let valueArg = args[1] as! Bool
        do {
          try api.setDebug(debugOptions: debugOptionsArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDebugChannel.setMessageHandler(nil)
    }
    /// Queries the map for rendered features.
    ///
    /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
    /// @param options The `render query options` for querying rendered features.
    /// @param completion The `query features completion` called when the query completes.
    /// @return A `cancelable` object that could be used to cancel the pending query.
    let queryRenderedFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      queryRenderedFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let geometryArg = args[0] as! RenderedQueryGeometry
        let optionsArg = args[1] as! RenderedQueryOptions
        api.queryRenderedFeatures(geometry: geometryArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryRenderedFeaturesChannel.setMessageHandler(nil)
    }
    /// Queries the map for source features.
    ///
    /// @param sourceId The style source identifier used to query for source features.
    /// @param options The `source query options` for querying source features.
    /// @param completion The `query features completion` called when the query completes.
    let querySourceFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      querySourceFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let optionsArg = args[1] as! SourceQueryOptions
        api.querySourceFeatures(sourceId: sourceIdArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      querySourceFeaturesChannel.setMessageHandler(nil)
    }
    /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
    /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
    ///
    /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
    ///
    /// @param sourceIdentifier GeoJsonSource identifier.
    /// @param cluster Cluster from which to retrieve leaves from
    /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
    /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
    /// @param completion The result will be returned through the completion block.
    ///         The result is a feature collection or a string describing an error if the operation was not successful.
    let getGeoJsonClusterLeavesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeoJsonClusterLeavesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdentifierArg = args[0] as! String
        let clusterArg = args[1] as! [String?: Any?]
        let limitArg: Int64? = isNullish(args[2]) ? nil : (args[2] is Int64? ? args[2] as! Int64? : Int64(args[2] as! Int32))
        let offsetArg: Int64? = isNullish(args[3]) ? nil : (args[3] is Int64? ? args[3] as! Int64? : Int64(args[3] as! Int32))
        api.getGeoJsonClusterLeaves(sourceIdentifier: sourceIdentifierArg, cluster: clusterArg, limit: limitArg, offset: offsetArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getGeoJsonClusterLeavesChannel.setMessageHandler(nil)
    }
    /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
    /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
    ///
    /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
    ///
    /// @param sourceIdentifier GeoJsonSource identifier.
    /// @param cluster cluster from which to retrieve children from
    /// @param completion The result will be returned through the completion block.
    ///         The result is a feature collection or a string describing an error if the operation was not successful.
    let getGeoJsonClusterChildrenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeoJsonClusterChildrenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdentifierArg = args[0] as! String
        let clusterArg = args[1] as! [String?: Any?]
        api.getGeoJsonClusterChildren(sourceIdentifier: sourceIdentifierArg, cluster: clusterArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getGeoJsonClusterChildrenChannel.setMessageHandler(nil)
    }
    /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
    /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
    ///
    /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
    ///
    /// @param sourceIdentifier GeoJsonSource identifier.
    /// @param cluster cluster from which to retrieve the expansion zoom from
    /// @param completion The result will be returned through the completion block.
    ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
    let getGeoJsonClusterExpansionZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeoJsonClusterExpansionZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdentifierArg = args[0] as! String
        let clusterArg = args[1] as! [String?: Any?]
        api.getGeoJsonClusterExpansionZoom(sourceIdentifier: sourceIdentifierArg, cluster: clusterArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getGeoJsonClusterExpansionZoomChannel.setMessageHandler(nil)
    }
    /// Updates the state object of a feature within a style source.
    ///
    /// Update entries in the `state` object of a given feature within a style source. Only properties of the
    /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
    /// retain its previous value.
    ///
    /// Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
    /// immediately visible using `getStateFeature`.
    ///
    /// @param sourceId The style source identifier.
    /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
    /// @param featureId The feature identifier of the feature whose state should be updated.
    /// @param state The `state` object with properties to update with their respective new values.
    let setFeatureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFeatureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let sourceLayerIdArg: String? = nilOrValue(args[1])
        let featureIdArg = args[2] as! String
        let stateArg = args[3] as! String
        api.setFeatureState(sourceId: sourceIdArg, sourceLayerId: sourceLayerIdArg, featureId: featureIdArg, state: stateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFeatureStateChannel.setMessageHandler(nil)
    }
    /// Gets the state map of a feature within a style source.
    ///
    /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
    /// immediately visible.
    ///
    /// @param sourceId The style source identifier.
    /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
    /// @param featureId The feature identifier of the feature whose state should be queried.
    /// @param completion The `query feature state completion` called when the query completes.
    let getFeatureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFeatureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let sourceLayerIdArg: String? = nilOrValue(args[1])
        let featureIdArg = args[2] as! String
        api.getFeatureState(sourceId: sourceIdArg, sourceLayerId: sourceLayerIdArg, featureId: featureIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFeatureStateChannel.setMessageHandler(nil)
    }
    /// Removes entries from a feature state object.
    ///
    /// Remove a specified property or all property from a feature's state object, depending on the value of
    /// `stateKey`.
    ///
    /// Note that updates to feature state are asynchronous, so changes made by this method migth not be
    /// immediately visible using `getStateFeature`.
    ///
    /// @param sourceId The style source identifier.
    /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
    /// @param featureId The feature identifier of the feature whose state should be removed.
    /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
    let removeFeatureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeFeatureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let sourceLayerIdArg: String? = nilOrValue(args[1])
        let featureIdArg = args[2] as! String
        let stateKeyArg: String? = nilOrValue(args[3])
        api.removeFeatureState(sourceId: sourceIdArg, sourceLayerId: sourceLayerIdArg, featureId: featureIdArg, stateKey: stateKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeFeatureStateChannel.setMessageHandler(nil)
    }
    /// Reduces memory use. Useful to call when the application gets paused or sent to background.
    let reduceMemoryUseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reduceMemoryUseChannel.setMessageHandler { _, reply in
        do {
          try api.reduceMemoryUse()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reduceMemoryUseChannel.setMessageHandler(nil)
    }
    /// Gets elevation for the given coordinate.
    /// Note: Elevation is only available for the visible region on the screen.
    ///
    /// @param coordinate The `coordinate` defined as longitude-latitude pair.
    /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
    let getElevationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getElevationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        do {
          let result = try api.getElevation(coordinate: coordinateArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getElevationChannel.setMessageHandler(nil)
    }
    /// Returns array of tile identifiers that cover current map camera.
    let tileCoverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.tileCover\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileCoverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! TileCoverOptions
        do {
          let result = try api.tileCover(options: optionsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tileCoverChannel.setMessageHandler(nil)
    }
  }
}
private class OfflineRegionCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CoordinateBounds.fromList(self.readValue() as! [Any?])
    case 129:
      return OfflineRegionGeometryDefinition.fromList(self.readValue() as! [Any?])
    case 130:
      return OfflineRegionTilePyramidDefinition.fromList(self.readValue() as! [Any?])
    case 131:
      return Point.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OfflineRegionCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CoordinateBounds {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionGeometryDefinition {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionTilePyramidDefinition {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class OfflineRegionCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OfflineRegionCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OfflineRegionCodecWriter(data: data)
  }
}

class OfflineRegionCodec: FlutterStandardMessageCodec {
  static let shared = OfflineRegionCodec(readerWriter: OfflineRegionCodecReaderWriter())
}

/// An offline region represents an identifiable geographic region with optional metadata.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol OfflineRegion {
  /// The regions identifier
  func getIdentifier() throws -> Int64
  /// The tile pyramid defining the region. Tile pyramid and geometry definitions are
  /// mutually exclusive.
  ///
  /// @return A definition describing the tile pyramid including attributes, otherwise empty.
  func getTilePyramidDefinition() throws -> OfflineRegionTilePyramidDefinition?
  /// The geometry defining the region. Geometry and tile pyramid definitions are
  /// mutually exclusive.
  ///
  /// @return A definition describing the geometry including attributes, otherwise empty.
  func getGeometryDefinition() throws -> OfflineRegionGeometryDefinition?
  /// Arbitrary binary region metadata.
  ///
  /// @return The metadata associated with the region.
  func getMetadata() throws -> FlutterStandardTypedData
  /// Sets arbitrary binary region metadata for the region.
  ///
  /// Note that this setter is asynchronous and the given metadata is applied only
  /// after the resulting callback is invoked with no error.
  ///
  /// @param metadata The metadata associated with the region.
  /// @param callback Called once the request is complete or an error occurred.
  func setMetadata(metadata: FlutterStandardTypedData, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the download state of an offline region
  /// A region is either inactive (not downloading, but previously-downloaded
  /// resources are available for use), or active (resources are being downloaded
  /// or will be downloaded, if necessary, when network access is available).
  ///
  /// If the region is already in the given state, this call is ignored.
  ///
  /// @param state The new state to set.
  func setOfflineRegionDownloadState(state: OfflineRegionDownloadState) throws
  /// Invalidate all the tiles for the region forcing to revalidate
  /// the tiles with the server before using. This is more efficient than deleting the
  /// offline region and downloading it again because if the data on the cache matches
  /// the server, no new data gets transmitted.
  ///
  /// @param callback Called once the request is complete or an error occurred.
  func invalidate(completion: @escaping (Result<Void, Error>) -> Void)
  /// Remove an offline region from the database and perform any resources
  /// evictions necessary as a result.
  ///
  /// @param callback Called once the request is complete or an error occurred.
  func purge(completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class OfflineRegionSetup {
  /// The codec used by OfflineRegion.
  static var codec: FlutterStandardMessageCodec { OfflineRegionCodec.shared }
  /// Sets up an instance of `OfflineRegion` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: OfflineRegion?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// The regions identifier
    let getIdentifierChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getIdentifier\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIdentifierChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getIdentifier()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getIdentifierChannel.setMessageHandler(nil)
    }
    /// The tile pyramid defining the region. Tile pyramid and geometry definitions are
    /// mutually exclusive.
    ///
    /// @return A definition describing the tile pyramid including attributes, otherwise empty.
    let getTilePyramidDefinitionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getTilePyramidDefinition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTilePyramidDefinitionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getTilePyramidDefinition()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTilePyramidDefinitionChannel.setMessageHandler(nil)
    }
    /// The geometry defining the region. Geometry and tile pyramid definitions are
    /// mutually exclusive.
    ///
    /// @return A definition describing the geometry including attributes, otherwise empty.
    let getGeometryDefinitionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getGeometryDefinition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeometryDefinitionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getGeometryDefinition()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getGeometryDefinitionChannel.setMessageHandler(nil)
    }
    /// Arbitrary binary region metadata.
    ///
    /// @return The metadata associated with the region.
    let getMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMetadataChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getMetadata()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMetadataChannel.setMessageHandler(nil)
    }
    /// Sets arbitrary binary region metadata for the region.
    ///
    /// Note that this setter is asynchronous and the given metadata is applied only
    /// after the resulting callback is invoked with no error.
    ///
    /// @param metadata The metadata associated with the region.
    /// @param callback Called once the request is complete or an error occurred.
    let setMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let metadataArg = args[0] as! FlutterStandardTypedData
        api.setMetadata(metadata: metadataArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMetadataChannel.setMessageHandler(nil)
    }
    /// Sets the download state of an offline region
    /// A region is either inactive (not downloading, but previously-downloaded
    /// resources are available for use), or active (resources are being downloaded
    /// or will be downloaded, if necessary, when network access is available).
    ///
    /// If the region is already in the given state, this call is ignored.
    ///
    /// @param state The new state to set.
    let setOfflineRegionDownloadStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setOfflineRegionDownloadState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setOfflineRegionDownloadStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let stateArg = OfflineRegionDownloadState(rawValue: args[0] as! Int)!
        do {
          try api.setOfflineRegionDownloadState(state: stateArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setOfflineRegionDownloadStateChannel.setMessageHandler(nil)
    }
    /// Invalidate all the tiles for the region forcing to revalidate
    /// the tiles with the server before using. This is more efficient than deleting the
    /// offline region and downloading it again because if the data on the cache matches
    /// the server, no new data gets transmitted.
    ///
    /// @param callback Called once the request is complete or an error occurred.
    let invalidateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.invalidate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      invalidateChannel.setMessageHandler { _, reply in
        api.invalidate { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      invalidateChannel.setMessageHandler(nil)
    }
    /// Remove an offline region from the database and perform any resources
    /// evictions necessary as a result.
    ///
    /// @param callback Called once the request is complete or an error occurred.
    let purgeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.purge\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      purgeChannel.setMessageHandler { _, reply in
        api.purge { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      purgeChannel.setMessageHandler(nil)
    }
  }
}
/// The `offline region manager` that manages offline packs. All of the classâ€™s instance methods are asynchronous
/// reflecting the fact that offline resources are stored in a database. The offline manager maintains a canonical
/// collection of offline packs.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol OfflineRegionManager {
  /// Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
  ///
  /// By default, the limit is set to 6,000.
  /// Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
  /// fires every additional attempt to download additional tiles until already downloaded tiles are removed
  /// by calling `OfflineRegion.purge()` API.
  ///
  /// @param limit the maximum number of tiles allowed to be downloaded
  func setOfflineMapboxTileCountLimit(limit: Int64) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class OfflineRegionManagerSetup {
  /// The codec used by OfflineRegionManager.
  /// Sets up an instance of `OfflineRegionManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: OfflineRegionManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
    ///
    /// By default, the limit is set to 6,000.
    /// Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
    /// fires every additional attempt to download additional tiles until already downloaded tiles are removed
    /// by calling `OfflineRegion.purge()` API.
    ///
    /// @param limit the maximum number of tiles allowed to be downloaded
    let setOfflineMapboxTileCountLimitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegionManager.setOfflineMapboxTileCountLimit\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setOfflineMapboxTileCountLimitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let limitArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        do {
          try api.setOfflineMapboxTileCountLimit(limit: limitArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setOfflineMapboxTileCountLimitChannel.setMessageHandler(nil)
    }
  }
}
private class ProjectionCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return MercatorCoordinate.fromList(self.readValue() as! [Any?])
    case 129:
      return Point.fromList(self.readValue() as! [Any?])
    case 130:
      return ProjectedMeters.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class ProjectionCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? MercatorCoordinate {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ProjectedMeters {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ProjectionCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ProjectionCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ProjectionCodecWriter(data: data)
  }
}

class ProjectionCodec: FlutterStandardMessageCodec {
  static let shared = ProjectionCodec(readerWriter: ProjectionCodecReaderWriter())
}

/// Collection of [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection methods.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Projection {
  /// Calculate distance spanned by one pixel at the specified latitude
  /// and zoom level.
  ///
  /// @param latitude The latitude for which to return the value.
  /// @param zoom The zoom level.
  ///
  /// @return Returns the distance measured in meters.
  func getMetersPerPixelAtLatitude(latitude: Double, zoom: Double) throws -> Double
  /// Calculate Spherical Mercator ProjectedMeters coordinates.
  ///
  /// @param coordinate A longitude-latitude pair for which to calculate
  /// `projected meters` coordinates.
  ///
  /// @return Returns Spherical Mercator ProjectedMeters coordinates.
  func projectedMetersForCoordinate(coordinate: Point) throws -> ProjectedMeters
  /// Calculate a longitude-latitude pair for a Spherical Mercator projected
  /// meters.
  ///
  /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
  /// which to calculate a longitude-latitude pair.
  ///
  /// @return Returns a longitude-latitude pair.
  func coordinateForProjectedMeters(projectedMeters: ProjectedMeters) throws -> Point
  /// Calculate a point on the map in Mercator Projection for a given
  /// coordinate at the specified zoom scale.
  ///
  /// @param coordinate The longitude-latitude pair for which to return the value.
  /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a point on the map in Mercator projection.
  func project(coordinate: Point, zoomScale: Double) throws -> MercatorCoordinate
  /// Calculate a coordinate for a given point on the map in Mercator Projection.
  ///
  /// @param coordinate Point on the map in Mercator projection.
  /// @param zoomScale The current zoom factor applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a coordinate.
  func unproject(coordinate: MercatorCoordinate, zoomScale: Double) throws -> Point
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ProjectionSetup {
  /// The codec used by Projection.
  static var codec: FlutterStandardMessageCodec { ProjectionCodec.shared }
  /// Sets up an instance of `Projection` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Projection?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Calculate distance spanned by one pixel at the specified latitude
    /// and zoom level.
    ///
    /// @param latitude The latitude for which to return the value.
    /// @param zoom The zoom level.
    ///
    /// @return Returns the distance measured in meters.
    let getMetersPerPixelAtLatitudeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMetersPerPixelAtLatitudeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let latitudeArg = args[0] as! Double
        let zoomArg = args[1] as! Double
        do {
          let result = try api.getMetersPerPixelAtLatitude(latitude: latitudeArg, zoom: zoomArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMetersPerPixelAtLatitudeChannel.setMessageHandler(nil)
    }
    /// Calculate Spherical Mercator ProjectedMeters coordinates.
    ///
    /// @param coordinate A longitude-latitude pair for which to calculate
    /// `projected meters` coordinates.
    ///
    /// @return Returns Spherical Mercator ProjectedMeters coordinates.
    let projectedMetersForCoordinateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      projectedMetersForCoordinateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        do {
          let result = try api.projectedMetersForCoordinate(coordinate: coordinateArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      projectedMetersForCoordinateChannel.setMessageHandler(nil)
    }
    /// Calculate a longitude-latitude pair for a Spherical Mercator projected
    /// meters.
    ///
    /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
    /// which to calculate a longitude-latitude pair.
    ///
    /// @return Returns a longitude-latitude pair.
    let coordinateForProjectedMetersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateForProjectedMetersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let projectedMetersArg = args[0] as! ProjectedMeters
        do {
          let result = try api.coordinateForProjectedMeters(projectedMeters: projectedMetersArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateForProjectedMetersChannel.setMessageHandler(nil)
    }
    /// Calculate a point on the map in Mercator Projection for a given
    /// coordinate at the specified zoom scale.
    ///
    /// @param coordinate The longitude-latitude pair for which to return the value.
    /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
    /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
    /// where tileSize is the width of a tile in pixels.
    ///
    /// @return Returns a point on the map in Mercator projection.
    let projectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.project\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      projectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        let zoomScaleArg = args[1] as! Double
        do {
          let result = try api.project(coordinate: coordinateArg, zoomScale: zoomScaleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      projectChannel.setMessageHandler(nil)
    }
    /// Calculate a coordinate for a given point on the map in Mercator Projection.
    ///
    /// @param coordinate Point on the map in Mercator projection.
    /// @param zoomScale The current zoom factor applied on the map, is used to
    /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
    /// where tileSize is the width of a tile in pixels.
    ///
    /// @return Returns a coordinate.
    let unprojectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unprojectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! MercatorCoordinate
        let zoomScaleArg = args[1] as! Double
        do {
          let result = try api.unproject(coordinate: coordinateArg, zoomScale: zoomScaleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unprojectChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapboxOptions {
  func getAccessToken() throws -> String
  func setAccessToken(token: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapboxOptionsSetup {
  /// The codec used by _MapboxOptions.
  /// Sets up an instance of `_MapboxOptions` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapboxOptions?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getAccessTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.getAccessToken\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getAccessTokenChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getAccessToken()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAccessTokenChannel.setMessageHandler(nil)
    }
    let setAccessTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.setAccessToken\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setAccessTokenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tokenArg = args[0] as! String
        do {
          try api.setAccessToken(token: tokenArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAccessTokenChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapboxMapsOptions {
  func getBaseUrl() throws -> String
  func setBaseUrl(url: String) throws
  func getDataPath() throws -> String
  func setDataPath(path: String) throws
  func getAssetPath() throws -> String
  func setAssetPath(path: String) throws
  func getTileStoreUsageMode() throws -> TileStoreUsageMode
  func setTileStoreUsageMode(mode: TileStoreUsageMode) throws
  func getWorldview() throws -> String?
  func setWorldview(worldview: String?) throws
  func getLanguage() throws -> String?
  func setLanguage(language: String?) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapboxMapsOptionsSetup {
  /// The codec used by _MapboxMapsOptions.
  /// Sets up an instance of `_MapboxMapsOptions` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapboxMapsOptions?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getBaseUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getBaseUrl\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getBaseUrlChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getBaseUrl()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBaseUrlChannel.setMessageHandler(nil)
    }
    let setBaseUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setBaseUrl\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setBaseUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let urlArg = args[0] as! String
        do {
          try api.setBaseUrl(url: urlArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setBaseUrlChannel.setMessageHandler(nil)
    }
    let getDataPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getDataPath\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getDataPathChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDataPath()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDataPathChannel.setMessageHandler(nil)
    }
    let setDataPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setDataPath\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setDataPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pathArg = args[0] as! String
        do {
          try api.setDataPath(path: pathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDataPathChannel.setMessageHandler(nil)
    }
    let getAssetPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getAssetPath\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getAssetPathChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getAssetPath()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAssetPathChannel.setMessageHandler(nil)
    }
    let setAssetPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setAssetPath\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setAssetPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pathArg = args[0] as! String
        do {
          try api.setAssetPath(path: pathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAssetPathChannel.setMessageHandler(nil)
    }
    let getTileStoreUsageModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getTileStoreUsageMode\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getTileStoreUsageModeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getTileStoreUsageMode()
          reply(wrapResult(result.rawValue))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTileStoreUsageModeChannel.setMessageHandler(nil)
    }
    let setTileStoreUsageModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setTileStoreUsageMode\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setTileStoreUsageModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = TileStoreUsageMode(rawValue: args[0] as! Int)!
        do {
          try api.setTileStoreUsageMode(mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTileStoreUsageModeChannel.setMessageHandler(nil)
    }
    let getWorldviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getWorldview\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getWorldviewChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getWorldview()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getWorldviewChannel.setMessageHandler(nil)
    }
    let setWorldviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setWorldview\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setWorldviewChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let worldviewArg: String? = nilOrValue(args[0])
        do {
          try api.setWorldview(worldview: worldviewArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setWorldviewChannel.setMessageHandler(nil)
    }
    let getLanguageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getLanguage\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getLanguageChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getLanguage()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLanguageChannel.setMessageHandler(nil)
    }
    let setLanguageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setLanguage\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setLanguageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg: String? = nilOrValue(args[0])
        do {
          try api.setLanguage(language: languageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLanguageChannel.setMessageHandler(nil)
    }
  }
}
/// Settings class provides non-persistent, in-process key-value storage.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Settings {
  /// Sets setting value for a specified key.
  ///
  /// @param key A name of the key.
  /// @param value The `value` for the key.
  func set(key: String, value: String) throws
  /// Return value for a key.
  ///
  /// @param key A name of the key.
  ///
  /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
  func get(key: String) throws -> String
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class SettingsSetup {
  /// The codec used by Settings.
  /// Sets up an instance of `Settings` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Settings?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Sets setting value for a specified key.
    ///
    /// @param key A name of the key.
    /// @param value The `value` for the key.
    let setChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Settings.set\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keyArg = args[0] as! String
        let valueArg = args[1] as! String
        do {
          try api.set(key: keyArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setChannel.setMessageHandler(nil)
    }
    /// Return value for a key.
    ///
    /// @param key A name of the key.
    ///
    /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
    let getChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Settings.get\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      getChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keyArg = args[0] as! String
        do {
          let result = try api.get(key: keyArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getChannel.setMessageHandler(nil)
    }
  }
}
private class StyleManagerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return AmbientLight.fromList(self.readValue() as! [Any?])
    case 129:
      return CameraBounds.fromList(self.readValue() as! [Any?])
    case 130:
      return CameraBoundsOptions.fromList(self.readValue() as! [Any?])
    case 131:
      return CameraOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return CameraState.fromList(self.readValue() as! [Any?])
    case 133:
      return CanonicalTileID.fromList(self.readValue() as! [Any?])
    case 134:
      return CoordinateBounds.fromList(self.readValue() as! [Any?])
    case 135:
      return CoordinateBoundsZoom.fromList(self.readValue() as! [Any?])
    case 136:
      return DirectionalLight.fromList(self.readValue() as! [Any?])
    case 137:
      return FeatureExtensionValue.fromList(self.readValue() as! [Any?])
    case 138:
      return FlatLight.fromList(self.readValue() as! [Any?])
    case 139:
      return GlyphsRasterizationOptions.fromList(self.readValue() as! [Any?])
    case 140:
      return ImageContent.fromList(self.readValue() as! [Any?])
    case 141:
      return ImageStretches.fromList(self.readValue() as! [Any?])
    case 142:
      return LayerPosition.fromList(self.readValue() as! [Any?])
    case 143:
      return MapAnimationOptions.fromList(self.readValue() as! [Any?])
    case 144:
      return MapDebugOptions.fromList(self.readValue() as! [Any?])
    case 145:
      return MapOptions.fromList(self.readValue() as! [Any?])
    case 146:
      return MbxEdgeInsets.fromList(self.readValue() as! [Any?])
    case 147:
      return MbxImage.fromList(self.readValue() as! [Any?])
    case 148:
      return MercatorCoordinate.fromList(self.readValue() as! [Any?])
    case 149:
      return OfflineRegionGeometryDefinition.fromList(self.readValue() as! [Any?])
    case 150:
      return OfflineRegionTilePyramidDefinition.fromList(self.readValue() as! [Any?])
    case 151:
      return Point.fromList(self.readValue() as! [Any?])
    case 152:
      return ProjectedMeters.fromList(self.readValue() as! [Any?])
    case 153:
      return QueriedFeature.fromList(self.readValue() as! [Any?])
    case 154:
      return QueriedRenderedFeature.fromList(self.readValue() as! [Any?])
    case 155:
      return QueriedSourceFeature.fromList(self.readValue() as! [Any?])
    case 156:
      return RenderedQueryGeometry.fromList(self.readValue() as! [Any?])
    case 157:
      return RenderedQueryOptions.fromList(self.readValue() as! [Any?])
    case 158:
      return ScreenBox.fromList(self.readValue() as! [Any?])
    case 159:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 160:
      return Size.fromList(self.readValue() as! [Any?])
    case 161:
      return SourceQueryOptions.fromList(self.readValue() as! [Any?])
    case 162:
      return StyleObjectInfo.fromList(self.readValue() as! [Any?])
    case 163:
      return StyleProjection.fromList(self.readValue() as! [Any?])
    case 164:
      return StylePropertyValue.fromList(self.readValue() as! [Any?])
    case 165:
      return TileCacheBudgetInMegabytes.fromList(self.readValue() as! [Any?])
    case 166:
      return TileCacheBudgetInTiles.fromList(self.readValue() as! [Any?])
    case 167:
      return TileCoverOptions.fromList(self.readValue() as! [Any?])
    case 168:
      return TransitionOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class StyleManagerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AmbientLight {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBounds {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBoundsOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? CameraOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? CameraState {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? CanonicalTileID {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBounds {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBoundsZoom {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? DirectionalLight {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? FeatureExtensionValue {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? FlatLight {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? GlyphsRasterizationOptions {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? ImageContent {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? ImageStretches {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? LayerPosition {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? MapAnimationOptions {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? MapDebugOptions {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? MapOptions {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? MbxEdgeInsets {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? MbxImage {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? MercatorCoordinate {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionGeometryDefinition {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? OfflineRegionTilePyramidDefinition {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else if let value = value as? ProjectedMeters {
      super.writeByte(152)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedFeature {
      super.writeByte(153)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedRenderedFeature {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedSourceFeature {
      super.writeByte(155)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryGeometry {
      super.writeByte(156)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryOptions {
      super.writeByte(157)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenBox {
      super.writeByte(158)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(159)
      super.writeValue(value.toList())
    } else if let value = value as? Size {
      super.writeByte(160)
      super.writeValue(value.toList())
    } else if let value = value as? SourceQueryOptions {
      super.writeByte(161)
      super.writeValue(value.toList())
    } else if let value = value as? StyleObjectInfo {
      super.writeByte(162)
      super.writeValue(value.toList())
    } else if let value = value as? StyleProjection {
      super.writeByte(163)
      super.writeValue(value.toList())
    } else if let value = value as? StylePropertyValue {
      super.writeByte(164)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInMegabytes {
      super.writeByte(165)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInTiles {
      super.writeByte(166)
      super.writeValue(value.toList())
    } else if let value = value as? TileCoverOptions {
      super.writeByte(167)
      super.writeValue(value.toList())
    } else if let value = value as? TransitionOptions {
      super.writeByte(168)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class StyleManagerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return StyleManagerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return StyleManagerCodecWriter(data: data)
  }
}

class StyleManagerCodec: FlutterStandardMessageCodec {
  static let shared = StyleManagerCodec(readerWriter: StyleManagerCodecReaderWriter())
}

/// Interface for managing style of the `map`.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol StyleManager {
  /// Get the URI of the current style in use.
  ///
  /// @return A string containing a style URI.
  func getStyleURI(completion: @escaping (Result<String, Error>) -> Void)
  /// Load style from provided URI.
  ///
  /// This is an asynchronous call. To check the result of this operation the user must register an observer observing
  /// `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
  ///
  /// @param uri URI where the style should be loaded from.
  func setStyleURI(uri: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Get the JSON serialization string of the current style in use.
  ///
  /// @return A JSON string containing a serialized style.
  func getStyleJSON(completion: @escaping (Result<String, Error>) -> Void)
  /// Load the style from a provided JSON string.
  ///
  /// @param json A JSON string containing a serialized style.
  func setStyleJSON(json: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the map style's default camera, if any, or a default camera otherwise.
  /// The map style's default camera is defined as follows:
  /// - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
  /// - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
  /// - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
  /// - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
  ///
  /// The style default camera is re-evaluated when a new style is loaded.
  ///
  /// @return The default `camera options` of the current style in use.
  func getStyleDefaultCamera(completion: @escaping (Result<CameraOptions, Error>) -> Void)
  /// Returns the map style's transition options. By default, the style parser will attempt
  /// to read the style default transition options, if any, fallbacking to an immediate transition
  /// otherwise. Transition options can be overriden via `setStyleTransition`, but the options are
  /// reset once a new style has been loaded.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @return The `transition options` of the current style in use.
  func getStyleTransition(completion: @escaping (Result<TransitionOptions, Error>) -> Void)
  /// Returns the list containing information about existing style import objects.
  func getStyleImports() throws -> [StyleObjectInfo?]
  /// Removes an existing style import.
  ///
  /// @param importId Identifier of the style import to remove.
  func removeStyleImport(importId: String) throws
  /// Gets the style import schema.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import schema, containing the default configurations for the style import.
  func getStyleImportSchema(importId: String) throws -> Any
  /// Gets style import config.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  func getStyleImportConfigProperties(importId: String) throws -> [String: StylePropertyValue]
  /// Gets the value of style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  func getStyleImportConfigProperty(importId: String, config: String) throws -> StylePropertyValue
  /// Sets style import config.
  /// This method can be used to perform batch update for a style import configurations.
  ///
  /// @param importId Identifier of the style import.
  /// @param configs A map of style import configurations.
  func setStyleImportConfigProperties(importId: String, configs: [String: Any]) throws
  /// Sets a value to a style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  /// @param value The style import config value.
  func setStyleImportConfigProperty(importId: String, config: String, value: Any) throws
  /// Overrides the map style's transition options with user-provided options.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @param transitionOptions The `transition options`.
  func setStyleTransition(transitionOptions: TransitionOptions, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Runtime style layers are valid until they are either removed or a new style is loaded.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func addStyleLayer(properties: String, layerPosition: LayerPosition?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Whenever a new style is being parsed and currently used style has persistent layers,
  /// an engine will try to do following:
  ///   - keep the persistent layer at its relative position
  ///   - keep the source used by a persistent layer
  ///   - keep images added through `addStyleImage` method
  ///
  /// In cases when a new style has the same layer, source or image resource, style's resources would be
  /// used instead and `MapLoadingError` event will be emitted.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func addPersistentStyleLayer(properties: String, layerPosition: LayerPosition?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks if a style layer is persistent.
  ///
  /// @param layerId A style layer identifier.
  /// @return A string describing an error if the operation was not successful, boolean representing state otherwise.
  func isStyleLayerPersistent(layerId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Removes an existing style layer.
  ///
  /// @param layerId An identifier of the style layer to remove.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func removeStyleLayer(layerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Moves an existing style layer
  ///
  /// @param layerId Identifier of the style layer to move.
  /// @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
  ///                      is provided then the layer is moved to the top of the layerstack.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func moveStyleLayer(layerId: String, layerPosition: LayerPosition?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks whether a given style layer exists.
  ///
  /// @param layerId Style layer identifier.
  ///
  /// @return A `true` value if the given style layer exists, `false` otherwise.
  func styleLayerExists(layerId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Returns the existing style layers.
  ///
  /// @return The list containing the information about existing style layer objects.
  func getStyleLayers(completion: @escaping (Result<[StyleObjectInfo?], Error>) -> Void)
  /// Gets the value of style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @return The `style property value`.
  func getStyleLayerProperty(layerId: String, property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to a style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @param value The style layer property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleLayerProperty(layerId: String, property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets style layer properties.
  ///
  /// @return The style layer properties or a string describing an error if the operation was not successful.
  func getStyleLayerProperties(layerId: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Sets style layer properties.
  /// This method can be used to perform batch update for a style layer properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
  /// Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
  ///
  /// @param layerId A style layer identifier.
  /// @param properties A map of style layer properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleLayerProperties(layerId: String, properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
  ///
  /// @param sourceId An identifier for the style source.
  /// @param properties A map of style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func addStyleSource(sourceId: String, properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the value of style source property.
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @return The value of a `property` in the source with a `sourceId`.
  func getStyleSourceProperty(sourceId: String, property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to a style source property.
  /// Note: When setting the `data` property of a `geojson` source, this method never returns an error.
  /// In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
  ///
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @param value The style source property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleSourceProperty(sourceId: String, property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets style source properties.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return The style source properties or a string describing an error if the operation was not successful.
  func getStyleSourceProperties(sourceId: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Sets style source properties.
  ///
  /// This method can be used to perform batch update for a style source properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
  /// Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
  ///
  /// @param sourceId A style source identifier.
  /// @param properties A map of Style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleSourceProperties(sourceId: String, properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
  ///
  /// @param sourceId A style source identifier.
  /// @param image An `image`.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func updateStyleImageSourceImage(sourceId: String, image: MbxImage, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes an existing style source.
  ///
  /// @param sourceId An identifier of the style source to remove.
  func removeStyleSource(sourceId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks whether a given style source exists.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return `true` if the given source exists, `false` otherwise.
  func styleSourceExists(sourceId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Returns the existing style sources.
  ///
  /// @return The list containing the information about existing style source objects.
  func getStyleSources(completion: @escaping (Result<[StyleObjectInfo?], Error>) -> Void)
  /// Returns an ordered list of the current style lights.
  func getStyleLights() throws -> [StyleObjectInfo?]
  /// Set global directional lightning.
  ///
  /// @param flatLight The flat light source.
  func setLight(flatLight: FlatLight) throws
  /// Set dynamic lightning.
  ///
  /// @param ambientLight The ambient light source.
  /// @param directionalLight The directional light source.
  func setLights(ambientLight: AmbientLight, directionalLight: DirectionalLight) throws
  /// Gets the value of a style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @return The style light property value.
  func getStyleLightProperty(id: String, property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to the the style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @param value The style light property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleLightProperty(id: String, property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
  ///
  /// @param properties A map of style terrain properties values, with their names as a key.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleTerrain(properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the value of a style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @return The style terrain property value.
  func getStyleTerrainProperty(property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to the the style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @param value The style terrain property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleTerrainProperty(property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Get an `image` from the style.
  ///
  /// @param imageId The identifier of the `image`.
  ///
  /// @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
  func getStyleImage(imageId: String, completion: @escaping (Result<MbxImage?, Error>) -> Void)
  /// Adds an image to be used in the style. This API can also be used for updating
  /// an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
  ///
  /// The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
  /// [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
  /// [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
  /// [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
  ///
  /// @param imageId An identifier of the image.
  /// @param scale A scale factor for the image.
  /// @param image A pixel data of the image.
  /// @param sdf An option to treat whether image is SDF(signed distance field) or not.
  /// @param stretchX An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched horizontally.
  /// @param stretchY An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched vertically.
  /// @param content An array of four numbers, with the first two specifying the left, top
  /// corner, and the last two specifying the right, bottom corner. If present, and if the
  /// icon uses icon-text-fit, the symbol's text will be fit inside the content box.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func addStyleImage(imageId: String, scale: Double, image: MbxImage, sdf: Bool, stretchX: [ImageStretches?], stretchY: [ImageStretches?], content: ImageContent?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes an image from the style.
  ///
  /// @param imageId The identifier of the image to remove.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func removeStyleImage(imageId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks whether an image exists.
  ///
  /// @param imageId The identifier of the image.
  ///
  /// @return True if image exists, false otherwise.
  func hasStyleImage(imageId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Set tile data of a custom geometry.
  ///
  /// @param sourceId A style source identifier.
  /// @param tileId A `canonical tile id` of the tile.
  /// @param featureCollection An array with the features to add.
  /// Invalidate tile for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier,.
  /// @param tileId A `canonical tile id` of the tile.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func invalidateStyleCustomGeometrySourceTile(sourceId: String, tileId: CanonicalTileID, completion: @escaping (Result<Void, Error>) -> Void)
  /// Invalidate region for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier
  /// @param bounds A `coordinate bounds` object.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func invalidateStyleCustomGeometrySourceRegion(sourceId: String, bounds: CoordinateBounds, completion: @escaping (Result<Void, Error>) -> Void)
  /// Check if the style is completely loaded.
  ///
  /// Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
  /// Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
  ///
  /// @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
  ///
  func isStyleLoaded(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Function to get the projection provided by the Style Extension.
  ///
  /// @return Projection that is currently applied to the map
  func getProjection() throws -> StyleProjection?
  /// Function to set the projection provided by the Style Extension.
  ///
  /// @param projection The projection to be set.
  func setProjection(projection: StyleProjection) throws
  /// Function to localize style labels.
  ///
  /// @param locale The locale to apply for localization
  /// @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
  func localizeLabels(locale: String, layerIds: [String]?, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class StyleManagerSetup {
  /// The codec used by StyleManager.
  static var codec: FlutterStandardMessageCodec { StyleManagerCodec.shared }
  /// Sets up an instance of `StyleManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: StyleManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Get the URI of the current style in use.
    ///
    /// @return A string containing a style URI.
    let getStyleURIChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleURIChannel.setMessageHandler { _, reply in
        api.getStyleURI { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleURIChannel.setMessageHandler(nil)
    }
    /// Load style from provided URI.
    ///
    /// This is an asynchronous call. To check the result of this operation the user must register an observer observing
    /// `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
    ///
    /// @param uri URI where the style should be loaded from.
    let setStyleURIChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleURIChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let uriArg = args[0] as! String
        api.setStyleURI(uri: uriArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleURIChannel.setMessageHandler(nil)
    }
    /// Get the JSON serialization string of the current style in use.
    ///
    /// @return A JSON string containing a serialized style.
    let getStyleJSONChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleJSONChannel.setMessageHandler { _, reply in
        api.getStyleJSON { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleJSONChannel.setMessageHandler(nil)
    }
    /// Load the style from a provided JSON string.
    ///
    /// @param json A JSON string containing a serialized style.
    let setStyleJSONChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleJSONChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonArg = args[0] as! String
        api.setStyleJSON(json: jsonArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleJSONChannel.setMessageHandler(nil)
    }
    /// Returns the map style's default camera, if any, or a default camera otherwise.
    /// The map style's default camera is defined as follows:
    /// - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
    /// - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
    /// - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
    /// - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
    ///
    /// The style default camera is re-evaluated when a new style is loaded.
    ///
    /// @return The default `camera options` of the current style in use.
    let getStyleDefaultCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleDefaultCameraChannel.setMessageHandler { _, reply in
        api.getStyleDefaultCamera { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleDefaultCameraChannel.setMessageHandler(nil)
    }
    /// Returns the map style's transition options. By default, the style parser will attempt
    /// to read the style default transition options, if any, fallbacking to an immediate transition
    /// otherwise. Transition options can be overriden via `setStyleTransition`, but the options are
    /// reset once a new style has been loaded.
    ///
    /// The style transition is re-evaluated when a new style is loaded.
    ///
    /// @return The `transition options` of the current style in use.
    let getStyleTransitionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleTransitionChannel.setMessageHandler { _, reply in
        api.getStyleTransition { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleTransitionChannel.setMessageHandler(nil)
    }
    /// Returns the list containing information about existing style import objects.
    let getStyleImportsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImports\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getStyleImports()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportsChannel.setMessageHandler(nil)
    }
    /// Removes an existing style import.
    ///
    /// @param importId Identifier of the style import to remove.
    let removeStyleImportChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImport\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleImportChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        do {
          try api.removeStyleImport(importId: importIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStyleImportChannel.setMessageHandler(nil)
    }
    /// Gets the style import schema.
    ///
    /// @param importId Identifier of the style import.
    ///
    /// Returns the style import schema, containing the default configurations for the style import.
    let getStyleImportSchemaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportSchema\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportSchemaChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        do {
          let result = try api.getStyleImportSchema(importId: importIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportSchemaChannel.setMessageHandler(nil)
    }
    /// Gets style import config.
    ///
    /// @param importId Identifier of the style import.
    ///
    /// Returns the style import configuration or a string describing an error if the operation was not successful.
    let getStyleImportConfigPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportConfigPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        do {
          let result = try api.getStyleImportConfigProperties(importId: importIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportConfigPropertiesChannel.setMessageHandler(nil)
    }
    /// Gets the value of style import config.
    ///
    /// @param importId Identifier of the style import.
    /// @param config The style import config name.
    ///
    /// Returns the style import configuration or a string describing an error if the operation was not successful.
    let getStyleImportConfigPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportConfigPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        let configArg = args[1] as! String
        do {
          let result = try api.getStyleImportConfigProperty(importId: importIdArg, config: configArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportConfigPropertyChannel.setMessageHandler(nil)
    }
    /// Sets style import config.
    /// This method can be used to perform batch update for a style import configurations.
    ///
    /// @param importId Identifier of the style import.
    /// @param configs A map of style import configurations.
    let setStyleImportConfigPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleImportConfigPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        let configsArg = args[1] as! [String: Any]
        do {
          try api.setStyleImportConfigProperties(importId: importIdArg, configs: configsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setStyleImportConfigPropertiesChannel.setMessageHandler(nil)
    }
    /// Sets a value to a style import config.
    ///
    /// @param importId Identifier of the style import.
    /// @param config The style import config name.
    /// @param value The style import config value.
    let setStyleImportConfigPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleImportConfigPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        let configArg = args[1] as! String
        let valueArg = args[2]!
        do {
          try api.setStyleImportConfigProperty(importId: importIdArg, config: configArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setStyleImportConfigPropertyChannel.setMessageHandler(nil)
    }
    /// Overrides the map style's transition options with user-provided options.
    ///
    /// The style transition is re-evaluated when a new style is loaded.
    ///
    /// @param transitionOptions The `transition options`.
    let setStyleTransitionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleTransitionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let transitionOptionsArg = args[0] as! TransitionOptions
        api.setStyleTransition(transitionOptions: transitionOptionsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleTransitionChannel.setMessageHandler(nil)
    }
    /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
    ///
    /// Runtime style layers are valid until they are either removed or a new style is loaded.
    ///
    /// @param properties A map of style layer properties.
    /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let addStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertiesArg = args[0] as! String
        let layerPositionArg: LayerPosition? = nilOrValue(args[1])
        api.addStyleLayer(properties: propertiesArg, layerPosition: layerPositionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleLayerChannel.setMessageHandler(nil)
    }
    /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
    ///
    /// Whenever a new style is being parsed and currently used style has persistent layers,
    /// an engine will try to do following:
    ///   - keep the persistent layer at its relative position
    ///   - keep the source used by a persistent layer
    ///   - keep images added through `addStyleImage` method
    ///
    /// In cases when a new style has the same layer, source or image resource, style's resources would be
    /// used instead and `MapLoadingError` event will be emitted.
    ///
    /// @param properties A map of style layer properties.
    /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let addPersistentStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addPersistentStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertiesArg = args[0] as! String
        let layerPositionArg: LayerPosition? = nilOrValue(args[1])
        api.addPersistentStyleLayer(properties: propertiesArg, layerPosition: layerPositionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addPersistentStyleLayerChannel.setMessageHandler(nil)
    }
    /// Checks if a style layer is persistent.
    ///
    /// @param layerId A style layer identifier.
    /// @return A string describing an error if the operation was not successful, boolean representing state otherwise.
    let isStyleLayerPersistentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isStyleLayerPersistentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.isStyleLayerPersistent(layerId: layerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isStyleLayerPersistentChannel.setMessageHandler(nil)
    }
    /// Removes an existing style layer.
    ///
    /// @param layerId An identifier of the style layer to remove.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let removeStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.removeStyleLayer(layerId: layerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleLayerChannel.setMessageHandler(nil)
    }
    /// Moves an existing style layer
    ///
    /// @param layerId Identifier of the style layer to move.
    /// @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
    ///                      is provided then the layer is moved to the top of the layerstack.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let moveStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      moveStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let layerPositionArg: LayerPosition? = nilOrValue(args[1])
        api.moveStyleLayer(layerId: layerIdArg, layerPosition: layerPositionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      moveStyleLayerChannel.setMessageHandler(nil)
    }
    /// Checks whether a given style layer exists.
    ///
    /// @param layerId Style layer identifier.
    ///
    /// @return A `true` value if the given style layer exists, `false` otherwise.
    let styleLayerExistsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      styleLayerExistsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.styleLayerExists(layerId: layerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      styleLayerExistsChannel.setMessageHandler(nil)
    }
    /// Returns the existing style layers.
    ///
    /// @return The list containing the information about existing style layer objects.
    let getStyleLayersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLayersChannel.setMessageHandler { _, reply in
        api.getStyleLayers { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLayersChannel.setMessageHandler(nil)
    }
    /// Gets the value of style layer property.
    ///
    /// @param layerId A style layer identifier.
    /// @param property The style layer property name.
    /// @return The `style property value`.
    let getStyleLayerPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLayerPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        api.getStyleLayerProperty(layerId: layerIdArg, property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLayerPropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to a style layer property.
    ///
    /// @param layerId A style layer identifier.
    /// @param property The style layer property name.
    /// @param value The style layer property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleLayerPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleLayerPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        let valueArg = args[2]!
        api.setStyleLayerProperty(layerId: layerIdArg, property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleLayerPropertyChannel.setMessageHandler(nil)
    }
    /// Gets style layer properties.
    ///
    /// @return The style layer properties or a string describing an error if the operation was not successful.
    let getStyleLayerPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLayerPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.getStyleLayerProperties(layerId: layerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLayerPropertiesChannel.setMessageHandler(nil)
    }
    /// Sets style layer properties.
    /// This method can be used to perform batch update for a style layer properties. The structure of a
    /// provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
    /// Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
    ///
    /// @param layerId A style layer identifier.
    /// @param properties A map of style layer properties.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleLayerPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleLayerPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let propertiesArg = args[1] as! String
        api.setStyleLayerProperties(layerId: layerIdArg, properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleLayerPropertiesChannel.setMessageHandler(nil)
    }
    /// Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
    ///
    /// @param sourceId An identifier for the style source.
    /// @param properties A map of style source properties.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let addStyleSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertiesArg = args[1] as! String
        api.addStyleSource(sourceId: sourceIdArg, properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleSourceChannel.setMessageHandler(nil)
    }
    /// Gets the value of style source property.
    ///
    /// @param sourceId A style source identifier.
    /// @param property The style source property name.
    /// @return The value of a `property` in the source with a `sourceId`.
    let getStyleSourcePropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleSourcePropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        api.getStyleSourceProperty(sourceId: sourceIdArg, property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleSourcePropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to a style source property.
    /// Note: When setting the `data` property of a `geojson` source, this method never returns an error.
    /// In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
    ///
    ///
    /// @param sourceId A style source identifier.
    /// @param property The style source property name.
    /// @param value The style source property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleSourcePropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleSourcePropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        let valueArg = args[2]!
        api.setStyleSourceProperty(sourceId: sourceIdArg, property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleSourcePropertyChannel.setMessageHandler(nil)
    }
    /// Gets style source properties.
    ///
    /// @param sourceId A style source identifier.
    ///
    /// @return The style source properties or a string describing an error if the operation was not successful.
    let getStyleSourcePropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleSourcePropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        api.getStyleSourceProperties(sourceId: sourceIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleSourcePropertiesChannel.setMessageHandler(nil)
    }
    /// Sets style source properties.
    ///
    /// This method can be used to perform batch update for a style source properties. The structure of a
    /// provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
    /// Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
    ///
    /// @param sourceId A style source identifier.
    /// @param properties A map of Style source properties.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleSourcePropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleSourcePropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertiesArg = args[1] as! String
        api.setStyleSourceProperties(sourceId: sourceIdArg, properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleSourcePropertiesChannel.setMessageHandler(nil)
    }
    /// Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
    ///
    /// @param sourceId A style source identifier.
    /// @param image An `image`.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let updateStyleImageSourceImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateStyleImageSourceImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let imageArg = args[1] as! MbxImage
        api.updateStyleImageSourceImage(sourceId: sourceIdArg, image: imageArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateStyleImageSourceImageChannel.setMessageHandler(nil)
    }
    /// Removes an existing style source.
    ///
    /// @param sourceId An identifier of the style source to remove.
    let removeStyleSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        api.removeStyleSource(sourceId: sourceIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleSourceChannel.setMessageHandler(nil)
    }
    /// Checks whether a given style source exists.
    ///
    /// @param sourceId A style source identifier.
    ///
    /// @return `true` if the given source exists, `false` otherwise.
    let styleSourceExistsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      styleSourceExistsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        api.styleSourceExists(sourceId: sourceIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      styleSourceExistsChannel.setMessageHandler(nil)
    }
    /// Returns the existing style sources.
    ///
    /// @return The list containing the information about existing style source objects.
    let getStyleSourcesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleSourcesChannel.setMessageHandler { _, reply in
        api.getStyleSources { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleSourcesChannel.setMessageHandler(nil)
    }
    /// Returns an ordered list of the current style lights.
    let getStyleLightsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLights\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLightsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getStyleLights()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleLightsChannel.setMessageHandler(nil)
    }
    /// Set global directional lightning.
    ///
    /// @param flatLight The flat light source.
    let setLightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLight\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let flatLightArg = args[0] as! FlatLight
        do {
          try api.setLight(flatLight: flatLightArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLightChannel.setMessageHandler(nil)
    }
    /// Set dynamic lightning.
    ///
    /// @param ambientLight The ambient light source.
    /// @param directionalLight The directional light source.
    let setLightsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLights\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLightsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let ambientLightArg = args[0] as! AmbientLight
        let directionalLightArg = args[1] as! DirectionalLight
        do {
          try api.setLights(ambientLight: ambientLightArg, directionalLight: directionalLightArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLightsChannel.setMessageHandler(nil)
    }
    /// Gets the value of a style light property.
    ///
    /// @param property The style light property name.
    /// @param id The unique identifier of the style light in lights list.
    /// @return The style light property value.
    let getStyleLightPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLightPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let propertyArg = args[1] as! String
        api.getStyleLightProperty(id: idArg, property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLightPropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to the the style light property.
    ///
    /// @param property The style light property name.
    /// @param id The unique identifier of the style light in lights list.
    /// @param value The style light property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleLightPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleLightPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let propertyArg = args[1] as! String
        let valueArg = args[2]!
        api.setStyleLightProperty(id: idArg, property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleLightPropertyChannel.setMessageHandler(nil)
    }
    /// Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
    ///
    /// @param properties A map of style terrain properties values, with their names as a key.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleTerrainChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleTerrainChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertiesArg = args[0] as! String
        api.setStyleTerrain(properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleTerrainChannel.setMessageHandler(nil)
    }
    /// Gets the value of a style terrain property.
    ///
    /// @param property The style terrain property name.
    /// @return The style terrain property value.
    let getStyleTerrainPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleTerrainPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertyArg = args[0] as! String
        api.getStyleTerrainProperty(property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleTerrainPropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to the the style terrain property.
    ///
    /// @param property The style terrain property name.
    /// @param value The style terrain property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleTerrainPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleTerrainPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertyArg = args[0] as! String
        let valueArg = args[1]!
        api.setStyleTerrainProperty(property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleTerrainPropertyChannel.setMessageHandler(nil)
    }
    /// Get an `image` from the style.
    ///
    /// @param imageId The identifier of the `image`.
    ///
    /// @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
    let getStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        api.getStyleImage(imageId: imageIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleImageChannel.setMessageHandler(nil)
    }
    /// Adds an image to be used in the style. This API can also be used for updating
    /// an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
    ///
    /// The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
    /// [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
    /// [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
    /// [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
    ///
    /// @param imageId An identifier of the image.
    /// @param scale A scale factor for the image.
    /// @param image A pixel data of the image.
    /// @param sdf An option to treat whether image is SDF(signed distance field) or not.
    /// @param stretchX An array of two-element arrays, consisting of two numbers that represent
    /// the from position and the to position of areas that can be stretched horizontally.
    /// @param stretchY An array of two-element arrays, consisting of two numbers that represent
    /// the from position and the to position of areas that can be stretched vertically.
    /// @param content An array of four numbers, with the first two specifying the left, top
    /// corner, and the last two specifying the right, bottom corner. If present, and if the
    /// icon uses icon-text-fit, the symbol's text will be fit inside the content box.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let addStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        let scaleArg = args[1] as! Double
        let imageArg = args[2] as! MbxImage
        let sdfArg = args[3] as! Bool
        let stretchXArg = args[4] as! [ImageStretches?]
        let stretchYArg = args[5] as! [ImageStretches?]
        let contentArg: ImageContent? = nilOrValue(args[6])
        api.addStyleImage(imageId: imageIdArg, scale: scaleArg, image: imageArg, sdf: sdfArg, stretchX: stretchXArg, stretchY: stretchYArg, content: contentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleImageChannel.setMessageHandler(nil)
    }
    /// Removes an image from the style.
    ///
    /// @param imageId The identifier of the image to remove.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let removeStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        api.removeStyleImage(imageId: imageIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleImageChannel.setMessageHandler(nil)
    }
    /// Checks whether an image exists.
    ///
    /// @param imageId The identifier of the image.
    ///
    /// @return True if image exists, false otherwise.
    let hasStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        api.hasStyleImage(imageId: imageIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      hasStyleImageChannel.setMessageHandler(nil)
    }
    /// Set tile data of a custom geometry.
    ///
    /// @param sourceId A style source identifier.
    /// @param tileId A `canonical tile id` of the tile.
    /// @param featureCollection An array with the features to add.
    /// Invalidate tile for provided custom geometry source.
    ///
    /// @param sourceId A style source identifier,.
    /// @param tileId A `canonical tile id` of the tile.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let invalidateStyleCustomGeometrySourceTileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      invalidateStyleCustomGeometrySourceTileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let tileIdArg = args[1] as! CanonicalTileID
        api.invalidateStyleCustomGeometrySourceTile(sourceId: sourceIdArg, tileId: tileIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      invalidateStyleCustomGeometrySourceTileChannel.setMessageHandler(nil)
    }
    /// Invalidate region for provided custom geometry source.
    ///
    /// @param sourceId A style source identifier
    /// @param bounds A `coordinate bounds` object.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let invalidateStyleCustomGeometrySourceRegionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      invalidateStyleCustomGeometrySourceRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let boundsArg = args[1] as! CoordinateBounds
        api.invalidateStyleCustomGeometrySourceRegion(sourceId: sourceIdArg, bounds: boundsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      invalidateStyleCustomGeometrySourceRegionChannel.setMessageHandler(nil)
    }
    /// Check if the style is completely loaded.
    ///
    /// Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
    /// Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
    ///
    /// @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
    ///
    let isStyleLoadedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isStyleLoadedChannel.setMessageHandler { _, reply in
        api.isStyleLoaded { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isStyleLoadedChannel.setMessageHandler(nil)
    }
    /// Function to get the projection provided by the Style Extension.
    ///
    /// @return Projection that is currently applied to the map
    let getProjectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getProjectionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getProjection()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getProjectionChannel.setMessageHandler(nil)
    }
    /// Function to set the projection provided by the Style Extension.
    ///
    /// @param projection The projection to be set.
    let setProjectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setProjectionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let projectionArg = args[0] as! StyleProjection
        do {
          try api.setProjection(projection: projectionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setProjectionChannel.setMessageHandler(nil)
    }
    /// Function to localize style labels.
    ///
    /// @param locale The locale to apply for localization
    /// @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
    let localizeLabelsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      localizeLabelsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let localeArg = args[0] as! String
        let layerIdsArg: [String]? = nilOrValue(args[1])
        api.localizeLabels(locale: localeArg, layerIds: layerIdsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      localizeLabelsChannel.setMessageHandler(nil)
    }
  }
}
/// Allows to cancel the associated asynchronous operation
///
/// The the associated asynchronous operation is not automatically canceled if this
/// object goes out of scope.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Cancelable {
  /// Cancels the associated asynchronous operation
  ///
  /// If the associated asynchronous operation has already finished, this call is ignored.
  func cancel() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CancelableSetup {
  /// The codec used by Cancelable.
  /// Sets up an instance of `Cancelable` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Cancelable?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Cancels the associated asynchronous operation
    ///
    /// If the associated asynchronous operation has already finished, this call is ignored.
    let cancelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      cancelChannel.setMessageHandler { _, reply in
        do {
          try api.cancel()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelChannel.setMessageHandler(nil)
    }
  }
}
/// Instance that allows connecting or disconnecting the Mapbox stack to the network.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol OfflineSwitch {
  /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
  /// with HttpRequestErrorType#ConnectionError.
  ///
  /// @param connected Set false to disconnect the Mapbox stack
  func setMapboxStackConnected(connected: Bool) throws
  /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
  ///
  /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
  func isMapboxStackConnected() throws -> Bool
  /// Releases the OfflineSwitch singleton instance.
  ///
  /// Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
  /// If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
  func reset() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class OfflineSwitchSetup {
  /// The codec used by OfflineSwitch.
  /// Sets up an instance of `OfflineSwitch` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: OfflineSwitch?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
    /// with HttpRequestErrorType#ConnectionError.
    ///
    /// @param connected Set false to disconnect the Mapbox stack
    let setMapboxStackConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.setMapboxStackConnected\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      setMapboxStackConnectedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let connectedArg = args[0] as! Bool
        do {
          try api.setMapboxStackConnected(connected: connectedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMapboxStackConnectedChannel.setMessageHandler(nil)
    }
    /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
    ///
    /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
    let isMapboxStackConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.isMapboxStackConnected\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      isMapboxStackConnectedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isMapboxStackConnected()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isMapboxStackConnectedChannel.setMessageHandler(nil)
    }
    /// Releases the OfflineSwitch singleton instance.
    ///
    /// Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
    /// If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
    let resetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.reset\(channelSuffix)", binaryMessenger: binaryMessenger)
    if let api = api {
      resetChannel.setMessageHandler { _, reply in
        do {
          try api.reset()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      resetChannel.setMessageHandler(nil)
    }
  }
}
/// A bundle that encapsulates tilesets creation for the tile store implementation.
///
/// Tileset descriptors describe the type of data that should be part of the Offline Region, like the routing profile for Navigation and the Tilesets of the Map style.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol TilesetDescriptor {
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class TilesetDescriptorSetup {
  /// The codec used by TilesetDescriptor.
  /// Sets up an instance of `TilesetDescriptor` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: TilesetDescriptor?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
}
