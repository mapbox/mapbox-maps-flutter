// Autogenerated from Pigeon (v18.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Orientation of circle when map is pitched.
enum CirclePitchAlignment: Int {
  /// The circle is aligned to the plane of the map.
  case mAP = 0
  /// The circle is aligned to the plane of the viewport.
  case vIEWPORT = 1
}

/// Controls the scaling behavior of the circle when the map is pitched.
enum CirclePitchScale: Int {
  /// Circles are scaled according to their apparent distance to the camera.
  case mAP = 0
  /// Circles are not scaled.
  case vIEWPORT = 1
}

/// Controls the frame of reference for `circle-translate`.
enum CircleTranslateAnchor: Int {
  /// The circle is translated relative to the map.
  case mAP = 0
  /// The circle is translated relative to the viewport.
  case vIEWPORT = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct CircleAnnotation {
  /// The id for annotation
  var id: String
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.
  var circleSortKey: Double?
  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.
  var circleBlur: Double?
  /// The fill color of the circle.
  var circleColor: Int64?
  /// The opacity at which the circle will be drawn.
  var circleOpacity: Double?
  /// Circle radius.
  var circleRadius: Double?
  /// The stroke color of the circle.
  var circleStrokeColor: Int64?
  /// The opacity of the circle's stroke.
  var circleStrokeOpacity: Double?
  /// The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.
  var circleStrokeWidth: Double?

  static func fromList(_ list: [Any?]) -> CircleAnnotation? {
    let id = list[0] as! String
    let geometry = Point.fromList(list[1] as! [Any?])!
    let circleSortKey: Double? = nilOrValue(list[2])
    let circleBlur: Double? = nilOrValue(list[3])
    let circleColor: Int64? = isNullish(list[4]) ? nil : (list[4] is Int64? ? list[4] as! Int64? : Int64(list[4] as! Int32))
    let circleOpacity: Double? = nilOrValue(list[5])
    let circleRadius: Double? = nilOrValue(list[6])
    let circleStrokeColor: Int64? = isNullish(list[7]) ? nil : (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))
    let circleStrokeOpacity: Double? = nilOrValue(list[8])
    let circleStrokeWidth: Double? = nilOrValue(list[9])

    return CircleAnnotation(
      id: id,
      geometry: geometry,
      circleSortKey: circleSortKey,
      circleBlur: circleBlur,
      circleColor: circleColor,
      circleOpacity: circleOpacity,
      circleRadius: circleRadius,
      circleStrokeColor: circleStrokeColor,
      circleStrokeOpacity: circleStrokeOpacity,
      circleStrokeWidth: circleStrokeWidth
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      geometry.toList(),
      circleSortKey,
      circleBlur,
      circleColor,
      circleOpacity,
      circleRadius,
      circleStrokeColor,
      circleStrokeOpacity,
      circleStrokeWidth,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct CircleAnnotationOptions {
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.
  var circleSortKey: Double?
  /// Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.
  var circleBlur: Double?
  /// The fill color of the circle.
  var circleColor: Int64?
  /// The opacity at which the circle will be drawn.
  var circleOpacity: Double?
  /// Circle radius.
  var circleRadius: Double?
  /// The stroke color of the circle.
  var circleStrokeColor: Int64?
  /// The opacity of the circle's stroke.
  var circleStrokeOpacity: Double?
  /// The width of the circle's stroke. Strokes are placed outside of the `circle-radius`.
  var circleStrokeWidth: Double?

  static func fromList(_ list: [Any?]) -> CircleAnnotationOptions? {
    let geometry = Point.fromList(list[0] as! [Any?])!
    let circleSortKey: Double? = nilOrValue(list[1])
    let circleBlur: Double? = nilOrValue(list[2])
    let circleColor: Int64? = isNullish(list[3]) ? nil : (list[3] is Int64? ? list[3] as! Int64? : Int64(list[3] as! Int32))
    let circleOpacity: Double? = nilOrValue(list[4])
    let circleRadius: Double? = nilOrValue(list[5])
    let circleStrokeColor: Int64? = isNullish(list[6]) ? nil : (list[6] is Int64? ? list[6] as! Int64? : Int64(list[6] as! Int32))
    let circleStrokeOpacity: Double? = nilOrValue(list[7])
    let circleStrokeWidth: Double? = nilOrValue(list[8])

    return CircleAnnotationOptions(
      geometry: geometry,
      circleSortKey: circleSortKey,
      circleBlur: circleBlur,
      circleColor: circleColor,
      circleOpacity: circleOpacity,
      circleRadius: circleRadius,
      circleStrokeColor: circleStrokeColor,
      circleStrokeOpacity: circleStrokeOpacity,
      circleStrokeWidth: circleStrokeWidth
    )
  }
  func toList() -> [Any?] {
    return [
      geometry.toList(),
      circleSortKey,
      circleBlur,
      circleColor,
      circleOpacity,
      circleRadius,
      circleStrokeColor,
      circleStrokeOpacity,
      circleStrokeWidth,
    ]
  }
}
private class OnCircleAnnotationClickListenerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CircleAnnotation.fromList(self.readValue() as! [Any?])
    case 129:
      return Point.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class OnCircleAnnotationClickListenerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CircleAnnotation {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class OnCircleAnnotationClickListenerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return OnCircleAnnotationClickListenerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return OnCircleAnnotationClickListenerCodecWriter(data: data)
  }
}

class OnCircleAnnotationClickListenerCodec: FlutterStandardMessageCodec {
  static let shared = OnCircleAnnotationClickListenerCodec(readerWriter: OnCircleAnnotationClickListenerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnCircleAnnotationClickListenerProtocol {
  func onCircleAnnotationClick(annotation annotationArg: CircleAnnotation, completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class OnCircleAnnotationClickListener: OnCircleAnnotationClickListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: FlutterStandardMessageCodec {
    return OnCircleAnnotationClickListenerCodec.shared
  }
  func onCircleAnnotationClick(annotation annotationArg: CircleAnnotation, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnCircleAnnotationClickListener.onCircleAnnotationClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
private class _CircleAnnotationMessengerCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return CircleAnnotation.fromList(self.readValue() as! [Any?])
    case 129:
      return CircleAnnotation.fromList(self.readValue() as! [Any?])
    case 130:
      return CircleAnnotationOptions.fromList(self.readValue() as! [Any?])
    case 131:
      return CircleAnnotationOptions.fromList(self.readValue() as! [Any?])
    case 132:
      return Point.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class _CircleAnnotationMessengerCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CircleAnnotation {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? CircleAnnotation {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? CircleAnnotationOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? CircleAnnotationOptions {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? Point {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class _CircleAnnotationMessengerCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return _CircleAnnotationMessengerCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return _CircleAnnotationMessengerCodecWriter(data: data)
  }
}

class _CircleAnnotationMessengerCodec: FlutterStandardMessageCodec {
  static let shared = _CircleAnnotationMessengerCodec(readerWriter: _CircleAnnotationMessengerCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _CircleAnnotationMessenger {
  func create(managerId: String, annotationOption: CircleAnnotationOptions, completion: @escaping (Result<CircleAnnotation, Error>) -> Void)
  func createMulti(managerId: String, annotationOptions: [CircleAnnotationOptions], completion: @escaping (Result<[CircleAnnotation], Error>) -> Void)
  func update(managerId: String, annotation: CircleAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func delete(managerId: String, annotation: CircleAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func deleteAll(managerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func setCircleEmissiveStrength(managerId: String, circleEmissiveStrength: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getCircleEmissiveStrength(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setCirclePitchAlignment(managerId: String, circlePitchAlignment: CirclePitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getCirclePitchAlignment(managerId: String, completion: @escaping (Result<CirclePitchAlignment?, Error>) -> Void)
  func setCirclePitchScale(managerId: String, circlePitchScale: CirclePitchScale, completion: @escaping (Result<Void, Error>) -> Void)
  func getCirclePitchScale(managerId: String, completion: @escaping (Result<CirclePitchScale?, Error>) -> Void)
  func setCircleTranslate(managerId: String, circleTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getCircleTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setCircleTranslateAnchor(managerId: String, circleTranslateAnchor: CircleTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getCircleTranslateAnchor(managerId: String, completion: @escaping (Result<CircleTranslateAnchor?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _CircleAnnotationMessengerSetup {
  /// The codec used by _CircleAnnotationMessenger.
  static var codec: FlutterStandardMessageCodec { _CircleAnnotationMessengerCodec.shared }
  /// Sets up an instance of `_CircleAnnotationMessenger` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _CircleAnnotationMessenger?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionArg = args[1] as! CircleAnnotationOptions
        api.create(managerId: managerIdArg, annotationOption: annotationOptionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let createMultiChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.createMulti\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createMultiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionsArg = args[1] as! [CircleAnnotationOptions]
        api.createMulti(managerId: managerIdArg, annotationOptions: annotationOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createMultiChannel.setMessageHandler(nil)
    }
    let updateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.update\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! CircleAnnotation
        api.update(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateChannel.setMessageHandler(nil)
    }
    let deleteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.delete\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! CircleAnnotation
        api.delete(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteChannel.setMessageHandler(nil)
    }
    let deleteAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.deleteAll\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteAllChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.deleteAll(managerId: managerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteAllChannel.setMessageHandler(nil)
    }
    let setCircleEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.setCircleEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCircleEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let circleEmissiveStrengthArg = args[1] as! Double
        api.setCircleEmissiveStrength(managerId: managerIdArg, circleEmissiveStrength: circleEmissiveStrengthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCircleEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let getCircleEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.getCircleEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCircleEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getCircleEmissiveStrength(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCircleEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let setCirclePitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.setCirclePitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCirclePitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let circlePitchAlignmentArg = CirclePitchAlignment(rawValue: args[1] as! Int)!
        api.setCirclePitchAlignment(managerId: managerIdArg, circlePitchAlignment: circlePitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCirclePitchAlignmentChannel.setMessageHandler(nil)
    }
    let getCirclePitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.getCirclePitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCirclePitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getCirclePitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCirclePitchAlignmentChannel.setMessageHandler(nil)
    }
    let setCirclePitchScaleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.setCirclePitchScale\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCirclePitchScaleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let circlePitchScaleArg = CirclePitchScale(rawValue: args[1] as! Int)!
        api.setCirclePitchScale(managerId: managerIdArg, circlePitchScale: circlePitchScaleArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCirclePitchScaleChannel.setMessageHandler(nil)
    }
    let getCirclePitchScaleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.getCirclePitchScale\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCirclePitchScaleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getCirclePitchScale(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCirclePitchScaleChannel.setMessageHandler(nil)
    }
    let setCircleTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.setCircleTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCircleTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let circleTranslateArg = args[1] as! [Double?]
        api.setCircleTranslate(managerId: managerIdArg, circleTranslate: circleTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCircleTranslateChannel.setMessageHandler(nil)
    }
    let getCircleTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.getCircleTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCircleTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getCircleTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCircleTranslateChannel.setMessageHandler(nil)
    }
    let setCircleTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.setCircleTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCircleTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let circleTranslateAnchorArg = CircleTranslateAnchor(rawValue: args[1] as! Int)!
        api.setCircleTranslateAnchor(managerId: managerIdArg, circleTranslateAnchor: circleTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setCircleTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getCircleTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CircleAnnotationMessenger.getCircleTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCircleTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getCircleTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res?.rawValue))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCircleTranslateAnchorChannel.setMessageHandler(nil)
    }
  }
}
