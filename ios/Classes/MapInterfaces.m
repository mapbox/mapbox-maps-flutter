// Autogenerated from Pigeon (v16.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "MapInterfaces.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}

static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

/// Describes glyphs rasterization modes.
@implementation FLTGlyphsRasterizationModeBox
- (instancetype)initWithValue:(FLTGlyphsRasterizationMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the map context mode.
/// We can make some optimizations if we know that the drawing context is not shared with other code.
@implementation FLTContextModeBox
- (instancetype)initWithValue:(FLTContextMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes whether to constrain the map in both axes or only vertically e.g. while panning.
@implementation FLTConstrainModeBox
- (instancetype)initWithValue:(FLTConstrainMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards.
@implementation FLTViewportModeBox
- (instancetype)initWithValue:(FLTViewportMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the map orientation.
@implementation FLTNorthOrientationBox
- (instancetype)initWithValue:(FLTNorthOrientation)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Options for enabling debugging features in a map.
@implementation FLTMapDebugOptionsDataBox
- (instancetype)initWithValue:(FLTMapDebugOptionsData)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum describing how to place view annotation relatively to geometry.
@implementation FLTViewAnnotationAnchorBox
- (instancetype)initWithValue:(FLTViewAnnotationAnchor)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Type information of the variant's content
@implementation FLTTypeBox
- (instancetype)initWithValue:(FLTType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the reason for a style package download request failure.
@implementation FLTStylePackErrorTypeBox
- (instancetype)initWithValue:(FLTStylePackErrorType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the reason for an offline request response error.
@implementation FLTResponseErrorReasonBox
- (instancetype)initWithValue:(FLTResponseErrorReason)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the download state of a region.
@implementation FLTOfflineRegionDownloadStateBox
- (instancetype)initWithValue:(FLTOfflineRegionDownloadState)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes tile store usage modes.
@implementation FLTTileStoreUsageModeBox
- (instancetype)initWithValue:(FLTTileStoreUsageMode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the kind of a style property value.
@implementation FLTStylePropertyValueKindBox
- (instancetype)initWithValue:(FLTStylePropertyValueKind)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation FLTStyleProjectionNameBox
- (instancetype)initWithValue:(FLTStyleProjectionName)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Whether extruded geometries are lit relative to the map or viewport.
@implementation FLTAnchorBox
- (instancetype)initWithValue:(FLTAnchor)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// HTTP defines a set of request methods to indicate the desired action to be performed for a given resource.
@implementation FLTHttpMethodBox
- (instancetype)initWithValue:(FLTHttpMethod)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Classify network types based on cost.
@implementation FLTNetworkRestrictionBox
- (instancetype)initWithValue:(FLTNetworkRestriction)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum which describes possible error types which could happen during HTTP request/download calls.
@implementation FLTHttpRequestErrorTypeBox
- (instancetype)initWithValue:(FLTHttpRequestErrorType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum which represents different error cases which could happen during download session.
@implementation FLTDownloadErrorCodeBox
- (instancetype)initWithValue:(FLTDownloadErrorCode)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Enum representing state of download session.
@implementation FLTDownloadStateBox
- (instancetype)initWithValue:(FLTDownloadState)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the tiles data domain.
@implementation FLTTileDataDomainBox
- (instancetype)initWithValue:(FLTTileDataDomain)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

/// Describes the reason for a tile region download request failure.
@implementation FLTTileRegionErrorTypeBox
- (instancetype)initWithValue:(FLTTileRegionErrorType)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@implementation FLT_MapEventBox
- (instancetype)initWithValue:(FLT_MapEvent)value {
  self = [super init];
  if (self) {
    _value = value;
  }
  return self;
}
@end

@interface FLTMbxEdgeInsets ()
+ (FLTMbxEdgeInsets *)fromList:(NSArray *)list;
+ (nullable FLTMbxEdgeInsets *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraOptions ()
+ (FLTCameraOptions *)fromList:(NSArray *)list;
+ (nullable FLTCameraOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraState ()
+ (FLTCameraState *)fromList:(NSArray *)list;
+ (nullable FLTCameraState *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraBoundsOptions ()
+ (FLTCameraBoundsOptions *)fromList:(NSArray *)list;
+ (nullable FLTCameraBoundsOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCameraBounds ()
+ (FLTCameraBounds *)fromList:(NSArray *)list;
+ (nullable FLTCameraBounds *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapAnimationOptions ()
+ (FLTMapAnimationOptions *)fromList:(NSArray *)list;
+ (nullable FLTMapAnimationOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCoordinateBounds ()
+ (FLTCoordinateBounds *)fromList:(NSArray *)list;
+ (nullable FLTCoordinateBounds *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapDebugOptions ()
+ (FLTMapDebugOptions *)fromList:(NSArray *)list;
+ (nullable FLTMapDebugOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTGlyphsRasterizationOptions ()
+ (FLTGlyphsRasterizationOptions *)fromList:(NSArray *)list;
+ (nullable FLTGlyphsRasterizationOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTTileCacheBudgetInMegabytes ()
+ (FLTTileCacheBudgetInMegabytes *)fromList:(NSArray *)list;
+ (nullable FLTTileCacheBudgetInMegabytes *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTTileCacheBudgetInTiles ()
+ (FLTTileCacheBudgetInTiles *)fromList:(NSArray *)list;
+ (nullable FLTTileCacheBudgetInTiles *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMapOptions ()
+ (FLTMapOptions *)fromList:(NSArray *)list;
+ (nullable FLTMapOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTScreenCoordinate ()
+ (FLTScreenCoordinate *)fromList:(NSArray *)list;
+ (nullable FLTScreenCoordinate *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTScreenBox ()
+ (FLTScreenBox *)fromList:(NSArray *)list;
+ (nullable FLTScreenBox *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCoordinateBoundsZoom ()
+ (FLTCoordinateBoundsZoom *)fromList:(NSArray *)list;
+ (nullable FLTCoordinateBoundsZoom *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTSize ()
+ (FLTSize *)fromList:(NSArray *)list;
+ (nullable FLTSize *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTRenderedQueryOptions ()
+ (FLTRenderedQueryOptions *)fromList:(NSArray *)list;
+ (nullable FLTRenderedQueryOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTSourceQueryOptions ()
+ (FLTSourceQueryOptions *)fromList:(NSArray *)list;
+ (nullable FLTSourceQueryOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTFeatureExtensionValue ()
+ (FLTFeatureExtensionValue *)fromList:(NSArray *)list;
+ (nullable FLTFeatureExtensionValue *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTLayerPosition ()
+ (FLTLayerPosition *)fromList:(NSArray *)list;
+ (nullable FLTLayerPosition *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTQueriedRenderedFeature ()
+ (FLTQueriedRenderedFeature *)fromList:(NSArray *)list;
+ (nullable FLTQueriedRenderedFeature *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTQueriedSourceFeature ()
+ (FLTQueriedSourceFeature *)fromList:(NSArray *)list;
+ (nullable FLTQueriedSourceFeature *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTQueriedFeature ()
+ (FLTQueriedFeature *)fromList:(NSArray *)list;
+ (nullable FLTQueriedFeature *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTRenderedQueryGeometry ()
+ (FLTRenderedQueryGeometry *)fromList:(NSArray *)list;
+ (nullable FLTRenderedQueryGeometry *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTOfflineRegionGeometryDefinition ()
+ (FLTOfflineRegionGeometryDefinition *)fromList:(NSArray *)list;
+ (nullable FLTOfflineRegionGeometryDefinition *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTOfflineRegionTilePyramidDefinition ()
+ (FLTOfflineRegionTilePyramidDefinition *)fromList:(NSArray *)list;
+ (nullable FLTOfflineRegionTilePyramidDefinition *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTProjectedMeters ()
+ (FLTProjectedMeters *)fromList:(NSArray *)list;
+ (nullable FLTProjectedMeters *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMercatorCoordinate ()
+ (FLTMercatorCoordinate *)fromList:(NSArray *)list;
+ (nullable FLTMercatorCoordinate *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTStyleObjectInfo ()
+ (FLTStyleObjectInfo *)fromList:(NSArray *)list;
+ (nullable FLTStyleObjectInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTStyleProjection ()
+ (FLTStyleProjection *)fromList:(NSArray *)list;
+ (nullable FLTStyleProjection *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTFlatLight ()
+ (FLTFlatLight *)fromList:(NSArray *)list;
+ (nullable FLTFlatLight *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTDirectionalLight ()
+ (FLTDirectionalLight *)fromList:(NSArray *)list;
+ (nullable FLTDirectionalLight *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTAmbientLight ()
+ (FLTAmbientLight *)fromList:(NSArray *)list;
+ (nullable FLTAmbientLight *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTMbxImage ()
+ (FLTMbxImage *)fromList:(NSArray *)list;
+ (nullable FLTMbxImage *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTImageStretches ()
+ (FLTImageStretches *)fromList:(NSArray *)list;
+ (nullable FLTImageStretches *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTImageContent ()
+ (FLTImageContent *)fromList:(NSArray *)list;
+ (nullable FLTImageContent *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTTransitionOptions ()
+ (FLTTransitionOptions *)fromList:(NSArray *)list;
+ (nullable FLTTransitionOptions *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTCanonicalTileID ()
+ (FLTCanonicalTileID *)fromList:(NSArray *)list;
+ (nullable FLTCanonicalTileID *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface FLTStylePropertyValue ()
+ (FLTStylePropertyValue *)fromList:(NSArray *)list;
+ (nullable FLTStylePropertyValue *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation FLTMbxEdgeInsets
+ (instancetype)makeWithTop:(double )top
    left:(double )left
    bottom:(double )bottom
    right:(double )right {
  FLTMbxEdgeInsets* pigeonResult = [[FLTMbxEdgeInsets alloc] init];
  pigeonResult.top = top;
  pigeonResult.left = left;
  pigeonResult.bottom = bottom;
  pigeonResult.right = right;
  return pigeonResult;
}
+ (FLTMbxEdgeInsets *)fromList:(NSArray *)list {
  FLTMbxEdgeInsets *pigeonResult = [[FLTMbxEdgeInsets alloc] init];
  pigeonResult.top = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.left = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.bottom = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.right = [GetNullableObjectAtIndex(list, 3) doubleValue];
  return pigeonResult;
}
+ (nullable FLTMbxEdgeInsets *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMbxEdgeInsets fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.top),
    @(self.left),
    @(self.bottom),
    @(self.right),
  ];
}
@end

@implementation FLTCameraOptions
+ (instancetype)makeWithCenter:(nullable NSDictionary<NSString *, id> *)center
    padding:(nullable FLTMbxEdgeInsets *)padding
    anchor:(nullable FLTScreenCoordinate *)anchor
    zoom:(nullable NSNumber *)zoom
    bearing:(nullable NSNumber *)bearing
    pitch:(nullable NSNumber *)pitch {
  FLTCameraOptions* pigeonResult = [[FLTCameraOptions alloc] init];
  pigeonResult.center = center;
  pigeonResult.padding = padding;
  pigeonResult.anchor = anchor;
  pigeonResult.zoom = zoom;
  pigeonResult.bearing = bearing;
  pigeonResult.pitch = pitch;
  return pigeonResult;
}
+ (FLTCameraOptions *)fromList:(NSArray *)list {
  FLTCameraOptions *pigeonResult = [[FLTCameraOptions alloc] init];
  pigeonResult.center = GetNullableObjectAtIndex(list, 0);
  pigeonResult.padding = [FLTMbxEdgeInsets nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  pigeonResult.anchor = [FLTScreenCoordinate nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  pigeonResult.zoom = GetNullableObjectAtIndex(list, 3);
  pigeonResult.bearing = GetNullableObjectAtIndex(list, 4);
  pigeonResult.pitch = GetNullableObjectAtIndex(list, 5);
  return pigeonResult;
}
+ (nullable FLTCameraOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.center ?: [NSNull null],
    (self.padding ? [self.padding toList] : [NSNull null]),
    (self.anchor ? [self.anchor toList] : [NSNull null]),
    self.zoom ?: [NSNull null],
    self.bearing ?: [NSNull null],
    self.pitch ?: [NSNull null],
  ];
}
@end

@implementation FLTCameraState
+ (instancetype)makeWithCenter:(NSDictionary<NSString *, id> *)center
    padding:(FLTMbxEdgeInsets *)padding
    zoom:(double )zoom
    bearing:(double )bearing
    pitch:(double )pitch {
  FLTCameraState* pigeonResult = [[FLTCameraState alloc] init];
  pigeonResult.center = center;
  pigeonResult.padding = padding;
  pigeonResult.zoom = zoom;
  pigeonResult.bearing = bearing;
  pigeonResult.pitch = pitch;
  return pigeonResult;
}
+ (FLTCameraState *)fromList:(NSArray *)list {
  FLTCameraState *pigeonResult = [[FLTCameraState alloc] init];
  pigeonResult.center = GetNullableObjectAtIndex(list, 0);
  pigeonResult.padding = [FLTMbxEdgeInsets nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  pigeonResult.zoom = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.bearing = [GetNullableObjectAtIndex(list, 3) doubleValue];
  pigeonResult.pitch = [GetNullableObjectAtIndex(list, 4) doubleValue];
  return pigeonResult;
}
+ (nullable FLTCameraState *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraState fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.center ?: [NSNull null],
    (self.padding ? [self.padding toList] : [NSNull null]),
    @(self.zoom),
    @(self.bearing),
    @(self.pitch),
  ];
}
@end

@implementation FLTCameraBoundsOptions
+ (instancetype)makeWithBounds:(nullable FLTCoordinateBounds *)bounds
    maxZoom:(nullable NSNumber *)maxZoom
    minZoom:(nullable NSNumber *)minZoom
    maxPitch:(nullable NSNumber *)maxPitch
    minPitch:(nullable NSNumber *)minPitch {
  FLTCameraBoundsOptions* pigeonResult = [[FLTCameraBoundsOptions alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxPitch = maxPitch;
  pigeonResult.minPitch = minPitch;
  return pigeonResult;
}
+ (FLTCameraBoundsOptions *)fromList:(NSArray *)list {
  FLTCameraBoundsOptions *pigeonResult = [[FLTCameraBoundsOptions alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  pigeonResult.maxZoom = GetNullableObjectAtIndex(list, 1);
  pigeonResult.minZoom = GetNullableObjectAtIndex(list, 2);
  pigeonResult.maxPitch = GetNullableObjectAtIndex(list, 3);
  pigeonResult.minPitch = GetNullableObjectAtIndex(list, 4);
  return pigeonResult;
}
+ (nullable FLTCameraBoundsOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraBoundsOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    self.maxZoom ?: [NSNull null],
    self.minZoom ?: [NSNull null],
    self.maxPitch ?: [NSNull null],
    self.minPitch ?: [NSNull null],
  ];
}
@end

@implementation FLTCameraBounds
+ (instancetype)makeWithBounds:(FLTCoordinateBounds *)bounds
    maxZoom:(double )maxZoom
    minZoom:(double )minZoom
    maxPitch:(double )maxPitch
    minPitch:(double )minPitch {
  FLTCameraBounds* pigeonResult = [[FLTCameraBounds alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxPitch = maxPitch;
  pigeonResult.minPitch = minPitch;
  return pigeonResult;
}
+ (FLTCameraBounds *)fromList:(NSArray *)list {
  FLTCameraBounds *pigeonResult = [[FLTCameraBounds alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  pigeonResult.maxZoom = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.minZoom = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.maxPitch = [GetNullableObjectAtIndex(list, 3) doubleValue];
  pigeonResult.minPitch = [GetNullableObjectAtIndex(list, 4) doubleValue];
  return pigeonResult;
}
+ (nullable FLTCameraBounds *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCameraBounds fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    @(self.maxZoom),
    @(self.minZoom),
    @(self.maxPitch),
    @(self.minPitch),
  ];
}
@end

@implementation FLTMapAnimationOptions
+ (instancetype)makeWithDuration:(nullable NSNumber *)duration
    startDelay:(nullable NSNumber *)startDelay {
  FLTMapAnimationOptions* pigeonResult = [[FLTMapAnimationOptions alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.startDelay = startDelay;
  return pigeonResult;
}
+ (FLTMapAnimationOptions *)fromList:(NSArray *)list {
  FLTMapAnimationOptions *pigeonResult = [[FLTMapAnimationOptions alloc] init];
  pigeonResult.duration = GetNullableObjectAtIndex(list, 0);
  pigeonResult.startDelay = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTMapAnimationOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapAnimationOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.duration ?: [NSNull null],
    self.startDelay ?: [NSNull null],
  ];
}
@end

@implementation FLTCoordinateBounds
+ (instancetype)makeWithSouthwest:(NSDictionary<NSString *, id> *)southwest
    northeast:(NSDictionary<NSString *, id> *)northeast
    infiniteBounds:(BOOL )infiniteBounds {
  FLTCoordinateBounds* pigeonResult = [[FLTCoordinateBounds alloc] init];
  pigeonResult.southwest = southwest;
  pigeonResult.northeast = northeast;
  pigeonResult.infiniteBounds = infiniteBounds;
  return pigeonResult;
}
+ (FLTCoordinateBounds *)fromList:(NSArray *)list {
  FLTCoordinateBounds *pigeonResult = [[FLTCoordinateBounds alloc] init];
  pigeonResult.southwest = GetNullableObjectAtIndex(list, 0);
  pigeonResult.northeast = GetNullableObjectAtIndex(list, 1);
  pigeonResult.infiniteBounds = [GetNullableObjectAtIndex(list, 2) boolValue];
  return pigeonResult;
}
+ (nullable FLTCoordinateBounds *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCoordinateBounds fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.southwest ?: [NSNull null],
    self.northeast ?: [NSNull null],
    @(self.infiniteBounds),
  ];
}
@end

@implementation FLTMapDebugOptions
+ (instancetype)makeWithData:(FLTMapDebugOptionsData)data {
  FLTMapDebugOptions* pigeonResult = [[FLTMapDebugOptions alloc] init];
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FLTMapDebugOptions *)fromList:(NSArray *)list {
  FLTMapDebugOptions *pigeonResult = [[FLTMapDebugOptions alloc] init];
  pigeonResult.data = [GetNullableObjectAtIndex(list, 0) integerValue];
  return pigeonResult;
}
+ (nullable FLTMapDebugOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapDebugOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.data),
  ];
}
@end

@implementation FLTGlyphsRasterizationOptions
+ (instancetype)makeWithRasterizationMode:(FLTGlyphsRasterizationMode)rasterizationMode
    fontFamily:(nullable NSString *)fontFamily {
  FLTGlyphsRasterizationOptions* pigeonResult = [[FLTGlyphsRasterizationOptions alloc] init];
  pigeonResult.rasterizationMode = rasterizationMode;
  pigeonResult.fontFamily = fontFamily;
  return pigeonResult;
}
+ (FLTGlyphsRasterizationOptions *)fromList:(NSArray *)list {
  FLTGlyphsRasterizationOptions *pigeonResult = [[FLTGlyphsRasterizationOptions alloc] init];
  pigeonResult.rasterizationMode = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.fontFamily = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTGlyphsRasterizationOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTGlyphsRasterizationOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.rasterizationMode),
    self.fontFamily ?: [NSNull null],
  ];
}
@end

@implementation FLTTileCacheBudgetInMegabytes
+ (instancetype)makeWithSize:(NSInteger )size {
  FLTTileCacheBudgetInMegabytes* pigeonResult = [[FLTTileCacheBudgetInMegabytes alloc] init];
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FLTTileCacheBudgetInMegabytes *)fromList:(NSArray *)list {
  FLTTileCacheBudgetInMegabytes *pigeonResult = [[FLTTileCacheBudgetInMegabytes alloc] init];
  pigeonResult.size = [GetNullableObjectAtIndex(list, 0) integerValue];
  return pigeonResult;
}
+ (nullable FLTTileCacheBudgetInMegabytes *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTTileCacheBudgetInMegabytes fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.size),
  ];
}
@end

@implementation FLTTileCacheBudgetInTiles
+ (instancetype)makeWithSize:(NSInteger )size {
  FLTTileCacheBudgetInTiles* pigeonResult = [[FLTTileCacheBudgetInTiles alloc] init];
  pigeonResult.size = size;
  return pigeonResult;
}
+ (FLTTileCacheBudgetInTiles *)fromList:(NSArray *)list {
  FLTTileCacheBudgetInTiles *pigeonResult = [[FLTTileCacheBudgetInTiles alloc] init];
  pigeonResult.size = [GetNullableObjectAtIndex(list, 0) integerValue];
  return pigeonResult;
}
+ (nullable FLTTileCacheBudgetInTiles *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTTileCacheBudgetInTiles fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.size),
  ];
}
@end

@implementation FLTMapOptions
+ (instancetype)makeWithContextMode:(nullable FLTContextModeBox *)contextMode
    constrainMode:(nullable FLTConstrainModeBox *)constrainMode
    viewportMode:(nullable FLTViewportModeBox *)viewportMode
    orientation:(nullable FLTNorthOrientationBox *)orientation
    crossSourceCollisions:(nullable NSNumber *)crossSourceCollisions
    size:(nullable FLTSize *)size
    pixelRatio:(double )pixelRatio
    glyphsRasterizationOptions:(nullable FLTGlyphsRasterizationOptions *)glyphsRasterizationOptions {
  FLTMapOptions* pigeonResult = [[FLTMapOptions alloc] init];
  pigeonResult.contextMode = contextMode;
  pigeonResult.constrainMode = constrainMode;
  pigeonResult.viewportMode = viewportMode;
  pigeonResult.orientation = orientation;
  pigeonResult.crossSourceCollisions = crossSourceCollisions;
  pigeonResult.size = size;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationOptions = glyphsRasterizationOptions;
  return pigeonResult;
}
+ (FLTMapOptions *)fromList:(NSArray *)list {
  FLTMapOptions *pigeonResult = [[FLTMapOptions alloc] init];
  NSNumber *contextModeAsNumber = GetNullableObjectAtIndex(list, 0);
  FLTContextModeBox *contextMode = contextModeAsNumber == nil ? nil : [[FLTContextModeBox alloc] initWithValue:[contextModeAsNumber integerValue]];
  pigeonResult.contextMode = contextMode;
  NSNumber *constrainModeAsNumber = GetNullableObjectAtIndex(list, 1);
  FLTConstrainModeBox *constrainMode = constrainModeAsNumber == nil ? nil : [[FLTConstrainModeBox alloc] initWithValue:[constrainModeAsNumber integerValue]];
  pigeonResult.constrainMode = constrainMode;
  NSNumber *viewportModeAsNumber = GetNullableObjectAtIndex(list, 2);
  FLTViewportModeBox *viewportMode = viewportModeAsNumber == nil ? nil : [[FLTViewportModeBox alloc] initWithValue:[viewportModeAsNumber integerValue]];
  pigeonResult.viewportMode = viewportMode;
  NSNumber *orientationAsNumber = GetNullableObjectAtIndex(list, 3);
  FLTNorthOrientationBox *orientation = orientationAsNumber == nil ? nil : [[FLTNorthOrientationBox alloc] initWithValue:[orientationAsNumber integerValue]];
  pigeonResult.orientation = orientation;
  pigeonResult.crossSourceCollisions = GetNullableObjectAtIndex(list, 4);
  pigeonResult.size = [FLTSize nullableFromList:(GetNullableObjectAtIndex(list, 5))];
  pigeonResult.pixelRatio = [GetNullableObjectAtIndex(list, 6) doubleValue];
  pigeonResult.glyphsRasterizationOptions = [FLTGlyphsRasterizationOptions nullableFromList:(GetNullableObjectAtIndex(list, 7))];
  return pigeonResult;
}
+ (nullable FLTMapOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMapOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.contextMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.contextMode.value]),
    (self.constrainMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.constrainMode.value]),
    (self.viewportMode == nil ? [NSNull null] : [NSNumber numberWithInteger:self.viewportMode.value]),
    (self.orientation == nil ? [NSNull null] : [NSNumber numberWithInteger:self.orientation.value]),
    self.crossSourceCollisions ?: [NSNull null],
    (self.size ? [self.size toList] : [NSNull null]),
    @(self.pixelRatio),
    (self.glyphsRasterizationOptions ? [self.glyphsRasterizationOptions toList] : [NSNull null]),
  ];
}
@end

@implementation FLTScreenCoordinate
+ (instancetype)makeWithX:(double )x
    y:(double )y {
  FLTScreenCoordinate* pigeonResult = [[FLTScreenCoordinate alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTScreenCoordinate *)fromList:(NSArray *)list {
  FLTScreenCoordinate *pigeonResult = [[FLTScreenCoordinate alloc] init];
  pigeonResult.x = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.y = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FLTScreenCoordinate *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTScreenCoordinate fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.x),
    @(self.y),
  ];
}
@end

@implementation FLTScreenBox
+ (instancetype)makeWithMin:(FLTScreenCoordinate *)min
    max:(FLTScreenCoordinate *)max {
  FLTScreenBox* pigeonResult = [[FLTScreenBox alloc] init];
  pigeonResult.min = min;
  pigeonResult.max = max;
  return pigeonResult;
}
+ (FLTScreenBox *)fromList:(NSArray *)list {
  FLTScreenBox *pigeonResult = [[FLTScreenBox alloc] init];
  pigeonResult.min = [FLTScreenCoordinate nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  pigeonResult.max = [FLTScreenCoordinate nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  return pigeonResult;
}
+ (nullable FLTScreenBox *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTScreenBox fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.min ? [self.min toList] : [NSNull null]),
    (self.max ? [self.max toList] : [NSNull null]),
  ];
}
@end

@implementation FLTCoordinateBoundsZoom
+ (instancetype)makeWithBounds:(FLTCoordinateBounds *)bounds
    zoom:(double )zoom {
  FLTCoordinateBoundsZoom* pigeonResult = [[FLTCoordinateBoundsZoom alloc] init];
  pigeonResult.bounds = bounds;
  pigeonResult.zoom = zoom;
  return pigeonResult;
}
+ (FLTCoordinateBoundsZoom *)fromList:(NSArray *)list {
  FLTCoordinateBoundsZoom *pigeonResult = [[FLTCoordinateBoundsZoom alloc] init];
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  pigeonResult.zoom = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FLTCoordinateBoundsZoom *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCoordinateBoundsZoom fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    @(self.zoom),
  ];
}
@end

@implementation FLTSize
+ (instancetype)makeWithWidth:(double )width
    height:(double )height {
  FLTSize* pigeonResult = [[FLTSize alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  return pigeonResult;
}
+ (FLTSize *)fromList:(NSArray *)list {
  FLTSize *pigeonResult = [[FLTSize alloc] init];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.height = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FLTSize *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTSize fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.width),
    @(self.height),
  ];
}
@end

@implementation FLTRenderedQueryOptions
+ (instancetype)makeWithLayerIds:(nullable NSArray<NSString *> *)layerIds
    filter:(nullable NSString *)filter {
  FLTRenderedQueryOptions* pigeonResult = [[FLTRenderedQueryOptions alloc] init];
  pigeonResult.layerIds = layerIds;
  pigeonResult.filter = filter;
  return pigeonResult;
}
+ (FLTRenderedQueryOptions *)fromList:(NSArray *)list {
  FLTRenderedQueryOptions *pigeonResult = [[FLTRenderedQueryOptions alloc] init];
  pigeonResult.layerIds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.filter = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTRenderedQueryOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTRenderedQueryOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.layerIds ?: [NSNull null],
    self.filter ?: [NSNull null],
  ];
}
@end

@implementation FLTSourceQueryOptions
+ (instancetype)makeWithSourceLayerIds:(nullable NSArray<NSString *> *)sourceLayerIds
    filter:(NSString *)filter {
  FLTSourceQueryOptions* pigeonResult = [[FLTSourceQueryOptions alloc] init];
  pigeonResult.sourceLayerIds = sourceLayerIds;
  pigeonResult.filter = filter;
  return pigeonResult;
}
+ (FLTSourceQueryOptions *)fromList:(NSArray *)list {
  FLTSourceQueryOptions *pigeonResult = [[FLTSourceQueryOptions alloc] init];
  pigeonResult.sourceLayerIds = GetNullableObjectAtIndex(list, 0);
  pigeonResult.filter = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTSourceQueryOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTSourceQueryOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.sourceLayerIds ?: [NSNull null],
    self.filter ?: [NSNull null],
  ];
}
@end

@implementation FLTFeatureExtensionValue
+ (instancetype)makeWithValue:(nullable NSString *)value
    featureCollection:(nullable NSArray<NSDictionary<NSString *, id> *> *)featureCollection {
  FLTFeatureExtensionValue* pigeonResult = [[FLTFeatureExtensionValue alloc] init];
  pigeonResult.value = value;
  pigeonResult.featureCollection = featureCollection;
  return pigeonResult;
}
+ (FLTFeatureExtensionValue *)fromList:(NSArray *)list {
  FLTFeatureExtensionValue *pigeonResult = [[FLTFeatureExtensionValue alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  pigeonResult.featureCollection = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTFeatureExtensionValue *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTFeatureExtensionValue fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.value ?: [NSNull null],
    self.featureCollection ?: [NSNull null],
  ];
}
@end

@implementation FLTLayerPosition
+ (instancetype)makeWithAbove:(nullable NSString *)above
    below:(nullable NSString *)below
    at:(nullable NSNumber *)at {
  FLTLayerPosition* pigeonResult = [[FLTLayerPosition alloc] init];
  pigeonResult.above = above;
  pigeonResult.below = below;
  pigeonResult.at = at;
  return pigeonResult;
}
+ (FLTLayerPosition *)fromList:(NSArray *)list {
  FLTLayerPosition *pigeonResult = [[FLTLayerPosition alloc] init];
  pigeonResult.above = GetNullableObjectAtIndex(list, 0);
  pigeonResult.below = GetNullableObjectAtIndex(list, 1);
  pigeonResult.at = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FLTLayerPosition *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTLayerPosition fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.above ?: [NSNull null],
    self.below ?: [NSNull null],
    self.at ?: [NSNull null],
  ];
}
@end

@implementation FLTQueriedRenderedFeature
+ (instancetype)makeWithQueriedFeature:(FLTQueriedFeature *)queriedFeature
    layers:(NSArray<NSString *> *)layers {
  FLTQueriedRenderedFeature* pigeonResult = [[FLTQueriedRenderedFeature alloc] init];
  pigeonResult.queriedFeature = queriedFeature;
  pigeonResult.layers = layers;
  return pigeonResult;
}
+ (FLTQueriedRenderedFeature *)fromList:(NSArray *)list {
  FLTQueriedRenderedFeature *pigeonResult = [[FLTQueriedRenderedFeature alloc] init];
  pigeonResult.queriedFeature = [FLTQueriedFeature nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  pigeonResult.layers = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTQueriedRenderedFeature *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTQueriedRenderedFeature fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.queriedFeature ? [self.queriedFeature toList] : [NSNull null]),
    self.layers ?: [NSNull null],
  ];
}
@end

@implementation FLTQueriedSourceFeature
+ (instancetype)makeWithQueriedFeature:(FLTQueriedFeature *)queriedFeature {
  FLTQueriedSourceFeature* pigeonResult = [[FLTQueriedSourceFeature alloc] init];
  pigeonResult.queriedFeature = queriedFeature;
  return pigeonResult;
}
+ (FLTQueriedSourceFeature *)fromList:(NSArray *)list {
  FLTQueriedSourceFeature *pigeonResult = [[FLTQueriedSourceFeature alloc] init];
  pigeonResult.queriedFeature = [FLTQueriedFeature nullableFromList:(GetNullableObjectAtIndex(list, 0))];
  return pigeonResult;
}
+ (nullable FLTQueriedSourceFeature *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTQueriedSourceFeature fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.queriedFeature ? [self.queriedFeature toList] : [NSNull null]),
  ];
}
@end

@implementation FLTQueriedFeature
+ (instancetype)makeWithFeature:(NSDictionary<NSString *, id> *)feature
    source:(NSString *)source
    sourceLayer:(nullable NSString *)sourceLayer
    state:(NSString *)state {
  FLTQueriedFeature* pigeonResult = [[FLTQueriedFeature alloc] init];
  pigeonResult.feature = feature;
  pigeonResult.source = source;
  pigeonResult.sourceLayer = sourceLayer;
  pigeonResult.state = state;
  return pigeonResult;
}
+ (FLTQueriedFeature *)fromList:(NSArray *)list {
  FLTQueriedFeature *pigeonResult = [[FLTQueriedFeature alloc] init];
  pigeonResult.feature = GetNullableObjectAtIndex(list, 0);
  pigeonResult.source = GetNullableObjectAtIndex(list, 1);
  pigeonResult.sourceLayer = GetNullableObjectAtIndex(list, 2);
  pigeonResult.state = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable FLTQueriedFeature *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTQueriedFeature fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.feature ?: [NSNull null],
    self.source ?: [NSNull null],
    self.sourceLayer ?: [NSNull null],
    self.state ?: [NSNull null],
  ];
}
@end

@implementation FLTRenderedQueryGeometry
+ (instancetype)makeWithValue:(NSString *)value
    type:(FLTType)type {
  FLTRenderedQueryGeometry* pigeonResult = [[FLTRenderedQueryGeometry alloc] init];
  pigeonResult.value = value;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (FLTRenderedQueryGeometry *)fromList:(NSArray *)list {
  FLTRenderedQueryGeometry *pigeonResult = [[FLTRenderedQueryGeometry alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  pigeonResult.type = [GetNullableObjectAtIndex(list, 1) integerValue];
  return pigeonResult;
}
+ (nullable FLTRenderedQueryGeometry *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTRenderedQueryGeometry fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.value ?: [NSNull null],
    @(self.type),
  ];
}
@end

@implementation FLTOfflineRegionGeometryDefinition
+ (instancetype)makeWithStyleURL:(NSString *)styleURL
    geometry:(NSDictionary<NSString *, id> *)geometry
    minZoom:(double )minZoom
    maxZoom:(double )maxZoom
    pixelRatio:(double )pixelRatio
    glyphsRasterizationMode:(FLTGlyphsRasterizationMode)glyphsRasterizationMode {
  FLTOfflineRegionGeometryDefinition* pigeonResult = [[FLTOfflineRegionGeometryDefinition alloc] init];
  pigeonResult.styleURL = styleURL;
  pigeonResult.geometry = geometry;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationMode = glyphsRasterizationMode;
  return pigeonResult;
}
+ (FLTOfflineRegionGeometryDefinition *)fromList:(NSArray *)list {
  FLTOfflineRegionGeometryDefinition *pigeonResult = [[FLTOfflineRegionGeometryDefinition alloc] init];
  pigeonResult.styleURL = GetNullableObjectAtIndex(list, 0);
  pigeonResult.geometry = GetNullableObjectAtIndex(list, 1);
  pigeonResult.minZoom = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.maxZoom = [GetNullableObjectAtIndex(list, 3) doubleValue];
  pigeonResult.pixelRatio = [GetNullableObjectAtIndex(list, 4) doubleValue];
  pigeonResult.glyphsRasterizationMode = [GetNullableObjectAtIndex(list, 5) integerValue];
  return pigeonResult;
}
+ (nullable FLTOfflineRegionGeometryDefinition *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTOfflineRegionGeometryDefinition fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.styleURL ?: [NSNull null],
    self.geometry ?: [NSNull null],
    @(self.minZoom),
    @(self.maxZoom),
    @(self.pixelRatio),
    @(self.glyphsRasterizationMode),
  ];
}
@end

@implementation FLTOfflineRegionTilePyramidDefinition
+ (instancetype)makeWithStyleURL:(NSString *)styleURL
    bounds:(FLTCoordinateBounds *)bounds
    minZoom:(double )minZoom
    maxZoom:(double )maxZoom
    pixelRatio:(double )pixelRatio
    glyphsRasterizationMode:(FLTGlyphsRasterizationMode)glyphsRasterizationMode {
  FLTOfflineRegionTilePyramidDefinition* pigeonResult = [[FLTOfflineRegionTilePyramidDefinition alloc] init];
  pigeonResult.styleURL = styleURL;
  pigeonResult.bounds = bounds;
  pigeonResult.minZoom = minZoom;
  pigeonResult.maxZoom = maxZoom;
  pigeonResult.pixelRatio = pixelRatio;
  pigeonResult.glyphsRasterizationMode = glyphsRasterizationMode;
  return pigeonResult;
}
+ (FLTOfflineRegionTilePyramidDefinition *)fromList:(NSArray *)list {
  FLTOfflineRegionTilePyramidDefinition *pigeonResult = [[FLTOfflineRegionTilePyramidDefinition alloc] init];
  pigeonResult.styleURL = GetNullableObjectAtIndex(list, 0);
  pigeonResult.bounds = [FLTCoordinateBounds nullableFromList:(GetNullableObjectAtIndex(list, 1))];
  pigeonResult.minZoom = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.maxZoom = [GetNullableObjectAtIndex(list, 3) doubleValue];
  pigeonResult.pixelRatio = [GetNullableObjectAtIndex(list, 4) doubleValue];
  pigeonResult.glyphsRasterizationMode = [GetNullableObjectAtIndex(list, 5) integerValue];
  return pigeonResult;
}
+ (nullable FLTOfflineRegionTilePyramidDefinition *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTOfflineRegionTilePyramidDefinition fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.styleURL ?: [NSNull null],
    (self.bounds ? [self.bounds toList] : [NSNull null]),
    @(self.minZoom),
    @(self.maxZoom),
    @(self.pixelRatio),
    @(self.glyphsRasterizationMode),
  ];
}
@end

@implementation FLTProjectedMeters
+ (instancetype)makeWithNorthing:(double )northing
    easting:(double )easting {
  FLTProjectedMeters* pigeonResult = [[FLTProjectedMeters alloc] init];
  pigeonResult.northing = northing;
  pigeonResult.easting = easting;
  return pigeonResult;
}
+ (FLTProjectedMeters *)fromList:(NSArray *)list {
  FLTProjectedMeters *pigeonResult = [[FLTProjectedMeters alloc] init];
  pigeonResult.northing = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.easting = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FLTProjectedMeters *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTProjectedMeters fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.northing),
    @(self.easting),
  ];
}
@end

@implementation FLTMercatorCoordinate
+ (instancetype)makeWithX:(double )x
    y:(double )y {
  FLTMercatorCoordinate* pigeonResult = [[FLTMercatorCoordinate alloc] init];
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTMercatorCoordinate *)fromList:(NSArray *)list {
  FLTMercatorCoordinate *pigeonResult = [[FLTMercatorCoordinate alloc] init];
  pigeonResult.x = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.y = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FLTMercatorCoordinate *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMercatorCoordinate fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.x),
    @(self.y),
  ];
}
@end

@implementation FLTStyleObjectInfo
+ (instancetype)makeWithId:(NSString *)id
    type:(NSString *)type {
  FLTStyleObjectInfo* pigeonResult = [[FLTStyleObjectInfo alloc] init];
  pigeonResult.id = id;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (FLTStyleObjectInfo *)fromList:(NSArray *)list {
  FLTStyleObjectInfo *pigeonResult = [[FLTStyleObjectInfo alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  pigeonResult.type = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable FLTStyleObjectInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTStyleObjectInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.id ?: [NSNull null],
    self.type ?: [NSNull null],
  ];
}
@end

@implementation FLTStyleProjection
+ (instancetype)makeWithName:(FLTStyleProjectionName)name {
  FLTStyleProjection* pigeonResult = [[FLTStyleProjection alloc] init];
  pigeonResult.name = name;
  return pigeonResult;
}
+ (FLTStyleProjection *)fromList:(NSArray *)list {
  FLTStyleProjection *pigeonResult = [[FLTStyleProjection alloc] init];
  pigeonResult.name = [GetNullableObjectAtIndex(list, 0) integerValue];
  return pigeonResult;
}
+ (nullable FLTStyleProjection *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTStyleProjection fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.name),
  ];
}
@end

@implementation FLTFlatLight
+ (instancetype)makeWithId:(NSString *)id
    anchor:(nullable FLTAnchorBox *)anchor
    color:(nullable NSNumber *)color
    colorTransition:(nullable FLTTransitionOptions *)colorTransition
    intensity:(nullable NSNumber *)intensity
    intensityTransition:(nullable FLTTransitionOptions *)intensityTransition
    position:(nullable NSArray<NSNumber *> *)position
    positionTransition:(nullable FLTTransitionOptions *)positionTransition {
  FLTFlatLight* pigeonResult = [[FLTFlatLight alloc] init];
  pigeonResult.id = id;
  pigeonResult.anchor = anchor;
  pigeonResult.color = color;
  pigeonResult.colorTransition = colorTransition;
  pigeonResult.intensity = intensity;
  pigeonResult.intensityTransition = intensityTransition;
  pigeonResult.position = position;
  pigeonResult.positionTransition = positionTransition;
  return pigeonResult;
}
+ (FLTFlatLight *)fromList:(NSArray *)list {
  FLTFlatLight *pigeonResult = [[FLTFlatLight alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  NSNumber *anchorAsNumber = GetNullableObjectAtIndex(list, 1);
  FLTAnchorBox *anchor = anchorAsNumber == nil ? nil : [[FLTAnchorBox alloc] initWithValue:[anchorAsNumber integerValue]];
  pigeonResult.anchor = anchor;
  pigeonResult.color = GetNullableObjectAtIndex(list, 2);
  pigeonResult.colorTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 3))];
  pigeonResult.intensity = GetNullableObjectAtIndex(list, 4);
  pigeonResult.intensityTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 5))];
  pigeonResult.position = GetNullableObjectAtIndex(list, 6);
  pigeonResult.positionTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 7))];
  return pigeonResult;
}
+ (nullable FLTFlatLight *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTFlatLight fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.id ?: [NSNull null],
    (self.anchor == nil ? [NSNull null] : [NSNumber numberWithInteger:self.anchor.value]),
    self.color ?: [NSNull null],
    (self.colorTransition ? [self.colorTransition toList] : [NSNull null]),
    self.intensity ?: [NSNull null],
    (self.intensityTransition ? [self.intensityTransition toList] : [NSNull null]),
    self.position ?: [NSNull null],
    (self.positionTransition ? [self.positionTransition toList] : [NSNull null]),
  ];
}
@end

@implementation FLTDirectionalLight
+ (instancetype)makeWithId:(NSString *)id
    castShadows:(nullable NSNumber *)castShadows
    color:(nullable NSNumber *)color
    colorTransition:(nullable FLTTransitionOptions *)colorTransition
    direction:(nullable NSArray<NSNumber *> *)direction
    directionTransition:(nullable FLTTransitionOptions *)directionTransition
    intensity:(nullable NSNumber *)intensity
    intensityTransition:(nullable FLTTransitionOptions *)intensityTransition
    shadowIntensity:(nullable NSNumber *)shadowIntensity
    shadowIntensityTransition:(nullable FLTTransitionOptions *)shadowIntensityTransition {
  FLTDirectionalLight* pigeonResult = [[FLTDirectionalLight alloc] init];
  pigeonResult.id = id;
  pigeonResult.castShadows = castShadows;
  pigeonResult.color = color;
  pigeonResult.colorTransition = colorTransition;
  pigeonResult.direction = direction;
  pigeonResult.directionTransition = directionTransition;
  pigeonResult.intensity = intensity;
  pigeonResult.intensityTransition = intensityTransition;
  pigeonResult.shadowIntensity = shadowIntensity;
  pigeonResult.shadowIntensityTransition = shadowIntensityTransition;
  return pigeonResult;
}
+ (FLTDirectionalLight *)fromList:(NSArray *)list {
  FLTDirectionalLight *pigeonResult = [[FLTDirectionalLight alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  pigeonResult.castShadows = GetNullableObjectAtIndex(list, 1);
  pigeonResult.color = GetNullableObjectAtIndex(list, 2);
  pigeonResult.colorTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 3))];
  pigeonResult.direction = GetNullableObjectAtIndex(list, 4);
  pigeonResult.directionTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 5))];
  pigeonResult.intensity = GetNullableObjectAtIndex(list, 6);
  pigeonResult.intensityTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 7))];
  pigeonResult.shadowIntensity = GetNullableObjectAtIndex(list, 8);
  pigeonResult.shadowIntensityTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 9))];
  return pigeonResult;
}
+ (nullable FLTDirectionalLight *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTDirectionalLight fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.id ?: [NSNull null],
    self.castShadows ?: [NSNull null],
    self.color ?: [NSNull null],
    (self.colorTransition ? [self.colorTransition toList] : [NSNull null]),
    self.direction ?: [NSNull null],
    (self.directionTransition ? [self.directionTransition toList] : [NSNull null]),
    self.intensity ?: [NSNull null],
    (self.intensityTransition ? [self.intensityTransition toList] : [NSNull null]),
    self.shadowIntensity ?: [NSNull null],
    (self.shadowIntensityTransition ? [self.shadowIntensityTransition toList] : [NSNull null]),
  ];
}
@end

@implementation FLTAmbientLight
+ (instancetype)makeWithId:(NSString *)id
    color:(nullable NSNumber *)color
    colorTransition:(nullable FLTTransitionOptions *)colorTransition
    intensity:(nullable NSNumber *)intensity
    intensityTransition:(nullable FLTTransitionOptions *)intensityTransition {
  FLTAmbientLight* pigeonResult = [[FLTAmbientLight alloc] init];
  pigeonResult.id = id;
  pigeonResult.color = color;
  pigeonResult.colorTransition = colorTransition;
  pigeonResult.intensity = intensity;
  pigeonResult.intensityTransition = intensityTransition;
  return pigeonResult;
}
+ (FLTAmbientLight *)fromList:(NSArray *)list {
  FLTAmbientLight *pigeonResult = [[FLTAmbientLight alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  pigeonResult.color = GetNullableObjectAtIndex(list, 1);
  pigeonResult.colorTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  pigeonResult.intensity = GetNullableObjectAtIndex(list, 3);
  pigeonResult.intensityTransition = [FLTTransitionOptions nullableFromList:(GetNullableObjectAtIndex(list, 4))];
  return pigeonResult;
}
+ (nullable FLTAmbientLight *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTAmbientLight fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.id ?: [NSNull null],
    self.color ?: [NSNull null],
    (self.colorTransition ? [self.colorTransition toList] : [NSNull null]),
    self.intensity ?: [NSNull null],
    (self.intensityTransition ? [self.intensityTransition toList] : [NSNull null]),
  ];
}
@end

@implementation FLTMbxImage
+ (instancetype)makeWithWidth:(NSInteger )width
    height:(NSInteger )height
    data:(FlutterStandardTypedData *)data {
  FLTMbxImage* pigeonResult = [[FLTMbxImage alloc] init];
  pigeonResult.width = width;
  pigeonResult.height = height;
  pigeonResult.data = data;
  return pigeonResult;
}
+ (FLTMbxImage *)fromList:(NSArray *)list {
  FLTMbxImage *pigeonResult = [[FLTMbxImage alloc] init];
  pigeonResult.width = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.height = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.data = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FLTMbxImage *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTMbxImage fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.width),
    @(self.height),
    self.data ?: [NSNull null],
  ];
}
@end

@implementation FLTImageStretches
+ (instancetype)makeWithFirst:(double )first
    second:(double )second {
  FLTImageStretches* pigeonResult = [[FLTImageStretches alloc] init];
  pigeonResult.first = first;
  pigeonResult.second = second;
  return pigeonResult;
}
+ (FLTImageStretches *)fromList:(NSArray *)list {
  FLTImageStretches *pigeonResult = [[FLTImageStretches alloc] init];
  pigeonResult.first = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.second = [GetNullableObjectAtIndex(list, 1) doubleValue];
  return pigeonResult;
}
+ (nullable FLTImageStretches *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTImageStretches fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.first),
    @(self.second),
  ];
}
@end

@implementation FLTImageContent
+ (instancetype)makeWithLeft:(double )left
    top:(double )top
    right:(double )right
    bottom:(double )bottom {
  FLTImageContent* pigeonResult = [[FLTImageContent alloc] init];
  pigeonResult.left = left;
  pigeonResult.top = top;
  pigeonResult.right = right;
  pigeonResult.bottom = bottom;
  return pigeonResult;
}
+ (FLTImageContent *)fromList:(NSArray *)list {
  FLTImageContent *pigeonResult = [[FLTImageContent alloc] init];
  pigeonResult.left = [GetNullableObjectAtIndex(list, 0) doubleValue];
  pigeonResult.top = [GetNullableObjectAtIndex(list, 1) doubleValue];
  pigeonResult.right = [GetNullableObjectAtIndex(list, 2) doubleValue];
  pigeonResult.bottom = [GetNullableObjectAtIndex(list, 3) doubleValue];
  return pigeonResult;
}
+ (nullable FLTImageContent *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTImageContent fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.left),
    @(self.top),
    @(self.right),
    @(self.bottom),
  ];
}
@end

@implementation FLTTransitionOptions
+ (instancetype)makeWithDuration:(nullable NSNumber *)duration
    delay:(nullable NSNumber *)delay
    enablePlacementTransitions:(nullable NSNumber *)enablePlacementTransitions {
  FLTTransitionOptions* pigeonResult = [[FLTTransitionOptions alloc] init];
  pigeonResult.duration = duration;
  pigeonResult.delay = delay;
  pigeonResult.enablePlacementTransitions = enablePlacementTransitions;
  return pigeonResult;
}
+ (FLTTransitionOptions *)fromList:(NSArray *)list {
  FLTTransitionOptions *pigeonResult = [[FLTTransitionOptions alloc] init];
  pigeonResult.duration = GetNullableObjectAtIndex(list, 0);
  pigeonResult.delay = GetNullableObjectAtIndex(list, 1);
  pigeonResult.enablePlacementTransitions = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable FLTTransitionOptions *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTTransitionOptions fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.duration ?: [NSNull null],
    self.delay ?: [NSNull null],
    self.enablePlacementTransitions ?: [NSNull null],
  ];
}
@end

@implementation FLTCanonicalTileID
+ (instancetype)makeWithZ:(NSInteger )z
    x:(NSInteger )x
    y:(NSInteger )y {
  FLTCanonicalTileID* pigeonResult = [[FLTCanonicalTileID alloc] init];
  pigeonResult.z = z;
  pigeonResult.x = x;
  pigeonResult.y = y;
  return pigeonResult;
}
+ (FLTCanonicalTileID *)fromList:(NSArray *)list {
  FLTCanonicalTileID *pigeonResult = [[FLTCanonicalTileID alloc] init];
  pigeonResult.z = [GetNullableObjectAtIndex(list, 0) integerValue];
  pigeonResult.x = [GetNullableObjectAtIndex(list, 1) integerValue];
  pigeonResult.y = [GetNullableObjectAtIndex(list, 2) integerValue];
  return pigeonResult;
}
+ (nullable FLTCanonicalTileID *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTCanonicalTileID fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    @(self.z),
    @(self.x),
    @(self.y),
  ];
}
@end

@implementation FLTStylePropertyValue
+ (instancetype)makeWithValue:(nullable id )value
    kind:(FLTStylePropertyValueKind)kind {
  FLTStylePropertyValue* pigeonResult = [[FLTStylePropertyValue alloc] init];
  pigeonResult.value = value;
  pigeonResult.kind = kind;
  return pigeonResult;
}
+ (FLTStylePropertyValue *)fromList:(NSArray *)list {
  FLTStylePropertyValue *pigeonResult = [[FLTStylePropertyValue alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  pigeonResult.kind = [GetNullableObjectAtIndex(list, 1) integerValue];
  return pigeonResult;
}
+ (nullable FLTStylePropertyValue *)nullableFromList:(NSArray *)list {
  return (list) ? [FLTStylePropertyValue fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    self.value ?: [NSNull null],
    @(self.kind),
  ];
}
@end

@interface FLT_AnimationManagerCodecReader : FlutterStandardReader
@end
@implementation FLT_AnimationManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 129: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 130: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 131: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 132: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_AnimationManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLT_AnimationManagerCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_AnimationManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_AnimationManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_AnimationManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_AnimationManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_AnimationManagerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_AnimationManagerCodecReaderWriter *readerWriter = [[FLT_AnimationManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLT_AnimationManager(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_AnimationManager> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(easeToCameraOptions:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(easeToCameraOptions:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api easeToCameraOptions:arg_cameraOptions mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(flyToCameraOptions:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(flyToCameraOptions:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api flyToCameraOptions:arg_cameraOptions mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pitchByPitch:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(pitchByPitch:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        double arg_pitch = [GetNullableObjectAtIndex(args, 0) doubleValue];
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api pitchByPitch:arg_pitch mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(scaleByAmount:screenCoordinate:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(scaleByAmount:screenCoordinate:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        double arg_amount = [GetNullableObjectAtIndex(args, 0) doubleValue];
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 1);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api scaleByAmount:arg_amount screenCoordinate:arg_screenCoordinate mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveByScreenCoordinate:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(moveByScreenCoordinate:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api moveByScreenCoordinate:arg_screenCoordinate mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(rotateByFirst:second:mapAnimationOptions:error:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(rotateByFirst:second:mapAnimationOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_first = GetNullableObjectAtIndex(args, 0);
        FLTScreenCoordinate *arg_second = GetNullableObjectAtIndex(args, 1);
        FLTMapAnimationOptions *arg_mapAnimationOptions = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api rotateByFirst:arg_first second:arg_second mapAnimationOptions:arg_mapAnimationOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation"
        binaryMessenger:binaryMessenger
        codec:FLT_AnimationManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelCameraAnimationWithError:)], @"FLT_AnimationManager api (%@) doesn't respond to @selector(cancelCameraAnimationWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelCameraAnimationWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLT_CameraManagerCodecReader : FlutterStandardReader
@end
@implementation FLT_CameraManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTAmbientLight fromList:[self readValue]];
    case 129: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 130: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 135: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 136: 
      return [FLTDirectionalLight fromList:[self readValue]];
    case 137: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 138: 
      return [FLTFlatLight fromList:[self readValue]];
    case 139: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 140: 
      return [FLTImageContent fromList:[self readValue]];
    case 141: 
      return [FLTImageStretches fromList:[self readValue]];
    case 142: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 143: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 144: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 145: 
      return [FLTMapOptions fromList:[self readValue]];
    case 146: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 147: 
      return [FLTMbxImage fromList:[self readValue]];
    case 148: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 150: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 151: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 152: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 153: 
      return [FLTQueriedRenderedFeature fromList:[self readValue]];
    case 154: 
      return [FLTQueriedSourceFeature fromList:[self readValue]];
    case 155: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 156: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 157: 
      return [FLTScreenBox fromList:[self readValue]];
    case 158: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 159: 
      return [FLTSize fromList:[self readValue]];
    case 160: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 161: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 162: 
      return [FLTStyleProjection fromList:[self readValue]];
    case 163: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 164: 
      return [FLTTileCacheBudgetInMegabytes fromList:[self readValue]];
    case 165: 
      return [FLTTileCacheBudgetInTiles fromList:[self readValue]];
    case 166: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_CameraManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLT_CameraManagerCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTAmbientLight class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTDirectionalLight class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFlatLight class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedRenderedFeature class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedSourceFeature class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleProjection class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInMegabytes class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInTiles class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_CameraManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_CameraManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_CameraManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_CameraManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_CameraManagerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_CameraManagerCodecReaderWriter *readerWriter = [[FLT_CameraManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLT_CameraManager(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_CameraManager> *api) {
  /// Convenience method that returns a `camera options` object for the given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
  /// If any of the fields in camera options is not provided then the current value from the map for that field will be used.
  /// @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
  /// This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesPadding"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesPaddingCoordinates:camera:coordinatesPadding:maxZoom:offset:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesPaddingCoordinates:camera:coordinatesPadding:maxZoom:offset:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 1);
        FLTMbxEdgeInsets *arg_coordinatesPadding = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_maxZoom = GetNullableObjectAtIndex(args, 3);
        FLTScreenCoordinate *arg_offset = GetNullableObjectAtIndex(args, 4);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesPaddingCoordinates:arg_coordinates camera:arg_camera coordinatesPadding:arg_coordinatesPadding maxZoom:arg_maxZoom offset:arg_offset error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param bounds The `coordinate bounds` of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinateBoundsBounds:padding:bearing:pitch:maxZoom:offset:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinateBoundsBounds:padding:bearing:pitch:maxZoom:offset:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCoordinateBounds *arg_bounds = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        NSNumber *arg_maxZoom = GetNullableObjectAtIndex(args, 4);
        FLTScreenCoordinate *arg_offset = GetNullableObjectAtIndex(args, 5);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinateBoundsBounds:arg_bounds padding:arg_padding bearing:arg_bearing pitch:arg_pitch maxZoom:arg_maxZoom offset:arg_offset error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesCoordinates:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesCoordinates:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesCoordinates:arg_coordinates padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that adjusts the provided `camera options` object for given parameters.
  ///
  /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
  /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
  /// Returns the provided `camera` options object unchanged upon an error.
  /// Note that this method may fail if the principal point of the projection is not inside the `box` or
  /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
  /// @param box The `screen box` into which `coordinates` should fit.
  ///
  /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForCoordinatesCameraOptionsCoordinates:camera:box:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForCoordinatesCameraOptionsCoordinates:camera:box:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 1);
        FLTScreenBox *arg_box = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForCoordinatesCameraOptionsCoordinates:arg_coordinates camera:arg_camera box:arg_box error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param geometry The `geometry` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cameraForGeometryGeometry:padding:bearing:pitch:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(cameraForGeometryGeometry:padding:bearing:pitch:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_geometry = GetNullableObjectAtIndex(args, 0);
        FLTMbxEdgeInsets *arg_padding = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_bearing = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_pitch = GetNullableObjectAtIndex(args, 3);
        FlutterError *error;
        FLTCameraOptions *output = [api cameraForGeometryGeometry:arg_geometry padding:arg_padding bearing:arg_bearing pitch:arg_pitch error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsForCameraCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsForCameraCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBounds *output = [api coordinateBoundsForCameraCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsForCameraUnwrappedCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsForCameraUnwrappedCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBounds *output = [api coordinateBoundsForCameraUnwrappedCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsZoomForCameraCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsZoomForCameraCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBoundsZoom *output = [api coordinateBoundsZoomForCameraCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateBoundsZoomForCameraUnwrappedCamera:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateBoundsZoomForCameraUnwrappedCamera:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_camera = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTCoordinateBoundsZoom *output = [api coordinateBoundsZoomForCameraUnwrappedCamera:arg_camera error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
  /// (i.e., longitude-latitude pair).
  ///
  /// The `screen coordinate` is in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
  ///
  /// @return A `screen coordinate` on the screen in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pixelForCoordinateCoordinate:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(pixelForCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTScreenCoordinate *output = [api pixelForCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
  /// to a `screen coordinate`.
  ///
  /// The screen coordinate is in `logical pixels`relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
  ///
  /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateForPixelPixel:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinateForPixelPixel:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_pixel = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateForPixelPixel:arg_pixel error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates `screen coordinates` that correspond to geographical `coordinates`
  /// (i.e., longitude-latitude pairs).
  ///
  /// The `screen coordinates` are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
  ///
  /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(pixelsForCoordinatesCoordinates:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(pixelsForCoordinatesCoordinates:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<NSDictionary<NSString *, id> *> *arg_coordinates = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<FLTScreenCoordinate *> *output = [api pixelsForCoordinatesCoordinates:arg_coordinates error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
  /// to `screen coordinates`.
  ///
  /// The screen coordinates are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixels A `screen coordinates` in `logical pixels`.
  ///
  /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinatesForPixelsPixels:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(coordinatesForPixelsPixels:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<FLTScreenCoordinate *> *arg_pixels = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSArray<NSDictionary<NSString *, id> *> *output = [api coordinatesForPixelsPixels:arg_pixels error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
  /// The map will retain its current values for any details not passed via the camera options argument.
  /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
  /// different `camera state`.
  ///
  /// @param cameraOptions The new `camera options` to be set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCameraCameraOptions:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(setCameraCameraOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraOptions *arg_cameraOptions = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setCameraCameraOptions:arg_cameraOptions error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the current `camera state`.
  ///
  /// @return The current `camera state`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getCameraStateWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getCameraStateWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTCameraState *output = [api getCameraStateWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the `camera bounds options` of the map. The map will retain its current values for any
  /// details not passed via the camera bounds options arguments.
  /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
  /// zoom level of the camera, to prevent out of bounds areas to be visible.
  /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
  ///
  /// @param options The `camera bounds options` to set.
  /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBoundsOptions:error:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(setBoundsOptions:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTCameraBoundsOptions *arg_options = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setBoundsOptions:arg_options error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `camera bounds` of the map.
  /// @return A `camera bounds` of the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds"
        binaryMessenger:binaryMessenger
        codec:FLT_CameraManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBoundsWithError:)], @"FLT_CameraManager api (%@) doesn't respond to @selector(getBoundsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTCameraBounds *output = [api getBoundsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLT_MapInterfaceCodecReader : FlutterStandardReader
@end
@implementation FLT_MapInterfaceCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTAmbientLight fromList:[self readValue]];
    case 129: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 130: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 135: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 136: 
      return [FLTDirectionalLight fromList:[self readValue]];
    case 137: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 138: 
      return [FLTFlatLight fromList:[self readValue]];
    case 139: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 140: 
      return [FLTImageContent fromList:[self readValue]];
    case 141: 
      return [FLTImageStretches fromList:[self readValue]];
    case 142: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 143: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 144: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 145: 
      return [FLTMapOptions fromList:[self readValue]];
    case 146: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 147: 
      return [FLTMbxImage fromList:[self readValue]];
    case 148: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 150: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 151: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 152: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 153: 
      return [FLTQueriedRenderedFeature fromList:[self readValue]];
    case 154: 
      return [FLTQueriedSourceFeature fromList:[self readValue]];
    case 155: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 156: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 157: 
      return [FLTScreenBox fromList:[self readValue]];
    case 158: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 159: 
      return [FLTSize fromList:[self readValue]];
    case 160: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 161: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 162: 
      return [FLTStyleProjection fromList:[self readValue]];
    case 163: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 164: 
      return [FLTTileCacheBudgetInMegabytes fromList:[self readValue]];
    case 165: 
      return [FLTTileCacheBudgetInTiles fromList:[self readValue]];
    case 166: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLT_MapInterfaceCodecWriter : FlutterStandardWriter
@end
@implementation FLT_MapInterfaceCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTAmbientLight class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTDirectionalLight class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFlatLight class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedRenderedFeature class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedSourceFeature class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleProjection class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInMegabytes class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInTiles class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLT_MapInterfaceCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLT_MapInterfaceCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLT_MapInterfaceCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLT_MapInterfaceCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLT_MapInterfaceGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLT_MapInterfaceCodecReaderWriter *readerWriter = [[FLT_MapInterfaceCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLT_MapInterface(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_MapInterface> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadStyleURIStyleURI:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(loadStyleURIStyleURI:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_styleURI = GetNullableObjectAtIndex(args, 0);
        [api loadStyleURIStyleURI:arg_styleURI completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(loadStyleJsonStyleJson:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(loadStyleJsonStyleJson:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_styleJson = GetNullableObjectAtIndex(args, 0);
        [api loadStyleJsonStyleJson:arg_styleJson completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(clearDataWithCompletion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(clearDataWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api clearDataWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setTileCacheBudget"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setTileCacheBudgetTileCacheBudgetInMegabytes:tileCacheBudgetInTiles:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setTileCacheBudgetTileCacheBudgetInMegabytes:tileCacheBudgetInTiles:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTTileCacheBudgetInMegabytes *arg_tileCacheBudgetInMegabytes = GetNullableObjectAtIndex(args, 0);
        FLTTileCacheBudgetInTiles *arg_tileCacheBudgetInTiles = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setTileCacheBudgetTileCacheBudgetInMegabytes:arg_tileCacheBudgetInMegabytes tileCacheBudgetInTiles:arg_tileCacheBudgetInTiles error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the size of the map.
  ///
  /// @return The `size` of the map in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSizeWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTSize *output = [api getSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Triggers a repaint of the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(triggerRepaintWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(triggerRepaintWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api triggerRepaintWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Tells the map rendering engine that there is currently a gesture in progress. This
  /// affects how the map renders labels, as it will use different texture filters if a gesture
  /// is ongoing.
  ///
  /// @param inProgress The `boolean` value representing if a gesture is in progress.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setGestureInProgressInProgress:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setGestureInProgressInProgress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        BOOL arg_inProgress = [GetNullableObjectAtIndex(args, 0) boolValue];
        FlutterError *error;
        [api setGestureInProgressInProgress:arg_inProgress error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns `true` if a gesture is currently in progress.
  ///
  /// @return `true` if a gesture is currently in progress, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isGestureInProgressWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(isGestureInProgressWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isGestureInProgressWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Tells the map rendering engine that the animation is currently performed by the
  /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
  /// In particular, it brings more stability to symbol placement and rendering.
  ///
  /// @param inProgress The `boolean` value representing if user animation is in progress
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setUserAnimationInProgressInProgress:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setUserAnimationInProgressInProgress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        BOOL arg_inProgress = [GetNullableObjectAtIndex(args, 0) boolValue];
        FlutterError *error;
        [api setUserAnimationInProgressInProgress:arg_inProgress error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns `true` if user animation is currently in progress.
  ///
  /// @return `true` if a user animation is currently in progress, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isUserAnimationInProgressWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(isUserAnimationInProgressWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isUserAnimationInProgressWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
  /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
  /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
  ///
  /// @param delta The new prefetch zoom delta.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setPrefetchZoomDeltaDelta:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setPrefetchZoomDeltaDelta:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSInteger arg_delta = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setPrefetchZoomDeltaDelta:arg_delta error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the map's prefetch zoom delta.
  ///
  /// @return The map's prefetch zoom `delta`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getPrefetchZoomDeltaWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getPrefetchZoomDeltaWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getPrefetchZoomDeltaWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the north `orientation mode`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setNorthOrientationOrientation:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setNorthOrientationOrientation:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTNorthOrientation arg_orientation = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setNorthOrientationOrientation:arg_orientation error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the map `constrain mode`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setConstrainModeMode:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setConstrainModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTConstrainMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setConstrainModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the `viewport mode`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setViewportModeMode:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setViewportModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTViewportMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setViewportModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `map options`.
  ///
  /// @return The map's `map options`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMapOptionsWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getMapOptionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTMapOptions *output = [api getMapOptionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the `map debug options`.
  ///
  /// @return An array of `map debug options` flags currently set to the map.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getDebugWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getDebugWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<FLTMapDebugOptions *> *output = [api getDebugWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the `map debug options` and enables debug mode based on the passed value.
  ///
  /// @param debugOptions An array of `map debug options` to be set.
  /// @param value A `boolean` value representing the state for a given `map debug options`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setDebugDebugOptions:value:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setDebugDebugOptions:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSArray<FLTMapDebugOptions *> *arg_debugOptions = GetNullableObjectAtIndex(args, 0);
        BOOL arg_value = [GetNullableObjectAtIndex(args, 1) boolValue];
        FlutterError *error;
        [api setDebugDebugOptions:arg_debugOptions value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Queries the map for rendered features.
  ///
  /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
  /// @param options The `render query options` for querying rendered features.
  /// @param completion The `query features completion` called when the query completes.
  /// @return A `cancelable` object that could be used to cancel the pending query.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(queryRenderedFeaturesGeometry:options:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(queryRenderedFeaturesGeometry:options:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTRenderedQueryGeometry *arg_geometry = GetNullableObjectAtIndex(args, 0);
        FLTRenderedQueryOptions *arg_options = GetNullableObjectAtIndex(args, 1);
        [api queryRenderedFeaturesGeometry:arg_geometry options:arg_options completion:^(NSArray<FLTQueriedRenderedFeature *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Queries the map for source features.
  ///
  /// @param sourceId The style source identifier used to query for source features.
  /// @param options The `source query options` for querying source features.
  /// @param completion The `query features completion` called when the query completes.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(querySourceFeaturesSourceId:options:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(querySourceFeaturesSourceId:options:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTSourceQueryOptions *arg_options = GetNullableObjectAtIndex(args, 1);
        [api querySourceFeaturesSourceId:arg_sourceId options:arg_options completion:^(NSArray<FLTQueriedSourceFeature *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
  /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster Cluster from which to retrieve leaves from
  /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
  /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterLeavesSourceIdentifier:cluster:limit:offset:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterLeavesSourceIdentifier:cluster:limit:offset:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        NSNumber *arg_limit = GetNullableObjectAtIndex(args, 2);
        NSNumber *arg_offset = GetNullableObjectAtIndex(args, 3);
        [api getGeoJsonClusterLeavesSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster limit:arg_limit offset:arg_offset completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
  /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve children from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterChildrenSourceIdentifier:cluster:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterChildrenSourceIdentifier:cluster:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        [api getGeoJsonClusterChildrenSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
  /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve the expansion zoom from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeoJsonClusterExpansionZoomSourceIdentifier:cluster:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getGeoJsonClusterExpansionZoomSourceIdentifier:cluster:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceIdentifier = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_cluster = GetNullableObjectAtIndex(args, 1);
        [api getGeoJsonClusterExpansionZoomSourceIdentifier:arg_sourceIdentifier cluster:arg_cluster completion:^(FLTFeatureExtensionValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the state object of a feature within a style source.
  ///
  /// Update entries in the `state` object of a given feature within a style source. Only properties of the
  /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
  /// retain its previous value.
  ///
  /// Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be updated.
  /// @param state The `state` object with properties to update with their respective new values.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setFeatureStateSourceId:sourceLayerId:featureId:state:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(setFeatureStateSourceId:sourceLayerId:featureId:state:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        NSString *arg_state = GetNullableObjectAtIndex(args, 3);
        [api setFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId state:arg_state completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the state map of a feature within a style source.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
  /// immediately visible.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be queried.
  /// @param completion The `query feature state completion` called when the query completes.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getFeatureStateSourceId:sourceLayerId:featureId:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getFeatureStateSourceId:sourceLayerId:featureId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        [api getFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Removes entries from a feature state object.
  ///
  /// Remove a specified property or all property from a feature's state object, depending on the value of
  /// `stateKey`.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method migth not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeFeatureStateSourceId:sourceLayerId:featureId:stateKey:completion:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(removeFeatureStateSourceId:sourceLayerId:featureId:stateKey:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_sourceLayerId = GetNullableObjectAtIndex(args, 1);
        NSString *arg_featureId = GetNullableObjectAtIndex(args, 2);
        NSString *arg_stateKey = GetNullableObjectAtIndex(args, 3);
        [api removeFeatureStateSourceId:arg_sourceId sourceLayerId:arg_sourceLayerId featureId:arg_featureId stateKey:arg_stateKey completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Reduces memory use. Useful to call when the application gets paused or sent to background.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(reduceMemoryUseWithError:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(reduceMemoryUseWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api reduceMemoryUseWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate The `coordinate` defined as longitude-latitude pair.
  /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation"
        binaryMessenger:binaryMessenger
        codec:FLT_MapInterfaceGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getElevationCoordinate:error:)], @"FLT_MapInterface api (%@) doesn't respond to @selector(getElevationCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api getElevationCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTOfflineRegionCodecReader : FlutterStandardReader
@end
@implementation FLTOfflineRegionCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 129: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 130: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTOfflineRegionCodecWriter : FlutterStandardWriter
@end
@implementation FLTOfflineRegionCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTOfflineRegionCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTOfflineRegionCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTOfflineRegionCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTOfflineRegionCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTOfflineRegionGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTOfflineRegionCodecReaderWriter *readerWriter = [[FLTOfflineRegionCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLTOfflineRegion(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineRegion> *api) {
  /// The regions identifier
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getIdentifier"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getIdentifierWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getIdentifierWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api getIdentifierWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// The tile pyramid defining the region. Tile pyramid and geometry definitions are
  /// mutually exclusive.
  ///
  /// @return A definition describing the tile pyramid including attributes, otherwise empty.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getTilePyramidDefinition"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getTilePyramidDefinitionWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getTilePyramidDefinitionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTOfflineRegionTilePyramidDefinition *output = [api getTilePyramidDefinitionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// The geometry defining the region. Geometry and tile pyramid definitions are
  /// mutually exclusive.
  ///
  /// @return A definition describing the geometry including attributes, otherwise empty.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getGeometryDefinition"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getGeometryDefinitionWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getGeometryDefinitionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTOfflineRegionGeometryDefinition *output = [api getGeometryDefinitionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Arbitrary binary region metadata.
  ///
  /// @return The metadata associated with the region.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getMetadata"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMetadataWithError:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(getMetadataWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FlutterStandardTypedData *output = [api getMetadataWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets arbitrary binary region metadata for the region.
  ///
  /// Note that this setter is asynchronous and the given metadata is applied only
  /// after the resulting callback is invoked with no error.
  ///
  /// @param metadata The metadata associated with the region.
  /// @param callback Called once the request is complete or an error occurred.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setMetadata"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMetadataMetadata:completion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(setMetadataMetadata:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FlutterStandardTypedData *arg_metadata = GetNullableObjectAtIndex(args, 0);
        [api setMetadataMetadata:arg_metadata completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the download state of an offline region
  /// A region is either inactive (not downloading, but previously-downloaded
  /// resources are available for use), or active (resources are being downloaded
  /// or will be downloaded, if necessary, when network access is available).
  ///
  /// If the region is already in the given state, this call is ignored.
  ///
  /// @param state The new state to set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setOfflineRegionDownloadState"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setOfflineRegionDownloadStateState:error:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(setOfflineRegionDownloadStateState:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTOfflineRegionDownloadState arg_state = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setOfflineRegionDownloadStateState:arg_state error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Invalidate all the tiles for the region forcing to revalidate
  /// the tiles with the server before using. This is more efficient than deleting the
  /// offline region and downloading it again because if the data on the cache matches
  /// the server, no new data gets transmitted.
  ///
  /// @param callback Called once the request is complete or an error occurred.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.invalidate"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateWithCompletion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(invalidateWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api invalidateWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Remove an offline region from the database and perform any resources
  /// evictions necessary as a result.
  ///
  /// @param callback Called once the request is complete or an error occurred.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.purge"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(purgeWithCompletion:)], @"FLTOfflineRegion api (%@) doesn't respond to @selector(purgeWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api purgeWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTOfflineRegionManagerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLTOfflineRegionManager(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineRegionManager> *api) {
  /// Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
  ///
  /// By default, the limit is set to 6,000.
  /// Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
  /// fires every additional attempt to download additional tiles until already downloaded tiles are removed
  /// by calling `OfflineRegion.purge()` API.
  ///
  /// @param limit the maximum number of tiles allowed to be downloaded
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegionManager.setOfflineMapboxTileCountLimit"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineRegionManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setOfflineMapboxTileCountLimitLimit:error:)], @"FLTOfflineRegionManager api (%@) doesn't respond to @selector(setOfflineMapboxTileCountLimitLimit:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSInteger arg_limit = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setOfflineMapboxTileCountLimitLimit:arg_limit error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTProjectionCodecReader : FlutterStandardReader
@end
@implementation FLTProjectionCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTAmbientLight fromList:[self readValue]];
    case 129: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 130: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 135: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 136: 
      return [FLTDirectionalLight fromList:[self readValue]];
    case 137: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 138: 
      return [FLTFlatLight fromList:[self readValue]];
    case 139: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 140: 
      return [FLTImageContent fromList:[self readValue]];
    case 141: 
      return [FLTImageStretches fromList:[self readValue]];
    case 142: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 143: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 144: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 145: 
      return [FLTMapOptions fromList:[self readValue]];
    case 146: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 147: 
      return [FLTMbxImage fromList:[self readValue]];
    case 148: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 150: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 151: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 152: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 153: 
      return [FLTQueriedRenderedFeature fromList:[self readValue]];
    case 154: 
      return [FLTQueriedSourceFeature fromList:[self readValue]];
    case 155: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 156: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 157: 
      return [FLTScreenBox fromList:[self readValue]];
    case 158: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 159: 
      return [FLTSize fromList:[self readValue]];
    case 160: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 161: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 162: 
      return [FLTStyleProjection fromList:[self readValue]];
    case 163: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 164: 
      return [FLTTileCacheBudgetInMegabytes fromList:[self readValue]];
    case 165: 
      return [FLTTileCacheBudgetInTiles fromList:[self readValue]];
    case 166: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTProjectionCodecWriter : FlutterStandardWriter
@end
@implementation FLTProjectionCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTAmbientLight class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTDirectionalLight class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFlatLight class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedRenderedFeature class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedSourceFeature class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleProjection class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInMegabytes class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInTiles class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTProjectionCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTProjectionCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTProjectionCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTProjectionCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTProjectionGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTProjectionCodecReaderWriter *readerWriter = [[FLTProjectionCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLTProjection(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTProjection> *api) {
  /// Calculate distance spanned by one pixel at the specified latitude
  /// and zoom level.
  ///
  /// @param latitude The latitude for which to return the value.
  /// @param zoom The zoom level.
  ///
  /// @return Returns the distance measured in meters.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getMetersPerPixelAtLatitudeLatitude:zoom:error:)], @"FLTProjection api (%@) doesn't respond to @selector(getMetersPerPixelAtLatitudeLatitude:zoom:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        double arg_latitude = [GetNullableObjectAtIndex(args, 0) doubleValue];
        double arg_zoom = [GetNullableObjectAtIndex(args, 1) doubleValue];
        FlutterError *error;
        NSNumber *output = [api getMetersPerPixelAtLatitudeLatitude:arg_latitude zoom:arg_zoom error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate Spherical Mercator ProjectedMeters coordinates.
  ///
  /// @param coordinate A longitude-latitude pair for which to calculate
  /// `projected meters` coordinates.
  ///
  /// @return Returns Spherical Mercator ProjectedMeters coordinates.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(projectedMetersForCoordinateCoordinate:error:)], @"FLTProjection api (%@) doesn't respond to @selector(projectedMetersForCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTProjectedMeters *output = [api projectedMetersForCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate a longitude-latitude pair for a Spherical Mercator projected
  /// meters.
  ///
  /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
  /// which to calculate a longitude-latitude pair.
  ///
  /// @return Returns a longitude-latitude pair.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateForProjectedMetersProjectedMeters:error:)], @"FLTProjection api (%@) doesn't respond to @selector(coordinateForProjectedMetersProjectedMeters:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTProjectedMeters *arg_projectedMeters = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateForProjectedMetersProjectedMeters:arg_projectedMeters error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate a point on the map in Mercator Projection for a given
  /// coordinate at the specified zoom scale.
  ///
  /// @param coordinate The longitude-latitude pair for which to return the value.
  /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a point on the map in Mercator projection.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.project"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(projectCoordinate:zoomScale:error:)], @"FLTProjection api (%@) doesn't respond to @selector(projectCoordinate:zoomScale:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        double arg_zoomScale = [GetNullableObjectAtIndex(args, 1) doubleValue];
        FlutterError *error;
        FLTMercatorCoordinate *output = [api projectCoordinate:arg_coordinate zoomScale:arg_zoomScale error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate a coordinate for a given point on the map in Mercator Projection.
  ///
  /// @param coordinate Point on the map in Mercator projection.
  /// @param zoomScale The current zoom factor applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a coordinate.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject"
        binaryMessenger:binaryMessenger
        codec:FLTProjectionGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unprojectCoordinate:zoomScale:error:)], @"FLTProjection api (%@) doesn't respond to @selector(unprojectCoordinate:zoomScale:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTMercatorCoordinate *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        double arg_zoomScale = [GetNullableObjectAtIndex(args, 1) doubleValue];
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api unprojectCoordinate:arg_coordinate zoomScale:arg_zoomScale error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLT_MapboxOptionsGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLT_MapboxOptions(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_MapboxOptions> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.getAccessToken"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAccessTokenWithError:)], @"FLT_MapboxOptions api (%@) doesn't respond to @selector(getAccessTokenWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api getAccessTokenWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.setAccessToken"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setAccessTokenToken:error:)], @"FLT_MapboxOptions api (%@) doesn't respond to @selector(setAccessTokenToken:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_token = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setAccessTokenToken:arg_token error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLT_MapboxMapsOptionsGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLT_MapboxMapsOptions(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLT_MapboxMapsOptions> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getBaseUrl"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getBaseUrlWithError:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(getBaseUrlWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api getBaseUrlWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setBaseUrl"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setBaseUrlUrl:error:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(setBaseUrlUrl:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_url = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setBaseUrlUrl:arg_url error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getDataPath"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getDataPathWithError:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(getDataPathWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api getDataPathWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setDataPath"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setDataPathPath:error:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(setDataPathPath:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_path = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setDataPathPath:arg_path error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getAssetPath"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAssetPathWithError:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(getAssetPathWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSString *output = [api getAssetPathWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setAssetPath"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setAssetPathPath:error:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(setAssetPathPath:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_path = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setAssetPathPath:arg_path error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getTileStoreUsageMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getTileStoreUsageModeWithError:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(getTileStoreUsageModeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTTileStoreUsageModeBox * enumBox = [api getTileStoreUsageModeWithError:&error];
        NSNumber *output = enumBox == nil ? nil : [NSNumber numberWithInteger:enumBox.value];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setTileStoreUsageMode"
        binaryMessenger:binaryMessenger
        codec:FLT_MapboxMapsOptionsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setTileStoreUsageModeMode:error:)], @"FLT_MapboxMapsOptions api (%@) doesn't respond to @selector(setTileStoreUsageModeMode:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTTileStoreUsageMode arg_mode = [GetNullableObjectAtIndex(args, 0) integerValue];
        FlutterError *error;
        [api setTileStoreUsageModeMode:arg_mode error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTSettingsGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLTSettings(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTSettings> *api) {
  /// Sets setting value for a specified key.
  ///
  /// @param key A name of the key.
  /// @param value The `value` for the key.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Settings.set"
        binaryMessenger:binaryMessenger
        codec:FLTSettingsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setKey:value:error:)], @"FLTSettings api (%@) doesn't respond to @selector(setKey:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        NSString *arg_value = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setKey:arg_key value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Return value for a key.
  ///
  /// @param key A name of the key.
  ///
  /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Settings.get"
        binaryMessenger:binaryMessenger
        codec:FLTSettingsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getKey:error:)], @"FLTSettings api (%@) doesn't respond to @selector(getKey:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_key = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSString *output = [api getKey:arg_key error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTMapSnapshotCodecReader : FlutterStandardReader
@end
@implementation FLTMapSnapshotCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTAmbientLight fromList:[self readValue]];
    case 129: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 130: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 135: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 136: 
      return [FLTDirectionalLight fromList:[self readValue]];
    case 137: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 138: 
      return [FLTFlatLight fromList:[self readValue]];
    case 139: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 140: 
      return [FLTImageContent fromList:[self readValue]];
    case 141: 
      return [FLTImageStretches fromList:[self readValue]];
    case 142: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 143: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 144: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 145: 
      return [FLTMapOptions fromList:[self readValue]];
    case 146: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 147: 
      return [FLTMbxImage fromList:[self readValue]];
    case 148: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 150: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 151: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 152: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 153: 
      return [FLTQueriedRenderedFeature fromList:[self readValue]];
    case 154: 
      return [FLTQueriedSourceFeature fromList:[self readValue]];
    case 155: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 156: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 157: 
      return [FLTScreenBox fromList:[self readValue]];
    case 158: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 159: 
      return [FLTSize fromList:[self readValue]];
    case 160: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 161: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 162: 
      return [FLTStyleProjection fromList:[self readValue]];
    case 163: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 164: 
      return [FLTTileCacheBudgetInMegabytes fromList:[self readValue]];
    case 165: 
      return [FLTTileCacheBudgetInTiles fromList:[self readValue]];
    case 166: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTMapSnapshotCodecWriter : FlutterStandardWriter
@end
@implementation FLTMapSnapshotCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTAmbientLight class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTDirectionalLight class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFlatLight class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedRenderedFeature class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedSourceFeature class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleProjection class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInMegabytes class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInTiles class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTMapSnapshotCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTMapSnapshotCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTMapSnapshotCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTMapSnapshotCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTMapSnapshotGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTMapSnapshotCodecReaderWriter *readerWriter = [[FLTMapSnapshotCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLTMapSnapshot(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTMapSnapshot> *api) {
  /// Calculate screen coordinate on the snapshot from geographical `coordinate`.
  ///
  /// @param coordinate A geographical `coordinate`.
  /// @return A `screen coordinate` measured in `logical pixels` on the snapshot for geographical `coordinate`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.screenCoordinate"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(screenCoordinateCoordinate:error:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(screenCoordinateCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        FLTScreenCoordinate *output = [api screenCoordinateCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Calculate geographical coordinates from a point on the snapshot.
  ///
  /// @param screenCoordinate A `screen coordinate` on the snapshot in `logical pixels`.
  /// @return A geographical `coordinate` for a `screen coordinate` on the snapshot.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.coordinate"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(coordinateScreenCoordinate:error:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(coordinateScreenCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTScreenCoordinate *arg_screenCoordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, id> *output = [api coordinateScreenCoordinate:arg_screenCoordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get list of attributions for the sources in this snapshot.
  ///
  /// @return A list of attributions for the sources in this snapshot.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.attributions"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(attributionsWithError:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(attributionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<NSString *> *output = [api attributionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get the rendered snapshot `image`.
  ///
  /// @return A rendered snapshot `image`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.image"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(imageWithError:)], @"FLTMapSnapshot api (%@) doesn't respond to @selector(imageWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTMbxImage *output = [api imageWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTMapSnapshotterCodecReader : FlutterStandardReader
@end
@implementation FLTMapSnapshotterCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTAmbientLight fromList:[self readValue]];
    case 129: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 130: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 135: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 136: 
      return [FLTDirectionalLight fromList:[self readValue]];
    case 137: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 138: 
      return [FLTFlatLight fromList:[self readValue]];
    case 139: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 140: 
      return [FLTImageContent fromList:[self readValue]];
    case 141: 
      return [FLTImageStretches fromList:[self readValue]];
    case 142: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 143: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 144: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 145: 
      return [FLTMapOptions fromList:[self readValue]];
    case 146: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 147: 
      return [FLTMbxImage fromList:[self readValue]];
    case 148: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 150: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 151: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 152: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 153: 
      return [FLTQueriedRenderedFeature fromList:[self readValue]];
    case 154: 
      return [FLTQueriedSourceFeature fromList:[self readValue]];
    case 155: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 156: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 157: 
      return [FLTScreenBox fromList:[self readValue]];
    case 158: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 159: 
      return [FLTSize fromList:[self readValue]];
    case 160: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 161: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 162: 
      return [FLTStyleProjection fromList:[self readValue]];
    case 163: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 164: 
      return [FLTTileCacheBudgetInMegabytes fromList:[self readValue]];
    case 165: 
      return [FLTTileCacheBudgetInTiles fromList:[self readValue]];
    case 166: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTMapSnapshotterCodecWriter : FlutterStandardWriter
@end
@implementation FLTMapSnapshotterCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTAmbientLight class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTDirectionalLight class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFlatLight class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedRenderedFeature class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedSourceFeature class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleProjection class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInMegabytes class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInTiles class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTMapSnapshotterCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTMapSnapshotterCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTMapSnapshotterCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTMapSnapshotterCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTMapSnapshotterGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTMapSnapshotterCodecReaderWriter *readerWriter = [[FLTMapSnapshotterCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLTMapSnapshotter(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTMapSnapshotter> *api) {
  /// Sets the `size` of the snapshot
  ///
  /// @param size The new `size` of the snapshot in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setSize"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSizeSize:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(setSizeSize:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTSize *arg_size = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setSizeSize:arg_size error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the size of the snapshot
  ///
  /// @return Snapshot `size` in `logical pixels`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getSize"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSizeWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(getSizeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTSize *output = [api getSizeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns `true` if the snapshotter is in the tile mode.
  ///
  /// @return `true` if the snapshotter is in the tile mode, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.isInTileMode"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isInTileModeWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(isInTileModeWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isInTileModeWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the snapshotter to the tile mode.
  ///
  /// In the tile mode, the snapshotter fetches the still image of a single tile.
  ///
  /// @param set A `boolean` value representing if the snapshotter is in the tile mode.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setTileMode"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setTileModeSet:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(setTileModeSet:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        BOOL arg_set = [GetNullableObjectAtIndex(args, 0) boolValue];
        FlutterError *error;
        [api setTileModeSet:arg_set error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Cancel the current snapshot operation.
  ///
  /// Cancel the current snapshot operation, if any. The callback passed to the start method
  /// is called with error parameter set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.cancel"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelWithError:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(cancelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate defined as longitude-latitude pair.
  ///
  /// @return Elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getElevation"
        binaryMessenger:binaryMessenger
        codec:FLTMapSnapshotterGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getElevationCoordinate:error:)], @"FLTMapSnapshotter api (%@) doesn't respond to @selector(getElevationCoordinate:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSDictionary<NSString *, id> *arg_coordinate = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSNumber *output = [api getElevationCoordinate:arg_coordinate error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FLTStyleManagerCodecReader : FlutterStandardReader
@end
@implementation FLTStyleManagerCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [FLTAmbientLight fromList:[self readValue]];
    case 129: 
      return [FLTCameraBounds fromList:[self readValue]];
    case 130: 
      return [FLTCameraBoundsOptions fromList:[self readValue]];
    case 131: 
      return [FLTCameraOptions fromList:[self readValue]];
    case 132: 
      return [FLTCameraState fromList:[self readValue]];
    case 133: 
      return [FLTCanonicalTileID fromList:[self readValue]];
    case 134: 
      return [FLTCoordinateBounds fromList:[self readValue]];
    case 135: 
      return [FLTCoordinateBoundsZoom fromList:[self readValue]];
    case 136: 
      return [FLTDirectionalLight fromList:[self readValue]];
    case 137: 
      return [FLTFeatureExtensionValue fromList:[self readValue]];
    case 138: 
      return [FLTFlatLight fromList:[self readValue]];
    case 139: 
      return [FLTGlyphsRasterizationOptions fromList:[self readValue]];
    case 140: 
      return [FLTImageContent fromList:[self readValue]];
    case 141: 
      return [FLTImageStretches fromList:[self readValue]];
    case 142: 
      return [FLTLayerPosition fromList:[self readValue]];
    case 143: 
      return [FLTMapAnimationOptions fromList:[self readValue]];
    case 144: 
      return [FLTMapDebugOptions fromList:[self readValue]];
    case 145: 
      return [FLTMapOptions fromList:[self readValue]];
    case 146: 
      return [FLTMbxEdgeInsets fromList:[self readValue]];
    case 147: 
      return [FLTMbxImage fromList:[self readValue]];
    case 148: 
      return [FLTMercatorCoordinate fromList:[self readValue]];
    case 149: 
      return [FLTOfflineRegionGeometryDefinition fromList:[self readValue]];
    case 150: 
      return [FLTOfflineRegionTilePyramidDefinition fromList:[self readValue]];
    case 151: 
      return [FLTProjectedMeters fromList:[self readValue]];
    case 152: 
      return [FLTQueriedFeature fromList:[self readValue]];
    case 153: 
      return [FLTQueriedRenderedFeature fromList:[self readValue]];
    case 154: 
      return [FLTQueriedSourceFeature fromList:[self readValue]];
    case 155: 
      return [FLTRenderedQueryGeometry fromList:[self readValue]];
    case 156: 
      return [FLTRenderedQueryOptions fromList:[self readValue]];
    case 157: 
      return [FLTScreenBox fromList:[self readValue]];
    case 158: 
      return [FLTScreenCoordinate fromList:[self readValue]];
    case 159: 
      return [FLTSize fromList:[self readValue]];
    case 160: 
      return [FLTSourceQueryOptions fromList:[self readValue]];
    case 161: 
      return [FLTStyleObjectInfo fromList:[self readValue]];
    case 162: 
      return [FLTStyleProjection fromList:[self readValue]];
    case 163: 
      return [FLTStylePropertyValue fromList:[self readValue]];
    case 164: 
      return [FLTTileCacheBudgetInMegabytes fromList:[self readValue]];
    case 165: 
      return [FLTTileCacheBudgetInTiles fromList:[self readValue]];
    case 166: 
      return [FLTTransitionOptions fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FLTStyleManagerCodecWriter : FlutterStandardWriter
@end
@implementation FLTStyleManagerCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[FLTAmbientLight class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBounds class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraBoundsOptions class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraOptions class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCameraState class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCanonicalTileID class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBounds class]]) {
    [self writeByte:134];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTCoordinateBoundsZoom class]]) {
    [self writeByte:135];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTDirectionalLight class]]) {
    [self writeByte:136];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFeatureExtensionValue class]]) {
    [self writeByte:137];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTFlatLight class]]) {
    [self writeByte:138];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTGlyphsRasterizationOptions class]]) {
    [self writeByte:139];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageContent class]]) {
    [self writeByte:140];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTImageStretches class]]) {
    [self writeByte:141];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTLayerPosition class]]) {
    [self writeByte:142];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapAnimationOptions class]]) {
    [self writeByte:143];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapDebugOptions class]]) {
    [self writeByte:144];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMapOptions class]]) {
    [self writeByte:145];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxEdgeInsets class]]) {
    [self writeByte:146];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMbxImage class]]) {
    [self writeByte:147];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTMercatorCoordinate class]]) {
    [self writeByte:148];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionGeometryDefinition class]]) {
    [self writeByte:149];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTOfflineRegionTilePyramidDefinition class]]) {
    [self writeByte:150];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTProjectedMeters class]]) {
    [self writeByte:151];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedFeature class]]) {
    [self writeByte:152];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedRenderedFeature class]]) {
    [self writeByte:153];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTQueriedSourceFeature class]]) {
    [self writeByte:154];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryGeometry class]]) {
    [self writeByte:155];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTRenderedQueryOptions class]]) {
    [self writeByte:156];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenBox class]]) {
    [self writeByte:157];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTScreenCoordinate class]]) {
    [self writeByte:158];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSize class]]) {
    [self writeByte:159];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTSourceQueryOptions class]]) {
    [self writeByte:160];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleObjectInfo class]]) {
    [self writeByte:161];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStyleProjection class]]) {
    [self writeByte:162];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTStylePropertyValue class]]) {
    [self writeByte:163];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInMegabytes class]]) {
    [self writeByte:164];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTileCacheBudgetInTiles class]]) {
    [self writeByte:165];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[FLTTransitionOptions class]]) {
    [self writeByte:166];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FLTStyleManagerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FLTStyleManagerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FLTStyleManagerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FLTStyleManagerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FLTStyleManagerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FLTStyleManagerCodecReaderWriter *readerWriter = [[FLTStyleManagerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void SetUpFLTStyleManager(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTStyleManager> *api) {
  /// Get the URI of the current style in use.
  ///
  /// @return A string containing a style URI.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleURIWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleURIWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleURIWithCompletion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Load style from provided URI.
  ///
  /// This is an asynchronous call. To check the result of this operation the user must register an observer observing
  /// `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
  ///
  /// @param uri URI where the style should be loaded from.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleURIUri:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleURIUri:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_uri = GetNullableObjectAtIndex(args, 0);
        [api setStyleURIUri:arg_uri completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get the JSON serialization string of the current style in use.
  ///
  /// @return A JSON string containing a serialized style.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleJSONWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleJSONWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleJSONWithCompletion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Load the style from a provided JSON string.
  ///
  /// @param json A JSON string containing a serialized style.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleJSONJson:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleJSONJson:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_json = GetNullableObjectAtIndex(args, 0);
        [api setStyleJSONJson:arg_json completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the map style's default camera, if any, or a default camera otherwise.
  /// The map style's default camera is defined as follows:
  /// - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
  /// - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
  /// - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
  /// - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
  ///
  /// The style default camera is re-evaluated when a new style is loaded.
  ///
  /// @return The default `camera options` of the current style in use.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleDefaultCameraWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleDefaultCameraWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleDefaultCameraWithCompletion:^(FLTCameraOptions *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the map style's transition options. By default, the style parser will attempt
  /// to read the style default transition options, if any, fallbacking to an immediate transition
  /// otherwise. Transition options can be overriden via `setStyleTransition`, but the options are
  /// reset once a new style has been loaded.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @return The `transition options` of the current style in use.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleTransitionWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleTransitionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleTransitionWithCompletion:^(FLTTransitionOptions *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the list containing information about existing style import objects.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImports"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleImportsWithError:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleImportsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<FLTStyleObjectInfo *> *output = [api getStyleImportsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Removes an existing style import.
  ///
  /// @param importId Identifier of the style import to remove.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImport"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleImportImportId:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleImportImportId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_importId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api removeStyleImportImportId:arg_importId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the style import schema.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import schema, containing the default configurations for the style import.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportSchema"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleImportSchemaImportId:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleImportSchemaImportId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_importId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        id output = [api getStyleImportSchemaImportId:arg_importId error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets style import config.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleImportConfigPropertiesImportId:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleImportConfigPropertiesImportId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_importId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        NSDictionary<NSString *, FLTStylePropertyValue *> *output = [api getStyleImportConfigPropertiesImportId:arg_importId error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the value of style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleImportConfigPropertyImportId:config:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleImportConfigPropertyImportId:config:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_importId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_config = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        FLTStylePropertyValue *output = [api getStyleImportConfigPropertyImportId:arg_importId config:arg_config error:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets style import config.
  /// This method can be used to perform batch update for a style import configurations.
  ///
  /// @param importId Identifier of the style import.
  /// @param configs A map of style import configurations.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleImportConfigPropertiesImportId:configs:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleImportConfigPropertiesImportId:configs:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_importId = GetNullableObjectAtIndex(args, 0);
        NSDictionary<NSString *, id> *arg_configs = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setStyleImportConfigPropertiesImportId:arg_importId configs:arg_configs error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets a value to a style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  /// @param value The style import config value.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleImportConfigPropertyImportId:config:value:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleImportConfigPropertyImportId:config:value:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_importId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_config = GetNullableObjectAtIndex(args, 1);
        id arg_value = GetNullableObjectAtIndex(args, 2);
        FlutterError *error;
        [api setStyleImportConfigPropertyImportId:arg_importId config:arg_config value:arg_value error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Overrides the map style's transition options with user-provided options.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @param transitionOptions The `transition options`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleTransitionTransitionOptions:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleTransitionTransitionOptions:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTTransitionOptions *arg_transitionOptions = GetNullableObjectAtIndex(args, 0);
        [api setStyleTransitionTransitionOptions:arg_transitionOptions completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Runtime style layers are valid until they are either removed or a new style is loaded.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addStyleLayerProperties:layerPosition:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addStyleLayerProperties:layerPosition:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        FLTLayerPosition *arg_layerPosition = GetNullableObjectAtIndex(args, 1);
        [api addStyleLayerProperties:arg_properties layerPosition:arg_layerPosition completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Whenever a new style is being parsed and currently used style has persistent layers,
  /// an engine will try to do following:
  ///   - keep the persistent layer at its relative position
  ///   - keep the source used by a persistent layer
  ///   - keep images added through `addStyleImage` method
  ///
  /// In cases when a new style has the same layer, source or image resource, style's resources would be
  /// used instead and `MapLoadingError` event will be emitted.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addPersistentStyleLayerProperties:layerPosition:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addPersistentStyleLayerProperties:layerPosition:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        FLTLayerPosition *arg_layerPosition = GetNullableObjectAtIndex(args, 1);
        [api addPersistentStyleLayerProperties:arg_properties layerPosition:arg_layerPosition completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Checks if a style layer is persistent.
  ///
  /// @param layerId A style layer identifier.
  /// @return A string describing an error if the operation was not successful, boolean representing state otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isStyleLayerPersistentLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(isStyleLayerPersistentLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api isStyleLayerPersistentLayerId:arg_layerId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Removes an existing style layer.
  ///
  /// @param layerId An identifier of the style layer to remove.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleLayerLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleLayerLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api removeStyleLayerLayerId:arg_layerId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Moves an existing style layer
  ///
  /// @param layerId Identifier of the style layer to move.
  /// @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
  ///                      is provided then the layer is moved to the top of the layerstack.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(moveStyleLayerLayerId:layerPosition:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(moveStyleLayerLayerId:layerPosition:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        FLTLayerPosition *arg_layerPosition = GetNullableObjectAtIndex(args, 1);
        [api moveStyleLayerLayerId:arg_layerId layerPosition:arg_layerPosition completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Checks whether a given style layer exists.
  ///
  /// @param layerId Style layer identifier.
  ///
  /// @return A `true` value if the given style layer exists, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(styleLayerExistsLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(styleLayerExistsLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api styleLayerExistsLayerId:arg_layerId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the existing style layers.
  ///
  /// @return The list containing the information about existing style layer objects.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLayersWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLayersWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleLayersWithCompletion:^(NSArray<FLTStyleObjectInfo *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the value of style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @return The `style property value`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLayerPropertyLayerId:property:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLayerPropertyLayerId:property:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        [api getStyleLayerPropertyLayerId:arg_layerId property:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets a value to a style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @param value The style layer property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLayerPropertyLayerId:property:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLayerPropertyLayerId:property:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        id arg_value = GetNullableObjectAtIndex(args, 2);
        [api setStyleLayerPropertyLayerId:arg_layerId property:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets style layer properties.
  ///
  /// @return The style layer properties or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLayerPropertiesLayerId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLayerPropertiesLayerId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        [api getStyleLayerPropertiesLayerId:arg_layerId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets style layer properties.
  /// This method can be used to perform batch update for a style layer properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
  /// Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
  ///
  /// @param layerId A style layer identifier.
  /// @param properties A map of style layer properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLayerPropertiesLayerId:properties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLayerPropertiesLayerId:properties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_layerId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_properties = GetNullableObjectAtIndex(args, 1);
        [api setStyleLayerPropertiesLayerId:arg_layerId properties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
  ///
  /// @param sourceId An identifier for the style source.
  /// @param properties A map of style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addStyleSourceSourceId:properties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addStyleSourceSourceId:properties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_properties = GetNullableObjectAtIndex(args, 1);
        [api addStyleSourceSourceId:arg_sourceId properties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the value of style source property.
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @return The value of a `property` in the source with a `sourceId`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleSourcePropertySourceId:property:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleSourcePropertySourceId:property:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        [api getStyleSourcePropertySourceId:arg_sourceId property:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets a value to a style source property.
  /// Note: When setting the `data` property of a `geojson` source, this method never returns an error.
  /// In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
  ///
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @param value The style source property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleSourcePropertySourceId:property:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleSourcePropertySourceId:property:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        id arg_value = GetNullableObjectAtIndex(args, 2);
        [api setStyleSourcePropertySourceId:arg_sourceId property:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets style source properties.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return The style source properties or a string describing an error if the operation was not successful.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleSourcePropertiesSourceId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleSourcePropertiesSourceId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        [api getStyleSourcePropertiesSourceId:arg_sourceId completion:^(NSString *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets style source properties.
  ///
  /// This method can be used to perform batch update for a style source properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
  /// Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
  ///
  /// @param sourceId A style source identifier.
  /// @param properties A map of Style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleSourcePropertiesSourceId:properties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleSourcePropertiesSourceId:properties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        NSString *arg_properties = GetNullableObjectAtIndex(args, 1);
        [api setStyleSourcePropertiesSourceId:arg_sourceId properties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
  ///
  /// @param sourceId A style source identifier.
  /// @param image An `image`.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateStyleImageSourceImageSourceId:image:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(updateStyleImageSourceImageSourceId:image:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTMbxImage *arg_image = GetNullableObjectAtIndex(args, 1);
        [api updateStyleImageSourceImageSourceId:arg_sourceId image:arg_image completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Removes an existing style source.
  ///
  /// @param sourceId An identifier of the style source to remove.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleSourceSourceId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleSourceSourceId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        [api removeStyleSourceSourceId:arg_sourceId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Checks whether a given style source exists.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return `true` if the given source exists, `false` otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(styleSourceExistsSourceId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(styleSourceExistsSourceId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        [api styleSourceExistsSourceId:arg_sourceId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns the existing style sources.
  ///
  /// @return The list containing the information about existing style source objects.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleSourcesWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleSourcesWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getStyleSourcesWithCompletion:^(NSArray<FLTStyleObjectInfo *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Returns an ordered list of the current style lights.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLights"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLightsWithError:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLightsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSArray<FLTStyleObjectInfo *> *output = [api getStyleLightsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Set global directional lightning.
  ///
  /// @param flatLight The flat light source.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLight"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLightFlatLight:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setLightFlatLight:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTFlatLight *arg_flatLight = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setLightFlatLight:arg_flatLight error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Set dynamic lightning.
  ///
  /// @param ambientLight The ambient light source.
  /// @param directionalLight The directional light source.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLights"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setLightsAmbientLight:directionalLight:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setLightsAmbientLight:directionalLight:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTAmbientLight *arg_ambientLight = GetNullableObjectAtIndex(args, 0);
        FLTDirectionalLight *arg_directionalLight = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api setLightsAmbientLight:arg_ambientLight directionalLight:arg_directionalLight error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the value of a style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @return The style light property value.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleLightPropertyId:property:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleLightPropertyId:property:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_id = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        [api getStyleLightPropertyId:arg_id property:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets a value to the the style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @param value The style light property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleLightPropertyId:property:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleLightPropertyId:property:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_id = GetNullableObjectAtIndex(args, 0);
        NSString *arg_property = GetNullableObjectAtIndex(args, 1);
        id arg_value = GetNullableObjectAtIndex(args, 2);
        [api setStyleLightPropertyId:arg_id property:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
  ///
  /// @param properties A map of style terrain properties values, with their names as a key.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleTerrainProperties:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleTerrainProperties:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_properties = GetNullableObjectAtIndex(args, 0);
        [api setStyleTerrainProperties:arg_properties completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Gets the value of a style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @return The style terrain property value.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleTerrainPropertyProperty:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleTerrainPropertyProperty:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_property = GetNullableObjectAtIndex(args, 0);
        [api getStyleTerrainPropertyProperty:arg_property completion:^(FLTStylePropertyValue *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Sets a value to the the style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @param value The style terrain property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setStyleTerrainPropertyProperty:value:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setStyleTerrainPropertyProperty:value:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_property = GetNullableObjectAtIndex(args, 0);
        id arg_value = GetNullableObjectAtIndex(args, 1);
        [api setStyleTerrainPropertyProperty:arg_property value:arg_value completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Get an `image` from the style.
  ///
  /// @param imageId The identifier of the `image`.
  ///
  /// @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getStyleImageImageId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getStyleImageImageId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        [api getStyleImageImageId:arg_imageId completion:^(FLTMbxImage *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Adds an image to be used in the style. This API can also be used for updating
  /// an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
  ///
  /// The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
  /// [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
  /// [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
  /// [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
  ///
  /// @param imageId An identifier of the image.
  /// @param scale A scale factor for the image.
  /// @param image A pixel data of the image.
  /// @param sdf An option to treat whether image is SDF(signed distance field) or not.
  /// @param stretchX An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched horizontally.
  /// @param stretchY An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched vertically.
  /// @param content An array of four numbers, with the first two specifying the left, top
  /// corner, and the last two specifying the right, bottom corner. If present, and if the
  /// icon uses icon-text-fit, the symbol's text will be fit inside the content box.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addStyleImageImageId:scale:image:sdf:stretchX:stretchY:content:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(addStyleImageImageId:scale:image:sdf:stretchX:stretchY:content:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        double arg_scale = [GetNullableObjectAtIndex(args, 1) doubleValue];
        FLTMbxImage *arg_image = GetNullableObjectAtIndex(args, 2);
        BOOL arg_sdf = [GetNullableObjectAtIndex(args, 3) boolValue];
        NSArray<FLTImageStretches *> *arg_stretchX = GetNullableObjectAtIndex(args, 4);
        NSArray<FLTImageStretches *> *arg_stretchY = GetNullableObjectAtIndex(args, 5);
        FLTImageContent *arg_content = GetNullableObjectAtIndex(args, 6);
        [api addStyleImageImageId:arg_imageId scale:arg_scale image:arg_image sdf:arg_sdf stretchX:arg_stretchX stretchY:arg_stretchY content:arg_content completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Removes an image from the style.
  ///
  /// @param imageId The identifier of the image to remove.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeStyleImageImageId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(removeStyleImageImageId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        [api removeStyleImageImageId:arg_imageId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Checks whether an image exists.
  ///
  /// @param imageId The identifier of the image.
  ///
  /// @return True if image exists, false otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasStyleImageImageId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(hasStyleImageImageId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_imageId = GetNullableObjectAtIndex(args, 0);
        [api hasStyleImageImageId:arg_imageId completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Set tile data of a custom geometry.
  ///
  /// @param sourceId A style source identifier.
  /// @param tileId A `canonical tile id` of the tile.
  /// @param featureCollection An array with the features to add.
  /// Invalidate tile for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier,.
  /// @param tileId A `canonical tile id` of the tile.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateStyleCustomGeometrySourceTileSourceId:tileId:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(invalidateStyleCustomGeometrySourceTileSourceId:tileId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTCanonicalTileID *arg_tileId = GetNullableObjectAtIndex(args, 1);
        [api invalidateStyleCustomGeometrySourceTileSourceId:arg_sourceId tileId:arg_tileId completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Invalidate region for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier
  /// @param bounds A `coordinate bounds` object.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(invalidateStyleCustomGeometrySourceRegionSourceId:bounds:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(invalidateStyleCustomGeometrySourceRegionSourceId:bounds:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_sourceId = GetNullableObjectAtIndex(args, 0);
        FLTCoordinateBounds *arg_bounds = GetNullableObjectAtIndex(args, 1);
        [api invalidateStyleCustomGeometrySourceRegionSourceId:arg_sourceId bounds:arg_bounds completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Check if the style is completely loaded.
  ///
  /// Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
  /// Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
  ///
  /// @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
  ///
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isStyleLoadedWithCompletion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(isStyleLoadedWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api isStyleLoadedWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Function to get the projection provided by the Style Extension.
  ///
  /// @return Projection that is currently applied to the map
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getProjectionWithError:)], @"FLTStyleManager api (%@) doesn't respond to @selector(getProjectionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        FLTStyleProjection *output = [api getProjectionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Function to set the projection provided by the Style Extension.
  ///
  /// @param projection The projection to be set.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setProjectionProjection:error:)], @"FLTStyleManager api (%@) doesn't respond to @selector(setProjectionProjection:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FLTStyleProjection *arg_projection = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api setProjectionProjection:arg_projection error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Function to localize style labels.
  ///
  /// @param locale The locale to apply for localization
  /// @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels"
        binaryMessenger:binaryMessenger
        codec:FLTStyleManagerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(localizeLabelsLocale:layerIds:completion:)], @"FLTStyleManager api (%@) doesn't respond to @selector(localizeLabelsLocale:layerIds:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_locale = GetNullableObjectAtIndex(args, 0);
        NSArray<NSString *> *arg_layerIds = GetNullableObjectAtIndex(args, 1);
        [api localizeLabelsLocale:arg_locale layerIds:arg_layerIds completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTCancelableGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLTCancelable(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTCancelable> *api) {
  /// Cancels the associated asynchronous operation
  ///
  /// If the associated asynchronous operation has already finished, this call is ignored.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel"
        binaryMessenger:binaryMessenger
        codec:FLTCancelableGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelWithError:)], @"FLTCancelable api (%@) doesn't respond to @selector(cancelWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTOfflineSwitchGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLTOfflineSwitch(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTOfflineSwitch> *api) {
  /// Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
  /// with HttpRequestErrorType#ConnectionError.
  ///
  /// @param connected Set false to disconnect the Mapbox stack
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.setMapboxStackConnected"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setMapboxStackConnectedConnected:error:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(setMapboxStackConnectedConnected:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        BOOL arg_connected = [GetNullableObjectAtIndex(args, 0) boolValue];
        FlutterError *error;
        [api setMapboxStackConnectedConnected:arg_connected error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
  ///
  /// @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.isMapboxStackConnected"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isMapboxStackConnectedWithError:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(isMapboxStackConnectedWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        NSNumber *output = [api isMapboxStackConnectedWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// Releases the OfflineSwitch singleton instance.
  ///
  /// Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
  /// If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.reset"
        binaryMessenger:binaryMessenger
        codec:FLTOfflineSwitchGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(resetWithError:)], @"FLTOfflineSwitch api (%@) doesn't respond to @selector(resetWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api resetWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *FLTTilesetDescriptorGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void SetUpFLTTilesetDescriptor(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FLTTilesetDescriptor> *api) {
}
