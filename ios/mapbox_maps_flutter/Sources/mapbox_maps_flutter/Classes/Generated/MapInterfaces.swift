// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point
import struct Turf.Feature

/// Error class for passing custom error details to Dart side.
final class MapInterfacesError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "MapInterfacesError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? MapInterfacesError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Describes glyphs rasterization modes.
enum GlyphsRasterizationMode: Int {
  /// No glyphs are rasterized locally. All glyphs are loaded from the server.
  case nOGLYPHSRASTERIZEDLOCALLY = 0
  /// Ideographs are rasterized locally, and they are not loaded from the server.
  case iDEOGRAPHSRASTERIZEDLOCALLY = 1
  /// All glyphs are rasterized locally. No glyphs are loaded from the server.
  case aLLGLYPHSRASTERIZEDLOCALLY = 2
}

/// Describes the map context mode.
/// We can make some optimizations if we know that the drawing context is not shared with other code.
enum ContextMode: Int {
  /// Unique context mode: in OpenGL, the GL context is not shared, thus we can retain knowledge about the GL state
  /// from a previous render pass. It also enables clearing the screen using glClear for the bottommost background
  /// layer when no pattern is applied to that layer.
  case uNIQUE = 0
  /// Shared context mode: in OpenGL, the GL context is shared with other renderers, thus we cannot rely on the GL
  /// state set from a previous render pass.
  case sHARED = 1
}

/// Describes whether to constrain the map in both axes or only vertically e.g. while panning.
enum ConstrainMode: Int {
  /// No constrains.
  case nONE = 0
  /// Constrain to height only
  case hEIGHTONLY = 1
  /// Constrain both width and height axes.
  case wIDTHANDHEIGHT = 2
}

/// Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards.
enum ViewportMode: Int {
  /// Default viewport
  case dEFAULT = 0
  /// Viewport flipped on the y-axis.
  case fLIPPEDY = 1
}

/// Describes the map orientation.
enum NorthOrientation: Int {
  /// Default, map oriented upwards
  case uPWARDS = 0
  /// Map oriented rightwards
  case rIGHTWARDS = 1
  /// Map oriented downwards
  case dOWNWARDS = 2
  /// Map oriented leftwards
  case lEFTWARDS = 3
}

enum _MapWidgetDebugOptions: Int {
  case tileBorders = 0
  case parseStatus = 1
  case timestamps = 2
  case collision = 3
  case overdraw = 4
  case stencilClip = 5
  case depthBuffer = 6
  case modelBounds = 7
  case terrainWireframe = 8
  case layers2DWireframe = 9
  case layers3DWireframe = 10
  case light = 11
  case camera = 12
  case padding = 13
}

/// Options for enabling debugging features in a map.
enum MapDebugOptionsData: Int {
  /// Edges of tile boundaries are shown as thick, red lines to help diagnose
  /// tile clipping issues.
  case tILEBORDERS = 0
  /// Each tile shows its tile coordinate (x/y/z) in the upper-left corner.
  case pARSESTATUS = 1
  /// Each tile shows a timestamp indicating when it was loaded.
  case tIMESTAMPS = 2
  /// Edges of glyphs and symbols are shown as faint, green lines to help
  /// diagnose collision and label placement issues.
  case cOLLISION = 3
  /// Each drawing operation is replaced by a translucent fill. Overlapping
  /// drawing operations appear more prominent to help diagnose overdrawing.
  case oVERDRAW = 4
  /// The stencil buffer is shown instead of the color buffer.
  case sTENCILCLIP = 5
  /// The depth buffer is shown instead of the color buffer.
  case dEPTHBUFFER = 6
  /// Visualize residency of tiles in the render cache. Tile boundaries of cached tiles
  /// are rendered with green, tiles waiting for an update with yellow and tiles not in the cache
  /// with red.
  case rENDERCACHE = 7
  /// Show 3D model bounding boxes.
  case mODELBOUNDS = 8
  /// Show a wireframe for terrain.
  case tERRAINWIREFRAME = 9
}

/// Enum describing how to place view annotation relatively to geometry.
enum ViewAnnotationAnchor: Int {
  /// The top of the view annotation is placed closest to the geometry.
  case tOP = 0
  /// The left side of the view annotation is placed closest to the geometry.
  case lEFT = 1
  /// The bottom of the view annotation is placed closest to the geometry.
  case bOTTOM = 2
  /// The right side of the view annotation is placed closest to the geometry.
  case rIGHT = 3
  /// The top-left corner of the view annotation is placed closest to the geometry.
  case tOPLEFT = 4
  /// The bottom-right corner of the view annotation is placed closest to the geometry.
  case bOTTOMRIGHT = 5
  /// The top-right corner of the view annotation is placed closest to the geometry.
  case tOPRIGHT = 6
  /// The bottom-left corner of the view annotation is placed closest to the geometry.
  case bOTTOMLEFT = 7
  /// The center of the view annotation is placed closest to the geometry.
  case cENTER = 8
}

/// Type information of the variant's content
enum Type: Int {
  case sCREENBOX = 0
  case sCREENCOORDINATE = 1
  case lIST = 2
}

/// Controls the behavior of fill extrusion base over terrain
enum FillExtrusionBaseAlignment: Int {
  /// The fill extrusion base follows terrain slope.
  case tERRAIN = 0
  /// The fill extrusion base is flat over terrain.
  case fLAT = 1
}

/// Controls the behavior of fill extrusion height over terrain
enum FillExtrusionHeightAlignment: Int {
  /// The fill extrusion base follows terrain slope.
  case tERRAIN = 0
  /// The fill extrusion base is flat over terrain.
  case fLAT = 1
}

/// Orientation of background layer.
enum BackgroundPitchAlignment: Int {
  /// The background is aligned to the plane of the map.
  case mAP = 0
  /// The background is aligned to the plane of the viewport, covering the whole screen.
  case vIEWPORT = 1
}

/// Describes the reason for a style package download request failure.
enum StylePackErrorType: Int {
  /// The operation was canceled.
  case cANCELED = 0
  /// The style package does not exist.
  case dOESNOTEXIST = 1
  /// There is no available space to store the resources.
  case dISKFULL = 2
  /// Other reason.
  case oTHER = 3
}

/// Describes the reason for an offline request response error.
enum ResponseErrorReason: Int {
  /// No error occurred during the resource request.
  case sUCCESS = 0
  /// The resource is not found.
  case nOTFOUND = 1
  /// The server error.
  case sERVER = 2
  /// The connection error.
  case cONNECTION = 3
  /// The error happened because of a rate limit.
  case rATELIMIT = 4
  /// The resource cannot be loaded because the device is in offline mode.
  case iNOFFLINEMODE = 5
  /// Other reason.
  case oTHER = 6
}

/// Describes the download state of a region.
enum OfflineRegionDownloadState: Int {
  /// Indicates downloading is inactive.
  case iNACTIVE = 0
  /// Indicates downloading is active.
  case aCTIVE = 1
}

/// Describes tile store usage modes.
enum TileStoreUsageMode: Int {
  /// Tile store usage is disabled.
  ///
  /// The implementation skips checking tile store when requesting a tile.
  case dISABLED = 0
  /// Tile store enabled for accessing loaded tile packs.
  ///
  /// The implementation first checks tile store when requesting a tile.
  /// If a tile pack is already loaded, the tile will be extracted and returned. Otherwise, the implementation
  /// falls back to requesting the individual tile and storing it in the disk cache.
  case rEADONLY = 1
  /// Tile store enabled for accessing local tile packs and for loading new tile packs from server.
  ///
  /// All tile requests are converted to tile pack requests, i.e.
  /// the tile pack that includes the request tile will be loaded, and the tile extracted
  /// from it. In this mode, no individual tile requests will be made.
  ///
  /// This mode can be useful if the map trajectory is predefined and the user cannot pan
  /// freely (e.g. navigation use cases), so that there is a good chance tile packs are already loaded
  /// in the vicinity of the user.
  ///
  /// If users can pan freely, this mode is not recommended. Otherwise, panning
  /// will download tile packs instead of using individual tiles. Note that this means that we could first
  /// download an individual tile, and then a tile pack that also includes this tile. The individual tile in
  /// the disk cache wonâ€™t be used as long as the up-to-date tile pack exists in the cache.
  case rEADANDUPDATE = 2
}

/// Describes the kind of a style property value.
enum StylePropertyValueKind: Int {
  /// The property value is not defined.
  case uNDEFINED = 0
  /// The property value is a constant.
  case cONSTANT = 1
  /// The property value is a style [expression](https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions).
  case eXPRESSION = 2
  /// Property value is a style [transition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#transition).
  case tRANSITION = 3
}

enum StyleProjectionName: Int {
  case mercator = 0
  case globe = 1
}

/// Whether extruded geometries are lit relative to the map or viewport.
enum Anchor: Int {
  /// The position of the light source is aligned to the rotation of the map.
  case mAP = 0
  /// The position of the light source is aligned to the rotation of the viewport.
  case vIEWPORT = 1
}

/// HTTP defines a set of request methods to indicate the desired action to be performed for a given resource.
enum HttpMethod: Int {
  /// The GET method requests a representation of the specified resource. Requests using GET should only retrieve data.
  case gET = 0
  /// The HEAD method asks for a response identical to that of a GET request, but without the response body.
  case hEAD = 1
  /// The POST method sends data (stored in the request body) to a server to create or update a given resource.
  case pOST = 2
}

/// Enum which describes possible error types which could happen during HTTP request/download calls.
enum HttpRequestErrorType: Int {
  /// Establishing connection related error.
  case cONNECTIONERROR = 0
  /// SSL related error.
  case sSLERROR = 1
  /// Request was cancelled by the user.
  case rEQUESTCANCELLED = 2
  /// Timeout error.
  case rEQUESTTIMEDOUT = 3
  /// Range request failed.
  case rANGEERROR = 4
  /// Other than above error.
  case oTHERERROR = 5
}

/// Enum which represents different error cases which could happen during download session.
enum DownloadErrorCode: Int {
  /// General filesystem related error code. For cases like: write error, no such file or directory, not enough space and etc.
  case fILESYSTEMERROR = 0
  /// General network related error. Should be probably representation of HttpRequestError.
  case nETWORKERROR = 1
}

/// Enum representing state of download session.
enum DownloadState: Int {
  /// Download session initiated but not started yet.
  case pENDING = 0
  /// Download session is in progress.
  case dOWNLOADING = 1
  /// Download session failed.
  case fAILED = 2
  /// Download session successfully finished.
  case fINISHED = 3
}

/// Describes the reason for a tile region download request failure.
enum TileRegionErrorType: Int {
  /// The operation was canceled.
  case cANCELED = 0
  /// tile region does not exist.
  case dOESNOTEXIST = 1
  /// Tileset descriptors resolving failed.
  case tILESETDESCRIPTOR = 2
  /// There is no available space to store the resources
  case dISKFULL = 3
  /// Other reason.
  case oTHER = 4
  /// The region contains more tiles than allowed.
  case tILECOUNTEXCEEDED = 5
}

enum _MapEvent: Int {
  case mapLoaded = 0
  case mapLoadingError = 1
  case styleLoaded = 2
  case styleDataLoaded = 3
  case cameraChanged = 4
  case mapIdle = 5
  case sourceAdded = 6
  case sourceRemoved = 7
  case sourceDataLoaded = 8
  case styleImageMissing = 9
  case styleImageRemoveUnused = 10
  case renderFrameStarted = 11
  case renderFrameFinished = 12
  case resourceRequest = 13
}

/// Describes the glyphs rasterization option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct GlyphsRasterizationOptions {
  /// Glyphs rasterization mode for client-side text rendering.
  var rasterizationMode: GlyphsRasterizationMode
  /// Font family to use as font fallback for client-side text renderings.
  ///
  /// Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
  /// or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
  /// font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
  /// default font are varied in platforms:
  /// - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
  ///   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
  /// - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
  ///
  /// Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
  ///
  var fontFamily: String?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GlyphsRasterizationOptions? {
    let rasterizationMode = pigeonVar_list[0] as! GlyphsRasterizationMode
    let fontFamily: String? = nilOrValue(pigeonVar_list[1])

    return GlyphsRasterizationOptions(
      rasterizationMode: rasterizationMode,
      fontFamily: fontFamily
    )
  }
  func toList() -> [Any?] {
    return [
      rasterizationMode,
      fontFamily,
    ]
  }
}

/// Various options needed for tile cover.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileCoverOptions {
  /// Tile size of the source. Defaults to 512.
  var tileSize: Int64?
  /// Min zoom defined in the source between range [0, 22].
  /// if not provided or is out of range, defaults to 0.
  var minZoom: Int64?
  /// Max zoom defined in the source between range [0, 22].
  /// Should be greater than or equal to minZoom.
  /// If not provided or is out of range, defaults to 22.
  var maxZoom: Int64?
  /// Whether to round zoom values when calculating tilecover.
  /// Set this to true for raster and raster-dem sources.
  /// If not specified, defaults to false.
  var roundZoom: Bool?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TileCoverOptions? {
    let tileSize: Int64? = nilOrValue(pigeonVar_list[0])
    let minZoom: Int64? = nilOrValue(pigeonVar_list[1])
    let maxZoom: Int64? = nilOrValue(pigeonVar_list[2])
    let roundZoom: Bool? = nilOrValue(pigeonVar_list[3])

    return TileCoverOptions(
      tileSize: tileSize,
      minZoom: minZoom,
      maxZoom: maxZoom,
      roundZoom: roundZoom
    )
  }
  func toList() -> [Any?] {
    return [
      tileSize,
      minZoom,
      maxZoom,
      roundZoom,
    ]
  }
}

/// The distance on each side between rectangles, when one is contained into other.
///
/// All fields' values are in `logical pixel` units.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MbxEdgeInsets {
  /// Padding from the top.
  var top: Double
  /// Padding from the left.
  var left: Double
  /// Padding from the bottom.
  var bottom: Double
  /// Padding from the right.
  var right: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MbxEdgeInsets? {
    let top = pigeonVar_list[0] as! Double
    let left = pigeonVar_list[1] as! Double
    let bottom = pigeonVar_list[2] as! Double
    let right = pigeonVar_list[3] as! Double

    return MbxEdgeInsets(
      top: top,
      left: left,
      bottom: bottom,
      right: right
    )
  }
  func toList() -> [Any?] {
    return [
      top,
      left,
      bottom,
      right,
    ]
  }
}

/// Various options for describing the viewpoint of a camera. All fields are
/// optional.
///
/// Anchor and center points are mutually exclusive, with preference for the
/// center point when both are set.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraOptions {
  /// Coordinate at the center of the camera.
  var center: Point?
  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  var padding: MbxEdgeInsets?
  /// Point of reference for `zoom` and `angle`, assuming an origin at the
  /// top-left corner of the view.
  var anchor: ScreenCoordinate?
  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  var zoom: Double?
  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  var bearing: Double?
  /// Pitch toward the horizon measured in degrees.
  var pitch: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CameraOptions? {
    let center: Point? = nilOrValue(pigeonVar_list[0])
    let padding: MbxEdgeInsets? = nilOrValue(pigeonVar_list[1])
    let anchor: ScreenCoordinate? = nilOrValue(pigeonVar_list[2])
    let zoom: Double? = nilOrValue(pigeonVar_list[3])
    let bearing: Double? = nilOrValue(pigeonVar_list[4])
    let pitch: Double? = nilOrValue(pigeonVar_list[5])

    return CameraOptions(
      center: center,
      padding: padding,
      anchor: anchor,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch
    )
  }
  func toList() -> [Any?] {
    return [
      center,
      padding,
      anchor,
      zoom,
      bearing,
      pitch,
    ]
  }
}

/// Describes the viewpoint of a camera.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraState {
  /// Coordinate at the center of the camera.
  var center: Point
  /// Padding around the interior of the view that affects the frame of
  /// reference for `center`.
  var padding: MbxEdgeInsets
  /// Zero-based zoom level. Constrained to the minimum and maximum zoom
  /// levels.
  var zoom: Double
  /// Bearing, measured in degrees from true north. Wrapped to [0, 360).
  var bearing: Double
  /// Pitch toward the horizon measured in degrees.
  var pitch: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CameraState? {
    let center = pigeonVar_list[0] as! Point
    let padding = pigeonVar_list[1] as! MbxEdgeInsets
    let zoom = pigeonVar_list[2] as! Double
    let bearing = pigeonVar_list[3] as! Double
    let pitch = pigeonVar_list[4] as! Double

    return CameraState(
      center: center,
      padding: padding,
      zoom: zoom,
      bearing: bearing,
      pitch: pitch
    )
  }
  func toList() -> [Any?] {
    return [
      center,
      padding,
      zoom,
      bearing,
      pitch,
    ]
  }
}

/// Holds options to be used for setting `camera bounds`.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraBoundsOptions {
  /// The latitude and longitude bounds to which the camera center are constrained.
  var bounds: CoordinateBounds?
  /// The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area.
  var maxZoom: Double?
  /// The minimum zoom level, in Mapbox zoom levels 0-25.5.
  var minZoom: Double?
  /// The maximum allowed pitch value in degrees.
  var maxPitch: Double?
  /// The minimum allowed pitch value in degrees.
  var minPitch: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CameraBoundsOptions? {
    let bounds: CoordinateBounds? = nilOrValue(pigeonVar_list[0])
    let maxZoom: Double? = nilOrValue(pigeonVar_list[1])
    let minZoom: Double? = nilOrValue(pigeonVar_list[2])
    let maxPitch: Double? = nilOrValue(pigeonVar_list[3])
    let minPitch: Double? = nilOrValue(pigeonVar_list[4])

    return CameraBoundsOptions(
      bounds: bounds,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch
    )
  }
  func toList() -> [Any?] {
    return [
      bounds,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    ]
  }
}

/// Holds information about `camera bounds`.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CameraBounds {
  /// The latitude and longitude bounds to which the camera center are constrained.
  var bounds: CoordinateBounds
  /// The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area.
  var maxZoom: Double
  /// The minimum zoom level, in Mapbox zoom levels 0-25.5.
  var minZoom: Double
  /// The maximum allowed pitch value in degrees.
  var maxPitch: Double
  /// The minimum allowed pitch value in degrees.
  var minPitch: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CameraBounds? {
    let bounds = pigeonVar_list[0] as! CoordinateBounds
    let maxZoom = pigeonVar_list[1] as! Double
    let minZoom = pigeonVar_list[2] as! Double
    let maxPitch = pigeonVar_list[3] as! Double
    let minPitch = pigeonVar_list[4] as! Double

    return CameraBounds(
      bounds: bounds,
      maxZoom: maxZoom,
      minZoom: minZoom,
      maxPitch: maxPitch,
      minPitch: minPitch
    )
  }
  func toList() -> [Any?] {
    return [
      bounds,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MapAnimationOptions {
  /// The duration of the animation in milliseconds.
  /// If not set explicitly default duration will be taken 300ms
  var duration: Int64?
  /// The amount of time, in milliseconds, to delay starting the animation after animation start.
  /// If not set explicitly default startDelay will be taken 0ms. This only works for Android.
  var startDelay: Int64?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MapAnimationOptions? {
    let duration: Int64? = nilOrValue(pigeonVar_list[0])
    let startDelay: Int64? = nilOrValue(pigeonVar_list[1])

    return MapAnimationOptions(
      duration: duration,
      startDelay: startDelay
    )
  }
  func toList() -> [Any?] {
    return [
      duration,
      startDelay,
    ]
  }
}

/// A rectangular area as measured on a two-dimensional map projection.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CoordinateBounds {
  /// Coordinate at the southwest corner.
  /// Note: setting this field with invalid values (infinite, NaN) will crash the application.
  var southwest: Point
  /// Coordinate at the northeast corner.
  /// Note: setting this field with invalid values (infinite, NaN) will crash the application.
  var northeast: Point
  /// If set to `true`, an infinite (unconstrained) bounds covering the world coordinates would be used.
  /// Coordinates provided in `southwest` and `northeast` fields would be omitted and have no effect.
  var infiniteBounds: Bool

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CoordinateBounds? {
    let southwest = pigeonVar_list[0] as! Point
    let northeast = pigeonVar_list[1] as! Point
    let infiniteBounds = pigeonVar_list[2] as! Bool

    return CoordinateBounds(
      southwest: southwest,
      northeast: northeast,
      infiniteBounds: infiniteBounds
    )
  }
  func toList() -> [Any?] {
    return [
      southwest,
      northeast,
      infiniteBounds,
    ]
  }
}

/// Options for enabling debugging features in a map.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapDebugOptions {
  var data: MapDebugOptionsData

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MapDebugOptions? {
    let data = pigeonVar_list[0] as! MapDebugOptionsData

    return MapDebugOptions(
      data: data
    )
  }
  func toList() -> [Any?] {
    return [
      data
    ]
  }
}

/// Map memory budget in megabytes.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileCacheBudgetInMegabytes {
  var size: Int64

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TileCacheBudgetInMegabytes? {
    let size = pigeonVar_list[0] as! Int64

    return TileCacheBudgetInMegabytes(
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      size
    ]
  }
}

/// Map memory budget in tiles.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TileCacheBudgetInTiles {
  var size: Int64

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TileCacheBudgetInTiles? {
    let size = pigeonVar_list[0] as! Int64

    return TileCacheBudgetInTiles(
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      size
    ]
  }
}

/// Describes the map option values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapOptions {
  /// The map context mode. This can be used to optimizations
  /// if we know that the drawing context is not shared with other code.
  var contextMode: ContextMode?
  /// The map constrain mode. This can be used to limit the map
  /// to wrap around the globe horizontally. By default, it is set to
  /// `HeightOnly`.
  var constrainMode: ConstrainMode?
  /// The viewport mode. This can be used to flip the vertical
  /// orientation of the map as some devices may use inverted orientation.
  var viewportMode: ViewportMode?
  /// The orientation of the Map. By default, it is set to
  /// `Upwards`.
  var orientation: NorthOrientation?
  /// Specify whether to enable cross-source symbol collision detection
  /// or not. By default, it is set to `true`.
  var crossSourceCollisions: Bool?
  /// The size to resize the map object and renderer backend.
  /// The size is given in `logical pixel` units. macOS and iOS platforms use
  /// device-independent pixel units, while other platforms, such as Android,
  /// use screen pixel units.
  var size: Size?
  /// The custom pixel ratio. By default, it is set to 1.0
  var pixelRatio: Double
  /// Glyphs rasterization options to use for client-side text rendering.
  var glyphsRasterizationOptions: GlyphsRasterizationOptions?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MapOptions? {
    let contextMode: ContextMode? = nilOrValue(pigeonVar_list[0])
    let constrainMode: ConstrainMode? = nilOrValue(pigeonVar_list[1])
    let viewportMode: ViewportMode? = nilOrValue(pigeonVar_list[2])
    let orientation: NorthOrientation? = nilOrValue(pigeonVar_list[3])
    let crossSourceCollisions: Bool? = nilOrValue(pigeonVar_list[4])
    let size: Size? = nilOrValue(pigeonVar_list[5])
    let pixelRatio = pigeonVar_list[6] as! Double
    let glyphsRasterizationOptions: GlyphsRasterizationOptions? = nilOrValue(pigeonVar_list[7])

    return MapOptions(
      contextMode: contextMode,
      constrainMode: constrainMode,
      viewportMode: viewportMode,
      orientation: orientation,
      crossSourceCollisions: crossSourceCollisions,
      size: size,
      pixelRatio: pixelRatio,
      glyphsRasterizationOptions: glyphsRasterizationOptions
    )
  }
  func toList() -> [Any?] {
    return [
      contextMode,
      constrainMode,
      viewportMode,
      orientation,
      crossSourceCollisions,
      size,
      pixelRatio,
      glyphsRasterizationOptions,
    ]
  }
}

/// Describes the coordinate on the screen, measured from top to bottom and from left to right.
/// Note: the `map` uses screen coordinate units measured in `logical pixels`.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ScreenCoordinate {
  /// A value representing the x position of this coordinate.
  var x: Double
  /// A value representing the y position of this coordinate.
  var y: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ScreenCoordinate? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double

    return ScreenCoordinate(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

/// Describes the coordinate box on the screen, measured in `logical pixels`
/// from top to bottom and from left to right.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ScreenBox {
  /// The screen coordinate close to the top left corner of the screen.
  var min: ScreenCoordinate
  /// The screen coordinate close to the bottom right corner of the screen.
  var max: ScreenCoordinate

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ScreenBox? {
    let min = pigeonVar_list[0] as! ScreenCoordinate
    let max = pigeonVar_list[1] as! ScreenCoordinate

    return ScreenBox(
      min: min,
      max: max
    )
  }
  func toList() -> [Any?] {
    return [
      min,
      max,
    ]
  }
}

/// A coordinate bounds and zoom.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CoordinateBoundsZoom {
  /// The latitude and longitude bounds.
  var bounds: CoordinateBounds
  /// Zoom.
  var zoom: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CoordinateBoundsZoom? {
    let bounds = pigeonVar_list[0] as! CoordinateBounds
    let zoom = pigeonVar_list[1] as! Double

    return CoordinateBoundsZoom(
      bounds: bounds,
      zoom: zoom
    )
  }
  func toList() -> [Any?] {
    return [
      bounds,
      zoom,
    ]
  }
}

/// Size type.
///
/// Generated class from Pigeon that represents data sent in messages.
struct Size {
  /// Width of the size.
  var width: Double
  /// Height of the size.
  var height: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> Size? {
    let width = pigeonVar_list[0] as! Double
    let height = pigeonVar_list[1] as! Double

    return Size(
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
    ]
  }
}

/// Options for querying rendered features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct RenderedQueryOptions {
  /// Layer IDs to include in the query.
  var layerIds: [String?]?
  /// Filters the returned features with an expression
  var filter: String?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RenderedQueryOptions? {
    let layerIds: [String?]? = nilOrValue(pigeonVar_list[0])
    let filter: String? = nilOrValue(pigeonVar_list[1])

    return RenderedQueryOptions(
      layerIds: layerIds,
      filter: filter
    )
  }
  func toList() -> [Any?] {
    return [
      layerIds,
      filter,
    ]
  }
}

/// Options for querying source features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct SourceQueryOptions {
  /// Source layer IDs to include in the query.
  var sourceLayerIds: [String?]?
  /// Filters the returned features with an expression
  var filter: String

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SourceQueryOptions? {
    let sourceLayerIds: [String?]? = nilOrValue(pigeonVar_list[0])
    let filter = pigeonVar_list[1] as! String

    return SourceQueryOptions(
      sourceLayerIds: sourceLayerIds,
      filter: filter
    )
  }
  func toList() -> [Any?] {
    return [
      sourceLayerIds,
      filter,
    ]
  }
}

/// A value or a collection of a feature extension.
///
/// Generated class from Pigeon that represents data sent in messages.
struct FeatureExtensionValue {
  /// An optional value of a feature extension
  var value: String?
  /// An optional array of features from a feature extension.
  var featureCollection: [[String?: Any?]?]?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FeatureExtensionValue? {
    let value: String? = nilOrValue(pigeonVar_list[0])
    let featureCollection: [[String?: Any?]?]? = nilOrValue(pigeonVar_list[1])

    return FeatureExtensionValue(
      value: value,
      featureCollection: featureCollection
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      featureCollection,
    ]
  }
}

/// Specifies position of a layer that is added via addStyleLayer method.
///
/// Generated class from Pigeon that represents data sent in messages.
struct LayerPosition {
  /// Layer should be positioned above specified layer id.
  var above: String?
  /// Layer should be positioned below specified layer id.
  var below: String?
  /// Layer should be positioned at specified index in a layers stack.
  var at: Int64?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> LayerPosition? {
    let above: String? = nilOrValue(pigeonVar_list[0])
    let below: String? = nilOrValue(pigeonVar_list[1])
    let at: Int64? = nilOrValue(pigeonVar_list[2])

    return LayerPosition(
      above: above,
      below: below,
      at: at
    )
  }
  func toList() -> [Any?] {
    return [
      above,
      below,
      at,
    ]
  }
}

/// Represents query result that is returned in QueryRenderedFeaturesCallback.
/// @see `queryRenderedFeatures`
///
/// Generated class from Pigeon that represents data sent in messages.
struct QueriedRenderedFeature {
  /// Feature returned by the query.
  var queriedFeature: QueriedFeature
  /// An array of layer Ids for the queried feature.
  /// If the feature has been rendered in multiple layers, multiple Ids will be provided.
  /// If the feature is only rendered in one layer, a single Id will be provided.
  var layers: [String?]
  /// An array of feature query targets that correspond to this queried feature.
  ///
  /// - Note: Returned query targets will omit the original `filter` data.
  var queryTargets: [FeaturesetQueryTarget]?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> QueriedRenderedFeature? {
    let queriedFeature = pigeonVar_list[0] as! QueriedFeature
    let layers = pigeonVar_list[1] as! [String?]
    let queryTargets: [FeaturesetQueryTarget]? = nilOrValue(pigeonVar_list[2])

    return QueriedRenderedFeature(
      queriedFeature: queriedFeature,
      layers: layers,
      queryTargets: queryTargets
    )
  }
  func toList() -> [Any?] {
    return [
      queriedFeature,
      layers,
      queryTargets,
    ]
  }
}

/// Represents query result that is returned in QuerySourceFeaturesCallback.
/// @see `querySourceFeatures`
///
/// Generated class from Pigeon that represents data sent in messages.
struct QueriedSourceFeature {
  /// Feature returned by the query.
  var queriedFeature: QueriedFeature

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> QueriedSourceFeature? {
    let queriedFeature = pigeonVar_list[0] as! QueriedFeature

    return QueriedSourceFeature(
      queriedFeature: queriedFeature
    )
  }
  func toList() -> [Any?] {
    return [
      queriedFeature
    ]
  }
}

/// Represents query result that is returned in QueryFeaturesCallback.
/// @see `queryRenderedFeatures` or `querySourceFeatures`
///
/// Generated class from Pigeon that represents data sent in messages.
struct QueriedFeature {
  /// Feature returned by the query.
  var feature: [String?: Any?]
  /// Source id for a queried feature.
  var source: String
  /// Source layer id for a queried feature. May be null if source does not support layers, e.g., 'geojson' source,
  /// or when data provided by the source is not layered.
  var sourceLayer: String?
  /// Feature state for a queried feature. Type of the value is an Object.
  /// @see `setFeatureState` and `getFeatureState`
  var state: String

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> QueriedFeature? {
    let feature = pigeonVar_list[0] as! [String?: Any?]
    let source = pigeonVar_list[1] as! String
    let sourceLayer: String? = nilOrValue(pigeonVar_list[2])
    let state = pigeonVar_list[3] as! String

    return QueriedFeature(
      feature: feature,
      source: source,
      sourceLayer: sourceLayer,
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      feature,
      source,
      sourceLayer,
      state,
    ]
  }
}

/// Identifies a feature in a featureset.
///
/// Knowing the feature identifier allows to set the feature states to a particular feature, see ``MapboxMap/setFeatureState(featureset:featureId:state:callback:)``.
///
/// In a featureset a feature can come from different underlying sources. In that case their IDs are not guaranteed to be unique in the featureset.
/// The ``FeaturesetFeatureId/namespace`` is used to disambiguate from which source the feature is coming.
///
/// - Warning: There is no guarantee of identifier persistency. This depends on the underlying source of the features and may vary from style to style.
/// If you want to store the identifiers persistently, please make sure that the style or source provides this guarantee.
///
/// Generated class from Pigeon that represents data sent in messages.
struct FeaturesetFeatureId {
  /// A feature id coming from the feature itself.exp
  var id: String
  /// A namespace of the feature
  var namespace: String?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FeaturesetFeatureId? {
    let id = pigeonVar_list[0] as! String
    let namespace: String? = nilOrValue(pigeonVar_list[1])

    return FeaturesetFeatureId(
      id: id,
      namespace: namespace
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      namespace,
    ]
  }
}

/// A featureset descriptor.
///
/// The descriptor instance acts as a universal target for interactions or querying rendered features (see 
/// ``MapboxMap/queryRenderedFeatures(with:featureset:filter:completion:)``).
///
/// Generated class from Pigeon that represents data sent in messages.
struct FeaturesetDescriptor {
  /// An optional unique identifier for the featureset within the style.
  /// This id is used to reference a specific featureset.
  /// 
  /// * Note: If `featuresetId` is provided and valid, it takes precedence over `layerId`,
  /// * meaning `layerId` will not be considered even if it has a valid value.
  var featuresetId: String?
  /// An optional import id that is required if the featureset is defined within an imported style.
  /// If the featureset belongs to the current style, this field should be set to a null string.
  /// 
  /// Note: `importId` is only applicable when used in conjunction with `featuresetId`
  /// and has no effect when used with `layerId`.
  var importId: String?
  /// An optional unique identifier for the layer within the current style.
  /// 
  /// Note: If `featuresetId` is valid, `layerId` will be ignored even if it has a valid value.
  /// Additionally, `importId` does not apply when using `layerId`.
  var layerId: String?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FeaturesetDescriptor? {
    let featuresetId: String? = nilOrValue(pigeonVar_list[0])
    let importId: String? = nilOrValue(pigeonVar_list[1])
    let layerId: String? = nilOrValue(pigeonVar_list[2])

    return FeaturesetDescriptor(
      featuresetId: featuresetId,
      importId: importId,
      layerId: layerId
    )
  }
  func toList() -> [Any?] {
    return [
      featuresetId,
      importId,
      layerId,
    ]
  }
}

/// A basic feature of a featureset.
///
/// The featureset feature is different to the `Turf.Feature`. The latter represents any GeoJSON feature, while the former is a high level representation of features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct FeaturesetFeature {
  /// An identifier of the feature.
  ///
  /// The identifier can be `nil` if the underlying source doesn't have identifiers for features.
  /// In this case it's impossible to set a feature state for an individual feature.
  var id: FeaturesetFeatureId?
  /// A featureset descriptor denoting the featureset this feature belongs to.
  var featureset: FeaturesetDescriptor
  /// A feature geometry.
  var geometry: [String?: Any?]
  /// Feature JSON properties.
  var properties: [String: Any?]
  /// A feature state.
  ///
  /// This is a **snapshot** of the state that the feature had when it was interacted with.
  /// To update and read the original state, use ``MapboxMap/setFeatureState()`` and ``MapboxMap/getFeatureState()``.
  var state: [String: Any?]

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FeaturesetFeature? {
    let id: FeaturesetFeatureId? = nilOrValue(pigeonVar_list[0])
    let featureset = pigeonVar_list[1] as! FeaturesetDescriptor
    let geometry = pigeonVar_list[2] as! [String?: Any?]
    let properties = pigeonVar_list[3] as! [String: Any?]
    let state = pigeonVar_list[4] as! [String: Any?]

    return FeaturesetFeature(
      id: id,
      featureset: featureset,
      geometry: geometry,
      properties: properties,
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      featureset,
      geometry,
      properties,
      state,
    ]
  }
}

/// Defines the parameters for querying features from a Featureset with an optional filter and id.
///
/// Generated class from Pigeon that represents data sent in messages.
struct FeaturesetQueryTarget {
  /// A `FeaturesetDescriptor` that specifies the featureset to be included in the query.
  var featureset: FeaturesetDescriptor
  /// An optional filter expression used to refine the query results based on conditions related to the specified featureset.
  var filter: String?
  /// An optional unique identifier associated with the target.
  var id: Int64?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FeaturesetQueryTarget? {
    let featureset = pigeonVar_list[0] as! FeaturesetDescriptor
    let filter: String? = nilOrValue(pigeonVar_list[1])
    let id: Int64? = nilOrValue(pigeonVar_list[2])

    return FeaturesetQueryTarget(
      featureset: featureset,
      filter: filter,
      id: id
    )
  }
  func toList() -> [Any?] {
    return [
      featureset,
      filter,
      id,
    ]
  }
}

/// Geometry for querying rendered features.
///
/// Generated class from Pigeon that represents data sent in messages.
struct _RenderedQueryGeometry {
  /// ScreenCoordinate/List<ScreenCoordinate>/ScreenBox in Json mode.
  var value: String
  var type: Type

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> _RenderedQueryGeometry? {
    let value = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! Type

    return _RenderedQueryGeometry(
      value: value,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      type,
    ]
  }
}

/// ProjectedMeters is a coordinate in a specific
/// [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection.
///
/// This specific Spherical Mercator projection assumes the Earth is a sphere with a radius
/// of 6,378,137 meters. Coordinates are determined as distances, in meters, on the surface
/// of that sphere.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ProjectedMeters {
  /// Projected meters in north direction.
  var northing: Double
  /// Projected meters in east direction.
  var easting: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ProjectedMeters? {
    let northing = pigeonVar_list[0] as! Double
    let easting = pigeonVar_list[1] as! Double

    return ProjectedMeters(
      northing: northing,
      easting: easting
    )
  }
  func toList() -> [Any?] {
    return [
      northing,
      easting,
    ]
  }
}

/// Describes a point on the map in Mercator projection.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MercatorCoordinate {
  /// A value representing the x position of this coordinate.
  var x: Double
  /// A value representing the y position of this coordinate.
  var y: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MercatorCoordinate? {
    let x = pigeonVar_list[0] as! Double
    let y = pigeonVar_list[1] as! Double

    return MercatorCoordinate(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

/// The information about style object (source or layer).
///
/// Generated class from Pigeon that represents data sent in messages.
struct StyleObjectInfo {
  /// The object's identifier.
  var id: String
  /// The object's type.
  var type: String

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StyleObjectInfo? {
    let id = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! String

    return StyleObjectInfo(
      id: id,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      type,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct StyleProjection {
  var name: StyleProjectionName

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StyleProjection? {
    let name = pigeonVar_list[0] as! StyleProjectionName

    return StyleProjection(
      name: name
    )
  }
  func toList() -> [Any?] {
    return [
      name
    ]
  }
}

/// A global directional light source which is only applied on 3D layers and hillshade layers. Using this type disables other light sources.
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
///
/// Generated class from Pigeon that represents data sent in messages.
struct FlatLight {
  /// Unique light name
  var id: String
  /// Whether extruded geometries are lit relative to the map or viewport.
  var anchor: Anchor?
  /// Color tint for lighting extruded geometries.
  var color: Int64?
  /// Transition property for `color`
  var colorTransition: TransitionOptions?
  /// Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.
  var intensity: Double?
  /// Transition property for `intensity`
  var intensityTransition: TransitionOptions?
  /// Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0 degree (0 degree when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0 degree when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0 degree, directly above, to 180 degree, directly below).
  var position: [Double?]?
  /// Transition property for `position`
  var positionTransition: TransitionOptions?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> FlatLight? {
    let id = pigeonVar_list[0] as! String
    let anchor: Anchor? = nilOrValue(pigeonVar_list[1])
    let color: Int64? = nilOrValue(pigeonVar_list[2])
    let colorTransition: TransitionOptions? = nilOrValue(pigeonVar_list[3])
    let intensity: Double? = nilOrValue(pigeonVar_list[4])
    let intensityTransition: TransitionOptions? = nilOrValue(pigeonVar_list[5])
    let position: [Double?]? = nilOrValue(pigeonVar_list[6])
    let positionTransition: TransitionOptions? = nilOrValue(pigeonVar_list[7])

    return FlatLight(
      id: id,
      anchor: anchor,
      color: color,
      colorTransition: colorTransition,
      intensity: intensity,
      intensityTransition: intensityTransition,
      position: position,
      positionTransition: positionTransition
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      anchor,
      color,
      colorTransition,
      intensity,
      intensityTransition,
      position,
      positionTransition,
    ]
  }
}

/// A light that has a direction and is located at infinite, so its rays are parallel. Simulates the sun light and it can cast shadows
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
///
/// Generated class from Pigeon that represents data sent in messages.
struct DirectionalLight {
  /// Unique light name
  var id: String
  /// Enable/Disable shadow casting for this light
  var castShadows: Bool?
  /// Color of the directional light.
  var color: Int64?
  /// Transition property for `color`
  var colorTransition: TransitionOptions?
  /// Direction of the light source specified as [a azimuthal angle, p polar angle] where a indicates the azimuthal angle of the light relative to north (in degrees and proceeding clockwise), and p indicates polar angle of the light (from 0 degree, directly above, to 180 degree, directly below).
  var direction: [Double?]?
  /// Transition property for `direction`
  var directionTransition: TransitionOptions?
  /// A multiplier for the color of the directional light.
  var intensity: Double?
  /// Transition property for `intensity`
  var intensityTransition: TransitionOptions?
  /// Determines the shadow strength, affecting the shadow receiver surfaces final color. Values near 0.0 reduce the shadow contribution to the final color. Values near to 1.0 make occluded surfaces receive almost no directional light. Designed to be used mostly for transitioning between values 0 and 1.
  var shadowIntensity: Double?
  /// Transition property for `shadowIntensity`
  var shadowIntensityTransition: TransitionOptions?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DirectionalLight? {
    let id = pigeonVar_list[0] as! String
    let castShadows: Bool? = nilOrValue(pigeonVar_list[1])
    let color: Int64? = nilOrValue(pigeonVar_list[2])
    let colorTransition: TransitionOptions? = nilOrValue(pigeonVar_list[3])
    let direction: [Double?]? = nilOrValue(pigeonVar_list[4])
    let directionTransition: TransitionOptions? = nilOrValue(pigeonVar_list[5])
    let intensity: Double? = nilOrValue(pigeonVar_list[6])
    let intensityTransition: TransitionOptions? = nilOrValue(pigeonVar_list[7])
    let shadowIntensity: Double? = nilOrValue(pigeonVar_list[8])
    let shadowIntensityTransition: TransitionOptions? = nilOrValue(pigeonVar_list[9])

    return DirectionalLight(
      id: id,
      castShadows: castShadows,
      color: color,
      colorTransition: colorTransition,
      direction: direction,
      directionTransition: directionTransition,
      intensity: intensity,
      intensityTransition: intensityTransition,
      shadowIntensity: shadowIntensity,
      shadowIntensityTransition: shadowIntensityTransition
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      castShadows,
      color,
      colorTransition,
      direction,
      directionTransition,
      intensity,
      intensityTransition,
      shadowIntensity,
      shadowIntensityTransition,
    ]
  }
}

/// An indirect light affecting all objects in the map adding a constant amount of light on them. It has no explicit direction and cannot cast shadows.
///
/// - SeeAlso: [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light)
///
/// Generated class from Pigeon that represents data sent in messages.
struct AmbientLight {
  /// Unique light name
  var id: String
  /// Color of the ambient light.
  var color: Int64?
  /// Transition property for `color`
  var colorTransition: TransitionOptions?
  /// A multiplier for the color of the ambient light.
  var intensity: Double?
  /// Transition property for `intensity`
  var intensityTransition: TransitionOptions?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AmbientLight? {
    let id = pigeonVar_list[0] as! String
    let color: Int64? = nilOrValue(pigeonVar_list[1])
    let colorTransition: TransitionOptions? = nilOrValue(pigeonVar_list[2])
    let intensity: Double? = nilOrValue(pigeonVar_list[3])
    let intensityTransition: TransitionOptions? = nilOrValue(pigeonVar_list[4])

    return AmbientLight(
      id: id,
      color: color,
      colorTransition: colorTransition,
      intensity: intensity,
      intensityTransition: intensityTransition
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      color,
      colorTransition,
      intensity,
      intensityTransition,
    ]
  }
}

/// Image type.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MbxImage {
  /// The width of the image, in screen pixels.
  var width: Int64
  /// The height of the image, in screen pixels.
  var height: Int64
  /// 32-bit premultiplied RGBA image data.
  ///
  /// An uncompressed image data encoded in 32-bit RGBA format with premultiplied
  /// alpha channel. This field should contain exactly `4 * width * height` bytes. It
  /// should consist of a sequence of scanlines.
  var data: FlutterStandardTypedData

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MbxImage? {
    let width = pigeonVar_list[0] as! Int64
    let height = pigeonVar_list[1] as! Int64
    let data = pigeonVar_list[2] as! FlutterStandardTypedData

    return MbxImage(
      width: width,
      height: height,
      data: data
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
      data,
    ]
  }
}

/// Describes the image stretch areas.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ImageStretches {
  /// The first stretchable part in screen pixel units.
  var first: Double
  /// The second stretchable part in screen pixel units.
  var second: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ImageStretches? {
    let first = pigeonVar_list[0] as! Double
    let second = pigeonVar_list[1] as! Double

    return ImageStretches(
      first: first,
      second: second
    )
  }
  func toList() -> [Any?] {
    return [
      first,
      second,
    ]
  }
}

/// Describes the image content, e.g. where text can be fit into an image.
///
/// When sizing icons with `icon-text-fit`, the icon size will be adjusted so that the this content box fits exactly around the text.
///
/// Generated class from Pigeon that represents data sent in messages.
struct ImageContent {
  /// Distance to the left, in screen pixels.
  var left: Double
  /// Distance to the top, in screen pixels.
  var top: Double
  /// Distance to the right, in screen pixels.
  var right: Double
  /// Distance to the bottom, in screen pixels.
  var bottom: Double

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ImageContent? {
    let left = pigeonVar_list[0] as! Double
    let top = pigeonVar_list[1] as! Double
    let right = pigeonVar_list[2] as! Double
    let bottom = pigeonVar_list[3] as! Double

    return ImageContent(
      left: left,
      top: top,
      right: right,
      bottom: bottom
    )
  }
  func toList() -> [Any?] {
    return [
      left,
      top,
      right,
      bottom,
    ]
  }
}

/// The `transition options` controls timing for the interpolation between a transitionable style
/// property's previous value and new value. These can be used to define the style default property
/// transition behavior. Also, any transitionable style property may also have its own `-transition`
/// property that defines specific transition timing for that specific layer property, overriding
/// the global transition values.
///
/// Generated class from Pigeon that represents data sent in messages.
struct TransitionOptions {
  /// Time allotted for transitions to complete. Units in milliseconds. Defaults to `300.0`.
  var duration: Int64?
  /// Length of time before a transition begins. Units in milliseconds. Defaults to `0.0`.
  var delay: Int64?
  /// Whether the fade in/out symbol placement transition is enabled. Defaults to `true`.
  var enablePlacementTransitions: Bool?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TransitionOptions? {
    let duration: Int64? = nilOrValue(pigeonVar_list[0])
    let delay: Int64? = nilOrValue(pigeonVar_list[1])
    let enablePlacementTransitions: Bool? = nilOrValue(pigeonVar_list[2])

    return TransitionOptions(
      duration: duration,
      delay: delay,
      enablePlacementTransitions: enablePlacementTransitions
    )
  }
  func toList() -> [Any?] {
    return [
      duration,
      delay,
      enablePlacementTransitions,
    ]
  }
}

/// Represents a tile coordinate.
///
/// Generated class from Pigeon that represents data sent in messages.
struct CanonicalTileID {
  /// The z value of the coordinate (zoom-level).
  var z: Int64
  /// The x value of the coordinate.
  var x: Int64
  /// The y value of the coordinate.
  var y: Int64

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CanonicalTileID? {
    let z = pigeonVar_list[0] as! Int64
    let x = pigeonVar_list[1] as! Int64
    let y = pigeonVar_list[2] as! Int64

    return CanonicalTileID(
      z: z,
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      z,
      x,
      y,
    ]
  }
}

/// Holds a style property value with meta data.
///
/// Generated class from Pigeon that represents data sent in messages.
struct StylePropertyValue {
  /// The property value.
  var value: Any?
  /// The kind of the property value.
  var kind: StylePropertyValueKind

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> StylePropertyValue? {
    let value: Any? = pigeonVar_list[0]
    let kind = pigeonVar_list[1] as! StylePropertyValueKind

    return StylePropertyValue(
      value: value,
      kind: kind
    )
  }
  func toList() -> [Any?] {
    return [
      value,
      kind,
    ]
  }
}

private class MapInterfacesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return GlyphsRasterizationMode(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ContextMode(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ConstrainMode(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ViewportMode(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return NorthOrientation(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return _MapWidgetDebugOptions(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return MapDebugOptionsData(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ViewAnnotationAnchor(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return Type(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FillExtrusionBaseAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return FillExtrusionHeightAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return BackgroundPitchAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return StylePackErrorType(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return ResponseErrorReason(rawValue: enumResultAsInt)
      }
      return nil
    case 143:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return OfflineRegionDownloadState(rawValue: enumResultAsInt)
      }
      return nil
    case 144:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TileStoreUsageMode(rawValue: enumResultAsInt)
      }
      return nil
    case 145:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return StylePropertyValueKind(rawValue: enumResultAsInt)
      }
      return nil
    case 146:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return StyleProjectionName(rawValue: enumResultAsInt)
      }
      return nil
    case 147:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return Anchor(rawValue: enumResultAsInt)
      }
      return nil
    case 148:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return HttpMethod(rawValue: enumResultAsInt)
      }
      return nil
    case 149:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return HttpRequestErrorType(rawValue: enumResultAsInt)
      }
      return nil
    case 150:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DownloadErrorCode(rawValue: enumResultAsInt)
      }
      return nil
    case 151:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return DownloadState(rawValue: enumResultAsInt)
      }
      return nil
    case 152:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TileRegionErrorType(rawValue: enumResultAsInt)
      }
      return nil
    case 153:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return _MapEvent(rawValue: enumResultAsInt)
      }
      return nil
    case 154:
      return Point.fromList(self.readValue() as! [Any?])
    case 155:
      return Feature.fromList(self.readValue() as! [Any?])
    case 156:
      return GlyphsRasterizationOptions.fromList(self.readValue() as! [Any?])
    case 157:
      return TileCoverOptions.fromList(self.readValue() as! [Any?])
    case 158:
      return MbxEdgeInsets.fromList(self.readValue() as! [Any?])
    case 159:
      return CameraOptions.fromList(self.readValue() as! [Any?])
    case 160:
      return CameraState.fromList(self.readValue() as! [Any?])
    case 161:
      return CameraBoundsOptions.fromList(self.readValue() as! [Any?])
    case 162:
      return CameraBounds.fromList(self.readValue() as! [Any?])
    case 163:
      return MapAnimationOptions.fromList(self.readValue() as! [Any?])
    case 164:
      return CoordinateBounds.fromList(self.readValue() as! [Any?])
    case 165:
      return MapDebugOptions.fromList(self.readValue() as! [Any?])
    case 166:
      return TileCacheBudgetInMegabytes.fromList(self.readValue() as! [Any?])
    case 167:
      return TileCacheBudgetInTiles.fromList(self.readValue() as! [Any?])
    case 168:
      return MapOptions.fromList(self.readValue() as! [Any?])
    case 169:
      return ScreenCoordinate.fromList(self.readValue() as! [Any?])
    case 170:
      return ScreenBox.fromList(self.readValue() as! [Any?])
    case 171:
      return CoordinateBoundsZoom.fromList(self.readValue() as! [Any?])
    case 172:
      return Size.fromList(self.readValue() as! [Any?])
    case 173:
      return RenderedQueryOptions.fromList(self.readValue() as! [Any?])
    case 174:
      return SourceQueryOptions.fromList(self.readValue() as! [Any?])
    case 175:
      return FeatureExtensionValue.fromList(self.readValue() as! [Any?])
    case 176:
      return LayerPosition.fromList(self.readValue() as! [Any?])
    case 177:
      return QueriedRenderedFeature.fromList(self.readValue() as! [Any?])
    case 178:
      return QueriedSourceFeature.fromList(self.readValue() as! [Any?])
    case 179:
      return QueriedFeature.fromList(self.readValue() as! [Any?])
    case 180:
      return _RenderedQueryGeometry.fromList(self.readValue() as! [Any?])
    case 181:
      return ProjectedMeters.fromList(self.readValue() as! [Any?])
    case 182:
      return MercatorCoordinate.fromList(self.readValue() as! [Any?])
    case 183:
      return StyleObjectInfo.fromList(self.readValue() as! [Any?])
    case 184:
      return StyleProjection.fromList(self.readValue() as! [Any?])
    case 185:
      return FlatLight.fromList(self.readValue() as! [Any?])
    case 186:
      return DirectionalLight.fromList(self.readValue() as! [Any?])
    case 187:
      return AmbientLight.fromList(self.readValue() as! [Any?])
    case 188:
      return MbxImage.fromList(self.readValue() as! [Any?])
    case 189:
      return ImageStretches.fromList(self.readValue() as! [Any?])
    case 190:
      return ImageContent.fromList(self.readValue() as! [Any?])
    case 191:
      return TransitionOptions.fromList(self.readValue() as! [Any?])
    case 192:
      return CanonicalTileID.fromList(self.readValue() as! [Any?])
    case 193:
      return StylePropertyValue.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MapInterfacesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? GlyphsRasterizationMode {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? ContextMode {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? ConstrainMode {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? ViewportMode {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? NorthOrientation {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? _MapWidgetDebugOptions {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? MapDebugOptionsData {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? ViewAnnotationAnchor {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? Type {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? FillExtrusionBaseAlignment {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? FillExtrusionHeightAlignment {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? BackgroundPitchAlignment {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? StylePackErrorType {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? ResponseErrorReason {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? OfflineRegionDownloadState {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? TileStoreUsageMode {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? StylePropertyValueKind {
      super.writeByte(145)
      super.writeValue(value.rawValue)
    } else if let value = value as? StyleProjectionName {
      super.writeByte(146)
      super.writeValue(value.rawValue)
    } else if let value = value as? Anchor {
      super.writeByte(147)
      super.writeValue(value.rawValue)
    } else if let value = value as? HttpMethod {
      super.writeByte(148)
      super.writeValue(value.rawValue)
    } else if let value = value as? HttpRequestErrorType {
      super.writeByte(149)
      super.writeValue(value.rawValue)
    } else if let value = value as? DownloadErrorCode {
      super.writeByte(150)
      super.writeValue(value.rawValue)
    } else if let value = value as? DownloadState {
      super.writeByte(151)
      super.writeValue(value.rawValue)
    } else if let value = value as? TileRegionErrorType {
      super.writeByte(152)
      super.writeValue(value.rawValue)
    } else if let value = value as? _MapEvent {
      super.writeByte(153)
      super.writeValue(value.rawValue)
    } else if let value = value as? Point {
      super.writeByte(154)
      super.writeValue(value.toList())
    } else if let value = value as? Feature {
      super.writeByte(155)
      super.writeValue(value.toList())
    } else if let value = value as? GlyphsRasterizationOptions {
      super.writeByte(156)
      super.writeValue(value.toList())
    } else if let value = value as? TileCoverOptions {
      super.writeByte(157)
      super.writeValue(value.toList())
    } else if let value = value as? MbxEdgeInsets {
      super.writeByte(158)
      super.writeValue(value.toList())
    } else if let value = value as? CameraOptions {
      super.writeByte(159)
      super.writeValue(value.toList())
    } else if let value = value as? CameraState {
      super.writeByte(160)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBoundsOptions {
      super.writeByte(161)
      super.writeValue(value.toList())
    } else if let value = value as? CameraBounds {
      super.writeByte(162)
      super.writeValue(value.toList())
    } else if let value = value as? MapAnimationOptions {
      super.writeByte(163)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBounds {
      super.writeByte(164)
      super.writeValue(value.toList())
    } else if let value = value as? MapDebugOptions {
      super.writeByte(165)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInMegabytes {
      super.writeByte(166)
      super.writeValue(value.toList())
    } else if let value = value as? TileCacheBudgetInTiles {
      super.writeByte(167)
      super.writeValue(value.toList())
    } else if let value = value as? MapOptions {
      super.writeByte(168)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenCoordinate {
      super.writeByte(169)
      super.writeValue(value.toList())
    } else if let value = value as? ScreenBox {
      super.writeByte(170)
      super.writeValue(value.toList())
    } else if let value = value as? CoordinateBoundsZoom {
      super.writeByte(171)
      super.writeValue(value.toList())
    } else if let value = value as? Size {
      super.writeByte(172)
      super.writeValue(value.toList())
    } else if let value = value as? RenderedQueryOptions {
      super.writeByte(173)
      super.writeValue(value.toList())
    } else if let value = value as? SourceQueryOptions {
      super.writeByte(174)
      super.writeValue(value.toList())
    } else if let value = value as? FeatureExtensionValue {
      super.writeByte(175)
      super.writeValue(value.toList())
    } else if let value = value as? LayerPosition {
      super.writeByte(176)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedRenderedFeature {
      super.writeByte(177)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedSourceFeature {
      super.writeByte(178)
      super.writeValue(value.toList())
    } else if let value = value as? QueriedFeature {
      super.writeByte(179)
      super.writeValue(value.toList())
    } else if let value = value as? _RenderedQueryGeometry {
      super.writeByte(180)
      super.writeValue(value.toList())
    } else if let value = value as? ProjectedMeters {
      super.writeByte(181)
      super.writeValue(value.toList())
    } else if let value = value as? MercatorCoordinate {
      super.writeByte(182)
      super.writeValue(value.toList())
    } else if let value = value as? StyleObjectInfo {
      super.writeByte(183)
      super.writeValue(value.toList())
    } else if let value = value as? StyleProjection {
      super.writeByte(184)
      super.writeValue(value.toList())
    } else if let value = value as? FlatLight {
      super.writeByte(185)
      super.writeValue(value.toList())
    } else if let value = value as? DirectionalLight {
      super.writeByte(186)
      super.writeValue(value.toList())
    } else if let value = value as? AmbientLight {
      super.writeByte(187)
      super.writeValue(value.toList())
    } else if let value = value as? MbxImage {
      super.writeByte(188)
      super.writeValue(value.toList())
    } else if let value = value as? ImageStretches {
      super.writeByte(189)
      super.writeValue(value.toList())
    } else if let value = value as? ImageContent {
      super.writeByte(190)
      super.writeValue(value.toList())
    } else if let value = value as? TransitionOptions {
      super.writeByte(191)
      super.writeValue(value.toList())
    } else if let value = value as? CanonicalTileID {
      super.writeByte(192)
      super.writeValue(value.toList())
    } else if let value = value as? StylePropertyValue {
      super.writeByte(193)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MapInterfacesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MapInterfacesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MapInterfacesPigeonCodecWriter(data: data)
  }
}

class MapInterfacesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MapInterfacesPigeonCodec(readerWriter: MapInterfacesPigeonCodecReaderWriter())
}

/// Interface for managing animation.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _AnimationManager {
  func easeTo(cameraOptions: CameraOptions, mapAnimationOptions: MapAnimationOptions?) throws
  func flyTo(cameraOptions: CameraOptions, mapAnimationOptions: MapAnimationOptions?) throws
  func pitchBy(pitch: Double, mapAnimationOptions: MapAnimationOptions?) throws
  func scaleBy(amount: Double, screenCoordinate: ScreenCoordinate?, mapAnimationOptions: MapAnimationOptions?) throws
  func moveBy(screenCoordinate: ScreenCoordinate, mapAnimationOptions: MapAnimationOptions?) throws
  func rotateBy(first: ScreenCoordinate, second: ScreenCoordinate, mapAnimationOptions: MapAnimationOptions?) throws
  func cancelCameraAnimation() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _AnimationManagerSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `_AnimationManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _AnimationManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let easeToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      easeToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraOptionsArg = args[0] as! CameraOptions
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.easeTo(cameraOptions: cameraOptionsArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      easeToChannel.setMessageHandler(nil)
    }
    let flyToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      flyToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraOptionsArg = args[0] as! CameraOptions
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.flyTo(cameraOptions: cameraOptionsArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      flyToChannel.setMessageHandler(nil)
    }
    let pitchByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pitchByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pitchArg = args[0] as! Double
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.pitchBy(pitch: pitchArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pitchByChannel.setMessageHandler(nil)
    }
    let scaleByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      scaleByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let amountArg = args[0] as! Double
        let screenCoordinateArg: ScreenCoordinate? = nilOrValue(args[1])
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[2])
        do {
          try api.scaleBy(amount: amountArg, screenCoordinate: screenCoordinateArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      scaleByChannel.setMessageHandler(nil)
    }
    let moveByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      moveByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let screenCoordinateArg = args[0] as! ScreenCoordinate
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[1])
        do {
          try api.moveBy(screenCoordinate: screenCoordinateArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      moveByChannel.setMessageHandler(nil)
    }
    let rotateByChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      rotateByChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let firstArg = args[0] as! ScreenCoordinate
        let secondArg = args[1] as! ScreenCoordinate
        let mapAnimationOptionsArg: MapAnimationOptions? = nilOrValue(args[2])
        do {
          try api.rotateBy(first: firstArg, second: secondArg, mapAnimationOptions: mapAnimationOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      rotateByChannel.setMessageHandler(nil)
    }
    let cancelCameraAnimationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelCameraAnimationChannel.setMessageHandler { _, reply in
        do {
          try api.cancelCameraAnimation()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelCameraAnimationChannel.setMessageHandler(nil)
    }
  }
}
/// Interface for managing camera.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _CameraManager {
  /// Convenience method that returns a `camera options` object for the given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
  /// If any of the fields in camera options is not provided then the current value from the map for that field will be used.
  /// @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
  /// This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  func cameraForCoordinatesPadding(coordinates: [Point], camera: CameraOptions, coordinatesPadding: MbxEdgeInsets?, maxZoom: Double?, offset: ScreenCoordinate?) throws -> CameraOptions
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param bounds The `coordinate bounds` of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  /// @param maxZoom The maximum zoom level allowed in the returned camera options.
  /// @param offset The center of the given bounds relative to map center in screen points.
  /// @return The `camera options` object representing the provided parameters.
  func cameraForCoordinateBounds(bounds: CoordinateBounds, padding: MbxEdgeInsets?, bearing: Double?, pitch: Double?, maxZoom: Double?, offset: ScreenCoordinate?) throws -> CameraOptions
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  func cameraForCoordinates(coordinates: [Point], padding: MbxEdgeInsets?, bearing: Double?, pitch: Double?) throws -> CameraOptions
  /// Convenience method that adjusts the provided `camera options` object for given parameters.
  ///
  /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
  /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
  /// Returns the provided `camera` options object unchanged upon an error.
  /// Note that this method may fail if the principal point of the projection is not inside the `box` or
  /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
  ///
  /// @param coordinates The `coordinates` representing the bounds of the camera.
  /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
  /// @param box The `screen box` into which `coordinates` should fit.
  ///
  /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
  func cameraForCoordinatesCameraOptions(coordinates: [Point], camera: CameraOptions, box: ScreenBox) throws -> CameraOptions
  /// Convenience method that returns the `camera options` object for given parameters.
  ///
  /// @param geometry The `geometry` representing the bounds of the camera.
  /// @param padding The `edge insets` of the camera.
  /// @param bearing The bearing of the camera.
  /// @param pitch The pitch of the camera.
  ///
  /// @return The `camera options` object representing the provided parameters.
  func cameraForGeometry(geometry: [String?: Any?], padding: MbxEdgeInsets, bearing: Double?, pitch: Double?) throws -> CameraOptions
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  func coordinateBoundsForCamera(camera: CameraOptions) throws -> CoordinateBounds
  /// Returns the `coordinate bounds` for a given camera.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds`.
  ///
  /// @return The `coordinate bounds` object representing a given `camera`.
  ///
  func coordinateBoundsForCameraUnwrapped(camera: CameraOptions) throws -> CoordinateBounds
  /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
  ///
  /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
  /// might not represent the minimum bounding box.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  func coordinateBoundsZoomForCamera(camera: CameraOptions) throws -> CoordinateBoundsZoom
  /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
  ///
  /// This method is useful if the `camera` shows the antimeridian.
  ///
  /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
  ///
  /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
  ///
  func coordinateBoundsZoomForCameraUnwrapped(camera: CameraOptions) throws -> CoordinateBoundsZoom
  /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
  /// (i.e., longitude-latitude pair).
  ///
  /// The `screen coordinate` is in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
  ///
  /// @return A `screen coordinate` on the screen in `logical pixels`.
  func pixelForCoordinate(coordinate: Point) throws -> ScreenCoordinate
  /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
  /// to a `screen coordinate`.
  ///
  /// The screen coordinate is in `logical pixels`relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
  ///
  /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
  func coordinateForPixel(pixel: ScreenCoordinate) throws -> Point
  /// Calculates `screen coordinates` that correspond to geographical `coordinates`
  /// (i.e., longitude-latitude pairs).
  ///
  /// The `screen coordinates` are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
  ///
  /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
  func pixelsForCoordinates(coordinates: [Point]) throws -> [ScreenCoordinate?]
  /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
  /// to `screen coordinates`.
  ///
  /// The screen coordinates are in `logical pixels` relative to the top left corner
  /// of the map (not of the whole screen).
  ///
  /// @param pixels A `screen coordinates` in `logical pixels`.
  ///
  /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
  func coordinatesForPixels(pixels: [ScreenCoordinate?]) throws -> [Point]
  /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
  /// The map will retain its current values for any details not passed via the camera options argument.
  /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
  /// different `camera state`.
  ///
  /// @param cameraOptions The new `camera options` to be set.
  func setCamera(cameraOptions: CameraOptions) throws
  /// Returns the current `camera state`.
  ///
  /// @return The current `camera state`.
  func getCameraState() throws -> CameraState
  /// Sets the `camera bounds options` of the map. The map will retain its current values for any
  /// details not passed via the camera bounds options arguments.
  /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
  /// zoom level of the camera, to prevent out of bounds areas to be visible.
  /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
  ///
  /// @param options The `camera bounds options` to set.
  /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
  func setBounds(options: CameraBoundsOptions) throws
  /// Returns the `camera bounds` of the map.
  /// @return A `camera bounds` of the map.
  func getBounds() throws -> CameraBounds
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _CameraManagerSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `_CameraManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _CameraManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Convenience method that returns a `camera options` object for the given parameters.
    ///
    /// @param coordinates The `coordinates` representing the bounds of the camera.
    /// @param camera The `camera options` which will be applied before calculating the camera for the coordinates.
    /// If any of the fields in camera options is not provided then the current value from the map for that field will be used.
    /// @param coordinatesPadding The amount of padding in screen points to add to the given `coordinates`.
    /// This padding is not applied to the map but to the coordinates provided. If you want to apply padding to the map use `camera` parameter.
    /// @param maxZoom The maximum zoom level allowed in the returned camera options.
    /// @param offset The center of the given bounds relative to map center in screen points.
    /// @return The `camera options` object representing the provided parameters.
    let cameraForCoordinatesPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinatesPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        let cameraArg = args[1] as! CameraOptions
        let coordinatesPaddingArg: MbxEdgeInsets? = nilOrValue(args[2])
        let maxZoomArg: Double? = nilOrValue(args[3])
        let offsetArg: ScreenCoordinate? = nilOrValue(args[4])
        do {
          let result = try api.cameraForCoordinatesPadding(coordinates: coordinatesArg, camera: cameraArg, coordinatesPadding: coordinatesPaddingArg, maxZoom: maxZoomArg, offset: offsetArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinatesPaddingChannel.setMessageHandler(nil)
    }
    /// Convenience method that returns the `camera options` object for given parameters.
    ///
    /// @param bounds The `coordinate bounds` of the camera.
    /// @param padding The `edge insets` of the camera.
    /// @param bearing The bearing of the camera.
    /// @param pitch The pitch of the camera.
    /// @param maxZoom The maximum zoom level allowed in the returned camera options.
    /// @param offset The center of the given bounds relative to map center in screen points.
    /// @return The `camera options` object representing the provided parameters.
    let cameraForCoordinateBoundsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinateBoundsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let boundsArg = args[0] as! CoordinateBounds
        let paddingArg: MbxEdgeInsets? = nilOrValue(args[1])
        let bearingArg: Double? = nilOrValue(args[2])
        let pitchArg: Double? = nilOrValue(args[3])
        let maxZoomArg: Double? = nilOrValue(args[4])
        let offsetArg: ScreenCoordinate? = nilOrValue(args[5])
        do {
          let result = try api.cameraForCoordinateBounds(bounds: boundsArg, padding: paddingArg, bearing: bearingArg, pitch: pitchArg, maxZoom: maxZoomArg, offset: offsetArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinateBoundsChannel.setMessageHandler(nil)
    }
    /// Convenience method that returns the `camera options` object for given parameters.
    ///
    /// @param coordinates The `coordinates` representing the bounds of the camera.
    /// @param padding The `edge insets` of the camera.
    /// @param bearing The bearing of the camera.
    /// @param pitch The pitch of the camera.
    ///
    /// @return The `camera options` object representing the provided parameters.
    let cameraForCoordinatesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinatesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        let paddingArg: MbxEdgeInsets? = nilOrValue(args[1])
        let bearingArg: Double? = nilOrValue(args[2])
        let pitchArg: Double? = nilOrValue(args[3])
        do {
          let result = try api.cameraForCoordinates(coordinates: coordinatesArg, padding: paddingArg, bearing: bearingArg, pitch: pitchArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinatesChannel.setMessageHandler(nil)
    }
    /// Convenience method that adjusts the provided `camera options` object for given parameters.
    ///
    /// Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
    /// top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
    /// Returns the provided `camera` options object unchanged upon an error.
    /// Note that this method may fail if the principal point of the projection is not inside the `box` or
    /// if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
    ///
    /// @param coordinates The `coordinates` representing the bounds of the camera.
    /// @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
    /// @param box The `screen box` into which `coordinates` should fit.
    ///
    /// @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
    let cameraForCoordinatesCameraOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForCoordinatesCameraOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        let cameraArg = args[1] as! CameraOptions
        let boxArg = args[2] as! ScreenBox
        do {
          let result = try api.cameraForCoordinatesCameraOptions(coordinates: coordinatesArg, camera: cameraArg, box: boxArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForCoordinatesCameraOptionsChannel.setMessageHandler(nil)
    }
    /// Convenience method that returns the `camera options` object for given parameters.
    ///
    /// @param geometry The `geometry` representing the bounds of the camera.
    /// @param padding The `edge insets` of the camera.
    /// @param bearing The bearing of the camera.
    /// @param pitch The pitch of the camera.
    ///
    /// @return The `camera options` object representing the provided parameters.
    let cameraForGeometryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cameraForGeometryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let geometryArg = args[0] as! [String?: Any?]
        let paddingArg = args[1] as! MbxEdgeInsets
        let bearingArg: Double? = nilOrValue(args[2])
        let pitchArg: Double? = nilOrValue(args[3])
        do {
          let result = try api.cameraForGeometry(geometry: geometryArg, padding: paddingArg, bearing: bearingArg, pitch: pitchArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cameraForGeometryChannel.setMessageHandler(nil)
    }
    /// Returns the `coordinate bounds` for a given camera.
    ///
    /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
    /// might not represent the minimum bounding box.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds`.
    ///
    /// @return The `coordinate bounds` object representing a given `camera`.
    ///
    let coordinateBoundsForCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsForCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsForCamera(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsForCameraChannel.setMessageHandler(nil)
    }
    /// Returns the `coordinate bounds` for a given camera.
    ///
    /// This method is useful if the `camera` shows the antimeridian.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds`.
    ///
    /// @return The `coordinate bounds` object representing a given `camera`.
    ///
    let coordinateBoundsForCameraUnwrappedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsForCameraUnwrappedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsForCameraUnwrapped(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsForCameraUnwrappedChannel.setMessageHandler(nil)
    }
    /// Returns the `coordinate bounds` and the `zoom` for a given `camera`.
    ///
    /// Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
    /// might not represent the minimum bounding box.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
    ///
    /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
    ///
    let coordinateBoundsZoomForCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsZoomForCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsZoomForCamera(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsZoomForCameraChannel.setMessageHandler(nil)
    }
    /// Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
    ///
    /// This method is useful if the `camera` shows the antimeridian.
    ///
    /// @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
    ///
    /// @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
    ///
    let coordinateBoundsZoomForCameraUnwrappedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateBoundsZoomForCameraUnwrappedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraArg = args[0] as! CameraOptions
        do {
          let result = try api.coordinateBoundsZoomForCameraUnwrapped(camera: cameraArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateBoundsZoomForCameraUnwrappedChannel.setMessageHandler(nil)
    }
    /// Calculates a `screen coordinate` that corresponds to a geographical coordinate
    /// (i.e., longitude-latitude pair).
    ///
    /// The `screen coordinate` is in `logical pixels` relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
    ///
    /// @return A `screen coordinate` on the screen in `logical pixels`.
    let pixelForCoordinateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pixelForCoordinateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        do {
          let result = try api.pixelForCoordinate(coordinate: coordinateArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pixelForCoordinateChannel.setMessageHandler(nil)
    }
    /// Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
    /// to a `screen coordinate`.
    ///
    /// The screen coordinate is in `logical pixels`relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param pixel A `screen coordinate` on the screen in `logical pixels`.
    ///
    /// @return A geographical `coordinate` corresponding to a given `screen coordinate`.
    let coordinateForPixelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateForPixelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pixelArg = args[0] as! ScreenCoordinate
        do {
          let result = try api.coordinateForPixel(pixel: pixelArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateForPixelChannel.setMessageHandler(nil)
    }
    /// Calculates `screen coordinates` that correspond to geographical `coordinates`
    /// (i.e., longitude-latitude pairs).
    ///
    /// The `screen coordinates` are in `logical pixels` relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
    ///
    /// @return A `screen coordinates` in `logical pixels` for a given geographical `coordinates`.
    let pixelsForCoordinatesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pixelsForCoordinatesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinatesArg = args[0] as! [Point]
        do {
          let result = try api.pixelsForCoordinates(coordinates: coordinatesArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pixelsForCoordinatesChannel.setMessageHandler(nil)
    }
    /// Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
    /// to `screen coordinates`.
    ///
    /// The screen coordinates are in `logical pixels` relative to the top left corner
    /// of the map (not of the whole screen).
    ///
    /// @param pixels A `screen coordinates` in `logical pixels`.
    ///
    /// @return A `geographical coordinates` that correspond to a given `screen coordinates`.
    let coordinatesForPixelsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinatesForPixelsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pixelsArg = args[0] as! [ScreenCoordinate?]
        do {
          let result = try api.coordinatesForPixels(pixels: pixelsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinatesForPixelsChannel.setMessageHandler(nil)
    }
    /// Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
    /// The map will retain its current values for any details not passed via the camera options argument.
    /// It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
    /// different `camera state`.
    ///
    /// @param cameraOptions The new `camera options` to be set.
    let setCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setCameraChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let cameraOptionsArg = args[0] as! CameraOptions
        do {
          try api.setCamera(cameraOptions: cameraOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setCameraChannel.setMessageHandler(nil)
    }
    /// Returns the current `camera state`.
    ///
    /// @return The current `camera state`.
    let getCameraStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCameraStateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getCameraState()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCameraStateChannel.setMessageHandler(nil)
    }
    /// Sets the `camera bounds options` of the map. The map will retain its current values for any
    /// details not passed via the camera bounds options arguments.
    /// When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
    /// zoom level of the camera, to prevent out of bounds areas to be visible.
    /// Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
    ///
    /// @param options The `camera bounds options` to set.
    /// @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
    let setBoundsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setBoundsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! CameraBoundsOptions
        do {
          try api.setBounds(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setBoundsChannel.setMessageHandler(nil)
    }
    /// Returns the `camera bounds` of the map.
    /// @return A `camera bounds` of the map.
    let getBoundsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBoundsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getBounds()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBoundsChannel.setMessageHandler(nil)
    }
  }
}
/// Map class provides map rendering functionality.
///
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapInterface {
  func loadStyleURI(styleURI: String, completion: @escaping (Result<Void, Error>) -> Void)
  func loadStyleJson(styleJson: String, completion: @escaping (Result<Void, Error>) -> Void)
  func clearData(completion: @escaping (Result<Void, Error>) -> Void)
  func setTileCacheBudget(tileCacheBudgetInMegabytes: TileCacheBudgetInMegabytes?, tileCacheBudgetInTiles: TileCacheBudgetInTiles?) throws
  /// Gets the size of the map.
  ///
  /// @return The `size` of the map in `logical pixels`.
  func getSize() throws -> Size
  /// Triggers a repaint of the map.
  func triggerRepaint() throws
  /// Tells the map rendering engine that there is currently a gesture in progress. This
  /// affects how the map renders labels, as it will use different texture filters if a gesture
  /// is ongoing.
  ///
  /// @param inProgress The `boolean` value representing if a gesture is in progress.
  func setGestureInProgress(inProgress: Bool) throws
  /// Returns `true` if a gesture is currently in progress.
  ///
  /// @return `true` if a gesture is currently in progress, `false` otherwise.
  func isGestureInProgress() throws -> Bool
  /// Tells the map rendering engine that the animation is currently performed by the
  /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
  /// In particular, it brings more stability to symbol placement and rendering.
  ///
  /// @param inProgress The `boolean` value representing if user animation is in progress
  func setUserAnimationInProgress(inProgress: Bool) throws
  /// Returns `true` if user animation is currently in progress.
  ///
  /// @return `true` if a user animation is currently in progress, `false` otherwise.
  func isUserAnimationInProgress() throws -> Bool
  /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
  /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
  /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
  ///
  /// @param delta The new prefetch zoom delta.
  func setPrefetchZoomDelta(delta: Int64) throws
  /// Returns the map's prefetch zoom delta.
  ///
  /// @return The map's prefetch zoom `delta`.
  func getPrefetchZoomDelta() throws -> Int64
  /// Sets the north `orientation mode`.
  func setNorthOrientation(orientation: NorthOrientation) throws
  /// Sets the map `constrain mode`.
  func setConstrainMode(mode: ConstrainMode) throws
  /// Sets the `viewport mode`.
  func setViewportMode(mode: ViewportMode) throws
  /// Returns the `map options`.
  ///
  /// @return The map's `map options`.
  func getMapOptions() throws -> MapOptions
  func getDebugOptions() throws -> [_MapWidgetDebugOptions]
  func setDebugOptions(debugOptions: [_MapWidgetDebugOptions]) throws
  /// Returns the `map debug options`.
  ///
  /// @return An array of `map debug options` flags currently set to the map.
  func getDebug() throws -> [MapDebugOptions?]
  /// Sets the `map debug options` and enables debug mode based on the passed value.
  ///
  /// @param debugOptions An array of `map debug options` to be set.
  /// @param value A `boolean` value representing the state for a given `map debug options`.
  ///
  func setDebug(debugOptions: [MapDebugOptions?], value: Bool) throws
  /// Queries the map for rendered features.
  ///
  /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
  /// @param options The `render query options` for querying rendered features.
  /// @param completion The `query features completion` called when the query completes.
  /// @return A `cancelable` object that could be used to cancel the pending query.
  func queryRenderedFeatures(geometry: _RenderedQueryGeometry, options: RenderedQueryOptions, completion: @escaping (Result<[QueriedRenderedFeature?], Error>) -> Void)
  /// Queries the map for rendered features using featureset descriptors.
  ///
  /// This method allows to query both featureset from imported styles and user layers in the root style.
  /// The results can be additionally filtered per-featureset.
  ///
  /// - Important: This is a low-level method. If you need to handle basic gestures on map content, please prefer ``MapboxMap/ queryRenderedFeaturesForFeatureset()``.
  ///
  /// @param geometry A screen geometry to query. Can be a `CGPoint`, `CGRect`, or an array of `CGPoint`.
  /// @param targets An array of targets to query with.
  func queryRenderedFeaturesForTargets(geometry: _RenderedQueryGeometry, targets: [FeaturesetQueryTarget], completion: @escaping (Result<[QueriedRenderedFeature?], Error>) -> Void)
  /// Queries the map for rendered features with one typed featureset.
  ///
  /// The results array will contain features of the type specified by this featureset.
  ///
  /// @param geometry A screen geometry to query. Can be a `CGPoint`, `CGRect`, or an array of `CGPoint`.
  /// @param featureset A typed featureset to query with.
  /// @param filter An additional filter for features.
  func queryRenderedFeaturesForFeatureset(geometry: _RenderedQueryGeometry, featureset: FeaturesetDescriptor, filter: String?, completion: @escaping (Result<[FeaturesetFeature], Error>) -> Void)
  /// Queries all rendered features in current viewport, using one typed featureset.
  ///
  /// This is same as `MapboxMap/ queryRenderedFeaturesForFeatureset()`` called with geometry matching the current viewport.
  ///
  /// @param featureset A typed featureset to query with.
  /// @param filter An additional filter for features.
  func queryRenderedFeaturesInViewport(featureset: FeaturesetDescriptor, filter: String?, completion: @escaping (Result<[FeaturesetFeature], Error>) -> Void)
  /// Queries the map for source features.
  ///
  /// @param sourceId The style source identifier used to query for source features.
  /// @param options The `source query options` for querying source features.
  /// @param completion The `query features completion` called when the query completes.
  func querySourceFeatures(sourceId: String, options: SourceQueryOptions, completion: @escaping (Result<[QueriedSourceFeature?], Error>) -> Void)
  /// Queries  the source features for a given featureset.
  ///
  /// @param target A featureset query target.
  func querySourceFeaturesForFeatureset(target: FeaturesetQueryTarget, completion: @escaping (Result<[QueriedSourceFeature?], Error>) -> Void)
  /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
  /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster Cluster from which to retrieve leaves from
  /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
  /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  func getGeoJsonClusterLeaves(sourceIdentifier: String, cluster: [String?: Any?], limit: Int64?, offset: Int64?, completion: @escaping (Result<FeatureExtensionValue, Error>) -> Void)
  /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
  /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve children from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature collection or a string describing an error if the operation was not successful.
  func getGeoJsonClusterChildren(sourceIdentifier: String, cluster: [String?: Any?], completion: @escaping (Result<FeatureExtensionValue, Error>) -> Void)
  /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
  /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
  ///
  /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
  ///
  /// @param sourceIdentifier GeoJsonSource identifier.
  /// @param cluster cluster from which to retrieve the expansion zoom from
  /// @param completion The result will be returned through the completion block.
  ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
  func getGeoJsonClusterExpansionZoom(sourceIdentifier: String, cluster: [String?: Any?], completion: @escaping (Result<FeatureExtensionValue, Error>) -> Void)
  /// Updates the state object of a feature within a style source.
  ///
  /// Update entries in the `state` object of a given feature within a style source. Only properties of the
  /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
  /// retain its previous value.
  ///
  /// Note that updates to feature `state` are asynchronous, so changes made by this method might not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be updated.
  /// @param state The `state` object with properties to update with their respective new values.
  func setFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, state: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Update the state map of a feature within a featureset.
  /// Update entries in the state map of a given feature within a style source. Only entries listed in the state map
  /// will be updated. An entry in the feature state map that is not listed in `state` will retain its previous value.
  /// 
  /// @param featureset The featureset to look the feature in.
  /// @param featureId Identifier of the feature whose state should be updated.
  /// @param state Map of entries to update with their respective new values
  /// 
  /// @return A `Cancelable` object  that could be used to cancel the pending operation.
  func setFeatureStateForFeaturesetFeatureDescriptor(featureset: FeaturesetDescriptor, featureId: FeaturesetFeatureId, state: [String: Any?], completion: @escaping (Result<Void, Error>) -> Void)
  /// Update the state map of an individual feature.
  /// 
  /// The feature should have a non-nil ``FeaturesetFeatureType/id``. Otherwise,
  /// the operation will be no-op and callback will receive an error.
  /// 
  /// @param feature The feature to update.
  /// @param state Map of entries to update with their respective new values
  /// 
  /// @return A `Cancelable` object  that could be used to cancel the pending operation.
  func setFeatureStateForFeaturesetFeature(feature: FeaturesetFeature, state: [String: Any?], completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the state map of a feature within a style source.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
  /// immediately visible.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be queried.
  /// 
  /// @return A `Cancelable` object  that could be used to cancel the pending operation.
  func getFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Get the state map of a feature within a style source.
  ///
  /// @param featureset A featureset the feature belongs to.
  /// @param featureId Identifier of the feature whose state should be queried.
  /// 
  /// @return  A `Cancelable` object that could be used to cancel the pending query.
  func getFeatureStateForFeaturesetDescriptor(featureset: FeaturesetDescriptor, featureId: FeaturesetFeatureId, completion: @escaping (Result<[String: Any?], Error>) -> Void)
  /// Get the state map of a feature within a style source.
  ///
  /// @param feature An interactive feature to query the state from.
  /// 
  /// @return  A `Cancelable` object that could be used to cancel the pending query.
  func getFeatureStateForFeaturesetFeature(feature: FeaturesetFeature, completion: @escaping (Result<[String: Any?], Error>) -> Void)
  /// Removes entries from a feature state object.
  ///
  /// Remove a specified property or all property from a feature's state object, depending on the value of
  /// `stateKey`.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method might not be
  /// immediately visible using `getStateFeature`.
  ///
  /// @param sourceId The style source identifier.
  /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
  /// @param featureId The feature identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
  func removeFeatureState(sourceId: String, sourceLayerId: String?, featureId: String, stateKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes entries from a feature state object of a feature in the specified featureset.
  /// Remove a specified property or all property from a feature's state object, depending on the value of `stateKey`.
  /// 
  /// @param featureset A featureset the feature belongs to.
  /// @param featureId Identifier of the feature whose state should be removed.
  /// @param stateKey The key of the property to remove. If `nil`, all feature's state object properties are removed. Defaults to `nil`.
  /// 
  /// @return A `Cancelable` object  that could be used to cancel the pending operation.
  func removeFeatureStateForFeaturesetFeatureDescriptor(featureset: FeaturesetDescriptor, featureId: FeaturesetFeatureId, stateKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes entries from a specified Feature.
  /// Remove a specified property or all property from a feature's state object, depending on the value of `stateKey`.
  /// 
  /// @param feature An interactive feature to update.
  /// @param stateKey The key of the property to remove. If `nil`, all feature's state object properties are removed. Defaults to `nil`.
  /// 
  /// @return A `Cancelable` object  that could be used to cancel the pending operation.
  func removeFeatureStateForFeaturesetFeature(feature: FeaturesetFeature, stateKey: String?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Reset all the feature states within a featureset.
  ///
  /// Note that updates to feature state are asynchronous, so changes made by this method might not be
  /// immediately visible using ``MapboxMap/getFeatureState()``.
  /// 
  /// @param featureset A featureset descriptor
  /// 
  /// @return A `Cancelable` object  that could be used to cancel the pending operation.
  func resetFeatureStatesForFeatureset(featureset: FeaturesetDescriptor, completion: @escaping (Result<Void, Error>) -> Void)
  /// Reduces memory use. Useful to call when the application gets paused or sent to background.
  func reduceMemoryUse() throws
  /// Gets elevation for the given coordinate.
  /// Note: Elevation is only available for the visible region on the screen.
  ///
  /// @param coordinate The `coordinate` defined as longitude-latitude pair.
  /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
  func getElevation(coordinate: Point) throws -> Double?
  /// Returns array of tile identifiers that cover current map camera.
  func tileCover(options: TileCoverOptions) throws -> [CanonicalTileID]
  /// Set whether legacy mode should be used for [snapshot].
  ///
  /// Legacy mode is not that efficient (as it blocks map rendering when making the snapshot)
  /// but may help with vendor specific issues like described in
  /// https://github.com/mapbox/mapbox-maps-android/issues/2280.
  ///
  /// Note: This method has no effect on iOS platform.
  func setSnapshotLegacyMode(enabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  /// The URL that points to the glyphs used by the style for rendering text labels on the map.
  ///
  /// This property allows setting a custom glyph URL at runtime, making it easier to
  /// apply custom fonts to the map without modifying the base style.
  func styleGlyphURL() throws -> String
  /// The URL that points to the glyphs used by the style for rendering text labels on the map.
  ///
  /// This property allows setting a custom glyph URL at runtime, making it easier to
  /// apply custom fonts to the map without modifying the base style.
  func setStyleGlyphURL(glyphURL: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapInterfaceSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `_MapInterface` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapInterface?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let loadStyleURIChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadStyleURIChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleURIArg = args[0] as! String
        api.loadStyleURI(styleURI: styleURIArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadStyleURIChannel.setMessageHandler(nil)
    }
    let loadStyleJsonChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadStyleJsonChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let styleJsonArg = args[0] as! String
        api.loadStyleJson(styleJson: styleJsonArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      loadStyleJsonChannel.setMessageHandler(nil)
    }
    let clearDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearDataChannel.setMessageHandler { _, reply in
        api.clearData { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      clearDataChannel.setMessageHandler(nil)
    }
    let setTileCacheBudgetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setTileCacheBudget\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTileCacheBudgetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tileCacheBudgetInMegabytesArg: TileCacheBudgetInMegabytes? = nilOrValue(args[0])
        let tileCacheBudgetInTilesArg: TileCacheBudgetInTiles? = nilOrValue(args[1])
        do {
          try api.setTileCacheBudget(tileCacheBudgetInMegabytes: tileCacheBudgetInMegabytesArg, tileCacheBudgetInTiles: tileCacheBudgetInTilesArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTileCacheBudgetChannel.setMessageHandler(nil)
    }
    /// Gets the size of the map.
    ///
    /// @return The `size` of the map in `logical pixels`.
    let getSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSizeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getSize()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getSizeChannel.setMessageHandler(nil)
    }
    /// Triggers a repaint of the map.
    let triggerRepaintChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      triggerRepaintChannel.setMessageHandler { _, reply in
        do {
          try api.triggerRepaint()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      triggerRepaintChannel.setMessageHandler(nil)
    }
    /// Tells the map rendering engine that there is currently a gesture in progress. This
    /// affects how the map renders labels, as it will use different texture filters if a gesture
    /// is ongoing.
    ///
    /// @param inProgress The `boolean` value representing if a gesture is in progress.
    let setGestureInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setGestureInProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let inProgressArg = args[0] as! Bool
        do {
          try api.setGestureInProgress(inProgress: inProgressArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setGestureInProgressChannel.setMessageHandler(nil)
    }
    /// Returns `true` if a gesture is currently in progress.
    ///
    /// @return `true` if a gesture is currently in progress, `false` otherwise.
    let isGestureInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isGestureInProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isGestureInProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isGestureInProgressChannel.setMessageHandler(nil)
    }
    /// Tells the map rendering engine that the animation is currently performed by the
    /// user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
    /// In particular, it brings more stability to symbol placement and rendering.
    ///
    /// @param inProgress The `boolean` value representing if user animation is in progress
    let setUserAnimationInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setUserAnimationInProgressChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let inProgressArg = args[0] as! Bool
        do {
          try api.setUserAnimationInProgress(inProgress: inProgressArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setUserAnimationInProgressChannel.setMessageHandler(nil)
    }
    /// Returns `true` if user animation is currently in progress.
    ///
    /// @return `true` if a user animation is currently in progress, `false` otherwise.
    let isUserAnimationInProgressChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isUserAnimationInProgressChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isUserAnimationInProgress()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isUserAnimationInProgressChannel.setMessageHandler(nil)
    }
    /// When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
    /// the map will first request a tile at zoom level lower than `zoom - delta`, with requested
    /// zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
    ///
    /// @param delta The new prefetch zoom delta.
    let setPrefetchZoomDeltaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPrefetchZoomDeltaChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deltaArg = args[0] as! Int64
        do {
          try api.setPrefetchZoomDelta(delta: deltaArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setPrefetchZoomDeltaChannel.setMessageHandler(nil)
    }
    /// Returns the map's prefetch zoom delta.
    ///
    /// @return The map's prefetch zoom `delta`.
    let getPrefetchZoomDeltaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPrefetchZoomDeltaChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPrefetchZoomDelta()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPrefetchZoomDeltaChannel.setMessageHandler(nil)
    }
    /// Sets the north `orientation mode`.
    let setNorthOrientationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setNorthOrientationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let orientationArg = args[0] as! NorthOrientation
        do {
          try api.setNorthOrientation(orientation: orientationArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setNorthOrientationChannel.setMessageHandler(nil)
    }
    /// Sets the map `constrain mode`.
    let setConstrainModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setConstrainModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = args[0] as! ConstrainMode
        do {
          try api.setConstrainMode(mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setConstrainModeChannel.setMessageHandler(nil)
    }
    /// Sets the `viewport mode`.
    let setViewportModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setViewportModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = args[0] as! ViewportMode
        do {
          try api.setViewportMode(mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setViewportModeChannel.setMessageHandler(nil)
    }
    /// Returns the `map options`.
    ///
    /// @return The map's `map options`.
    let getMapOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMapOptionsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getMapOptions()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMapOptionsChannel.setMessageHandler(nil)
    }
    let getDebugOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebugOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDebugOptionsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDebugOptions()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDebugOptionsChannel.setMessageHandler(nil)
    }
    let setDebugOptionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebugOptions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDebugOptionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let debugOptionsArg = args[0] as! [_MapWidgetDebugOptions]
        do {
          try api.setDebugOptions(debugOptions: debugOptionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDebugOptionsChannel.setMessageHandler(nil)
    }
    /// Returns the `map debug options`.
    ///
    /// @return An array of `map debug options` flags currently set to the map.
    let getDebugChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDebugChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDebug()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDebugChannel.setMessageHandler(nil)
    }
    /// Sets the `map debug options` and enables debug mode based on the passed value.
    ///
    /// @param debugOptions An array of `map debug options` to be set.
    /// @param value A `boolean` value representing the state for a given `map debug options`.
    ///
    let setDebugChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDebugChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let debugOptionsArg = args[0] as! [MapDebugOptions?]
        let valueArg = args[1] as! Bool
        do {
          try api.setDebug(debugOptions: debugOptionsArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDebugChannel.setMessageHandler(nil)
    }
    /// Queries the map for rendered features.
    ///
    /// @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
    /// @param options The `render query options` for querying rendered features.
    /// @param completion The `query features completion` called when the query completes.
    /// @return A `cancelable` object that could be used to cancel the pending query.
    let queryRenderedFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      queryRenderedFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let geometryArg = args[0] as! _RenderedQueryGeometry
        let optionsArg = args[1] as! RenderedQueryOptions
        api.queryRenderedFeatures(geometry: geometryArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryRenderedFeaturesChannel.setMessageHandler(nil)
    }
    /// Queries the map for rendered features using featureset descriptors.
    ///
    /// This method allows to query both featureset from imported styles and user layers in the root style.
    /// The results can be additionally filtered per-featureset.
    ///
    /// - Important: This is a low-level method. If you need to handle basic gestures on map content, please prefer ``MapboxMap/ queryRenderedFeaturesForFeatureset()``.
    ///
    /// @param geometry A screen geometry to query. Can be a `CGPoint`, `CGRect`, or an array of `CGPoint`.
    /// @param targets An array of targets to query with.
    let queryRenderedFeaturesForTargetsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeaturesForTargets\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      queryRenderedFeaturesForTargetsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let geometryArg = args[0] as! _RenderedQueryGeometry
        let targetsArg = args[1] as! [FeaturesetQueryTarget]
        api.queryRenderedFeaturesForTargets(geometry: geometryArg, targets: targetsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryRenderedFeaturesForTargetsChannel.setMessageHandler(nil)
    }
    /// Queries the map for rendered features with one typed featureset.
    ///
    /// The results array will contain features of the type specified by this featureset.
    ///
    /// @param geometry A screen geometry to query. Can be a `CGPoint`, `CGRect`, or an array of `CGPoint`.
    /// @param featureset A typed featureset to query with.
    /// @param filter An additional filter for features.
    let queryRenderedFeaturesForFeaturesetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeaturesForFeatureset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      queryRenderedFeaturesForFeaturesetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let geometryArg = args[0] as! _RenderedQueryGeometry
        let featuresetArg = args[1] as! FeaturesetDescriptor
        let filterArg: String? = nilOrValue(args[2])
        api.queryRenderedFeaturesForFeatureset(geometry: geometryArg, featureset: featuresetArg, filter: filterArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryRenderedFeaturesForFeaturesetChannel.setMessageHandler(nil)
    }
    /// Queries all rendered features in current viewport, using one typed featureset.
    ///
    /// This is same as `MapboxMap/ queryRenderedFeaturesForFeatureset()`` called with geometry matching the current viewport.
    ///
    /// @param featureset A typed featureset to query with.
    /// @param filter An additional filter for features.
    let queryRenderedFeaturesInViewportChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeaturesInViewport\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      queryRenderedFeaturesInViewportChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featuresetArg = args[0] as! FeaturesetDescriptor
        let filterArg: String? = nilOrValue(args[1])
        api.queryRenderedFeaturesInViewport(featureset: featuresetArg, filter: filterArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryRenderedFeaturesInViewportChannel.setMessageHandler(nil)
    }
    /// Queries the map for source features.
    ///
    /// @param sourceId The style source identifier used to query for source features.
    /// @param options The `source query options` for querying source features.
    /// @param completion The `query features completion` called when the query completes.
    let querySourceFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      querySourceFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let optionsArg = args[1] as! SourceQueryOptions
        api.querySourceFeatures(sourceId: sourceIdArg, options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      querySourceFeaturesChannel.setMessageHandler(nil)
    }
    /// Queries  the source features for a given featureset.
    ///
    /// @param target A featureset query target.
    let querySourceFeaturesForFeaturesetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeaturesForFeatureset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      querySourceFeaturesForFeaturesetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let targetArg = args[0] as! FeaturesetQueryTarget
        api.querySourceFeaturesForFeatureset(target: targetArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      querySourceFeaturesForFeaturesetChannel.setMessageHandler(nil)
    }
    /// Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
    /// to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
    ///
    /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
    ///
    /// @param sourceIdentifier GeoJsonSource identifier.
    /// @param cluster Cluster from which to retrieve leaves from
    /// @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
    /// @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
    /// @param completion The result will be returned through the completion block.
    ///         The result is a feature collection or a string describing an error if the operation was not successful.
    let getGeoJsonClusterLeavesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeoJsonClusterLeavesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdentifierArg = args[0] as! String
        let clusterArg = args[1] as! [String?: Any?]
        let limitArg: Int64? = nilOrValue(args[2])
        let offsetArg: Int64? = nilOrValue(args[3])
        api.getGeoJsonClusterLeaves(sourceIdentifier: sourceIdentifierArg, cluster: clusterArg, limit: limitArg, offset: offsetArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getGeoJsonClusterLeavesChannel.setMessageHandler(nil)
    }
    /// Returns the children (original points or clusters) of a cluster (on the next zoom level)
    /// given its id (cluster_id value from feature properties) from a GeoJsonSource.
    ///
    /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
    ///
    /// @param sourceIdentifier GeoJsonSource identifier.
    /// @param cluster cluster from which to retrieve children from
    /// @param completion The result will be returned through the completion block.
    ///         The result is a feature collection or a string describing an error if the operation was not successful.
    let getGeoJsonClusterChildrenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeoJsonClusterChildrenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdentifierArg = args[0] as! String
        let clusterArg = args[1] as! [String?: Any?]
        api.getGeoJsonClusterChildren(sourceIdentifier: sourceIdentifierArg, cluster: clusterArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getGeoJsonClusterChildrenChannel.setMessageHandler(nil)
    }
    /// Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
    /// given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
    ///
    /// Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
    ///
    /// @param sourceIdentifier GeoJsonSource identifier.
    /// @param cluster cluster from which to retrieve the expansion zoom from
    /// @param completion The result will be returned through the completion block.
    ///         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
    let getGeoJsonClusterExpansionZoomChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getGeoJsonClusterExpansionZoomChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdentifierArg = args[0] as! String
        let clusterArg = args[1] as! [String?: Any?]
        api.getGeoJsonClusterExpansionZoom(sourceIdentifier: sourceIdentifierArg, cluster: clusterArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getGeoJsonClusterExpansionZoomChannel.setMessageHandler(nil)
    }
    /// Updates the state object of a feature within a style source.
    ///
    /// Update entries in the `state` object of a given feature within a style source. Only properties of the
    /// `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
    /// retain its previous value.
    ///
    /// Note that updates to feature `state` are asynchronous, so changes made by this method might not be
    /// immediately visible using `getStateFeature`.
    ///
    /// @param sourceId The style source identifier.
    /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
    /// @param featureId The feature identifier of the feature whose state should be updated.
    /// @param state The `state` object with properties to update with their respective new values.
    let setFeatureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFeatureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let sourceLayerIdArg: String? = nilOrValue(args[1])
        let featureIdArg = args[2] as! String
        let stateArg = args[3] as! String
        api.setFeatureState(sourceId: sourceIdArg, sourceLayerId: sourceLayerIdArg, featureId: featureIdArg, state: stateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFeatureStateChannel.setMessageHandler(nil)
    }
    /// Update the state map of a feature within a featureset.
    /// Update entries in the state map of a given feature within a style source. Only entries listed in the state map
    /// will be updated. An entry in the feature state map that is not listed in `state` will retain its previous value.
    /// 
    /// @param featureset The featureset to look the feature in.
    /// @param featureId Identifier of the feature whose state should be updated.
    /// @param state Map of entries to update with their respective new values
    /// 
    /// @return A `Cancelable` object  that could be used to cancel the pending operation.
    let setFeatureStateForFeaturesetFeatureDescriptorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureStateForFeaturesetFeatureDescriptor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFeatureStateForFeaturesetFeatureDescriptorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featuresetArg = args[0] as! FeaturesetDescriptor
        let featureIdArg = args[1] as! FeaturesetFeatureId
        let stateArg = args[2] as! [String: Any?]
        api.setFeatureStateForFeaturesetFeatureDescriptor(featureset: featuresetArg, featureId: featureIdArg, state: stateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFeatureStateForFeaturesetFeatureDescriptorChannel.setMessageHandler(nil)
    }
    /// Update the state map of an individual feature.
    /// 
    /// The feature should have a non-nil ``FeaturesetFeatureType/id``. Otherwise,
    /// the operation will be no-op and callback will receive an error.
    /// 
    /// @param feature The feature to update.
    /// @param state Map of entries to update with their respective new values
    /// 
    /// @return A `Cancelable` object  that could be used to cancel the pending operation.
    let setFeatureStateForFeaturesetFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureStateForFeaturesetFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFeatureStateForFeaturesetFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureArg = args[0] as! FeaturesetFeature
        let stateArg = args[1] as! [String: Any?]
        api.setFeatureStateForFeaturesetFeature(feature: featureArg, state: stateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setFeatureStateForFeaturesetFeatureChannel.setMessageHandler(nil)
    }
    /// Gets the state map of a feature within a style source.
    ///
    /// Note that updates to feature state are asynchronous, so changes made by other methods might not be
    /// immediately visible.
    ///
    /// @param sourceId The style source identifier.
    /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
    /// @param featureId The feature identifier of the feature whose state should be queried.
    /// 
    /// @return A `Cancelable` object  that could be used to cancel the pending operation.
    let getFeatureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFeatureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let sourceLayerIdArg: String? = nilOrValue(args[1])
        let featureIdArg = args[2] as! String
        api.getFeatureState(sourceId: sourceIdArg, sourceLayerId: sourceLayerIdArg, featureId: featureIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFeatureStateChannel.setMessageHandler(nil)
    }
    /// Get the state map of a feature within a style source.
    ///
    /// @param featureset A featureset the feature belongs to.
    /// @param featureId Identifier of the feature whose state should be queried.
    /// 
    /// @return  A `Cancelable` object that could be used to cancel the pending query.
    let getFeatureStateForFeaturesetDescriptorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureStateForFeaturesetDescriptor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFeatureStateForFeaturesetDescriptorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featuresetArg = args[0] as! FeaturesetDescriptor
        let featureIdArg = args[1] as! FeaturesetFeatureId
        api.getFeatureStateForFeaturesetDescriptor(featureset: featuresetArg, featureId: featureIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFeatureStateForFeaturesetDescriptorChannel.setMessageHandler(nil)
    }
    /// Get the state map of a feature within a style source.
    ///
    /// @param feature An interactive feature to query the state from.
    /// 
    /// @return  A `Cancelable` object that could be used to cancel the pending query.
    let getFeatureStateForFeaturesetFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureStateForFeaturesetFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFeatureStateForFeaturesetFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureArg = args[0] as! FeaturesetFeature
        api.getFeatureStateForFeaturesetFeature(feature: featureArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getFeatureStateForFeaturesetFeatureChannel.setMessageHandler(nil)
    }
    /// Removes entries from a feature state object.
    ///
    /// Remove a specified property or all property from a feature's state object, depending on the value of
    /// `stateKey`.
    ///
    /// Note that updates to feature state are asynchronous, so changes made by this method might not be
    /// immediately visible using `getStateFeature`.
    ///
    /// @param sourceId The style source identifier.
    /// @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
    /// @param featureId The feature identifier of the feature whose state should be removed.
    /// @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
    let removeFeatureStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeFeatureStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let sourceLayerIdArg: String? = nilOrValue(args[1])
        let featureIdArg = args[2] as! String
        let stateKeyArg: String? = nilOrValue(args[3])
        api.removeFeatureState(sourceId: sourceIdArg, sourceLayerId: sourceLayerIdArg, featureId: featureIdArg, stateKey: stateKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeFeatureStateChannel.setMessageHandler(nil)
    }
    /// Removes entries from a feature state object of a feature in the specified featureset.
    /// Remove a specified property or all property from a feature's state object, depending on the value of `stateKey`.
    /// 
    /// @param featureset A featureset the feature belongs to.
    /// @param featureId Identifier of the feature whose state should be removed.
    /// @param stateKey The key of the property to remove. If `nil`, all feature's state object properties are removed. Defaults to `nil`.
    /// 
    /// @return A `Cancelable` object  that could be used to cancel the pending operation.
    let removeFeatureStateForFeaturesetFeatureDescriptorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureStateForFeaturesetFeatureDescriptor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeFeatureStateForFeaturesetFeatureDescriptorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featuresetArg = args[0] as! FeaturesetDescriptor
        let featureIdArg = args[1] as! FeaturesetFeatureId
        let stateKeyArg: String? = nilOrValue(args[2])
        api.removeFeatureStateForFeaturesetFeatureDescriptor(featureset: featuresetArg, featureId: featureIdArg, stateKey: stateKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeFeatureStateForFeaturesetFeatureDescriptorChannel.setMessageHandler(nil)
    }
    /// Removes entries from a specified Feature.
    /// Remove a specified property or all property from a feature's state object, depending on the value of `stateKey`.
    /// 
    /// @param feature An interactive feature to update.
    /// @param stateKey The key of the property to remove. If `nil`, all feature's state object properties are removed. Defaults to `nil`.
    /// 
    /// @return A `Cancelable` object  that could be used to cancel the pending operation.
    let removeFeatureStateForFeaturesetFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureStateForFeaturesetFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeFeatureStateForFeaturesetFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureArg = args[0] as! FeaturesetFeature
        let stateKeyArg: String? = nilOrValue(args[1])
        api.removeFeatureStateForFeaturesetFeature(feature: featureArg, stateKey: stateKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeFeatureStateForFeaturesetFeatureChannel.setMessageHandler(nil)
    }
    /// Reset all the feature states within a featureset.
    ///
    /// Note that updates to feature state are asynchronous, so changes made by this method might not be
    /// immediately visible using ``MapboxMap/getFeatureState()``.
    /// 
    /// @param featureset A featureset descriptor
    /// 
    /// @return A `Cancelable` object  that could be used to cancel the pending operation.
    let resetFeatureStatesForFeaturesetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.resetFeatureStatesForFeatureset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resetFeatureStatesForFeaturesetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featuresetArg = args[0] as! FeaturesetDescriptor
        api.resetFeatureStatesForFeatureset(featureset: featuresetArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      resetFeatureStatesForFeaturesetChannel.setMessageHandler(nil)
    }
    /// Reduces memory use. Useful to call when the application gets paused or sent to background.
    let reduceMemoryUseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reduceMemoryUseChannel.setMessageHandler { _, reply in
        do {
          try api.reduceMemoryUse()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      reduceMemoryUseChannel.setMessageHandler(nil)
    }
    /// Gets elevation for the given coordinate.
    /// Note: Elevation is only available for the visible region on the screen.
    ///
    /// @param coordinate The `coordinate` defined as longitude-latitude pair.
    /// @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
    let getElevationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getElevationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        do {
          let result = try api.getElevation(coordinate: coordinateArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getElevationChannel.setMessageHandler(nil)
    }
    /// Returns array of tile identifiers that cover current map camera.
    let tileCoverChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.tileCover\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tileCoverChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! TileCoverOptions
        do {
          let result = try api.tileCover(options: optionsArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tileCoverChannel.setMessageHandler(nil)
    }
    /// Set whether legacy mode should be used for [snapshot].
    ///
    /// Legacy mode is not that efficient (as it blocks map rendering when making the snapshot)
    /// but may help with vendor specific issues like described in
    /// https://github.com/mapbox/mapbox-maps-android/issues/2280.
    ///
    /// Note: This method has no effect on iOS platform.
    let setSnapshotLegacyModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setSnapshotLegacyMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSnapshotLegacyModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let enabledArg = args[0] as! Bool
        api.setSnapshotLegacyMode(enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSnapshotLegacyModeChannel.setMessageHandler(nil)
    }
    /// The URL that points to the glyphs used by the style for rendering text labels on the map.
    ///
    /// This property allows setting a custom glyph URL at runtime, making it easier to
    /// apply custom fonts to the map without modifying the base style.
    let styleGlyphURLChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.styleGlyphURL\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      styleGlyphURLChannel.setMessageHandler { _, reply in
        do {
          let result = try api.styleGlyphURL()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      styleGlyphURLChannel.setMessageHandler(nil)
    }
    /// The URL that points to the glyphs used by the style for rendering text labels on the map.
    ///
    /// This property allows setting a custom glyph URL at runtime, making it easier to
    /// apply custom fonts to the map without modifying the base style.
    let setStyleGlyphURLChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setStyleGlyphURL\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleGlyphURLChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let glyphURLArg = args[0] as! String
        do {
          try api.setStyleGlyphURL(glyphURL: glyphURLArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setStyleGlyphURLChannel.setMessageHandler(nil)
    }
  }
}
/// Collection of [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection methods.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Projection {
  /// Calculate distance spanned by one pixel at the specified latitude
  /// and zoom level.
  ///
  /// @param latitude The latitude for which to return the value.
  /// @param zoom The zoom level.
  ///
  /// @return Returns the distance measured in meters.
  func getMetersPerPixelAtLatitude(latitude: Double, zoom: Double) throws -> Double
  /// Calculate Spherical Mercator ProjectedMeters coordinates.
  ///
  /// @param coordinate A longitude-latitude pair for which to calculate
  /// `projected meters` coordinates.
  ///
  /// @return Returns Spherical Mercator ProjectedMeters coordinates.
  func projectedMetersForCoordinate(coordinate: Point) throws -> ProjectedMeters
  /// Calculate a longitude-latitude pair for a Spherical Mercator projected
  /// meters.
  ///
  /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
  /// which to calculate a longitude-latitude pair.
  ///
  /// @return Returns a longitude-latitude pair.
  func coordinateForProjectedMeters(projectedMeters: ProjectedMeters) throws -> Point
  /// Calculate a point on the map in Mercator Projection for a given
  /// coordinate at the specified zoom scale.
  ///
  /// @param coordinate The longitude-latitude pair for which to return the value.
  /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a point on the map in Mercator projection.
  func project(coordinate: Point, zoomScale: Double) throws -> MercatorCoordinate
  /// Calculate a coordinate for a given point on the map in Mercator Projection.
  ///
  /// @param coordinate Point on the map in Mercator projection.
  /// @param zoomScale The current zoom factor applied on the map, is used to
  /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
  /// where tileSize is the width of a tile in pixels.
  ///
  /// @return Returns a coordinate.
  func unproject(coordinate: MercatorCoordinate, zoomScale: Double) throws -> Point
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ProjectionSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `Projection` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Projection?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Calculate distance spanned by one pixel at the specified latitude
    /// and zoom level.
    ///
    /// @param latitude The latitude for which to return the value.
    /// @param zoom The zoom level.
    ///
    /// @return Returns the distance measured in meters.
    let getMetersPerPixelAtLatitudeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMetersPerPixelAtLatitudeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let latitudeArg = args[0] as! Double
        let zoomArg = args[1] as! Double
        do {
          let result = try api.getMetersPerPixelAtLatitude(latitude: latitudeArg, zoom: zoomArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getMetersPerPixelAtLatitudeChannel.setMessageHandler(nil)
    }
    /// Calculate Spherical Mercator ProjectedMeters coordinates.
    ///
    /// @param coordinate A longitude-latitude pair for which to calculate
    /// `projected meters` coordinates.
    ///
    /// @return Returns Spherical Mercator ProjectedMeters coordinates.
    let projectedMetersForCoordinateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      projectedMetersForCoordinateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        do {
          let result = try api.projectedMetersForCoordinate(coordinate: coordinateArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      projectedMetersForCoordinateChannel.setMessageHandler(nil)
    }
    /// Calculate a longitude-latitude pair for a Spherical Mercator projected
    /// meters.
    ///
    /// @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
    /// which to calculate a longitude-latitude pair.
    ///
    /// @return Returns a longitude-latitude pair.
    let coordinateForProjectedMetersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      coordinateForProjectedMetersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let projectedMetersArg = args[0] as! ProjectedMeters
        do {
          let result = try api.coordinateForProjectedMeters(projectedMeters: projectedMetersArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      coordinateForProjectedMetersChannel.setMessageHandler(nil)
    }
    /// Calculate a point on the map in Mercator Projection for a given
    /// coordinate at the specified zoom scale.
    ///
    /// @param coordinate The longitude-latitude pair for which to return the value.
    /// @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
    /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
    /// where tileSize is the width of a tile in pixels.
    ///
    /// @return Returns a point on the map in Mercator projection.
    let projectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.project\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      projectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! Point
        let zoomScaleArg = args[1] as! Double
        do {
          let result = try api.project(coordinate: coordinateArg, zoomScale: zoomScaleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      projectChannel.setMessageHandler(nil)
    }
    /// Calculate a coordinate for a given point on the map in Mercator Projection.
    ///
    /// @param coordinate Point on the map in Mercator projection.
    /// @param zoomScale The current zoom factor applied on the map, is used to
    /// calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
    /// where tileSize is the width of a tile in pixels.
    ///
    /// @return Returns a coordinate.
    let unprojectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unprojectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let coordinateArg = args[0] as! MercatorCoordinate
        let zoomScaleArg = args[1] as! Double
        do {
          let result = try api.unproject(coordinate: coordinateArg, zoomScale: zoomScaleArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      unprojectChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapboxOptions {
  func getAccessToken() throws -> String
  func setAccessToken(token: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapboxOptionsSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `_MapboxOptions` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapboxOptions?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getAccessTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.getAccessToken\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAccessTokenChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getAccessToken()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAccessTokenChannel.setMessageHandler(nil)
    }
    let setAccessTokenChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxOptions.setAccessToken\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAccessTokenChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let tokenArg = args[0] as! String
        do {
          try api.setAccessToken(token: tokenArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAccessTokenChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapboxMapsOptions {
  func getBaseUrl() throws -> String
  func setBaseUrl(url: String) throws
  func getDataPath() throws -> String
  func setDataPath(path: String) throws
  func getAssetPath() throws -> String
  func setAssetPath(path: String) throws
  func getFlutterAssetPath(flutterAssetUri: String?) throws -> String?
  func getTileStoreUsageMode() throws -> TileStoreUsageMode
  func setTileStoreUsageMode(mode: TileStoreUsageMode) throws
  func getWorldview() throws -> String?
  func setWorldview(worldview: String?) throws
  func getLanguage() throws -> String?
  func setLanguage(language: String?) throws
  func clearData(completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapboxMapsOptionsSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `_MapboxMapsOptions` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapboxMapsOptions?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getBaseUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getBaseUrl\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getBaseUrlChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getBaseUrl()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getBaseUrlChannel.setMessageHandler(nil)
    }
    let setBaseUrlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setBaseUrl\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setBaseUrlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let urlArg = args[0] as! String
        do {
          try api.setBaseUrl(url: urlArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setBaseUrlChannel.setMessageHandler(nil)
    }
    let getDataPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getDataPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDataPathChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDataPath()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDataPathChannel.setMessageHandler(nil)
    }
    let setDataPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setDataPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setDataPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pathArg = args[0] as! String
        do {
          try api.setDataPath(path: pathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setDataPathChannel.setMessageHandler(nil)
    }
    let getAssetPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getAssetPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAssetPathChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getAssetPath()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getAssetPathChannel.setMessageHandler(nil)
    }
    let setAssetPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setAssetPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAssetPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let pathArg = args[0] as! String
        do {
          try api.setAssetPath(path: pathArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setAssetPathChannel.setMessageHandler(nil)
    }
    let getFlutterAssetPathChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getFlutterAssetPath\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFlutterAssetPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let flutterAssetUriArg: String? = nilOrValue(args[0])
        do {
          let result = try api.getFlutterAssetPath(flutterAssetUri: flutterAssetUriArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFlutterAssetPathChannel.setMessageHandler(nil)
    }
    let getTileStoreUsageModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getTileStoreUsageMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTileStoreUsageModeChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getTileStoreUsageMode()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTileStoreUsageModeChannel.setMessageHandler(nil)
    }
    let setTileStoreUsageModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setTileStoreUsageMode\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTileStoreUsageModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modeArg = args[0] as! TileStoreUsageMode
        do {
          try api.setTileStoreUsageMode(mode: modeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setTileStoreUsageModeChannel.setMessageHandler(nil)
    }
    let getWorldviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getWorldview\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getWorldviewChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getWorldview()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getWorldviewChannel.setMessageHandler(nil)
    }
    let setWorldviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setWorldview\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setWorldviewChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let worldviewArg: String? = nilOrValue(args[0])
        do {
          try api.setWorldview(worldview: worldviewArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setWorldviewChannel.setMessageHandler(nil)
    }
    let getLanguageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.getLanguage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getLanguageChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getLanguage()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getLanguageChannel.setMessageHandler(nil)
    }
    let setLanguageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.setLanguage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLanguageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let languageArg: String? = nilOrValue(args[0])
        do {
          try api.setLanguage(language: languageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLanguageChannel.setMessageHandler(nil)
    }
    let clearDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapboxMapsOptions.clearData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      clearDataChannel.setMessageHandler { _, reply in
        api.clearData { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      clearDataChannel.setMessageHandler(nil)
    }
  }
}
/// Settings class provides non-persistent, in-process key-value storage.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Settings {
  /// Sets setting value for a specified key.
  ///
  /// @param key A name of the key.
  /// @param value The `value` for the key.
  func set(key: String, value: String) throws
  /// Return value for a key.
  ///
  /// @param key A name of the key.
  ///
  /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
  func get(key: String) throws -> String
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class SettingsSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `Settings` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Settings?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Sets setting value for a specified key.
    ///
    /// @param key A name of the key.
    /// @param value The `value` for the key.
    let setChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Settings.set\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keyArg = args[0] as! String
        let valueArg = args[1] as! String
        do {
          try api.set(key: keyArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setChannel.setMessageHandler(nil)
    }
    /// Return value for a key.
    ///
    /// @param key A name of the key.
    ///
    /// @return `value` if a key exists in settings otherwise a `null value` will be returned.
    let getChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Settings.get\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keyArg = args[0] as! String
        do {
          let result = try api.get(key: keyArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getChannel.setMessageHandler(nil)
    }
  }
}
/// Interface for managing style of the `map`.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol StyleManager {
  /// Get the URI of the current style in use.
  ///
  /// @return A string containing a style URI.
  func getStyleURI(completion: @escaping (Result<String, Error>) -> Void)
  /// Load style from provided URI.
  ///
  /// This is an asynchronous call. To check the result of this operation the user must register an observer observing
  /// `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
  ///
  /// @param uri URI where the style should be loaded from.
  func setStyleURI(uri: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Get the JSON serialization string of the current style in use.
  ///
  /// @return A JSON string containing a serialized style.
  func getStyleJSON(completion: @escaping (Result<String, Error>) -> Void)
  /// Load the style from a provided JSON string.
  ///
  /// @param json A JSON string containing a serialized style.
  func setStyleJSON(json: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the map style's default camera, if any, or a default camera otherwise.
  /// The map style's default camera is defined as follows:
  /// - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
  /// - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
  /// - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
  /// - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
  ///
  /// The style default camera is re-evaluated when a new style is loaded.
  ///
  /// @return The default `camera options` of the current style in use.
  func getStyleDefaultCamera(completion: @escaping (Result<CameraOptions, Error>) -> Void)
  /// Returns the map style's transition options. By default, the style parser will attempt
  /// to read the style default transition options, if any, fallbacking to an immediate transition
  /// otherwise. Transition options can be overridden via `setStyleTransition`, but the options are
  /// reset once a new style has been loaded.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @return The `transition options` of the current style in use.
  func getStyleTransition(completion: @escaping (Result<TransitionOptions, Error>) -> Void)
  /// Returns the list containing information about existing style import objects.
  func getStyleImports() throws -> [StyleObjectInfo?]
  /// Removes an existing style import.
  ///
  /// @param importId Identifier of the style import to remove.
  func removeStyleImport(importId: String) throws
  /// Gets the style import schema.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import schema, containing the default configurations for the style import.
  func getStyleImportSchema(importId: String) throws -> Any
  /// Gets style import config.
  ///
  /// @param importId Identifier of the style import.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  func getStyleImportConfigProperties(importId: String) throws -> [String: StylePropertyValue]
  /// Gets the value of style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  ///
  /// Returns the style import configuration or a string describing an error if the operation was not successful.
  func getStyleImportConfigProperty(importId: String, config: String) throws -> StylePropertyValue
  /// Sets style import config.
  /// This method can be used to perform batch update for a style import configurations.
  ///
  /// @param importId Identifier of the style import.
  /// @param configs A map of style import configurations.
  func setStyleImportConfigProperties(importId: String, configs: [String: Any]) throws
  /// Sets a value to a style import config.
  ///
  /// @param importId Identifier of the style import.
  /// @param config The style import config name.
  /// @param value The style import config value.
  func setStyleImportConfigProperty(importId: String, config: String, value: Any) throws
  /// Overrides the map style's transition options with user-provided options.
  ///
  /// The style transition is re-evaluated when a new style is loaded.
  ///
  /// @param transitionOptions The `transition options`.
  func setStyleTransition(transitionOptions: TransitionOptions, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Runtime style layers are valid until they are either removed or a new style is loaded.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func addStyleLayer(properties: String, layerPosition: LayerPosition?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
  ///
  /// Whenever a new style is being parsed and currently used style has persistent layers,
  /// an engine will try to do following:
  ///   - keep the persistent layer at its relative position
  ///   - keep the source used by a persistent layer
  ///   - keep images added through `addStyleImage` method
  ///
  /// In cases when a new style has the same layer, source or image resource, style's resources would be
  /// used instead and `MapLoadingError` event will be emitted.
  ///
  /// @param properties A map of style layer properties.
  /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func addPersistentStyleLayer(properties: String, layerPosition: LayerPosition?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks if a style layer is persistent.
  ///
  /// @param layerId A style layer identifier.
  /// @return A string describing an error if the operation was not successful, boolean representing state otherwise.
  func isStyleLayerPersistent(layerId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Removes an existing style layer.
  ///
  /// @param layerId An identifier of the style layer to remove.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func removeStyleLayer(layerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Moves an existing style layer
  ///
  /// @param layerId Identifier of the style layer to move.
  /// @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
  ///                      is provided then the layer is moved to the top of the layerstack.
  ///
  /// @return A string describing an error if the operation was not successful, or empty otherwise.
  func moveStyleLayer(layerId: String, layerPosition: LayerPosition?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks whether a given style layer exists.
  ///
  /// @param layerId Style layer identifier.
  ///
  /// @return A `true` value if the given style layer exists, `false` otherwise.
  func styleLayerExists(layerId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Returns the existing style layers.
  ///
  /// @return The list containing the information about existing style layer objects.
  func getStyleLayers(completion: @escaping (Result<[StyleObjectInfo?], Error>) -> Void)
  /// Gets the value of style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @return The `style property value`.
  func getStyleLayerProperty(layerId: String, property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to a style layer property.
  ///
  /// @param layerId A style layer identifier.
  /// @param property The style layer property name.
  /// @param value The style layer property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleLayerProperty(layerId: String, property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets style layer properties.
  ///
  /// @return The style layer properties or a string describing an error if the operation was not successful.
  func getStyleLayerProperties(layerId: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Sets style layer properties.
  /// This method can be used to perform batch update for a style layer properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
  /// Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
  ///
  /// @param layerId A style layer identifier.
  /// @param properties A map of style layer properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleLayerProperties(layerId: String, properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
  ///
  /// @param sourceId An identifier for the style source.
  /// @param properties A map of style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func addStyleSource(sourceId: String, properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the value of style source property.
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @return The value of a `property` in the source with a `sourceId`.
  func getStyleSourceProperty(sourceId: String, property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to a style source property.
  /// Note: When setting the `data` property of a `geojson` source, this method never returns an error.
  /// In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
  ///
  ///
  /// @param sourceId A style source identifier.
  /// @param property The style source property name.
  /// @param value The style source property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleSourceProperty(sourceId: String, property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets style source properties.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return The style source properties or a string describing an error if the operation was not successful.
  func getStyleSourceProperties(sourceId: String, completion: @escaping (Result<String, Error>) -> Void)
  /// Sets style source properties.
  ///
  /// This method can be used to perform batch update for a style source properties. The structure of a
  /// provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
  /// Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
  ///
  /// @param sourceId A style source identifier.
  /// @param properties A map of Style source properties.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleSourceProperties(sourceId: String, properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Add additional features to a GeoJSON style source.
  ///
  /// The add operation will be scheduled and applied on a GeoJSON serialization queue.
  ///
  /// In order to capture events when actual data is drawn on the map please refer to Events API
  /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
  /// or `onMapLoadingError` with `type = metadata` if data parsing error has occurred.
  ///
  /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
  /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
  /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
  /// in a `map-loading-error`.
  ///
  /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
  /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
  /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
  /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
  /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
  /// call, the data ID in the `source-data-loaded`event will be null.
  /// 
  /// @param sourceId The identifier of the style source.
  /// @param dataId An arbitrary string used to track the given GeoJSON data.
  /// @param features An array of GeoJSON features to be added to the source.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func addGeoJSONSourceFeatures(sourceId: String, dataId: String, features: [Feature], completion: @escaping (Result<Void, Error>) -> Void)
  /// Update existing features in a GeoJSON style source.
  ///
  /// The update operation will be scheduled and applied on a GeoJSON serialization queue.
  ///
  /// In order to capture events when actual data is drawn on the map please refer to Events API
  /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
  /// or `onMapLoadingError` with `type = metadata` if data parsing error has occurred.
  ///
  /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
  /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
  /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
  /// in a `map-loading-error`.
  ///
  /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
  /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
  /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
  /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
  /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
  /// call, the data ID in the `source-data-loaded`event will be null.
  /// 
  /// @param sourceId A style source identifier.
  /// @param dataId An arbitrary string used to track the given GeoJSON data.
  /// @param features The GeoJSON features to be updated in the source.
  /// 
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func updateGeoJSONSourceFeatures(sourceId: String, dataId: String, features: [Feature], completion: @escaping (Result<Void, Error>) -> Void)
  /// Remove features from a GeoJSON style source.
  ///
  /// The remove operation will be scheduled and applied on a GeoJSON serialization queue.
  ///
  /// In order to capture events when actual data is drawn on the map please refer to Events API
  /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
  /// or `onMapLoadingError` with `type = metadata` if an error has occurred.
  ///
  /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
  /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
  /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
  /// in a `map-loading-error`.
  ///
  /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
  /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
  /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
  /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
  /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
  /// call, the data ID in the `source-data-loaded`event will be null.
  /// 
  /// @param sourceId A style source identifier.
  /// @param dataId An arbitrary string used to track the given GeoJSON data.
  /// @param featureIds The Ids of the features that need to be removed from the source.
  /// 
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func removeGeoJSONSourceFeatures(sourceId: String, dataId: String, featureIds: [String], completion: @escaping (Result<Void, Error>) -> Void)
  /// Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
  ///
  /// @param sourceId A style source identifier.
  /// @param image An `image`.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func updateStyleImageSourceImage(sourceId: String, image: MbxImage, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes an existing style source.
  ///
  /// @param sourceId An identifier of the style source to remove.
  func removeStyleSource(sourceId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks whether a given style source exists.
  ///
  /// @param sourceId A style source identifier.
  ///
  /// @return `true` if the given source exists, `false` otherwise.
  func styleSourceExists(sourceId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Returns the existing style sources.
  ///
  /// @return The list containing the information about existing style source objects.
  func getStyleSources(completion: @escaping (Result<[StyleObjectInfo?], Error>) -> Void)
  /// Returns an ordered list of the current style lights.
  func getStyleLights() throws -> [StyleObjectInfo?]
  /// Set global directional lightning.
  ///
  /// @param flatLight The flat light source.
  func setLight(flatLight: FlatLight) throws
  /// Set dynamic lightning.
  ///
  /// @param ambientLight The ambient light source.
  /// @param directionalLight The directional light source.
  func setLights(ambientLight: AmbientLight, directionalLight: DirectionalLight) throws
  /// Gets the value of a style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @return The style light property value.
  func getStyleLightProperty(id: String, property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to the the style light property.
  ///
  /// @param property The style light property name.
  /// @param id The unique identifier of the style light in lights list.
  /// @param value The style light property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleLightProperty(id: String, property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
  ///
  /// @param properties A map of style terrain properties values, with their names as a key.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleTerrain(properties: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Gets the value of a style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @return The style terrain property value.
  func getStyleTerrainProperty(property: String, completion: @escaping (Result<StylePropertyValue, Error>) -> Void)
  /// Sets a value to the the style terrain property.
  ///
  /// @param property The style terrain property name.
  /// @param value The style terrain property value.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func setStyleTerrainProperty(property: String, value: Any, completion: @escaping (Result<Void, Error>) -> Void)
  /// Get an `image` from the style.
  ///
  /// @param imageId The identifier of the `image`.
  ///
  /// @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
  func getStyleImage(imageId: String, completion: @escaping (Result<MbxImage?, Error>) -> Void)
  /// Adds an image to be used in the style. This API can also be used for updating
  /// an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
  ///
  /// The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
  /// [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
  /// [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
  /// [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
  ///
  /// @param imageId An identifier of the image.
  /// @param scale A scale factor for the image.
  /// @param image A pixel data of the image.
  /// @param sdf An option to treat whether image is SDF(signed distance field) or not.
  /// @param stretchX An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched horizontally.
  /// @param stretchY An array of two-element arrays, consisting of two numbers that represent
  /// the from position and the to position of areas that can be stretched vertically.
  /// @param content An array of four numbers, with the first two specifying the left, top
  /// corner, and the last two specifying the right, bottom corner. If present, and if the
  /// icon uses icon-text-fit, the symbol's text will be fit inside the content box.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func addStyleImage(imageId: String, scale: Double, image: MbxImage, sdf: Bool, stretchX: [ImageStretches?], stretchY: [ImageStretches?], content: ImageContent?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes an image from the style.
  ///
  /// @param imageId The identifier of the image to remove.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func removeStyleImage(imageId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Checks whether an image exists.
  ///
  /// @param imageId The identifier of the image.
  ///
  /// @return True if image exists, false otherwise.
  func hasStyleImage(imageId: String, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Adds a model to be used in the style. This API can also be used for updating
  /// a model. If the model for a given `modelId` was already added, it gets replaced by the new model.
  ///
  /// The model can be used in `model-id` property in model layer.
  ///
  /// @param modelId An identifier of the model.
  /// @param modelUri A URI for the model.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func addStyleModel(modelId: String, modelUri: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Removes a model from the style.
  ///
  /// @param modelId The identifier of the model to remove.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func removeStyleModel(modelId: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Set tile data of a custom geometry.
  ///
  /// @param sourceId A style source identifier.
  /// @param tileId A `canonical tile id` of the tile.
  /// @param featureCollection An array with the features to add.
  /// Invalidate tile for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier,.
  /// @param tileId A `canonical tile id` of the tile.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func invalidateStyleCustomGeometrySourceTile(sourceId: String, tileId: CanonicalTileID, completion: @escaping (Result<Void, Error>) -> Void)
  /// Invalidate region for provided custom geometry source.
  ///
  /// @param sourceId A style source identifier
  /// @param bounds A `coordinate bounds` object.
  ///
  /// @return A string describing an error if the operation was not successful, empty otherwise.
  func invalidateStyleCustomGeometrySourceRegion(sourceId: String, bounds: CoordinateBounds, completion: @escaping (Result<Void, Error>) -> Void)
  /// Check if the style is completely loaded.
  ///
  /// Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
  /// Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
  ///
  /// @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
  ///
  func isStyleLoaded(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Function to get the projection provided by the Style Extension.
  ///
  /// @return Projection that is currently applied to the map
  func getProjection() throws -> StyleProjection?
  /// Function to set the projection provided by the Style Extension.
  ///
  /// @param projection The projection to be set.
  func setProjection(projection: StyleProjection) throws
  /// Function to localize style labels.
  ///
  /// @param locale The locale to apply for localization
  /// @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
  func localizeLabels(locale: String, layerIds: [String]?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the available featuresets in the currently loaded style.
  ///
  /// - Note: This function should only be called after the style is fully loaded; otherwise, the result may be unreliable.
  func getFeaturesets() throws -> [FeaturesetDescriptor]
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class StyleManagerSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `StyleManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: StyleManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Get the URI of the current style in use.
    ///
    /// @return A string containing a style URI.
    let getStyleURIChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleURIChannel.setMessageHandler { _, reply in
        api.getStyleURI { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleURIChannel.setMessageHandler(nil)
    }
    /// Load style from provided URI.
    ///
    /// This is an asynchronous call. To check the result of this operation the user must register an observer observing
    /// `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
    ///
    /// @param uri URI where the style should be loaded from.
    let setStyleURIChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleURIChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let uriArg = args[0] as! String
        api.setStyleURI(uri: uriArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleURIChannel.setMessageHandler(nil)
    }
    /// Get the JSON serialization string of the current style in use.
    ///
    /// @return A JSON string containing a serialized style.
    let getStyleJSONChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleJSONChannel.setMessageHandler { _, reply in
        api.getStyleJSON { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleJSONChannel.setMessageHandler(nil)
    }
    /// Load the style from a provided JSON string.
    ///
    /// @param json A JSON string containing a serialized style.
    let setStyleJSONChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleJSONChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let jsonArg = args[0] as! String
        api.setStyleJSON(json: jsonArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleJSONChannel.setMessageHandler(nil)
    }
    /// Returns the map style's default camera, if any, or a default camera otherwise.
    /// The map style's default camera is defined as follows:
    /// - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
    /// - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
    /// - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
    /// - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
    ///
    /// The style default camera is re-evaluated when a new style is loaded.
    ///
    /// @return The default `camera options` of the current style in use.
    let getStyleDefaultCameraChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleDefaultCameraChannel.setMessageHandler { _, reply in
        api.getStyleDefaultCamera { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleDefaultCameraChannel.setMessageHandler(nil)
    }
    /// Returns the map style's transition options. By default, the style parser will attempt
    /// to read the style default transition options, if any, fallbacking to an immediate transition
    /// otherwise. Transition options can be overridden via `setStyleTransition`, but the options are
    /// reset once a new style has been loaded.
    ///
    /// The style transition is re-evaluated when a new style is loaded.
    ///
    /// @return The `transition options` of the current style in use.
    let getStyleTransitionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleTransitionChannel.setMessageHandler { _, reply in
        api.getStyleTransition { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleTransitionChannel.setMessageHandler(nil)
    }
    /// Returns the list containing information about existing style import objects.
    let getStyleImportsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImports\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getStyleImports()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportsChannel.setMessageHandler(nil)
    }
    /// Removes an existing style import.
    ///
    /// @param importId Identifier of the style import to remove.
    let removeStyleImportChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImport\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleImportChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        do {
          try api.removeStyleImport(importId: importIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      removeStyleImportChannel.setMessageHandler(nil)
    }
    /// Gets the style import schema.
    ///
    /// @param importId Identifier of the style import.
    ///
    /// Returns the style import schema, containing the default configurations for the style import.
    let getStyleImportSchemaChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportSchema\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportSchemaChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        do {
          let result = try api.getStyleImportSchema(importId: importIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportSchemaChannel.setMessageHandler(nil)
    }
    /// Gets style import config.
    ///
    /// @param importId Identifier of the style import.
    ///
    /// Returns the style import configuration or a string describing an error if the operation was not successful.
    let getStyleImportConfigPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportConfigPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        do {
          let result = try api.getStyleImportConfigProperties(importId: importIdArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportConfigPropertiesChannel.setMessageHandler(nil)
    }
    /// Gets the value of style import config.
    ///
    /// @param importId Identifier of the style import.
    /// @param config The style import config name.
    ///
    /// Returns the style import configuration or a string describing an error if the operation was not successful.
    let getStyleImportConfigPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImportConfigProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImportConfigPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        let configArg = args[1] as! String
        do {
          let result = try api.getStyleImportConfigProperty(importId: importIdArg, config: configArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleImportConfigPropertyChannel.setMessageHandler(nil)
    }
    /// Sets style import config.
    /// This method can be used to perform batch update for a style import configurations.
    ///
    /// @param importId Identifier of the style import.
    /// @param configs A map of style import configurations.
    let setStyleImportConfigPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleImportConfigPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        let configsArg = args[1] as! [String: Any]
        do {
          try api.setStyleImportConfigProperties(importId: importIdArg, configs: configsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setStyleImportConfigPropertiesChannel.setMessageHandler(nil)
    }
    /// Sets a value to a style import config.
    ///
    /// @param importId Identifier of the style import.
    /// @param config The style import config name.
    /// @param value The style import config value.
    let setStyleImportConfigPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleImportConfigProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleImportConfigPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let importIdArg = args[0] as! String
        let configArg = args[1] as! String
        let valueArg = args[2]!
        do {
          try api.setStyleImportConfigProperty(importId: importIdArg, config: configArg, value: valueArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setStyleImportConfigPropertyChannel.setMessageHandler(nil)
    }
    /// Overrides the map style's transition options with user-provided options.
    ///
    /// The style transition is re-evaluated when a new style is loaded.
    ///
    /// @param transitionOptions The `transition options`.
    let setStyleTransitionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleTransitionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let transitionOptionsArg = args[0] as! TransitionOptions
        api.setStyleTransition(transitionOptions: transitionOptionsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleTransitionChannel.setMessageHandler(nil)
    }
    /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
    ///
    /// Runtime style layers are valid until they are either removed or a new style is loaded.
    ///
    /// @param properties A map of style layer properties.
    /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let addStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertiesArg = args[0] as! String
        let layerPositionArg: LayerPosition? = nilOrValue(args[1])
        api.addStyleLayer(properties: propertiesArg, layerPosition: layerPositionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleLayerChannel.setMessageHandler(nil)
    }
    /// Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
    ///
    /// Whenever a new style is being parsed and currently used style has persistent layers,
    /// an engine will try to do following:
    ///   - keep the persistent layer at its relative position
    ///   - keep the source used by a persistent layer
    ///   - keep images added through `addStyleImage` method
    ///
    /// In cases when a new style has the same layer, source or image resource, style's resources would be
    /// used instead and `MapLoadingError` event will be emitted.
    ///
    /// @param properties A map of style layer properties.
    /// @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let addPersistentStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addPersistentStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertiesArg = args[0] as! String
        let layerPositionArg: LayerPosition? = nilOrValue(args[1])
        api.addPersistentStyleLayer(properties: propertiesArg, layerPosition: layerPositionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addPersistentStyleLayerChannel.setMessageHandler(nil)
    }
    /// Checks if a style layer is persistent.
    ///
    /// @param layerId A style layer identifier.
    /// @return A string describing an error if the operation was not successful, boolean representing state otherwise.
    let isStyleLayerPersistentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isStyleLayerPersistentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.isStyleLayerPersistent(layerId: layerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isStyleLayerPersistentChannel.setMessageHandler(nil)
    }
    /// Removes an existing style layer.
    ///
    /// @param layerId An identifier of the style layer to remove.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let removeStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.removeStyleLayer(layerId: layerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleLayerChannel.setMessageHandler(nil)
    }
    /// Moves an existing style layer
    ///
    /// @param layerId Identifier of the style layer to move.
    /// @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
    ///                      is provided then the layer is moved to the top of the layerstack.
    ///
    /// @return A string describing an error if the operation was not successful, or empty otherwise.
    let moveStyleLayerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      moveStyleLayerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let layerPositionArg: LayerPosition? = nilOrValue(args[1])
        api.moveStyleLayer(layerId: layerIdArg, layerPosition: layerPositionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      moveStyleLayerChannel.setMessageHandler(nil)
    }
    /// Checks whether a given style layer exists.
    ///
    /// @param layerId Style layer identifier.
    ///
    /// @return A `true` value if the given style layer exists, `false` otherwise.
    let styleLayerExistsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      styleLayerExistsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.styleLayerExists(layerId: layerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      styleLayerExistsChannel.setMessageHandler(nil)
    }
    /// Returns the existing style layers.
    ///
    /// @return The list containing the information about existing style layer objects.
    let getStyleLayersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLayersChannel.setMessageHandler { _, reply in
        api.getStyleLayers { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLayersChannel.setMessageHandler(nil)
    }
    /// Gets the value of style layer property.
    ///
    /// @param layerId A style layer identifier.
    /// @param property The style layer property name.
    /// @return The `style property value`.
    let getStyleLayerPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLayerPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        api.getStyleLayerProperty(layerId: layerIdArg, property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLayerPropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to a style layer property.
    ///
    /// @param layerId A style layer identifier.
    /// @param property The style layer property name.
    /// @param value The style layer property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleLayerPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleLayerPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        let valueArg = args[2]!
        api.setStyleLayerProperty(layerId: layerIdArg, property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleLayerPropertyChannel.setMessageHandler(nil)
    }
    /// Gets style layer properties.
    ///
    /// @return The style layer properties or a string describing an error if the operation was not successful.
    let getStyleLayerPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLayerPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        api.getStyleLayerProperties(layerId: layerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLayerPropertiesChannel.setMessageHandler(nil)
    }
    /// Sets style layer properties.
    /// This method can be used to perform batch update for a style layer properties. The structure of a
    /// provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
    /// Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
    ///
    /// @param layerId A style layer identifier.
    /// @param properties A map of style layer properties.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleLayerPropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleLayerPropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let layerIdArg = args[0] as! String
        let propertiesArg = args[1] as! String
        api.setStyleLayerProperties(layerId: layerIdArg, properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleLayerPropertiesChannel.setMessageHandler(nil)
    }
    /// Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
    ///
    /// @param sourceId An identifier for the style source.
    /// @param properties A map of style source properties.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let addStyleSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertiesArg = args[1] as! String
        api.addStyleSource(sourceId: sourceIdArg, properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleSourceChannel.setMessageHandler(nil)
    }
    /// Gets the value of style source property.
    ///
    /// @param sourceId A style source identifier.
    /// @param property The style source property name.
    /// @return The value of a `property` in the source with a `sourceId`.
    let getStyleSourcePropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleSourcePropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        api.getStyleSourceProperty(sourceId: sourceIdArg, property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleSourcePropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to a style source property.
    /// Note: When setting the `data` property of a `geojson` source, this method never returns an error.
    /// In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
    ///
    ///
    /// @param sourceId A style source identifier.
    /// @param property The style source property name.
    /// @param value The style source property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleSourcePropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleSourcePropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertyArg = args[1] as! String
        let valueArg = args[2]!
        api.setStyleSourceProperty(sourceId: sourceIdArg, property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleSourcePropertyChannel.setMessageHandler(nil)
    }
    /// Gets style source properties.
    ///
    /// @param sourceId A style source identifier.
    ///
    /// @return The style source properties or a string describing an error if the operation was not successful.
    let getStyleSourcePropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleSourcePropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        api.getStyleSourceProperties(sourceId: sourceIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleSourcePropertiesChannel.setMessageHandler(nil)
    }
    /// Sets style source properties.
    ///
    /// This method can be used to perform batch update for a style source properties. The structure of a
    /// provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
    /// Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
    ///
    /// @param sourceId A style source identifier.
    /// @param properties A map of Style source properties.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleSourcePropertiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleSourcePropertiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let propertiesArg = args[1] as! String
        api.setStyleSourceProperties(sourceId: sourceIdArg, properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleSourcePropertiesChannel.setMessageHandler(nil)
    }
    /// Add additional features to a GeoJSON style source.
    ///
    /// The add operation will be scheduled and applied on a GeoJSON serialization queue.
    ///
    /// In order to capture events when actual data is drawn on the map please refer to Events API
    /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
    /// or `onMapLoadingError` with `type = metadata` if data parsing error has occurred.
    ///
    /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
    /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
    /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
    /// in a `map-loading-error`.
    ///
    /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
    /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
    /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
    /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
    /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
    /// call, the data ID in the `source-data-loaded`event will be null.
    /// 
    /// @param sourceId The identifier of the style source.
    /// @param dataId An arbitrary string used to track the given GeoJSON data.
    /// @param features An array of GeoJSON features to be added to the source.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let addGeoJSONSourceFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addGeoJSONSourceFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addGeoJSONSourceFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let dataIdArg = args[1] as! String
        let featuresArg = args[2] as! [Feature]
        api.addGeoJSONSourceFeatures(sourceId: sourceIdArg, dataId: dataIdArg, features: featuresArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addGeoJSONSourceFeaturesChannel.setMessageHandler(nil)
    }
    /// Update existing features in a GeoJSON style source.
    ///
    /// The update operation will be scheduled and applied on a GeoJSON serialization queue.
    ///
    /// In order to capture events when actual data is drawn on the map please refer to Events API
    /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
    /// or `onMapLoadingError` with `type = metadata` if data parsing error has occurred.
    ///
    /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
    /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
    /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
    /// in a `map-loading-error`.
    ///
    /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
    /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
    /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
    /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
    /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
    /// call, the data ID in the `source-data-loaded`event will be null.
    /// 
    /// @param sourceId A style source identifier.
    /// @param dataId An arbitrary string used to track the given GeoJSON data.
    /// @param features The GeoJSON features to be updated in the source.
    /// 
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let updateGeoJSONSourceFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateGeoJSONSourceFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateGeoJSONSourceFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let dataIdArg = args[1] as! String
        let featuresArg = args[2] as! [Feature]
        api.updateGeoJSONSourceFeatures(sourceId: sourceIdArg, dataId: dataIdArg, features: featuresArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateGeoJSONSourceFeaturesChannel.setMessageHandler(nil)
    }
    /// Remove features from a GeoJSON style source.
    ///
    /// The remove operation will be scheduled and applied on a GeoJSON serialization queue.
    ///
    /// In order to capture events when actual data is drawn on the map please refer to Events API
    /// and listen to `onSourceDataLoaded` (optionally pass the `dataId` parameter to filter the events)
    /// or `onMapLoadingError` with `type = metadata` if an error has occurred.
    ///
    /// Partially updating a GeoJSON source is not compatible with using shared cache and generated IDs.
    /// It is important to ensure that every feature in the GeoJSON style source, as well as the newly added
    /// feature, has a unique ID (or a unique promote ID if in use). Failure to provide unique IDs will result
    /// in a `map-loading-error`.
    ///
    /// - Note: The method allows the user to provide a data ID, which will be returned as the `dataId` parameter in the
    /// `source-data-loaded` event. However, it's important to note that multiple partial updates can be queued
    /// for the same GeoJSON source when ongoing source parsing is taking place. In these cases, the partial
    /// updates will be applied to the source in batches. Only the data ID provided in the most recent call within
    /// each batch will be included in the `source-data-loaded` event. If no data ID is provided in the most recent
    /// call, the data ID in the `source-data-loaded`event will be null.
    /// 
    /// @param sourceId A style source identifier.
    /// @param dataId An arbitrary string used to track the given GeoJSON data.
    /// @param featureIds The Ids of the features that need to be removed from the source.
    /// 
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let removeGeoJSONSourceFeaturesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeGeoJSONSourceFeatures\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeGeoJSONSourceFeaturesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let dataIdArg = args[1] as! String
        let featureIdsArg = args[2] as! [String]
        api.removeGeoJSONSourceFeatures(sourceId: sourceIdArg, dataId: dataIdArg, featureIds: featureIdsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeGeoJSONSourceFeaturesChannel.setMessageHandler(nil)
    }
    /// Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
    ///
    /// @param sourceId A style source identifier.
    /// @param image An `image`.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let updateStyleImageSourceImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateStyleImageSourceImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let imageArg = args[1] as! MbxImage
        api.updateStyleImageSourceImage(sourceId: sourceIdArg, image: imageArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateStyleImageSourceImageChannel.setMessageHandler(nil)
    }
    /// Removes an existing style source.
    ///
    /// @param sourceId An identifier of the style source to remove.
    let removeStyleSourceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleSourceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        api.removeStyleSource(sourceId: sourceIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleSourceChannel.setMessageHandler(nil)
    }
    /// Checks whether a given style source exists.
    ///
    /// @param sourceId A style source identifier.
    ///
    /// @return `true` if the given source exists, `false` otherwise.
    let styleSourceExistsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      styleSourceExistsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        api.styleSourceExists(sourceId: sourceIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      styleSourceExistsChannel.setMessageHandler(nil)
    }
    /// Returns the existing style sources.
    ///
    /// @return The list containing the information about existing style source objects.
    let getStyleSourcesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleSourcesChannel.setMessageHandler { _, reply in
        api.getStyleSources { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleSourcesChannel.setMessageHandler(nil)
    }
    /// Returns an ordered list of the current style lights.
    let getStyleLightsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLights\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLightsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getStyleLights()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getStyleLightsChannel.setMessageHandler(nil)
    }
    /// Set global directional lightning.
    ///
    /// @param flatLight The flat light source.
    let setLightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLight\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let flatLightArg = args[0] as! FlatLight
        do {
          try api.setLight(flatLight: flatLightArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLightChannel.setMessageHandler(nil)
    }
    /// Set dynamic lightning.
    ///
    /// @param ambientLight The ambient light source.
    /// @param directionalLight The directional light source.
    let setLightsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setLights\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLightsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let ambientLightArg = args[0] as! AmbientLight
        let directionalLightArg = args[1] as! DirectionalLight
        do {
          try api.setLights(ambientLight: ambientLightArg, directionalLight: directionalLightArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setLightsChannel.setMessageHandler(nil)
    }
    /// Gets the value of a style light property.
    ///
    /// @param property The style light property name.
    /// @param id The unique identifier of the style light in lights list.
    /// @return The style light property value.
    let getStyleLightPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleLightPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let propertyArg = args[1] as! String
        api.getStyleLightProperty(id: idArg, property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleLightPropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to the the style light property.
    ///
    /// @param property The style light property name.
    /// @param id The unique identifier of the style light in lights list.
    /// @param value The style light property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleLightPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleLightPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let idArg = args[0] as! String
        let propertyArg = args[1] as! String
        let valueArg = args[2]!
        api.setStyleLightProperty(id: idArg, property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleLightPropertyChannel.setMessageHandler(nil)
    }
    /// Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
    ///
    /// @param properties A map of style terrain properties values, with their names as a key.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleTerrainChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleTerrainChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertiesArg = args[0] as! String
        api.setStyleTerrain(properties: propertiesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleTerrainChannel.setMessageHandler(nil)
    }
    /// Gets the value of a style terrain property.
    ///
    /// @param property The style terrain property name.
    /// @return The style terrain property value.
    let getStyleTerrainPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleTerrainPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertyArg = args[0] as! String
        api.getStyleTerrainProperty(property: propertyArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleTerrainPropertyChannel.setMessageHandler(nil)
    }
    /// Sets a value to the the style terrain property.
    ///
    /// @param property The style terrain property name.
    /// @param value The style terrain property value.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let setStyleTerrainPropertyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setStyleTerrainPropertyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let propertyArg = args[0] as! String
        let valueArg = args[1]!
        api.setStyleTerrainProperty(property: propertyArg, value: valueArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setStyleTerrainPropertyChannel.setMessageHandler(nil)
    }
    /// Get an `image` from the style.
    ///
    /// @param imageId The identifier of the `image`.
    ///
    /// @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
    let getStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        api.getStyleImage(imageId: imageIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getStyleImageChannel.setMessageHandler(nil)
    }
    /// Adds an image to be used in the style. This API can also be used for updating
    /// an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
    ///
    /// The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
    /// [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
    /// [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
    /// [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
    ///
    /// @param imageId An identifier of the image.
    /// @param scale A scale factor for the image.
    /// @param image A pixel data of the image.
    /// @param sdf An option to treat whether image is SDF(signed distance field) or not.
    /// @param stretchX An array of two-element arrays, consisting of two numbers that represent
    /// the from position and the to position of areas that can be stretched horizontally.
    /// @param stretchY An array of two-element arrays, consisting of two numbers that represent
    /// the from position and the to position of areas that can be stretched vertically.
    /// @param content An array of four numbers, with the first two specifying the left, top
    /// corner, and the last two specifying the right, bottom corner. If present, and if the
    /// icon uses icon-text-fit, the symbol's text will be fit inside the content box.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let addStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        let scaleArg = args[1] as! Double
        let imageArg = args[2] as! MbxImage
        let sdfArg = args[3] as! Bool
        let stretchXArg = args[4] as! [ImageStretches?]
        let stretchYArg = args[5] as! [ImageStretches?]
        let contentArg: ImageContent? = nilOrValue(args[6])
        api.addStyleImage(imageId: imageIdArg, scale: scaleArg, image: imageArg, sdf: sdfArg, stretchX: stretchXArg, stretchY: stretchYArg, content: contentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleImageChannel.setMessageHandler(nil)
    }
    /// Removes an image from the style.
    ///
    /// @param imageId The identifier of the image to remove.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let removeStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        api.removeStyleImage(imageId: imageIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleImageChannel.setMessageHandler(nil)
    }
    /// Checks whether an image exists.
    ///
    /// @param imageId The identifier of the image.
    ///
    /// @return True if image exists, false otherwise.
    let hasStyleImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasStyleImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let imageIdArg = args[0] as! String
        api.hasStyleImage(imageId: imageIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      hasStyleImageChannel.setMessageHandler(nil)
    }
    /// Adds a model to be used in the style. This API can also be used for updating
    /// a model. If the model for a given `modelId` was already added, it gets replaced by the new model.
    ///
    /// The model can be used in `model-id` property in model layer.
    ///
    /// @param modelId An identifier of the model.
    /// @param modelUri A URI for the model.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let addStyleModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleModel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      addStyleModelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modelIdArg = args[0] as! String
        let modelUriArg = args[1] as! String
        api.addStyleModel(modelId: modelIdArg, modelUri: modelUriArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      addStyleModelChannel.setMessageHandler(nil)
    }
    /// Removes a model from the style.
    ///
    /// @param modelId The identifier of the model to remove.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let removeStyleModelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleModel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeStyleModelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let modelIdArg = args[0] as! String
        api.removeStyleModel(modelId: modelIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      removeStyleModelChannel.setMessageHandler(nil)
    }
    /// Set tile data of a custom geometry.
    ///
    /// @param sourceId A style source identifier.
    /// @param tileId A `canonical tile id` of the tile.
    /// @param featureCollection An array with the features to add.
    /// Invalidate tile for provided custom geometry source.
    ///
    /// @param sourceId A style source identifier,.
    /// @param tileId A `canonical tile id` of the tile.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let invalidateStyleCustomGeometrySourceTileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      invalidateStyleCustomGeometrySourceTileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let tileIdArg = args[1] as! CanonicalTileID
        api.invalidateStyleCustomGeometrySourceTile(sourceId: sourceIdArg, tileId: tileIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      invalidateStyleCustomGeometrySourceTileChannel.setMessageHandler(nil)
    }
    /// Invalidate region for provided custom geometry source.
    ///
    /// @param sourceId A style source identifier
    /// @param bounds A `coordinate bounds` object.
    ///
    /// @return A string describing an error if the operation was not successful, empty otherwise.
    let invalidateStyleCustomGeometrySourceRegionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      invalidateStyleCustomGeometrySourceRegionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceIdArg = args[0] as! String
        let boundsArg = args[1] as! CoordinateBounds
        api.invalidateStyleCustomGeometrySourceRegion(sourceId: sourceIdArg, bounds: boundsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      invalidateStyleCustomGeometrySourceRegionChannel.setMessageHandler(nil)
    }
    /// Check if the style is completely loaded.
    ///
    /// Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
    /// Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
    ///
    /// @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
    ///
    let isStyleLoadedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isStyleLoadedChannel.setMessageHandler { _, reply in
        api.isStyleLoaded { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isStyleLoadedChannel.setMessageHandler(nil)
    }
    /// Function to get the projection provided by the Style Extension.
    ///
    /// @return Projection that is currently applied to the map
    let getProjectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getProjectionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getProjection()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getProjectionChannel.setMessageHandler(nil)
    }
    /// Function to set the projection provided by the Style Extension.
    ///
    /// @param projection The projection to be set.
    let setProjectionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setProjectionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let projectionArg = args[0] as! StyleProjection
        do {
          try api.setProjection(projection: projectionArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setProjectionChannel.setMessageHandler(nil)
    }
    /// Function to localize style labels.
    ///
    /// @param locale The locale to apply for localization
    /// @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
    let localizeLabelsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      localizeLabelsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let localeArg = args[0] as! String
        let layerIdsArg: [String]? = nilOrValue(args[1])
        api.localizeLabels(locale: localeArg, layerIds: layerIdsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      localizeLabelsChannel.setMessageHandler(nil)
    }
    /// Returns the available featuresets in the currently loaded style.
    ///
    /// - Note: This function should only be called after the style is fully loaded; otherwise, the result may be unreliable.
    let getFeaturesetsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getFeaturesets\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getFeaturesetsChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getFeaturesets()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getFeaturesetsChannel.setMessageHandler(nil)
    }
  }
}
/// Allows to cancel the associated asynchronous operation
///
/// The the associated asynchronous operation is not automatically canceled if this
/// object goes out of scope.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol Cancelable {
  /// Cancels the associated asynchronous operation
  ///
  /// If the associated asynchronous operation has already finished, this call is ignored.
  func cancel() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CancelableSetup {
  static var codec: FlutterStandardMessageCodec { MapInterfacesPigeonCodec.shared }
  /// Sets up an instance of `Cancelable` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: Cancelable?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Cancels the associated asynchronous operation
    ///
    /// If the associated asynchronous operation has already finished, this call is ignored.
    let cancelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelChannel.setMessageHandler { _, reply in
        do {
          try api.cancel()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelChannel.setMessageHandler(nil)
    }
  }
}
