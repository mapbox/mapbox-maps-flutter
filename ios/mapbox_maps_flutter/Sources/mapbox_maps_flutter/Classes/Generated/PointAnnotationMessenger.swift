// Autogenerated from Pigeon (v22.4.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif
import struct Turf.Point

/// Error class for passing custom error details to Dart side.
final class PointAnnotationMessengerError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PointAnnotationMessengerError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PointAnnotationMessengerError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PointAnnotationMessengerError {
  return PointAnnotationMessengerError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Part of the icon placed closest to the anchor.
/// Default value: "center".
enum IconAnchor: Int {
  /// The center of the icon is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the icon is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the icon is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the icon is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the icon is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the icon is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the icon is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the icon is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the icon is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// Orientation of icon when map is pitched.
/// Default value: "auto".
enum IconPitchAlignment: Int {
  /// The icon is aligned to the plane of the map.
  case mAP = 0
  /// The icon is aligned to the plane of the viewport.
  case vIEWPORT = 1
  /// Automatically matches the value of `icon-rotation-alignment`.
  case aUTO = 2
}

/// In combination with `symbol-placement`, determines the rotation behavior of icons.
/// Default value: "auto".
enum IconRotationAlignment: Int {
  /// When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line.
  case mAP = 0
  /// Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.
  case vIEWPORT = 1
  /// When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.
  case aUTO = 2
}

/// Scales the icon to fit around the associated text.
/// Default value: "none".
enum IconTextFit: Int {
  /// The icon is displayed at its intrinsic aspect ratio.
  case nONE = 0
  /// The icon is scaled in the x-dimension to fit the width of the text.
  case wIDTH = 1
  /// The icon is scaled in the y-dimension to fit the height of the text.
  case hEIGHT = 2
  /// The icon is scaled in both x- and y-dimensions.
  case bOTH = 3
}

/// Selects the base of symbol-elevation.
/// Default value: "ground".
enum SymbolElevationReference: Int {
  /// Elevate symbols relative to the sea level.
  case sEA = 0
  /// Elevate symbols relative to the ground's height below them.
  case gROUND = 1
}

/// Label placement relative to its geometry.
/// Default value: "point".
enum SymbolPlacement: Int {
  /// The label is placed at the point where the geometry is located.
  case pOINT = 0
  /// The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries.
  case lINE = 1
  /// The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries.
  case lINECENTER = 2
}

/// Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.
/// Default value: "auto".
enum SymbolZOrder: Int {
  /// Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.
  case aUTO = 0
  /// Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`.
  case vIEWPORTY = 1
  /// Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data.
  case sOURCE = 2
}

/// Part of the text placed closest to the anchor.
/// Default value: "center".
enum TextAnchor: Int {
  /// The center of the text is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the text is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the text is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the text is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the text is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the text is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the text is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the text is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the text is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// Text justification options.
/// Default value: "center".
enum TextJustify: Int {
  /// The text is aligned towards the anchor position.
  case aUTO = 0
  /// The text is aligned to the left.
  case lEFT = 1
  /// The text is centered.
  case cENTER = 2
  /// The text is aligned to the right.
  case rIGHT = 3
}

/// Orientation of text when map is pitched.
/// Default value: "auto".
enum TextPitchAlignment: Int {
  /// The text is aligned to the plane of the map.
  case mAP = 0
  /// The text is aligned to the plane of the viewport.
  case vIEWPORT = 1
  /// Automatically matches the value of `text-rotation-alignment`.
  case aUTO = 2
}

/// In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.
/// Default value: "auto".
enum TextRotationAlignment: Int {
  /// When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line.
  case mAP = 0
  /// Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`.
  case vIEWPORT = 1
  /// When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`.
  case aUTO = 2
}

/// Specifies how to capitalize text, similar to the CSS `text-transform` property.
/// Default value: "none".
enum TextTransform: Int {
  /// The text is not altered.
  case nONE = 0
  /// Forces all letters to be displayed in uppercase.
  case uPPERCASE = 1
  /// Forces all letters to be displayed in lowercase.
  case lOWERCASE = 2
}

/// To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.
enum TextVariableAnchor: Int {
  /// The center of the text is placed closest to the anchor.
  case cENTER = 0
  /// The left side of the text is placed closest to the anchor.
  case lEFT = 1
  /// The right side of the text is placed closest to the anchor.
  case rIGHT = 2
  /// The top of the text is placed closest to the anchor.
  case tOP = 3
  /// The bottom of the text is placed closest to the anchor.
  case bOTTOM = 4
  /// The top left corner of the text is placed closest to the anchor.
  case tOPLEFT = 5
  /// The top right corner of the text is placed closest to the anchor.
  case tOPRIGHT = 6
  /// The bottom left corner of the text is placed closest to the anchor.
  case bOTTOMLEFT = 7
  /// The bottom right corner of the text is placed closest to the anchor.
  case bOTTOMRIGHT = 8
}

/// The property allows control over a symbol's orientation. Note that the property values act as a hint, so that a symbol whose language doesnâ€™t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single 'vertical' enum value. For symbol with point placement, the order of elements in an array define priority order for the placement of an orientation variant. For symbol with line placement, the default text writing mode is either ['horizontal', 'vertical'] or ['vertical', 'horizontal'], the order doesn't affect the placement.
enum TextWritingMode: Int {
  /// If a text's language supports horizontal writing mode, symbols would be laid out horizontally.
  case hORIZONTAL = 0
  /// If a text's language supports vertical writing mode, symbols would be laid out vertically.
  case vERTICAL = 1
}

/// Controls the frame of reference for `icon-translate`.
/// Default value: "map".
enum IconTranslateAnchor: Int {
  /// Icons are translated relative to the map.
  case mAP = 0
  /// Icons are translated relative to the viewport.
  case vIEWPORT = 1
}

/// Controls the frame of reference for `text-translate`.
/// Default value: "map".
enum TextTranslateAnchor: Int {
  /// The text is translated relative to the map.
  case mAP = 0
  /// The text is translated relative to the viewport.
  case vIEWPORT = 1
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointAnnotation {
  /// The id for annotation
  var id: String
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// The bitmap image for this Annotation
  /// Will not take effect if [iconImage] has been set.
  var image: FlutterStandardTypedData?
  /// Part of the icon placed closest to the anchor.
  /// Default value: "center".
  var iconAnchor: IconAnchor?
  /// Name of image in sprite to use for drawing an image background.
  var iconImage: String?
  /// Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
  /// Default value: [0,0].
  var iconOffset: [Double?]?
  /// Rotates the icon clockwise.
  /// Default value: 0.
  var iconRotate: Double?
  /// Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
  /// Default value: 1. Minimum value: 0.
  var iconSize: Double?
  /// Scales the icon to fit around the associated text.
  /// Default value: "none".
  var iconTextFit: IconTextFit?
  /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
  /// Default value: [0,0,0,0].
  var iconTextFitPadding: [Double?]?
  /// Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.
  var symbolSortKey: Double?
  /// Part of the text placed closest to the anchor.
  /// Default value: "center".
  var textAnchor: TextAnchor?
  /// Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
  /// Default value: "".
  var textField: String?
  /// Text justification options.
  /// Default value: "center".
  var textJustify: TextJustify?
  /// Text tracking amount.
  /// Default value: 0.
  var textLetterSpacing: Double?
  /// Text leading value for multi-line text.
  /// Default value: 1.2.
  var textLineHeight: Double?
  /// The maximum line width for text wrapping.
  /// Default value: 10. Minimum value: 0.
  var textMaxWidth: Double?
  /// Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
  /// Default value: [0,0].
  var textOffset: [Double?]?
  /// Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
  /// Default value: 0.
  var textRadialOffset: Double?
  /// Rotates the text clockwise.
  /// Default value: 0.
  var textRotate: Double?
  /// Font size.
  /// Default value: 16. Minimum value: 0.
  var textSize: Double?
  /// Specifies how to capitalize text, similar to the CSS `text-transform` property.
  /// Default value: "none".
  var textTransform: TextTransform?
  /// The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "#000000".
  var iconColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var iconEmissiveStrength: Double?
  /// Fade out the halo towards the outside.
  /// Default value: 0. Minimum value: 0.
  var iconHaloBlur: Double?
  /// The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "rgba(0, 0, 0, 0)".
  var iconHaloColor: Int64?
  /// Distance of halo to the icon outline.
  /// Default value: 0. Minimum value: 0.
  var iconHaloWidth: Double?
  /// Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
  /// Default value: 0. Value range: [0, 1]
  var iconImageCrossFade: Double?
  /// The opacity at which the icon will be drawn in case of being depth occluded. Absent value means full occlusion against terrain only.
  /// Default value: 0. Value range: [0, 1]
  var iconOcclusionOpacity: Double?
  /// The opacity at which the icon will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var iconOpacity: Double?
  /// Specifies an uniform elevation from the ground, in meters.
  /// Default value: 0. Minimum value: 0.
  /// @experimental
  var symbolZOffset: Double?
  /// The color with which the text will be drawn.
  /// Default value: "#000000".
  var textColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var textEmissiveStrength: Double?
  /// The halo's fadeout distance towards the outside.
  /// Default value: 0. Minimum value: 0.
  var textHaloBlur: Double?
  /// The color of the text's halo, which helps it stand out from backgrounds.
  /// Default value: "rgba(0, 0, 0, 0)".
  var textHaloColor: Int64?
  /// Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
  /// Default value: 0. Minimum value: 0.
  var textHaloWidth: Double?
  /// The opacity at which the text will be drawn in case of being depth occluded. Absent value means full occlusion against terrain only.
  /// Default value: 0. Value range: [0, 1]
  var textOcclusionOpacity: Double?
  /// The opacity at which the text will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var textOpacity: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PointAnnotation? {
    let id = pigeonVar_list[0] as! String
    let geometry = pigeonVar_list[1] as! Point
    let image: FlutterStandardTypedData? = nilOrValue(pigeonVar_list[2])
    let iconAnchor: IconAnchor? = nilOrValue(pigeonVar_list[3])
    let iconImage: String? = nilOrValue(pigeonVar_list[4])
    let iconOffset: [Double?]? = nilOrValue(pigeonVar_list[5])
    let iconRotate: Double? = nilOrValue(pigeonVar_list[6])
    let iconSize: Double? = nilOrValue(pigeonVar_list[7])
    let iconTextFit: IconTextFit? = nilOrValue(pigeonVar_list[8])
    let iconTextFitPadding: [Double?]? = nilOrValue(pigeonVar_list[9])
    let symbolSortKey: Double? = nilOrValue(pigeonVar_list[10])
    let textAnchor: TextAnchor? = nilOrValue(pigeonVar_list[11])
    let textField: String? = nilOrValue(pigeonVar_list[12])
    let textJustify: TextJustify? = nilOrValue(pigeonVar_list[13])
    let textLetterSpacing: Double? = nilOrValue(pigeonVar_list[14])
    let textLineHeight: Double? = nilOrValue(pigeonVar_list[15])
    let textMaxWidth: Double? = nilOrValue(pigeonVar_list[16])
    let textOffset: [Double?]? = nilOrValue(pigeonVar_list[17])
    let textRadialOffset: Double? = nilOrValue(pigeonVar_list[18])
    let textRotate: Double? = nilOrValue(pigeonVar_list[19])
    let textSize: Double? = nilOrValue(pigeonVar_list[20])
    let textTransform: TextTransform? = nilOrValue(pigeonVar_list[21])
    let iconColor: Int64? = nilOrValue(pigeonVar_list[22])
    let iconEmissiveStrength: Double? = nilOrValue(pigeonVar_list[23])
    let iconHaloBlur: Double? = nilOrValue(pigeonVar_list[24])
    let iconHaloColor: Int64? = nilOrValue(pigeonVar_list[25])
    let iconHaloWidth: Double? = nilOrValue(pigeonVar_list[26])
    let iconImageCrossFade: Double? = nilOrValue(pigeonVar_list[27])
    let iconOcclusionOpacity: Double? = nilOrValue(pigeonVar_list[28])
    let iconOpacity: Double? = nilOrValue(pigeonVar_list[29])
    let symbolZOffset: Double? = nilOrValue(pigeonVar_list[30])
    let textColor: Int64? = nilOrValue(pigeonVar_list[31])
    let textEmissiveStrength: Double? = nilOrValue(pigeonVar_list[32])
    let textHaloBlur: Double? = nilOrValue(pigeonVar_list[33])
    let textHaloColor: Int64? = nilOrValue(pigeonVar_list[34])
    let textHaloWidth: Double? = nilOrValue(pigeonVar_list[35])
    let textOcclusionOpacity: Double? = nilOrValue(pigeonVar_list[36])
    let textOpacity: Double? = nilOrValue(pigeonVar_list[37])

    return PointAnnotation(
      id: id,
      geometry: geometry,
      image: image,
      iconAnchor: iconAnchor,
      iconImage: iconImage,
      iconOffset: iconOffset,
      iconRotate: iconRotate,
      iconSize: iconSize,
      iconTextFit: iconTextFit,
      iconTextFitPadding: iconTextFitPadding,
      symbolSortKey: symbolSortKey,
      textAnchor: textAnchor,
      textField: textField,
      textJustify: textJustify,
      textLetterSpacing: textLetterSpacing,
      textLineHeight: textLineHeight,
      textMaxWidth: textMaxWidth,
      textOffset: textOffset,
      textRadialOffset: textRadialOffset,
      textRotate: textRotate,
      textSize: textSize,
      textTransform: textTransform,
      iconColor: iconColor,
      iconEmissiveStrength: iconEmissiveStrength,
      iconHaloBlur: iconHaloBlur,
      iconHaloColor: iconHaloColor,
      iconHaloWidth: iconHaloWidth,
      iconImageCrossFade: iconImageCrossFade,
      iconOcclusionOpacity: iconOcclusionOpacity,
      iconOpacity: iconOpacity,
      symbolZOffset: symbolZOffset,
      textColor: textColor,
      textEmissiveStrength: textEmissiveStrength,
      textHaloBlur: textHaloBlur,
      textHaloColor: textHaloColor,
      textHaloWidth: textHaloWidth,
      textOcclusionOpacity: textOcclusionOpacity,
      textOpacity: textOpacity
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      geometry,
      image,
      iconAnchor,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor,
      textField,
      textJustify,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOcclusionOpacity,
      iconOpacity,
      symbolZOffset,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOcclusionOpacity,
      textOpacity,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PointAnnotationOptions {
  /// The geometry that determines the location/shape of this annotation
  var geometry: Point
  /// The bitmap image for this Annotation
  /// Will not take effect if [iconImage] has been set.
  var image: FlutterStandardTypedData?
  /// Part of the icon placed closest to the anchor.
  /// Default value: "center".
  var iconAnchor: IconAnchor?
  /// Name of image in sprite to use for drawing an image background.
  var iconImage: String?
  /// Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.
  /// Default value: [0,0].
  var iconOffset: [Double?]?
  /// Rotates the icon clockwise.
  /// Default value: 0.
  var iconRotate: Double?
  /// Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.
  /// Default value: 1. Minimum value: 0.
  var iconSize: Double?
  /// Scales the icon to fit around the associated text.
  /// Default value: "none".
  var iconTextFit: IconTextFit?
  /// Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.
  /// Default value: [0,0,0,0].
  var iconTextFitPadding: [Double?]?
  /// Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first. When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.
  var symbolSortKey: Double?
  /// Part of the text placed closest to the anchor.
  /// Default value: "center".
  var textAnchor: TextAnchor?
  /// Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options. SDF images are not supported in formatted text and will be ignored.
  /// Default value: "".
  var textField: String?
  /// Text justification options.
  /// Default value: "center".
  var textJustify: TextJustify?
  /// Text tracking amount.
  /// Default value: 0.
  var textLetterSpacing: Double?
  /// Text leading value for multi-line text.
  /// Default value: 1.2.
  var textLineHeight: Double?
  /// The maximum line width for text wrapping.
  /// Default value: 10. Minimum value: 0.
  var textMaxWidth: Double?
  /// Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.
  /// Default value: [0,0].
  var textOffset: [Double?]?
  /// Radial offset of text, in the direction of the symbol's anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.
  /// Default value: 0.
  var textRadialOffset: Double?
  /// Rotates the text clockwise.
  /// Default value: 0.
  var textRotate: Double?
  /// Font size.
  /// Default value: 16. Minimum value: 0.
  var textSize: Double?
  /// Specifies how to capitalize text, similar to the CSS `text-transform` property.
  /// Default value: "none".
  var textTransform: TextTransform?
  /// The color of the icon. This can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "#000000".
  var iconColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var iconEmissiveStrength: Double?
  /// Fade out the halo towards the outside.
  /// Default value: 0. Minimum value: 0.
  var iconHaloBlur: Double?
  /// The color of the icon's halo. Icon halos can only be used with [SDF icons](/help/troubleshooting/using-recolorable-images-in-mapbox-maps/).
  /// Default value: "rgba(0, 0, 0, 0)".
  var iconHaloColor: Int64?
  /// Distance of halo to the icon outline.
  /// Default value: 0. Minimum value: 0.
  var iconHaloWidth: Double?
  /// Controls the transition progress between the image variants of icon-image. Zero means the first variant is used, one is the second, and in between they are blended together.
  /// Default value: 0. Value range: [0, 1]
  var iconImageCrossFade: Double?
  /// The opacity at which the icon will be drawn in case of being depth occluded. Absent value means full occlusion against terrain only.
  /// Default value: 0. Value range: [0, 1]
  var iconOcclusionOpacity: Double?
  /// The opacity at which the icon will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var iconOpacity: Double?
  /// Specifies an uniform elevation from the ground, in meters.
  /// Default value: 0. Minimum value: 0.
  /// @experimental
  var symbolZOffset: Double?
  /// The color with which the text will be drawn.
  /// Default value: "#000000".
  var textColor: Int64?
  /// Controls the intensity of light emitted on the source features.
  /// Default value: 1. Minimum value: 0.
  var textEmissiveStrength: Double?
  /// The halo's fadeout distance towards the outside.
  /// Default value: 0. Minimum value: 0.
  var textHaloBlur: Double?
  /// The color of the text's halo, which helps it stand out from backgrounds.
  /// Default value: "rgba(0, 0, 0, 0)".
  var textHaloColor: Int64?
  /// Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.
  /// Default value: 0. Minimum value: 0.
  var textHaloWidth: Double?
  /// The opacity at which the text will be drawn in case of being depth occluded. Absent value means full occlusion against terrain only.
  /// Default value: 0. Value range: [0, 1]
  var textOcclusionOpacity: Double?
  /// The opacity at which the text will be drawn.
  /// Default value: 1. Value range: [0, 1]
  var textOpacity: Double?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PointAnnotationOptions? {
    let geometry = pigeonVar_list[0] as! Point
    let image: FlutterStandardTypedData? = nilOrValue(pigeonVar_list[1])
    let iconAnchor: IconAnchor? = nilOrValue(pigeonVar_list[2])
    let iconImage: String? = nilOrValue(pigeonVar_list[3])
    let iconOffset: [Double?]? = nilOrValue(pigeonVar_list[4])
    let iconRotate: Double? = nilOrValue(pigeonVar_list[5])
    let iconSize: Double? = nilOrValue(pigeonVar_list[6])
    let iconTextFit: IconTextFit? = nilOrValue(pigeonVar_list[7])
    let iconTextFitPadding: [Double?]? = nilOrValue(pigeonVar_list[8])
    let symbolSortKey: Double? = nilOrValue(pigeonVar_list[9])
    let textAnchor: TextAnchor? = nilOrValue(pigeonVar_list[10])
    let textField: String? = nilOrValue(pigeonVar_list[11])
    let textJustify: TextJustify? = nilOrValue(pigeonVar_list[12])
    let textLetterSpacing: Double? = nilOrValue(pigeonVar_list[13])
    let textLineHeight: Double? = nilOrValue(pigeonVar_list[14])
    let textMaxWidth: Double? = nilOrValue(pigeonVar_list[15])
    let textOffset: [Double?]? = nilOrValue(pigeonVar_list[16])
    let textRadialOffset: Double? = nilOrValue(pigeonVar_list[17])
    let textRotate: Double? = nilOrValue(pigeonVar_list[18])
    let textSize: Double? = nilOrValue(pigeonVar_list[19])
    let textTransform: TextTransform? = nilOrValue(pigeonVar_list[20])
    let iconColor: Int64? = nilOrValue(pigeonVar_list[21])
    let iconEmissiveStrength: Double? = nilOrValue(pigeonVar_list[22])
    let iconHaloBlur: Double? = nilOrValue(pigeonVar_list[23])
    let iconHaloColor: Int64? = nilOrValue(pigeonVar_list[24])
    let iconHaloWidth: Double? = nilOrValue(pigeonVar_list[25])
    let iconImageCrossFade: Double? = nilOrValue(pigeonVar_list[26])
    let iconOcclusionOpacity: Double? = nilOrValue(pigeonVar_list[27])
    let iconOpacity: Double? = nilOrValue(pigeonVar_list[28])
    let symbolZOffset: Double? = nilOrValue(pigeonVar_list[29])
    let textColor: Int64? = nilOrValue(pigeonVar_list[30])
    let textEmissiveStrength: Double? = nilOrValue(pigeonVar_list[31])
    let textHaloBlur: Double? = nilOrValue(pigeonVar_list[32])
    let textHaloColor: Int64? = nilOrValue(pigeonVar_list[33])
    let textHaloWidth: Double? = nilOrValue(pigeonVar_list[34])
    let textOcclusionOpacity: Double? = nilOrValue(pigeonVar_list[35])
    let textOpacity: Double? = nilOrValue(pigeonVar_list[36])

    return PointAnnotationOptions(
      geometry: geometry,
      image: image,
      iconAnchor: iconAnchor,
      iconImage: iconImage,
      iconOffset: iconOffset,
      iconRotate: iconRotate,
      iconSize: iconSize,
      iconTextFit: iconTextFit,
      iconTextFitPadding: iconTextFitPadding,
      symbolSortKey: symbolSortKey,
      textAnchor: textAnchor,
      textField: textField,
      textJustify: textJustify,
      textLetterSpacing: textLetterSpacing,
      textLineHeight: textLineHeight,
      textMaxWidth: textMaxWidth,
      textOffset: textOffset,
      textRadialOffset: textRadialOffset,
      textRotate: textRotate,
      textSize: textSize,
      textTransform: textTransform,
      iconColor: iconColor,
      iconEmissiveStrength: iconEmissiveStrength,
      iconHaloBlur: iconHaloBlur,
      iconHaloColor: iconHaloColor,
      iconHaloWidth: iconHaloWidth,
      iconImageCrossFade: iconImageCrossFade,
      iconOcclusionOpacity: iconOcclusionOpacity,
      iconOpacity: iconOpacity,
      symbolZOffset: symbolZOffset,
      textColor: textColor,
      textEmissiveStrength: textEmissiveStrength,
      textHaloBlur: textHaloBlur,
      textHaloColor: textHaloColor,
      textHaloWidth: textHaloWidth,
      textOcclusionOpacity: textOcclusionOpacity,
      textOpacity: textOpacity
    )
  }
  func toList() -> [Any?] {
    return [
      geometry,
      image,
      iconAnchor,
      iconImage,
      iconOffset,
      iconRotate,
      iconSize,
      iconTextFit,
      iconTextFitPadding,
      symbolSortKey,
      textAnchor,
      textField,
      textJustify,
      textLetterSpacing,
      textLineHeight,
      textMaxWidth,
      textOffset,
      textRadialOffset,
      textRotate,
      textSize,
      textTransform,
      iconColor,
      iconEmissiveStrength,
      iconHaloBlur,
      iconHaloColor,
      iconHaloWidth,
      iconImageCrossFade,
      iconOcclusionOpacity,
      iconOpacity,
      symbolZOffset,
      textColor,
      textEmissiveStrength,
      textHaloBlur,
      textHaloColor,
      textHaloWidth,
      textOcclusionOpacity,
      textOpacity,
    ]
  }
}

private class PointAnnotationMessengerPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IconAnchor(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IconPitchAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IconRotationAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 132:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IconTextFit(rawValue: enumResultAsInt)
      }
      return nil
    case 133:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SymbolElevationReference(rawValue: enumResultAsInt)
      }
      return nil
    case 134:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SymbolPlacement(rawValue: enumResultAsInt)
      }
      return nil
    case 135:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SymbolZOrder(rawValue: enumResultAsInt)
      }
      return nil
    case 136:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextAnchor(rawValue: enumResultAsInt)
      }
      return nil
    case 137:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextJustify(rawValue: enumResultAsInt)
      }
      return nil
    case 138:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextPitchAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 139:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextRotationAlignment(rawValue: enumResultAsInt)
      }
      return nil
    case 140:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextTransform(rawValue: enumResultAsInt)
      }
      return nil
    case 141:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextVariableAnchor(rawValue: enumResultAsInt)
      }
      return nil
    case 142:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextWritingMode(rawValue: enumResultAsInt)
      }
      return nil
    case 143:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return IconTranslateAnchor(rawValue: enumResultAsInt)
      }
      return nil
    case 144:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TextTranslateAnchor(rawValue: enumResultAsInt)
      }
      return nil
    case 145:
      return Point.fromList(self.readValue() as! [Any?])
    case 146:
      return PointAnnotation.fromList(self.readValue() as! [Any?])
    case 147:
      return PointAnnotationOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class PointAnnotationMessengerPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? IconAnchor {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconPitchAlignment {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconRotationAlignment {
      super.writeByte(131)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconTextFit {
      super.writeByte(132)
      super.writeValue(value.rawValue)
    } else if let value = value as? SymbolElevationReference {
      super.writeByte(133)
      super.writeValue(value.rawValue)
    } else if let value = value as? SymbolPlacement {
      super.writeByte(134)
      super.writeValue(value.rawValue)
    } else if let value = value as? SymbolZOrder {
      super.writeByte(135)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextAnchor {
      super.writeByte(136)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextJustify {
      super.writeByte(137)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextPitchAlignment {
      super.writeByte(138)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextRotationAlignment {
      super.writeByte(139)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextTransform {
      super.writeByte(140)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextVariableAnchor {
      super.writeByte(141)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextWritingMode {
      super.writeByte(142)
      super.writeValue(value.rawValue)
    } else if let value = value as? IconTranslateAnchor {
      super.writeByte(143)
      super.writeValue(value.rawValue)
    } else if let value = value as? TextTranslateAnchor {
      super.writeByte(144)
      super.writeValue(value.rawValue)
    } else if let value = value as? Point {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotation {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? PointAnnotationOptions {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class PointAnnotationMessengerPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return PointAnnotationMessengerPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return PointAnnotationMessengerPigeonCodecWriter(data: data)
  }
}

class PointAnnotationMessengerPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = PointAnnotationMessengerPigeonCodec(readerWriter: PointAnnotationMessengerPigeonCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol OnPointAnnotationClickListenerProtocol {
  func onPointAnnotationClick(annotation annotationArg: PointAnnotation, completion: @escaping (Result<Void, PointAnnotationMessengerError>) -> Void)
}
class OnPointAnnotationClickListener: OnPointAnnotationClickListenerProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: PointAnnotationMessengerPigeonCodec {
    return PointAnnotationMessengerPigeonCodec.shared
  }
  func onPointAnnotationClick(annotation annotationArg: PointAnnotation, completion: @escaping (Result<Void, PointAnnotationMessengerError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.mapbox_maps_flutter.OnPointAnnotationClickListener.onPointAnnotationClick\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([annotationArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PointAnnotationMessengerError(code: code, message: message, details: details)))
      } else {
        completion(.success(Void()))
      }
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _PointAnnotationMessenger {
  func create(managerId: String, annotationOption: PointAnnotationOptions, completion: @escaping (Result<PointAnnotation, Error>) -> Void)
  func createMulti(managerId: String, annotationOptions: [PointAnnotationOptions], completion: @escaping (Result<[PointAnnotation], Error>) -> Void)
  func update(managerId: String, annotation: PointAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func delete(managerId: String, annotation: PointAnnotation, completion: @escaping (Result<Void, Error>) -> Void)
  func deleteAll(managerId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func setIconAllowOverlap(managerId: String, iconAllowOverlap: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconAllowOverlap(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconAnchor(managerId: String, iconAnchor: IconAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconAnchor(managerId: String, completion: @escaping (Result<IconAnchor?, Error>) -> Void)
  func setIconIgnorePlacement(managerId: String, iconIgnorePlacement: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconIgnorePlacement(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconImage(managerId: String, iconImage: String, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconImage(managerId: String, completion: @escaping (Result<String?, Error>) -> Void)
  func setIconKeepUpright(managerId: String, iconKeepUpright: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconKeepUpright(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconOffset(managerId: String, iconOffset: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOffset(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setIconOptional(managerId: String, iconOptional: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOptional(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setIconPadding(managerId: String, iconPadding: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconPadding(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconPitchAlignment(managerId: String, iconPitchAlignment: IconPitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconPitchAlignment(managerId: String, completion: @escaping (Result<IconPitchAlignment?, Error>) -> Void)
  func setIconRotate(managerId: String, iconRotate: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconRotate(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconRotationAlignment(managerId: String, iconRotationAlignment: IconRotationAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconRotationAlignment(managerId: String, completion: @escaping (Result<IconRotationAlignment?, Error>) -> Void)
  func setIconSize(managerId: String, iconSize: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconSize(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconTextFit(managerId: String, iconTextFit: IconTextFit, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTextFit(managerId: String, completion: @escaping (Result<IconTextFit?, Error>) -> Void)
  func setIconTextFitPadding(managerId: String, iconTextFitPadding: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTextFitPadding(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setSymbolAvoidEdges(managerId: String, symbolAvoidEdges: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolAvoidEdges(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setSymbolElevationReference(managerId: String, symbolElevationReference: SymbolElevationReference, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolElevationReference(managerId: String, completion: @escaping (Result<SymbolElevationReference?, Error>) -> Void)
  func setSymbolPlacement(managerId: String, symbolPlacement: SymbolPlacement, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolPlacement(managerId: String, completion: @escaping (Result<SymbolPlacement?, Error>) -> Void)
  func setSymbolSortKey(managerId: String, symbolSortKey: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolSortKey(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setSymbolSpacing(managerId: String, symbolSpacing: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolSpacing(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setSymbolZElevate(managerId: String, symbolZElevate: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZElevate(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setSymbolZOrder(managerId: String, symbolZOrder: SymbolZOrder, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZOrder(managerId: String, completion: @escaping (Result<SymbolZOrder?, Error>) -> Void)
  func setTextAllowOverlap(managerId: String, textAllowOverlap: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextAllowOverlap(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextAnchor(managerId: String, textAnchor: TextAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextAnchor(managerId: String, completion: @escaping (Result<TextAnchor?, Error>) -> Void)
  func setTextField(managerId: String, textField: String, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextField(managerId: String, completion: @escaping (Result<String?, Error>) -> Void)
  func setTextFont(managerId: String, textFont: [String?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextFont(managerId: String, completion: @escaping (Result<[String?]?, Error>) -> Void)
  func setTextIgnorePlacement(managerId: String, textIgnorePlacement: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextIgnorePlacement(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextJustify(managerId: String, textJustify: TextJustify, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextJustify(managerId: String, completion: @escaping (Result<TextJustify?, Error>) -> Void)
  func setTextKeepUpright(managerId: String, textKeepUpright: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextKeepUpright(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextLetterSpacing(managerId: String, textLetterSpacing: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextLetterSpacing(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextLineHeight(managerId: String, textLineHeight: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextLineHeight(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextMaxAngle(managerId: String, textMaxAngle: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextMaxAngle(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextMaxWidth(managerId: String, textMaxWidth: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextMaxWidth(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextOffset(managerId: String, textOffset: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOffset(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setTextOptional(managerId: String, textOptional: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOptional(managerId: String, completion: @escaping (Result<Bool?, Error>) -> Void)
  func setTextPadding(managerId: String, textPadding: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextPadding(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextPitchAlignment(managerId: String, textPitchAlignment: TextPitchAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextPitchAlignment(managerId: String, completion: @escaping (Result<TextPitchAlignment?, Error>) -> Void)
  func setTextRadialOffset(managerId: String, textRadialOffset: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextRadialOffset(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextRotate(managerId: String, textRotate: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextRotate(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextRotationAlignment(managerId: String, textRotationAlignment: TextRotationAlignment, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextRotationAlignment(managerId: String, completion: @escaping (Result<TextRotationAlignment?, Error>) -> Void)
  func setTextSize(managerId: String, textSize: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextSize(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextTransform(managerId: String, textTransform: TextTransform, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTransform(managerId: String, completion: @escaping (Result<TextTransform?, Error>) -> Void)
  func setIconColor(managerId: String, iconColor: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconColor(managerId: String, completion: @escaping (Result<Int64?, Error>) -> Void)
  func setIconColorSaturation(managerId: String, iconColorSaturation: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconColorSaturation(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconEmissiveStrength(managerId: String, iconEmissiveStrength: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconEmissiveStrength(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconHaloBlur(managerId: String, iconHaloBlur: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconHaloBlur(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconHaloColor(managerId: String, iconHaloColor: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconHaloColor(managerId: String, completion: @escaping (Result<Int64?, Error>) -> Void)
  func setIconHaloWidth(managerId: String, iconHaloWidth: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconHaloWidth(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconImageCrossFade(managerId: String, iconImageCrossFade: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconImageCrossFade(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconOcclusionOpacity(managerId: String, iconOcclusionOpacity: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOcclusionOpacity(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconOpacity(managerId: String, iconOpacity: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconOpacity(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setIconTranslate(managerId: String, iconTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setIconTranslateAnchor(managerId: String, iconTranslateAnchor: IconTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getIconTranslateAnchor(managerId: String, completion: @escaping (Result<IconTranslateAnchor?, Error>) -> Void)
  func setSymbolZOffset(managerId: String, symbolZOffset: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getSymbolZOffset(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextColor(managerId: String, textColor: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextColor(managerId: String, completion: @escaping (Result<Int64?, Error>) -> Void)
  func setTextEmissiveStrength(managerId: String, textEmissiveStrength: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextEmissiveStrength(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextHaloBlur(managerId: String, textHaloBlur: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextHaloBlur(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextHaloColor(managerId: String, textHaloColor: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextHaloColor(managerId: String, completion: @escaping (Result<Int64?, Error>) -> Void)
  func setTextHaloWidth(managerId: String, textHaloWidth: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextHaloWidth(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextOcclusionOpacity(managerId: String, textOcclusionOpacity: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOcclusionOpacity(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextOpacity(managerId: String, textOpacity: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextOpacity(managerId: String, completion: @escaping (Result<Double?, Error>) -> Void)
  func setTextTranslate(managerId: String, textTranslate: [Double?], completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTranslate(managerId: String, completion: @escaping (Result<[Double?]?, Error>) -> Void)
  func setTextTranslateAnchor(managerId: String, textTranslateAnchor: TextTranslateAnchor, completion: @escaping (Result<Void, Error>) -> Void)
  func getTextTranslateAnchor(managerId: String, completion: @escaping (Result<TextTranslateAnchor?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _PointAnnotationMessengerSetup {
  static var codec: FlutterStandardMessageCodec { PointAnnotationMessengerPigeonCodec.shared }
  /// Sets up an instance of `_PointAnnotationMessenger` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _PointAnnotationMessenger?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionArg = args[1] as! PointAnnotationOptions
        api.create(managerId: managerIdArg, annotationOption: annotationOptionArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let createMultiChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.createMulti\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createMultiChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationOptionsArg = args[1] as! [PointAnnotationOptions]
        api.createMulti(managerId: managerIdArg, annotationOptions: annotationOptionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createMultiChannel.setMessageHandler(nil)
    }
    let updateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.update\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PointAnnotation
        api.update(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      updateChannel.setMessageHandler(nil)
    }
    let deleteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.delete\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let annotationArg = args[1] as! PointAnnotation
        api.delete(managerId: managerIdArg, annotation: annotationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteChannel.setMessageHandler(nil)
    }
    let deleteAllChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.deleteAll\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      deleteAllChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.deleteAll(managerId: managerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      deleteAllChannel.setMessageHandler(nil)
    }
    let setIconAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconAllowOverlapArg = args[1] as! Bool
        api.setIconAllowOverlap(managerId: managerIdArg, iconAllowOverlap: iconAllowOverlapArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconAllowOverlapChannel.setMessageHandler(nil)
    }
    let getIconAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconAllowOverlap(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconAllowOverlapChannel.setMessageHandler(nil)
    }
    let setIconAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconAnchorArg = args[1] as! IconAnchor
        api.setIconAnchor(managerId: managerIdArg, iconAnchor: iconAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconAnchorChannel.setMessageHandler(nil)
    }
    let getIconAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconAnchorChannel.setMessageHandler(nil)
    }
    let setIconIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconIgnorePlacementArg = args[1] as! Bool
        api.setIconIgnorePlacement(managerId: managerIdArg, iconIgnorePlacement: iconIgnorePlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconIgnorePlacementChannel.setMessageHandler(nil)
    }
    let getIconIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconIgnorePlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconIgnorePlacementChannel.setMessageHandler(nil)
    }
    let setIconImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconImageArg = args[1] as! String
        api.setIconImage(managerId: managerIdArg, iconImage: iconImageArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconImageChannel.setMessageHandler(nil)
    }
    let getIconImageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconImage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconImageChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconImage(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconImageChannel.setMessageHandler(nil)
    }
    let setIconKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconKeepUprightArg = args[1] as! Bool
        api.setIconKeepUpright(managerId: managerIdArg, iconKeepUpright: iconKeepUprightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconKeepUprightChannel.setMessageHandler(nil)
    }
    let getIconKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconKeepUpright(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconKeepUprightChannel.setMessageHandler(nil)
    }
    let setIconOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOffsetArg = args[1] as! [Double?]
        api.setIconOffset(managerId: managerIdArg, iconOffset: iconOffsetArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOffsetChannel.setMessageHandler(nil)
    }
    let getIconOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOffset(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOffsetChannel.setMessageHandler(nil)
    }
    let setIconOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOptionalArg = args[1] as! Bool
        api.setIconOptional(managerId: managerIdArg, iconOptional: iconOptionalArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOptionalChannel.setMessageHandler(nil)
    }
    let getIconOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOptional(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOptionalChannel.setMessageHandler(nil)
    }
    let setIconPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconPaddingArg = args[1] as! Double
        api.setIconPadding(managerId: managerIdArg, iconPadding: iconPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconPaddingChannel.setMessageHandler(nil)
    }
    let getIconPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconPaddingChannel.setMessageHandler(nil)
    }
    let setIconPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconPitchAlignmentArg = args[1] as! IconPitchAlignment
        api.setIconPitchAlignment(managerId: managerIdArg, iconPitchAlignment: iconPitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconPitchAlignmentChannel.setMessageHandler(nil)
    }
    let getIconPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconPitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconPitchAlignmentChannel.setMessageHandler(nil)
    }
    let setIconRotateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconRotate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconRotateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconRotateArg = args[1] as! Double
        api.setIconRotate(managerId: managerIdArg, iconRotate: iconRotateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconRotateChannel.setMessageHandler(nil)
    }
    let getIconRotateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconRotate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconRotateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconRotate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconRotateChannel.setMessageHandler(nil)
    }
    let setIconRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconRotationAlignmentArg = args[1] as! IconRotationAlignment
        api.setIconRotationAlignment(managerId: managerIdArg, iconRotationAlignment: iconRotationAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconRotationAlignmentChannel.setMessageHandler(nil)
    }
    let getIconRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconRotationAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconRotationAlignmentChannel.setMessageHandler(nil)
    }
    let setIconSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconSize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconSizeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconSizeArg = args[1] as! Double
        api.setIconSize(managerId: managerIdArg, iconSize: iconSizeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconSizeChannel.setMessageHandler(nil)
    }
    let getIconSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconSize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconSizeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconSize(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconSizeChannel.setMessageHandler(nil)
    }
    let setIconTextFitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTextFit\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTextFitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTextFitArg = args[1] as! IconTextFit
        api.setIconTextFit(managerId: managerIdArg, iconTextFit: iconTextFitArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTextFitChannel.setMessageHandler(nil)
    }
    let getIconTextFitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTextFit\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTextFitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTextFit(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTextFitChannel.setMessageHandler(nil)
    }
    let setIconTextFitPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTextFitPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTextFitPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTextFitPaddingArg = args[1] as! [Double?]
        api.setIconTextFitPadding(managerId: managerIdArg, iconTextFitPadding: iconTextFitPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTextFitPaddingChannel.setMessageHandler(nil)
    }
    let getIconTextFitPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTextFitPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTextFitPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTextFitPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTextFitPaddingChannel.setMessageHandler(nil)
    }
    let setSymbolAvoidEdgesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolAvoidEdges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolAvoidEdgesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolAvoidEdgesArg = args[1] as! Bool
        api.setSymbolAvoidEdges(managerId: managerIdArg, symbolAvoidEdges: symbolAvoidEdgesArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolAvoidEdgesChannel.setMessageHandler(nil)
    }
    let getSymbolAvoidEdgesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolAvoidEdges\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolAvoidEdgesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolAvoidEdges(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolAvoidEdgesChannel.setMessageHandler(nil)
    }
    let setSymbolElevationReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolElevationReference\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolElevationReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolElevationReferenceArg = args[1] as! SymbolElevationReference
        api.setSymbolElevationReference(managerId: managerIdArg, symbolElevationReference: symbolElevationReferenceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolElevationReferenceChannel.setMessageHandler(nil)
    }
    let getSymbolElevationReferenceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolElevationReference\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolElevationReferenceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolElevationReference(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolElevationReferenceChannel.setMessageHandler(nil)
    }
    let setSymbolPlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolPlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolPlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolPlacementArg = args[1] as! SymbolPlacement
        api.setSymbolPlacement(managerId: managerIdArg, symbolPlacement: symbolPlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolPlacementChannel.setMessageHandler(nil)
    }
    let getSymbolPlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolPlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolPlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolPlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolPlacementChannel.setMessageHandler(nil)
    }
    let setSymbolSortKeyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolSortKey\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolSortKeyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolSortKeyArg = args[1] as! Double
        api.setSymbolSortKey(managerId: managerIdArg, symbolSortKey: symbolSortKeyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolSortKeyChannel.setMessageHandler(nil)
    }
    let getSymbolSortKeyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolSortKey\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolSortKeyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolSortKey(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolSortKeyChannel.setMessageHandler(nil)
    }
    let setSymbolSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolSpacingArg = args[1] as! Double
        api.setSymbolSpacing(managerId: managerIdArg, symbolSpacing: symbolSpacingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolSpacingChannel.setMessageHandler(nil)
    }
    let getSymbolSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolSpacing(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolSpacingChannel.setMessageHandler(nil)
    }
    let setSymbolZElevateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZElevate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZElevateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZElevateArg = args[1] as! Bool
        api.setSymbolZElevate(managerId: managerIdArg, symbolZElevate: symbolZElevateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZElevateChannel.setMessageHandler(nil)
    }
    let getSymbolZElevateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZElevate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZElevateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZElevate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZElevateChannel.setMessageHandler(nil)
    }
    let setSymbolZOrderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZOrder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZOrderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZOrderArg = args[1] as! SymbolZOrder
        api.setSymbolZOrder(managerId: managerIdArg, symbolZOrder: symbolZOrderArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZOrderChannel.setMessageHandler(nil)
    }
    let getSymbolZOrderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZOrder\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZOrderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZOrder(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZOrderChannel.setMessageHandler(nil)
    }
    let setTextAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textAllowOverlapArg = args[1] as! Bool
        api.setTextAllowOverlap(managerId: managerIdArg, textAllowOverlap: textAllowOverlapArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextAllowOverlapChannel.setMessageHandler(nil)
    }
    let getTextAllowOverlapChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextAllowOverlap\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextAllowOverlapChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextAllowOverlap(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextAllowOverlapChannel.setMessageHandler(nil)
    }
    let setTextAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textAnchorArg = args[1] as! TextAnchor
        api.setTextAnchor(managerId: managerIdArg, textAnchor: textAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextAnchorChannel.setMessageHandler(nil)
    }
    let getTextAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextAnchorChannel.setMessageHandler(nil)
    }
    let setTextFieldChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextField\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextFieldChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textFieldArg = args[1] as! String
        api.setTextField(managerId: managerIdArg, textField: textFieldArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextFieldChannel.setMessageHandler(nil)
    }
    let getTextFieldChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextField\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextFieldChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextField(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextFieldChannel.setMessageHandler(nil)
    }
    let setTextFontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextFont\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextFontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textFontArg = args[1] as! [String?]
        api.setTextFont(managerId: managerIdArg, textFont: textFontArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextFontChannel.setMessageHandler(nil)
    }
    let getTextFontChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextFont\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextFontChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextFont(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextFontChannel.setMessageHandler(nil)
    }
    let setTextIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textIgnorePlacementArg = args[1] as! Bool
        api.setTextIgnorePlacement(managerId: managerIdArg, textIgnorePlacement: textIgnorePlacementArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextIgnorePlacementChannel.setMessageHandler(nil)
    }
    let getTextIgnorePlacementChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextIgnorePlacement\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextIgnorePlacementChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextIgnorePlacement(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextIgnorePlacementChannel.setMessageHandler(nil)
    }
    let setTextJustifyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextJustify\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextJustifyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textJustifyArg = args[1] as! TextJustify
        api.setTextJustify(managerId: managerIdArg, textJustify: textJustifyArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextJustifyChannel.setMessageHandler(nil)
    }
    let getTextJustifyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextJustify\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextJustifyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextJustify(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextJustifyChannel.setMessageHandler(nil)
    }
    let setTextKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textKeepUprightArg = args[1] as! Bool
        api.setTextKeepUpright(managerId: managerIdArg, textKeepUpright: textKeepUprightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextKeepUprightChannel.setMessageHandler(nil)
    }
    let getTextKeepUprightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextKeepUpright\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextKeepUprightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextKeepUpright(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextKeepUprightChannel.setMessageHandler(nil)
    }
    let setTextLetterSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextLetterSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextLetterSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textLetterSpacingArg = args[1] as! Double
        api.setTextLetterSpacing(managerId: managerIdArg, textLetterSpacing: textLetterSpacingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextLetterSpacingChannel.setMessageHandler(nil)
    }
    let getTextLetterSpacingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextLetterSpacing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextLetterSpacingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextLetterSpacing(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextLetterSpacingChannel.setMessageHandler(nil)
    }
    let setTextLineHeightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextLineHeight\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextLineHeightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textLineHeightArg = args[1] as! Double
        api.setTextLineHeight(managerId: managerIdArg, textLineHeight: textLineHeightArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextLineHeightChannel.setMessageHandler(nil)
    }
    let getTextLineHeightChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextLineHeight\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextLineHeightChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextLineHeight(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextLineHeightChannel.setMessageHandler(nil)
    }
    let setTextMaxAngleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextMaxAngle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextMaxAngleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textMaxAngleArg = args[1] as! Double
        api.setTextMaxAngle(managerId: managerIdArg, textMaxAngle: textMaxAngleArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextMaxAngleChannel.setMessageHandler(nil)
    }
    let getTextMaxAngleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextMaxAngle\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextMaxAngleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextMaxAngle(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextMaxAngleChannel.setMessageHandler(nil)
    }
    let setTextMaxWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextMaxWidth\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextMaxWidthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textMaxWidthArg = args[1] as! Double
        api.setTextMaxWidth(managerId: managerIdArg, textMaxWidth: textMaxWidthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextMaxWidthChannel.setMessageHandler(nil)
    }
    let getTextMaxWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextMaxWidth\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextMaxWidthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextMaxWidth(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextMaxWidthChannel.setMessageHandler(nil)
    }
    let setTextOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOffsetArg = args[1] as! [Double?]
        api.setTextOffset(managerId: managerIdArg, textOffset: textOffsetArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOffsetChannel.setMessageHandler(nil)
    }
    let getTextOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOffset(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOffsetChannel.setMessageHandler(nil)
    }
    let setTextOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOptionalArg = args[1] as! Bool
        api.setTextOptional(managerId: managerIdArg, textOptional: textOptionalArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOptionalChannel.setMessageHandler(nil)
    }
    let getTextOptionalChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOptional\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOptionalChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOptional(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOptionalChannel.setMessageHandler(nil)
    }
    let setTextPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textPaddingArg = args[1] as! Double
        api.setTextPadding(managerId: managerIdArg, textPadding: textPaddingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextPaddingChannel.setMessageHandler(nil)
    }
    let getTextPaddingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPadding\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextPaddingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextPadding(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextPaddingChannel.setMessageHandler(nil)
    }
    let setTextPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textPitchAlignmentArg = args[1] as! TextPitchAlignment
        api.setTextPitchAlignment(managerId: managerIdArg, textPitchAlignment: textPitchAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextPitchAlignmentChannel.setMessageHandler(nil)
    }
    let getTextPitchAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextPitchAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextPitchAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextPitchAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextPitchAlignmentChannel.setMessageHandler(nil)
    }
    let setTextRadialOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRadialOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextRadialOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textRadialOffsetArg = args[1] as! Double
        api.setTextRadialOffset(managerId: managerIdArg, textRadialOffset: textRadialOffsetArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextRadialOffsetChannel.setMessageHandler(nil)
    }
    let getTextRadialOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRadialOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextRadialOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextRadialOffset(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextRadialOffsetChannel.setMessageHandler(nil)
    }
    let setTextRotateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRotate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextRotateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textRotateArg = args[1] as! Double
        api.setTextRotate(managerId: managerIdArg, textRotate: textRotateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextRotateChannel.setMessageHandler(nil)
    }
    let getTextRotateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRotate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextRotateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextRotate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextRotateChannel.setMessageHandler(nil)
    }
    let setTextRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textRotationAlignmentArg = args[1] as! TextRotationAlignment
        api.setTextRotationAlignment(managerId: managerIdArg, textRotationAlignment: textRotationAlignmentArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextRotationAlignmentChannel.setMessageHandler(nil)
    }
    let getTextRotationAlignmentChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextRotationAlignment\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextRotationAlignmentChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextRotationAlignment(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextRotationAlignmentChannel.setMessageHandler(nil)
    }
    let setTextSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextSize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextSizeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textSizeArg = args[1] as! Double
        api.setTextSize(managerId: managerIdArg, textSize: textSizeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextSizeChannel.setMessageHandler(nil)
    }
    let getTextSizeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextSize\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextSizeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextSize(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextSizeChannel.setMessageHandler(nil)
    }
    let setTextTransformChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTransform\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTransformChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTransformArg = args[1] as! TextTransform
        api.setTextTransform(managerId: managerIdArg, textTransform: textTransformArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTransformChannel.setMessageHandler(nil)
    }
    let getTextTransformChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTransform\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTransformChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTransform(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTransformChannel.setMessageHandler(nil)
    }
    let setIconColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconColorArg = args[1] as! Int64
        api.setIconColor(managerId: managerIdArg, iconColor: iconColorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconColorChannel.setMessageHandler(nil)
    }
    let getIconColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconColor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconColorChannel.setMessageHandler(nil)
    }
    let setIconColorSaturationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconColorSaturation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconColorSaturationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconColorSaturationArg = args[1] as! Double
        api.setIconColorSaturation(managerId: managerIdArg, iconColorSaturation: iconColorSaturationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconColorSaturationChannel.setMessageHandler(nil)
    }
    let getIconColorSaturationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconColorSaturation\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconColorSaturationChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconColorSaturation(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconColorSaturationChannel.setMessageHandler(nil)
    }
    let setIconEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconEmissiveStrengthArg = args[1] as! Double
        api.setIconEmissiveStrength(managerId: managerIdArg, iconEmissiveStrength: iconEmissiveStrengthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let getIconEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconEmissiveStrength(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let setIconHaloBlurChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconHaloBlur\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconHaloBlurChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconHaloBlurArg = args[1] as! Double
        api.setIconHaloBlur(managerId: managerIdArg, iconHaloBlur: iconHaloBlurArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconHaloBlurChannel.setMessageHandler(nil)
    }
    let getIconHaloBlurChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconHaloBlur\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconHaloBlurChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconHaloBlur(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconHaloBlurChannel.setMessageHandler(nil)
    }
    let setIconHaloColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconHaloColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconHaloColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconHaloColorArg = args[1] as! Int64
        api.setIconHaloColor(managerId: managerIdArg, iconHaloColor: iconHaloColorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconHaloColorChannel.setMessageHandler(nil)
    }
    let getIconHaloColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconHaloColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconHaloColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconHaloColor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconHaloColorChannel.setMessageHandler(nil)
    }
    let setIconHaloWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconHaloWidth\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconHaloWidthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconHaloWidthArg = args[1] as! Double
        api.setIconHaloWidth(managerId: managerIdArg, iconHaloWidth: iconHaloWidthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconHaloWidthChannel.setMessageHandler(nil)
    }
    let getIconHaloWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconHaloWidth\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconHaloWidthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconHaloWidth(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconHaloWidthChannel.setMessageHandler(nil)
    }
    let setIconImageCrossFadeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconImageCrossFade\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconImageCrossFadeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconImageCrossFadeArg = args[1] as! Double
        api.setIconImageCrossFade(managerId: managerIdArg, iconImageCrossFade: iconImageCrossFadeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconImageCrossFadeChannel.setMessageHandler(nil)
    }
    let getIconImageCrossFadeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconImageCrossFade\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconImageCrossFadeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconImageCrossFade(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconImageCrossFadeChannel.setMessageHandler(nil)
    }
    let setIconOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOcclusionOpacityArg = args[1] as! Double
        api.setIconOcclusionOpacity(managerId: managerIdArg, iconOcclusionOpacity: iconOcclusionOpacityArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let getIconOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOcclusionOpacity(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let setIconOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconOpacityArg = args[1] as! Double
        api.setIconOpacity(managerId: managerIdArg, iconOpacity: iconOpacityArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconOpacityChannel.setMessageHandler(nil)
    }
    let getIconOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconOpacity(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconOpacityChannel.setMessageHandler(nil)
    }
    let setIconTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTranslateArg = args[1] as! [Double?]
        api.setIconTranslate(managerId: managerIdArg, iconTranslate: iconTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTranslateChannel.setMessageHandler(nil)
    }
    let getIconTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTranslateChannel.setMessageHandler(nil)
    }
    let setIconTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setIconTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setIconTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let iconTranslateAnchorArg = args[1] as! IconTranslateAnchor
        api.setIconTranslateAnchor(managerId: managerIdArg, iconTranslateAnchor: iconTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setIconTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getIconTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getIconTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIconTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getIconTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIconTranslateAnchorChannel.setMessageHandler(nil)
    }
    let setSymbolZOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setSymbolZOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSymbolZOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let symbolZOffsetArg = args[1] as! Double
        api.setSymbolZOffset(managerId: managerIdArg, symbolZOffset: symbolZOffsetArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSymbolZOffsetChannel.setMessageHandler(nil)
    }
    let getSymbolZOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getSymbolZOffset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSymbolZOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getSymbolZOffset(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSymbolZOffsetChannel.setMessageHandler(nil)
    }
    let setTextColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textColorArg = args[1] as! Int64
        api.setTextColor(managerId: managerIdArg, textColor: textColorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextColorChannel.setMessageHandler(nil)
    }
    let getTextColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextColor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextColorChannel.setMessageHandler(nil)
    }
    let setTextEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textEmissiveStrengthArg = args[1] as! Double
        api.setTextEmissiveStrength(managerId: managerIdArg, textEmissiveStrength: textEmissiveStrengthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let getTextEmissiveStrengthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextEmissiveStrength\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextEmissiveStrengthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextEmissiveStrength(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextEmissiveStrengthChannel.setMessageHandler(nil)
    }
    let setTextHaloBlurChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextHaloBlur\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextHaloBlurChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textHaloBlurArg = args[1] as! Double
        api.setTextHaloBlur(managerId: managerIdArg, textHaloBlur: textHaloBlurArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextHaloBlurChannel.setMessageHandler(nil)
    }
    let getTextHaloBlurChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextHaloBlur\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextHaloBlurChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextHaloBlur(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextHaloBlurChannel.setMessageHandler(nil)
    }
    let setTextHaloColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextHaloColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextHaloColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textHaloColorArg = args[1] as! Int64
        api.setTextHaloColor(managerId: managerIdArg, textHaloColor: textHaloColorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextHaloColorChannel.setMessageHandler(nil)
    }
    let getTextHaloColorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextHaloColor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextHaloColorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextHaloColor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextHaloColorChannel.setMessageHandler(nil)
    }
    let setTextHaloWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextHaloWidth\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextHaloWidthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textHaloWidthArg = args[1] as! Double
        api.setTextHaloWidth(managerId: managerIdArg, textHaloWidth: textHaloWidthArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextHaloWidthChannel.setMessageHandler(nil)
    }
    let getTextHaloWidthChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextHaloWidth\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextHaloWidthChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextHaloWidth(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextHaloWidthChannel.setMessageHandler(nil)
    }
    let setTextOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOcclusionOpacityArg = args[1] as! Double
        api.setTextOcclusionOpacity(managerId: managerIdArg, textOcclusionOpacity: textOcclusionOpacityArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let getTextOcclusionOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOcclusionOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOcclusionOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOcclusionOpacity(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOcclusionOpacityChannel.setMessageHandler(nil)
    }
    let setTextOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textOpacityArg = args[1] as! Double
        api.setTextOpacity(managerId: managerIdArg, textOpacity: textOpacityArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextOpacityChannel.setMessageHandler(nil)
    }
    let getTextOpacityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextOpacity\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextOpacityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextOpacity(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextOpacityChannel.setMessageHandler(nil)
    }
    let setTextTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTranslateArg = args[1] as! [Double?]
        api.setTextTranslate(managerId: managerIdArg, textTranslate: textTranslateArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTranslateChannel.setMessageHandler(nil)
    }
    let getTextTranslateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTranslateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTranslate(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTranslateChannel.setMessageHandler(nil)
    }
    let setTextTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.setTextTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setTextTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        let textTranslateAnchorArg = args[1] as! TextTranslateAnchor
        api.setTextTranslateAnchor(managerId: managerIdArg, textTranslateAnchor: textTranslateAnchorArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setTextTranslateAnchorChannel.setMessageHandler(nil)
    }
    let getTextTranslateAnchorChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PointAnnotationMessenger.getTextTranslateAnchor\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTextTranslateAnchorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let managerIdArg = args[0] as! String
        api.getTextTranslateAnchor(managerId: managerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTextTranslateAnchorChannel.setMessageHandler(nil)
    }
  }
}
