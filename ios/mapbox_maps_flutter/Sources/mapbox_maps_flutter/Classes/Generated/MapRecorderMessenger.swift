// Autogenerated from Pigeon (v25.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Options for recording the map when using MapRecorder.
///
/// These recordings can be used to debug issues which require multiple steps to reproduce.
/// Additionally, playbacks can be used for performance testing custom scenarios.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapRecorderOptions {
  /// The maximum duration (in milliseconds) from the current time until API calls are kept.
  /// If not specified, all API calls will be kept during the recording,
  /// which can lead to significant memory consumption for long sessions.
  var timeWindow: Int64? = nil
  /// If set to true, the recorded API calls will be printed in the logs.
  var loggingEnabled: Bool
  /// If set to true, the recorded output will be compressed with gzip.
  var compressed: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MapRecorderOptions? {
    let timeWindow: Int64? = nilOrValue(pigeonVar_list[0])
    let loggingEnabled = pigeonVar_list[1] as! Bool
    let compressed = pigeonVar_list[2] as! Bool

    return MapRecorderOptions(
      timeWindow: timeWindow,
      loggingEnabled: loggingEnabled,
      compressed: compressed
    )
  }
  func toList() -> [Any?] {
    return [
      timeWindow,
      loggingEnabled,
      compressed,
    ]
  }
}

/// Options for playback when using MapRecorder.
///
/// Generated class from Pigeon that represents data sent in messages.
struct MapPlayerOptions {
  /// The number of times the sequence is played. If negative, the playback loops indefinitely.
  var playbackCount: Int64
  /// Multiplies the speed of playback for faster or slower replays. (1 means no change.)
  var playbackSpeedMultiplier: Double
  /// When set to true, the player will try to interpolate actions between short wait actions,
  /// to continuously render during the playback.
  /// This can help to maintain a consistent load during performance testing.
  var avoidPlaybackPauses: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MapPlayerOptions? {
    let playbackCount = pigeonVar_list[0] as! Int64
    let playbackSpeedMultiplier = pigeonVar_list[1] as! Double
    let avoidPlaybackPauses = pigeonVar_list[2] as! Bool

    return MapPlayerOptions(
      playbackCount: playbackCount,
      playbackSpeedMultiplier: playbackSpeedMultiplier,
      avoidPlaybackPauses: avoidPlaybackPauses
    )
  }
  func toList() -> [Any?] {
    return [
      playbackCount,
      playbackSpeedMultiplier,
      avoidPlaybackPauses,
    ]
  }
}

private class MapRecorderMessengerPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return MapRecorderOptions.fromList(self.readValue() as! [Any?])
    case 130:
      return MapPlayerOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MapRecorderMessengerPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? MapRecorderOptions {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? MapPlayerOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MapRecorderMessengerPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MapRecorderMessengerPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MapRecorderMessengerPigeonCodecWriter(data: data)
  }
}

class MapRecorderMessengerPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MapRecorderMessengerPigeonCodec(readerWriter: MapRecorderMessengerPigeonCodecReaderWriter())
}


/// Interface for MapRecorder functionality.
///
/// MapRecorder provides functions to record and replay API calls of a MapboxMap instance.
/// These recordings can be used to debug issues which require multiple steps to reproduce.
/// Additionally, playbacks can be used for performance testing custom scenarios.
///
/// Note: The raw format produced by stopRecording is experimental and there is no guarantee
/// for version cross-compatibility when feeding it to replay.
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _MapRecorderMessenger {
  /// Begins the recording session.
  ///
  /// @param options MapRecorderOptions to control recording.
  func startRecording(options: MapRecorderOptions) throws
  /// Stops the current recording session.
  /// Recorded section could be replayed with replay function.
  ///
  /// @return the Uint8List containing the recorded sequence in raw format.
  func stopRecording(completion: @escaping (Result<FlutterStandardTypedData, Error>) -> Void)
  /// Replay a supplied sequence.
  ///
  /// @param recordedSequence Sequence recorded with stopRecording method.
  /// @param options Options to customize the behaviour of the playback.
  func replay(recordedSequence: FlutterStandardTypedData, options: MapPlayerOptions, completion: @escaping (Result<Void, Error>) -> Void)
  /// Temporarily pauses or resumes playback if already paused.
  func togglePauseReplay() throws
  /// Returns the string description of the current state of playback.
  func getPlaybackState() throws -> String
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _MapRecorderMessengerSetup {
  static var codec: FlutterStandardMessageCodec { MapRecorderMessengerPigeonCodec.shared }
  /// Sets up an instance of `_MapRecorderMessenger` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _MapRecorderMessenger?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Begins the recording session.
    ///
    /// @param options MapRecorderOptions to control recording.
    let startRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapRecorderMessenger.startRecording\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! MapRecorderOptions
        do {
          try api.startRecording(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startRecordingChannel.setMessageHandler(nil)
    }
    /// Stops the current recording session.
    /// Recorded section could be replayed with replay function.
    ///
    /// @return the Uint8List containing the recorded sequence in raw format.
    let stopRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapRecorderMessenger.stopRecording\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopRecordingChannel.setMessageHandler { _, reply in
        api.stopRecording { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopRecordingChannel.setMessageHandler(nil)
    }
    /// Replay a supplied sequence.
    ///
    /// @param recordedSequence Sequence recorded with stopRecording method.
    /// @param options Options to customize the behaviour of the playback.
    let replayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapRecorderMessenger.replay\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      replayChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let recordedSequenceArg = args[0] as! FlutterStandardTypedData
        let optionsArg = args[1] as! MapPlayerOptions
        api.replay(recordedSequence: recordedSequenceArg, options: optionsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      replayChannel.setMessageHandler(nil)
    }
    /// Temporarily pauses or resumes playback if already paused.
    let togglePauseReplayChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapRecorderMessenger.togglePauseReplay\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      togglePauseReplayChannel.setMessageHandler { _, reply in
        do {
          try api.togglePauseReplay()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      togglePauseReplayChannel.setMessageHandler(nil)
    }
    /// Returns the string description of the current state of playback.
    let getPlaybackStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._MapRecorderMessenger.getPlaybackState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlaybackStateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPlaybackState()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlaybackStateChannel.setMessageHandler(nil)
    }
  }
}
